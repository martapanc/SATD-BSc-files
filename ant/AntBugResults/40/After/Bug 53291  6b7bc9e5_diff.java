diff --git a/WHATSNEW b/WHATSNEW
index 11f20da08..7ef320266 100644
--- a/WHATSNEW
+++ b/WHATSNEW
@@ -1,1018 +1,1018 @@
 Changes from Ant 1.8.4 TO Ant 1.9.0
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
 Fixed bugs:
 -----------
 
  * External XML catalog resolver failed to use project basedir when given an
    unmentioned relative path like the internal resolver does.
    Bugzilla Report 52754.
 
  * Fixed some potential stream leaks.
    Bugzilla Reports 52738, 52740, 52742, 52743.
 
  * Updated documentation to fix spelling errors / broken links.
-   Bugzilla Reports 53215, 53291 (excluding api)
+   Bugzilla Reports 53215, 53291
    
 Other changes:
 --------------
 
 Changes from Ant 1.8.3 TO Ant 1.8.4
 ===================================
 
 Fixed bugs:
 -----------
 
  * Ported libbzip2's fallback sort algorithm to CBZip2OutputStream to
    speed up compression in certain edge cases.  Merge from Commons
    Compress.
 
    Using specially crafted inputs this can be used as a denial of
    service attack.
    See http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2098
 
 Changes from Ant 1.8.2 TO Ant 1.8.3
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * The Enumeration returned by AntClassLoader#getResources used to
    return null in nextElement after hasNextElement would return false.
    It has been changed to throw a NoSuchElementException instead so
    that it now adheres to the contract of java.util.Enumeration.
    Bugzilla Report 51579.
 
 Fixed bugs:
 -----------
 
  * Removed buggy duplicate JAR list in RPM mode.
    Bugzilla Report 52556.
 
  * Launcher fixed to pass the right class loader parent.
    Bugzilla Report 48633.
 
  * <junitreport> mishandled ${line.separator}.
    Bugzilla Report 51049.
 
  * <junitreport> did not work in embedded environments on JDK 7.
    Nor did <xslt> when using Xalan redirects.
    Bugzilla Report 51668, 52382.
 
  * Encoding of unicode escape sequences by the property file task
    Bugzilla Report 50515.
 
  * The code that implicitly sets the -source switch if only -target
    has been specified in <javac> was broken for Java 5 and 6.
    Bugzilla Report 50578.
 
  * MailLogger ignore the Maillogger.starttls.enable property.
    Bugzilla Report 50668.
 
  * Delete task example does not work
    Bugzilla Report 50816.
 
  * <splash>'s proxy handling has been delegated to <setproxy>
    internally so the two tasks are consistent.  <splash>'s way of not
    setting a proxy caused problems with other Java libraries.
    Bugzilla Report 50888.
 
  * Include task breaks dependencies or extension-points for multiple
    files.
    Bugzilla Report 50866.
 
  * Read on System.in hangs for forked java task.
    Bugzilla Report 50960.
 
  * FileResource specified using basedir/name attributes was non-functional.
 
  * Resource collection implementation of mapped PropertySet returned
    unusable resources.
 
  * The hasmethod condition failed with a NullPointerException when
    ignoresystemclasses is true and Ant tried to load a "restricted
    class" - i.e. a class that the Java VM will only accept when loaded
    via the bootclassloader (a java.* class).
    It will now fail with a more useful error message.
    Bugzilla Report 51035.
 
  * Exec task may mix the stderr and stdout output while logging it
    Bugzilla Report 50507.
 
  * Missing space between "finished" and timestamp in task/target 
    finish message from ProfileLogger.
    Bugzilla Report 51109.
 
  * Redirecting the output of a java, exec or apply task could print in the
    error output stream some "Pipe broken" errors.
    Bugzilla Report 48789.
 
  * ZipFile failed to clean up some resources which could lead to
    OutOfMemoryException while unzipping large archives.
    A similar problem in ZipArchiveOutputStream has been fixed as well.
    Bugzilla Report 42696.
 
  * quiet attribute added to the copy and move tasks, to be used together
    with failonerror=false, so warnings won't get logged 
    Bugzilla Report 48789.
 
  * System.in was closed and not readable anymore by the DefaultInputHandler 
    when Ant is used via its Java API.
    Bugzilla Report 51161
 
  * <sync> only supported a single non-fileset resource collection even
    though the manual said it could be multiple.
 
  * <sync> didn't work properly when working on resource collections.
    Bugzilla Report 51462.
 
  * <augment> cause a NullPointerException if it was used in a target
    that was invoked by multiple targets from the command line.
    Bugzilla Report 50894.
 
  * The ZipFile class could read past the start of the file if the
    given file is not a ZIP archive and it is smaller than the size of
    a ZIP "end of central directory record".
 
  * <javac> would create the empty package-info.class file in the wrong
    directory if no destdir was specified.  Note it may still pick the
    wrong directory if you specify more than one source directory but
    no destDir.  It is highly recommended that you always explicitly
    specify the destDir attribute.
    Bugzilla Report 51947.
 
  * packagemapper now honors the handleDirSep attribute.
    Bugzilla Report 51086.
 
  * the attributes of macrodef tasks had their values run through
    property expansion twice. Still true by default, but can be disabled.
    Bugzilla Report 42046.
 
  * jvc doesn't like it if source file names in argument files are
    quoted.
    Bugzilla Report 31667.
 
  * ZipFile didn't work properly for archives using unicode extra
    fields rather than UTF-8 filenames and the EFS-Flag.
 
  * Access to DirectoryScanner's default excludes wasn't synchronized.
    Bugzilla Report 52188.
 
  * When a Project instance was created by a custom tasks its
    createTask method didn't work.
    Bugzilla Report 50788.
 
 Other changes:
 --------------
 
  * -f/-file/-buildfile accepts a directory containing build.xml.
 
  * The <javacc>, <jjtree> and <jjdoc> now support a new maxmemory
    attribute.
    Bugzilla Report 50513.
 
  * the documented inputstring attribute of sshexec has been
    implemented and the actually existing attribute inputproperty
    documented.
    Bugzilla Report 50576.
 
  * The concat task now permits the name of its exposed resource
    by means of its 'resourcename' attribute.
 
  * The expandproperties filter now accepts a nested propertyset
    which, if specified, provides the properties for expansion.
    Bugzilla Report 51044.
 
  * <junit filtertrace="true"/> will no longer filter out the very
    first line of the stacktrace containing the original exception
    message even if it matches one of the filter expressions.
 
  * Upgraded to Apache AntUnit 1.2
 
  * Provide read access to Mkdir.dir.  Bugzilla Report 51684.
 
  * <delete> and <move> have a new attribute performGCOnFailedDelete
    that may - when set to true - help resolve some problems with
    deleting empty directories on NFS shares.
    Bugzilla Report 45786.
 
  * <loadfile> and <loadresource> used to log at level INFO to signal a
    property hasn't been set when the resource was empty even if the
    quiet attribute was set to true.  They will now use VERBOSE
    instead.
    Bugzilla Report 52107.
 
  * <javac> has a new attribute createMissingPackageInfoClass that can
    be set to false to prevent Ant from creating empty dummy classes
    used for up-to-date-ness checks.
    Bugzilla Report 52096.
 
  * URLResources#isExists has become less noisy.
    Bugzilla Report 51829.
 
  * The <retry> task has a new optional attribute retryDelay that can
    be used to make the task sleep between retry attempts.
    Bugzilla Report 52076.
 
  * <signjar> has new attributes that control the signature and digest
    algorithms.
    Bugzilla Report 52344.
 
  * Initial support for Java 8.
 
  * <sshexec> can optionally create a pseudo terminal (like ssh -t)
    Bugzilla Report 52554.
 
 Changes from Ant 1.8.1 TO Ant 1.8.2
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Prior to Ant 1.8.0 the <copy> task and several other tasks would
    overwrite read-only destination files.  Starting with 1.8.0 they
    would only do so under special circumstances.  Ant 1.8.2 now
    consistently won't replace a read-only file by default. The same is
    true for a number of other tasks.
    The <copy>, <move> and <echo> tasks now have a new force attribute
    and <concat> has a new forceReadonly attribute that can be used to
    make the task overwrite read-only destinations.
    Bugzilla Report 49261.
 
  * Removed ant-nodeps.jar; it is now merged into ant.jar.
 
  * DOMElementWriter#encode used to employ special code before encoding
    ampersands so that &#123; remained &#123; rather than being turned
    into &amp;#123;.  This is no longer the case, ampersands will now
    be encoded unconditionally.
    Also DOMElementWriter#encodeData will treat CDATA sections containing a
    literal "]]>" sequence different now - it will split the CDATA
    section between the second "]" and ">" and create two sections.
    This affects <echoxml> task as well as the XML logger or JUnit
    formatter where ampersands will now always get encoded.
    In addition DOMElementWriter will now replace the characters \t, \r
    and \n in attribute values by entity references.
    Bugzilla Report 49404.
 
  * The list elements returned by ProjectHelper#getExtensionStack are
    now String arrays of length 3 rather than 2 in order to support the
    onMissingExtensionPoint attribute.
    Bugzilla Report 49473.
 
  * When using <property file="..." prefix="..."/> properties defined
    inside the same file will only get used in expansions if the ${}
    reference uses the same prefix.  This is different from Ant 1.8.1
    but is the same behavior Ant 1.8.0 and earlier exhibited.
    A new attribute prefixValues can be used to re-enable the behavior
    of Ant 1.8.1.
    Bugzilla Report 49373.
 
  * The files and directories used by Git, Mercurial and Bazaar to
    store their information are now excluded by the defaultexcludes.
    Bugzilla Report 49624.
 
  * The <junit> task no longer generates TestListener events - which
    have been introduced in ant 1.7.0 - by default.  The task has a new
    attribute enableTestListenerEvents and a new "magic" property
    ant.junit.enabletestlistenerevents has been added that can be used
    to reinstate the old behavior.
 
 Fixed bugs:
 -----------
 
  * hostinfo now prefers addresses with a hostname over addresses without 
    a hostname, provided the addresses have the same scope.
    For local lookup, no IP address will be put in NAME / DOMAIN anymore.
    For remote lookup, if a host name was provided and only an IP address is 
    found, the IP address will no longer overwrite the host name provided to the
    task.
    Bugzilla Report 49513
 
  * mmap-based file copy problems under JDK 1.4 on Linux.
    Bugzilla Report 49430.
 
  * The Sun JVM tries to mmap the entire file during a copy. 
    For large files this is not feasible. 
    We now explicitly request to copy at most 16 MiB per request.
    Bugzilla Report 49326.
 
  * DemuxInputStream.read() should return unsigned values
    Bugzilla Report 49279.
 
  * The MIME mailer ignored the port parameter when using SSL.
    Bugzilla Report 49267.
 
  * <xslt> ignored the classpath when using the default TraX processor.
    Bugzilla Report 49271.
 
  * <checksum>'s totalproperty only worked reliably if the same file
    name didn't occur inside more than one directory.
    Bugzilla Report 36748.
 
  * <ftp> could fail to download files from remote subdirectories under
    certain circumstances.
    Bugzilla Report 49296.
 
  * <junit> will now produce better diagnostics when it fails to delete
    a temporary file.
    Bugzilla Report 49419.
 
  * Ant would often scan directories even though there were known to
    only hold excluded files when evaluating filesets.  This never
    resulted in wrong results but degraded performance of the scan
    itself.
    Bugzilla Report 49420.
 
  * <javac> failed for long command lines on OS/2.
    Bugzilla Report 49425.
 
  * <junitreport> did not handle encodings well for stdout/stderr.
    Bugzilla Report 49418.
 
  * <junit> could issue a warning about multiple versions of Ant on the
    CLASSPATH if two CLASSPATH entries differed in case on a
    case-insensitive file system.
    Bugzilla Report 49041.
 
  * The <restrict> resource collection was checking every resource even if
    we actually just want the first one, like in the example of use of
    resourcelist in the documentation (getting the first available resource
    from a mirror list).
 
  * A race condition could lead to build failures if multiple <mkdir>
    tasks were trying to create the same directory.
    Bugzilla Report 49572.
 
  * the toString() method of the Resources class - and thus any
    ${toString:} expansion of a reference to a <resources> element -
    didn't iterate over its nested elements if it hadn't done so prior
    to the toString invocation already.
    Bugzilla Report 49588.
 
  * <apply> in parallel mode didn't work together with a nested
    <redirector> if maxparallel was <= 0 (the default) or no source
    files matched.
    Bugzilla Report 49594.
 
  * <jar filesetmanifest="merge"> didn't work for manifests added via
    <zipfileset>s that used the prefix or fullpath attributes.
    Bugzilla Report 49605.
 
  * <tempfile createfile="true"> would cause an error unless the prefix
    attribute has been specified.
    Bugzilla Report 49755.
 
  * If forked, after finished <java> was still reading the input stream
    for a bunch of characters, then stealing them from a following <input>.
    Bugzilla Report 49119.
 
  * Ant could be leaking threads for each forked process (started by
    <exec>, <apply>, <java> or similar tasks) that didn't receive input
    from a resource or string explicitly.
    Bugzilla Report 49587.
 
  * Project#setDefault threw an exception when null was passed in as
    argument, even though the Javadoc says null is a valid value.
    Bugzilla Report 49803.
 
  * runant.py would swallow the first argument if CLASSPATH wasn't set.
    Bugzilla Report 49963.
 
  * <taskdef> failed to load resources from jar files contained in a
    directory that has a "!" in its name.
    Bugzilla Report 50007.
 
  * ant.bat exit strategy improvements and issues
    make the exit codes work in environments where 4NT or MKS are installed
    Bugzilla Report 41039.
 
  * <signjar> would fail if used via its Java API and the File passed
    into the setJar method was not "normalized" (i.e. contained ".."
    segments).
    Bugzilla Report 50081.
 
  * <delete> ignored <fileset>'s errorOnMissingDir attribute
    Bugzilla Report 50124.
 
  * <symlink> failed to close files when reading a list of symbolic
    links from a properties file.
    Bugzilla Report 50136.
 
  * <parallel> could allow tasks to start executing even if a task
    scheduled to run before them timed out.
    Bugzilla Report 49527.
 
  * If a <junit> batch with multiple tests times out Ant logs a message
    about a test named Batch-With-Multiple-Tests since 1.8.0 but the
    logic that determined the Java package of this pseudo-test has been
    wrong.
    Bugzilla Report 45227.
 
  * <propertyfile> didn't preserve the original linefeed style when
    updating a file.
    Bugzilla Report 50049.
 
  * <zip>'s whenEmpty behavior never consulted the non-fileset
    resources so the task could fail even though resources have been
    provided using non-fileset resource collections.
    Bugzilla Issue 50115.
 
 *  ftp chmod could throw a NPE.
    Bugzilla report 50217.
 
 *  The project help (-p option in the command line) will now print
    the dependencies of the targets in debug mode (-d on the command
    line)
 
 Other changes:
 --------------
 
  * <concat>'s force attribute has been deprecated in favor of a new
    overwrite attribute that is consistent with <copy>'s attribute
    names.
 
  * You can now specify a list of methods to run in a JUnit test case.
    Bugzilla Report 34748.
 
  * properties in files read because of the -propertyfile command line
    option will now get resolved against other properties that are
    defined before the project starts executing (those from the same or
    earlier -propertfiles or defined via the -D option).
    Bugzilla Report 18732.
 
  * <pathelement>s can now contain wildcards in order to use wildcard
    CLASSPATH entries introduced with Java6.
    The wildcards are not expanded or even evaluated by Ant and will be
    used literally.  The resulting path may be unusable as a CLASSPATH
    for Java versions prior to Java6 and likely doesn't mean anything
    when used in any other way than a CLASSPATH for a forked Java VM. 
    Bugzilla Report 46842.
 
  * A new attribute allows targets to deal with nonexistent extension
    points, i.e. they can extend an extension-point if it has been
    defined or silently work as plain targets if it hasn't.  This is
    useful for targets that get included/imported in different
    scenarios where a given extension-point may or may not exist.
    Bugzilla Report 49473.
 
  * Ant now logs a warning message if it fails to change the file
    modification time in for example when using <touch> or preserving
    timestamps in various tasks.
    Bugzilla Report 49485.
 
  * ProjectHelpers can now be installed dynamically via the <projecthelper>
    Ant task.
 
  * <import> is now able to switch to the proper ProjectHelper to parse
    the imported resource. This means that several kinds of different build
    files can import each other.
 
  * <copy tofile=""> now also works for non-filesystem resources.
    Bugzilla Report 49756.
 
  * The <linecontainsregexp> filter now supports a casesensitive
    attribute.
 
  * The <containsregexp> selector now supports casesensitive, multiline
    and singleline attributes.
    Bugzilla Report 49764.
 
  * A new <cutdirsmapper> can be used like wget's --cut-dirs option to
    strip leading directories from file names.
 
  * <javah> now supports the GNU project's gcjh compiler.
    Bugzilla Report 50149.
 
  * <checksum> supports additional views of a file's path as elements
    for a custom pattern.
    Bugzilla Report 50114.
 
  * JUnit XMLResultAggregator logs the stack trace of caught IO exceptions
    in verbose runs.
    Bugzilla Report 48836.
 
  * StringUtils.parseHumanSizes() should turn parse failures into
    BuildExceptions.
    Bugzilla Report 48835.
 
  * New task <bindtargets> to make a list of targets bound to some
    specified extension point.
 
  * Initial support for OpenJDK7 has been added.
 
  * Ant now uses java.net.CookieStore rather than
    java.util.ServiceLocator to detect whether the environment is a
    Java 1.6 system.  This means releases of gcj/gij at the time of
    this release of Ant are detected as Java 1.5 and not 1.6.
    Bugzilla Report 50256.
 
  * It is now possible to write a compiler adapter for <javac> that
    compiles sources with extensions other than .java (but that still
    compile to .class files).
    Bugzilla Report 48829.
 
  * The performance of VectorSet#add(Object) has been improved which
    should also benefit any operation that scans directories in Ant.
    Bugzilla Report 50200.
 
 Changes from Ant 1.8.0 TO Ant 1.8.1 
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * ant-trax.jar is no longer produced since TrAX is included in JDK 1.4+.
 
  * Ant no longer ships with Apache Xerces-J or the XML APIs but relies
    on the Java runtime to provide a parser and matching API versions.
 
  * The stylebook ant task and the ant-stylebook.jar are removed.
 
 Fixed bugs:
 -----------
 
  * Tasks that iterate over task or type definitions, references or
    targets now iterate over copies instead of the live maps to avoid
    ConcurrentModificationExceptions if another thread changes the
    maps.
    Bugzilla Report 48310.
 
  * The filesmatch condition threw a NullPointerException when
    comparing text files and the second file contained fewer lines than
    the first one.
    Bugzilla Report 48715.
 
  * Regression: The <ear> task would allow multiple
    META-INF/application.xml files to be added.
    Bugzilla Report 6836.
 
  * VectorSet#remove(Object) would fail if the size of the vector
    equaled its capacity.
 
  * Regression : ant -diagnostics was returning with exit code 1
    Bugzilla Report 48782
 
  * Fix for exec task sometimes inserts extraneous newlines
    Bugzilla Report 48746
 
  * SymlinkTest#testSymbolicLinkUtilsMethods failing on MacOS
    Bugzilla Report 48785.
 
  * If <concat>'s first resourcecollection child is a <resources>,
    any subsequently added child resourcecollection joins the first.
    Bugzilla Report 48816.
 
  * <get> with an invalid URL could trigger an NPE in some JVMs.
    Bugzilla Report 48833
 
  * Broken Pipe issue under Ubuntu Linux
    Bugzilla Report 48789
 
  * Properties wrongly read from file or not update during read
    Bugzilla Report 48768
 
  * AntClassLoader in Ant 1.8.0 has been considerably slower than in
    1.7.1
    Bugzilla Report 48853
 
  * ANT_CMD_LINE_ARGS are rippling through lower level Ant usage 
    Bugzilla Report 48876
 
  * email : IO error sending mail with plain mimetype
    Bugzilla Report 48932
 
  * the complete-ant-cmd.pl script failed to create a proper cache of
    target if "ant -p" failed.
    Bugzilla Report 48980
 
  * <rmic>'s sourcebase attribute was broken.
    Bugzilla Report 48970
 
  * <copy>'s failonerror didn't work as expected when copying a single
    element resource collection to a file.
    Bugzilla Report 49070
 
  * <get> no longer followed redirects if the redirect URL was relative
    and not an absolute URL.
    Bugzilla Report 48972
 
  * fixed a performance degradation in the code that expands property
    references.
    Bugzilla Reports 48961 and 49079
 
  * <jar filesetmanifest="merge"> was broken on Windows.
    Bugzilla Report 49090
 
  * <symlink> delete failed if the link attribute was a relative path
    to a link inside the current directory without a leading ".".
    Bugzilla Report 49137
 
  * <telnet> and <rexec> failed to find the expected strings when
    waiting for responses and thus always failed.
    Bugzilla Report 49173
 
 Other changes:
 --------------
 
  * Project provides new get methods that return copies instead of the
    live maps of task and type definitions, references and targets.
 
  * Ant is now more lenient with ZIP extra fields and will be able to
    read archives that it failed to read in earlier versions.
    Bugzilla Report 48781.
 
  * The <zip> family of tasks has been sped up for bigger archives.
    Bugzilla Report 48755.
 
  * Add removeKeepExtension option to NetRexxC task.
    Bugzilla Report 48788.
 
  * Add prefix attribute to loadproperties task.
 
  * Add resource attribute to length task.
 
  * PropertyResource will effectively proxy another Resource if ${name}
    evaluates to a Resource object.
 
  * Added forcestring attribute to equals condition to force evaluation
    of Object args as strings; previously only API-level usage of the
    equals condition allowed Object args, but Ant 1.8.x+ property
    evaluation may yield values of any type.
 
  * BuildFileTest.assertPropertyUnset() fails with a slightly more 
    meaningful error message
    Bugzilla Report 48834
 
  * <junit> will now throw an exception if a test name is empty.  This
    used to manifest itself in unrelated errors like
    Bugzilla Report 43586.
 
  * A change that made <exec> more reliable on Windows (Bugzilla Report
    5003) strongly impacts the performance for commands that execute
    quickly, like attrib.  Basically no single execution of a command
    could take less than a second on Windows.
    A few timeouts have been tweaked to allow these commands to finish
    more quickly but still they will take longer than they did with Ant
    1.7.1.
    Bugzilla Report 48734.
 
  * Added SimpleBigProjectLogger, intermediate between NoBannerLogger and
    BigProjectLogger.
 
  * <mappedresources> supports new attributes enablemultiplemappings
    and cache.
 
  * Added the augment task to manipulate existing references via Ant's basic
    introspection mechanisms.
 
 Changes from Ant 1.8.0RC1 TO Ant 1.8.0
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * the appendtolines filter has been renamed to suffixlines.
 
 Fixed bugs:
 -----------
 
  * stack traces were not reported at all by <junit/>
    when filtertrace="on", which is the default.
 
  * ant.bat can now also process the -noclasspath switch when it is 
    the first switch on a command line.
    Bugzilla Report 48186.
 
  * <fixcrlf> now tries to delete the created temporary files earlier.
    Bugzilla Report 48506.
 
  * the implementation of <zip> had been changed in a way that broke
    the jarjar links task and protentially other third-party subclasses
    as well.
    Bugzilla Report 48541.
 
  * <scp> task didn't report build file location when a remote operation failed
    Bugzilla Report 48578.
 
  * <propertyfile> would add the same comment and a date line each time
    it updated an existing property file.
    Bugzilla Report 48558.
 
  * <sound> didn't work properly in recent Java VMs.
    Bugzilla Report 48637.
 
 Other changes:
 --------------
 
 Changes from Ant 1.7.1 TO Ant 1.8.0RC1
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * if and unless attributes (on <target> as well as various tasks and other
    elements) have long permitted ${property} interpolation. Now, if the result
    evaluates to "true" or "false" (or "yes", "no", "on", "off"), that boolean
    value will be used; otherwise the traditional behavior of treating the value
    as a property name (defined ~ true, undefined ~ false) is used. Existing
    scripts could be broken if they perversely defined a property named "false"
    and expected if="false" to be true, or used if="true" expecting this to be
    triggered only if a property named "true" were defined.
 
  * Ant now requires Java 1.4 or later.
 
  * Improved handling of InterruptException (lets suppose someone/thing
    is trying to kill the thread when we receive an
    InterruptException), when an InterruptException is received, we do
    not wait anymore in a while loop till the end time has been
    reached.
    Bugzilla Report 42924.
 
  * Refactor PropertyHelper and introspection APIs to make extension
    more granular and support setting task/type attribute values to
    objects decoded by custom PropertyEvaluator delegates. Also add
    <propertyhelper> task for registering delegates and/or replacing
    the registered PropertyHelper instance.
    Bugzilla Report 42736.
 
  * Added a restricted form of typedef called <componentdef>. This
    allows definition of elements that can only be within tasks or
    types. This method is now used to define conditions, selectors,
    comparators and filterreaders. This means that tasks may now have
    nested conditions just by implementing the Condition interface,
    rather than extending ConditionBase. It also means that the use of
    namespaces for some of the selectors introduced in Ant 1.7.0 is no
    longer necessary.  Implementing this means that the DynamicElement
    work-around introduced in Ant 1.7.0 has been removed.
    Bugzilla Report 40511.
 
  * In the <touch> task when a <mapper> is used, the millis and
    datetime attributes now override the time of the source resource if
    provisioned.
    Bugzilla Report 43235.
 
  * Remove fall-back mechanism for references that are not resolved
    during normal runtime execution.
 
  * FileUtils.createTempFile now actually creates the file.
    The TempFile task still does not create the file by default, can be
    instructed to do so however using a new parameter.
    Bugzilla Report 33969.
 
  * A lock in Project ensured that a BuildListener's messageLogged
    method was only ever executed by a single thread at a time, while
    all other methods could be invoked by multiple threads
    simultaniously (while within <parallel>, for example).  This lock
    is no longer in place, messageLogged should be made thread-safe
    now.
 
  * <sql>'s onError="stop" no longer fails the build if an error
    occurs,  this is the main difference between stop and error and
    matches what the documentation implied.
    Bugzilla Report 24668.
 
  * Ant's configuration introspection mechanisms have been modified to prefer
    Resource and FileProvider attributes to plain java.io.File attributes;
    however the configuration-from-String behavior remains equivalent, rendering
    a FileResource.
 
  * CBZip2InputStream will now throw an IOException if
    passed in a null or empty InputStream to read from.
    Bugzilla Reports 32200.
 
  * <unzip> will now fail when trying to extract certain broken
    archives that would have been silently ignored in earlier version.
    Bugzilla Report 35000.
 
  * Ant's <zip> family of tasks tries to preserve the existing Unix
    permissions when updating archives or copying entries from one
    archive to another.
    Since not all archiving tools support storing Unix permissions in
    the same way that is used by Ant, sometimes the permissions read by
    Ant seem to be 0, which means nobody is allowed to do anything to
    the file or directory.
    If Ant now encounters a permission set of 0 it will assume that
    this is not the intended value and instead apply its own default
    values.  Ant used to create entries with 0 permissions itself.
    The <zip> family of tasks has a new attribute preserve0permissions
    that can be set to restore the old behavior.
    Bugzilla Report 42122.
 
  * If a batch containing multiple JUnit tests running inside a forked
    Java VM caused the VM to crash (or caused a timeout), the
    formatters would receive an error message for the last test in the
    batch.
    Ant will now pass in a test with the name "Batch-With-Multiple-Tests"
    instead - this is supposed to show more clearly that the last test
    may not have started at all.
    Bugzilla Report 45227.
 
  * If the number of minutes a build takes is bigger then 1000 Ant will
    no longer print a thousands separator in the "elapsed time"
    message.  It used to be the thousands separator of the current
    locale.
    Bugzilla Report 44659.
 
  * <symlink action="delete"> used to fail if the link was broken (i.e.
    pointing to a file or directory that no longer existed).  It will now
    silently try to remove the link.
    Bugzilla Report 41285.
 
  * <delete file="..."> used to log a warning and not delete broken
    symbolic links.  <delete dir="..."/> didn't even log a warning.
    The task will now try to delete them in both cases.
    Bugzilla Report 41285.
 
  * if the dir attribute of a <fileset> points to a symbolic link and
    followsymlinks is set to false, the fileset will no longer be
    scanned and always seem empty.
    Bugzilla Report 45741.
 
  * the .NET tasks that have been deprecated since Ant 1.7.0 have been
    removed, please use the stand-alone Antlib you can find at
    http://ant.apache.org/antlibs/dotnet/index.html
    instead.
 
  * the logic of closing streams connected to forked processes (read
    the input and output of <exec> and friends) has been changed to
    deal with cases where child processes of the forked processes live
    longer than their parents and keep Ant from exiting.
    It is unlikely but possible that the changed logic breaks stream
    handling on certain Java VMs.
    Bugzilla issue 5003.
 
  * <checksum>'s totalproperty was platform dependent because it relied
    on java.io.File#compareTo.  It has now been made platform
    independent, which means that totalPropery values obtained on
    Windows (and other systems where the sort order of File is not case
    sensitive) can be different from the values obtained with earlier
    versions of Ant.
    Bugzilla Report 36748.
 
  * globmapper didn't work properly if the "to" or "from" patterns
    didn't contain a "*".  In particular it implicitly added a * to the
    end of the pattern(s).  This is no longer the case.  If you relied
    on this behavior you will now need to explicitly specify the
    trailing "*".
    Bugzilla Report 46506.
 
  * <copy> silently ignored missing resources even with
    failOnError="true".  If your build tries to copy non-existant
    resources and you relied on this behavior you must now explicitly
    set failOnError to false.
    Bugzilla Report 47362.
 
  * Ant now prefers the java.runtime.version system property over
    java.vm.version for the Created-By Manifest attribute.
    Bugzilla Report 47632.
 
  * The <image> task now supports a nested mapper.  In order to
    implement this, the Java API of the task had to change so any
    custom subclass overriding the processFile method will need to
    adapt (by overriding the new two-arg processFile method).
    Bugzilla Report 23243.
 
  * A new property syntax can be used to set attributes from
    references: ${ant.ref:some-reference}
 
    In most cases this will yield the exact same result as 
    ${toString:some-reference} - only when an attribute setter method
    accepts an object type other than string and the project's
    reference is an Object of matching type the new syntax will pass in
    that object.
 
    If your build file already contains properties whose name starts
    with "ant.ref:" there is a potential for collision.  If your
    property has been set, normal property expansion will take
    precedence over the new syntax.  If the property has not been set
    and a reference with the postfix of your property name exists
    (i.e. in a very unlikely event) then the new syntax would yield a
    different result (an expanded property) than Ant 1.7.1 did.
 
  * A ProjectHelper implementation can now provide the default build file
    name it is expecting, and can specify if they can support a specific build
    file. So Ant is now capable of supporting several ProjectHelper
    implementations, deciding on which to use depending of the input build file.
 
  * Mapper-aware selectors (depends, different, present) now accept typedef'd
    FileNameMappers.
 
 Fixed bugs:
 -----------
 
  * The default logger was failing to print complete stack traces for
    exceptions other than BuildException when inside <ant> or
    <antcall>, thus omitting often important diagnostic
    information.
    Bugzilla 43398 (continued).
 
  * Better handling of package-info.class.
    Bugzilla Report 43114.
 
  * RPM task needed an inserted space between the define and the value.
    Bugzilla Report 46659.
 
  * Got rid of deadlock between in, out and err in the Redirector. 
    Bugzilla Report 44544.
 
  * Caused by AssertionError no longer filtered.
    Bugzilla Report 45631.
  
  * <zip> would sometimes recreate JARs unnecessarily.
    Bugzilla Report 45902.
 
  * <symlink> task couldn't overwrite existing symlinks that pointed to
    nonexistent files
    Bugzilla Report 38199.
 
  * <symlink> task couldn't overwrite files that were in the way of the symlink.
    Bugzilla Report 43426.
 
  * <symlink> task failonerror="false" does not stop build from failing
    when 'ln' command returns non-zero.
    Bugzilla Report 43624
 
  * <touch> task couldn't differentiate between "no resources
    specified" and "no resources matched."
    Bugzilla Report 43799.
 
  * ManifestClassPath failed when a relative path would traverse the
    file system root.
    Bugzilla Report 44499.
 
  * <globmapper> had an indexoutofbounds when the prefix and postfix
    overlapped.
    Bugzilla Report 44731.
 
  * <typedef> and <taskdef> failed to accept file names with #
    characters in them.
    Bugzilla Report 45190
 
  * A deadlock could occur if a BuildListener tried to access an Ant property
    within messageLogged while a different thread also accessed one.
    Bugzilla Report 45194
 
  * Handle null result of system getProperty() in CommandlineJava.
    Similar to Bugzilla Report 42334.
 
  * Length task did not process nonexistent Resources even though these might
    conceivably still carry file length information.
    Bugzilla Report 45271.
 
  * <javac>'s includeJavaRuntime="false" should work for gcj now.  Note
    that you may need to set includeAntRuntime to false in order to
    have full control.
    Bugzilla Report 34638.
 
  * <sql> would fail if the executed statment didn't return a result
    set with some JDBC driver that dissalow Statement.getResultSet to
    be called in such a situation.
    Bugzilla Report 36265 
 
  * if the executed statement in <sql> returned a result set and an
    update count, the count would be lost.
 
  * if an executed statement in <sql> mixes update count and result set
    parts, some result sets wouldn't get printed.
    Bugzilla Report 32168.
 
  * XmlLogger could lose messages if <parallel> is used.
    Bugzilla Report 25734.
 
  * <scp> creates remoteToDir if it doesn't exist.
    Bugzilla Report 42781
 
  * CBZip2OutputStream threw an exception if it was closed prior to
    writing anything.
    Bugzilla Reports 32200, 45836
 
  * The IPlanetDeploymentTool didn't use the configured DTD locations.
    Bugzilla Report 31876.
 
  * The ant shell script printed a warning under Cygwin if JAVA_HOME
    was not set.
    Bugzilla Report 45245.
 
  * <filterset> sometimes incorrectly flagged infinite recursions of
    filter tokens
    Bugzilla Report 44226.
 
  * failures were treated as errors in forked JUnit tests when JUnit 4
    was used.
    Bugzilla Report 43892.
 
  * <jar> and <manifest> disallowed manifest attributes whose name
    contained the character '8'.
    Bugzilla Report 45675.
 
  * BigProjectLogger would set the project's basedir to the current
    working directory.
    Bugzilla Report 45607.
 
  * only <formatter>s that logged to a file were notified if forked VM
    crashed or a timeout occured in <junit>.
    Bugzilla Report 37312.
 
diff --git a/src/main/org/apache/tools/ant/AntTypeDefinition.java b/src/main/org/apache/tools/ant/AntTypeDefinition.java
index 9755041e7..1abd47a72 100644
--- a/src/main/org/apache/tools/ant/AntTypeDefinition.java
+++ b/src/main/org/apache/tools/ant/AntTypeDefinition.java
@@ -1,388 +1,388 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Constructor;
 
 
 /**
  * This class contains all the information
  * on a particular ant type,
- * the classname, adaptor and the class
+ * the classname, adapter and the class
  * it should be assignable from.
  * This type replaces the task/datatype split
  * of pre ant 1.6.
  *
  */
 public class AntTypeDefinition {
     private String      name;
     private Class       clazz;
     private Class       adapterClass;
     private Class       adaptToClass;
     private String      className;
     private ClassLoader classLoader;
     private boolean     restrict = false;
 
     /**
      * Set the restrict attribute.
      * @param restrict the value to set.
       */
      public void setRestrict(boolean restrict) {
          this.restrict = restrict;
      }
 
     /**
      * Get the restrict attribute.
       * @return the restrict attribute.
       */
     public boolean isRestrict() {
         return restrict;
     }
 
     /**
      * Set the definition's name.
      * @param name the name of the definition.
      */
     public void setName(String name) {
         this.name = name;
     }
 
     /**
      * Return the definition's name.
      * @return the name of the definition.
      */
     public String getName() {
         return name;
     }
 
     /**
      * Set the class of the definition.
      * As a side-effect may set the classloader and classname.
      * @param clazz the class of this definition.
      */
     public void setClass(Class clazz) {
         this.clazz = clazz;
         if (clazz == null) {
             return;
         }
         this.classLoader = (classLoader == null)
             ? clazz.getClassLoader() : classLoader;
         this.className = (className == null) ? clazz.getName() : className;
     }
 
     /**
      * Set the classname of the definition.
      * @param className the classname of this definition.
      */
     public void setClassName(String className) {
         this.className = className;
     }
 
     /**
      * Get the classname of the definition.
      * @return the name of the class of this definition.
      */
     public String getClassName() {
         return className;
     }
 
     /**
      * Set the adapter class for this definition.
      * This class is used to adapt the definitions class if
      * required.
      * @param adapterClass the adapterClass.
      */
     public void setAdapterClass(Class adapterClass) {
         this.adapterClass = adapterClass;
     }
 
     /**
      * Set the assignable class for this definition.
      * @param adaptToClass the assignable class.
      */
 
     public void setAdaptToClass(Class adaptToClass) {
         this.adaptToClass = adaptToClass;
     }
 
     /**
      * Set the classloader to use to create an instance
      * of the definition.
      * @param classLoader the ClassLoader.
      */
     public void setClassLoader(ClassLoader classLoader) {
         this.classLoader = classLoader;
     }
 
     /**
      * Get the classloader for this definition.
      * @return the classloader for this definition.
      */
     public ClassLoader getClassLoader() {
         return classLoader;
     }
 
     /**
      * Get the exposed class for this
      * definition. This will be a proxy class
      * (adapted class) if there is an adapter
      * class and the definition class is not
      * assignable from the assignable class.
      * @param project the current project.
      * @return the exposed class - may return null if unable to load the class
      */
     public Class getExposedClass(Project project) {
         if (adaptToClass != null) {
             Class z = getTypeClass(project);
             if (z == null || adaptToClass.isAssignableFrom(z)) {
                 return z;
             }
         }
         return (adapterClass == null) ? getTypeClass(project) :  adapterClass;
     }
 
     /**
      * Get the definition class.
      * @param project the current project.
      * @return the type of the definition.
      */
     public Class getTypeClass(Project project) {
         try {
             return innerGetTypeClass();
         } catch (NoClassDefFoundError ncdfe) {
             project.log("Could not load a dependent class ("
                         + ncdfe.getMessage() + ") for type "
                         + name, Project.MSG_DEBUG);
         } catch (ClassNotFoundException cnfe) {
             project.log("Could not load class (" + className
                         + ") for type " + name, Project.MSG_DEBUG);
         }
         return null;
     }
 
     /**
      * Try and load a class, with no attempt to catch any fault.
      * @return the class that implements this component
      * @throws ClassNotFoundException if the class cannot be found.
      * @throws NoClassDefFoundError   if the there is an error
      *                                finding the class.
      */
     public Class innerGetTypeClass() throws ClassNotFoundException {
         if (clazz != null) {
             return clazz;
         }
         if (classLoader == null) {
             clazz = Class.forName(className);
         } else {
             clazz = classLoader.loadClass(className);
         }
         return clazz;
     }
 
     /**
      * Create an instance of the definition.
      * The instance may be wrapped in a proxy class.
      * @param project the current project.
      * @return the created object.
      */
     public Object create(Project project) {
         return icreate(project);
     }
 
     /**
      * Create a component object based on
      * its definition.
      * @return the component as an <code>Object</code>.
      */
     private Object icreate(Project project) {
         Class c = getTypeClass(project);
         if (c == null) {
             return null;
         }
         Object o = createAndSet(project, c);
         if (o == null || adapterClass == null) {
             return o;
         }
         if (adaptToClass != null) {
             if (adaptToClass.isAssignableFrom(o.getClass())) {
                 return o;
             }
         }
         TypeAdapter adapterObject = (TypeAdapter) createAndSet(
             project, adapterClass);
         if (adapterObject == null) {
             return null;
         }
         adapterObject.setProxy(o);
         return adapterObject;
     }
 
     /**
      * Checks if the attributes are correct.
      * <dl>
      *   <li>if the class can be created.</li>
      *   <li>if an adapter class can be created</li>
-     *   <li>if the type is assignable from adapto</li>
+     *   <li>if the type is assignable from adapter</li>
      *   <li>if the type can be used with the adapter class</li>
      * </dl>
      * @param project the current project.
      */
     public void checkClass(Project project) {
         if (clazz == null) {
             clazz = getTypeClass(project);
             if (clazz == null) {
                 throw new BuildException(
                     "Unable to create class for " + getName());
             }
         }
         // check adapter
         if (adapterClass != null && (adaptToClass == null
             || !adaptToClass.isAssignableFrom(clazz))) {
             TypeAdapter adapter = (TypeAdapter) createAndSet(
                 project, adapterClass);
             if (adapter == null) {
                 throw new BuildException("Unable to create adapter object");
             }
             adapter.checkProxyClass(clazz);
         }
     }
 
     /**
      * Get the constructor of the definition
      * and invoke it.
      * @return the instantiated <code>Object</code>.
      */
     private Object createAndSet(Project project, Class c) {
         try {
             Object o = innerCreateAndSet(c, project);
             return o;
         } catch (InvocationTargetException ex) {
             Throwable t = ex.getTargetException();
             throw new BuildException(
                 "Could not create type " + name + " due to " + t, t);
         } catch (NoClassDefFoundError ncdfe) {
             String msg = "Type " + name + ": A class needed by class "
                 + c + " cannot be found: " + ncdfe.getMessage();
             throw new BuildException(msg, ncdfe);
         } catch (NoSuchMethodException nsme) {
             throw new BuildException("Could not create type " + name
                     + " as the class " + c + " has no compatible constructor");
         } catch (InstantiationException nsme) {
             throw new BuildException("Could not create type "
                     + name + " as the class " + c + " is abstract");
         } catch (IllegalAccessException e) {
             throw new BuildException("Could not create type "
                     + name + " as the constructor " + c + " is not accessible");
         } catch (Throwable t) {
             throw new BuildException(
                 "Could not create type " + name + " due to " + t, t);
         }
     }
 
     /**
      * Inner implementation of the {@link #createAndSet(Project, Class)} logic, with no
      * exception catching
      * @param newclass class to create
      * @param project the project to use
      * @return a newly constructed and bound instance.
-     * @throws NoSuchMethodException  no good construtor.
+     * @throws NoSuchMethodException  no good constructor.
      * @throws InstantiationException cannot initialize the object.
      * @throws IllegalAccessException cannot access the object.
      * @throws InvocationTargetException error in invocation.
      */
     public Object innerCreateAndSet(Class newclass, Project project)
             throws NoSuchMethodException,
             InstantiationException,
             IllegalAccessException,
             InvocationTargetException {
         Constructor ctor = null;
         boolean noArg = false;
         // DataType can have a "no arg" constructor or take a single
         // Project argument.
         try {
             ctor = newclass.getConstructor(new Class[0]);
             noArg = true;
         } catch (NoSuchMethodException nse) {
             //can throw the same exception, if there is no this(Project) ctor.
             ctor = newclass.getConstructor(new Class[] {Project.class});
             noArg = false;
         }
         //now we instantiate
         Object o = ctor.newInstance(
             ((noArg) ? new Object[0] : new Object[] {project}));
 
         //set up project references.
         project.setProjectReference(o);
         return o;
     }
 
     /**
      * Equality method for this definition (assumes the names are the same).
      *
      * @param other another definition.
      * @param project the project the definition.
      * @return true if the definitions are the same.
      */
     public boolean sameDefinition(AntTypeDefinition other, Project project) {
         return (other != null && other.getClass() == getClass()
             && other.getTypeClass(project).equals(getTypeClass(project))
             && other.getExposedClass(project).equals(getExposedClass(project))
             && other.restrict == restrict
             && other.adapterClass == adapterClass
             && other.adaptToClass == adaptToClass);
     }
 
     /**
      * Similar definition;
      * used to compare two definitions defined twice with the same
      * name and the same types.
      * The classloader may be different but have the same
      * path so #sameDefinition cannot
      * be used.
      * @param other the definition to compare to.
      * @param project the current project.
      * @return true if the definitions are the same.
      */
     public boolean similarDefinition(AntTypeDefinition other, Project project) {
         if (other == null
             || getClass() != other.getClass()
             || !getClassName().equals(other.getClassName())
             || !extractClassname(adapterClass).equals(
             extractClassname(other.adapterClass))
             || !extractClassname(adaptToClass).equals(
             extractClassname(other.adaptToClass))
             || restrict != other.restrict) {
             return false;
         }
         // all the names are the same: check if the class path of the loader
         // is the same
         ClassLoader oldLoader = other.getClassLoader();
         ClassLoader newLoader = getClassLoader();
         return oldLoader == newLoader
             || (oldLoader instanceof AntClassLoader
             && newLoader instanceof AntClassLoader
             && ((AntClassLoader) oldLoader).getClasspath()
             .equals(((AntClassLoader) newLoader).getClasspath()));
     }
 
     private String extractClassname(Class c) {
         return (c == null) ? "<null>" : c.getClass().getName();
     }
 }
diff --git a/src/main/org/apache/tools/ant/ComponentHelper.java b/src/main/org/apache/tools/ant/ComponentHelper.java
index ad32faf63..f6001ffda 100644
--- a/src/main/org/apache/tools/ant/ComponentHelper.java
+++ b/src/main/org/apache/tools/ant/ComponentHelper.java
@@ -1,1148 +1,1148 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant;
 
 import java.lang.reflect.Modifier;
 import java.lang.reflect.InvocationTargetException;
 import java.io.InputStream;
 import java.io.IOException;
 import java.io.File;
 import java.io.StringWriter;
 import java.io.PrintWriter;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Properties;
 import java.util.Set;
 import java.util.Stack;
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Map;
 import java.util.HashMap;
 
 import org.apache.tools.ant.taskdefs.Typedef;
 import org.apache.tools.ant.taskdefs.Definer;
 import org.apache.tools.ant.launch.Launcher;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * Component creation and configuration.
  *
  * The class is based around handing component
  * definitions in an AntTypeTable.
  *
  * The old task/type methods have been kept
  * for backward compatibly.
  * Project will just delegate its calls to this class.
  *
  * A very simple hook mechanism is provided that allows users to plug
  * in custom code. It is also possible to replace the default behavior
  * ( for example in an app embedding ant )
  *
  * @since Ant1.6
  */
 public class ComponentHelper  {
     /** Map of component name to lists of restricted definitions */
     private Map          restrictedDefinitions = new HashMap();
 
     /** Map from component name to anttypedefinition */
     private AntTypeTable antTypeTable;
 
     /** Map of tasks generated from antTypeTable */
     private final Hashtable taskClassDefinitions = new Hashtable();
 
     /** flag to rebuild taskClassDefinitions */
     private boolean rebuildTaskClassDefinitions = true;
 
     /** Map of types generated from antTypeTable */
     private final Hashtable typeClassDefinitions = new Hashtable();
 
     /** flag to rebuild typeClassDefinitions */
     private boolean rebuildTypeClassDefinitions = true;
 
     /** Set of namespaces that have been checked for antlibs */
     private final HashSet checkedNamespaces = new HashSet();
 
     /**
      * Stack of antlib contexts used to resolve definitions while
      *   processing antlib
      */
     private Stack antLibStack = new Stack();
 
     /** current antlib uri */
     private String antLibCurrentUri = null;
 
     /**
      * this does not appear to be used anywhere in the Ant codebase
      * even via its accessors
      */
     private ComponentHelper next;
 
     /**
      * Project that owns a component helper
      */
     private Project project;
 
     /**
      * Error string when the file taskdefs/defaults.properties cannot be found
      */
     private static final String ERROR_NO_TASK_LIST_LOAD = "Can't load default task list";
 
     /**
      * Error string when the typedefs/defaults.properties cannot be found
      */
     private static final String ERROR_NO_TYPE_LIST_LOAD = "Can't load default type list";
 
     /**
      * reference under which we register ourselves with a project -{@value}
      */
     public static final String COMPONENT_HELPER_REFERENCE = "ant.ComponentHelper";
 
     /**
      * string used to control build.syspath policy {@value}
      */
     private static final String BUILD_SYSCLASSPATH_ONLY = "only";
 
     /**
      * special name of ant's property task -{@value}. There is some
      * contrived work here to enable this early.
      */
     private static final String ANT_PROPERTY_TASK = "property";
 
     // {tasks, types}
     private static Properties[] defaultDefinitions = new Properties[2];
 
      /**
      * Get the project.
      * @return the project owner of this helper.
      */
      public Project getProject() {
          return project;
      }
 
     /**
      * Find a project component for a specific project, creating
      * it if it does not exist.
      * @param project the project.
      * @return the project component for a specific project.
      */
     public static ComponentHelper getComponentHelper(Project project) {
         if (project == null) {
             return null;
         }
         // Singleton for now, it may change ( per/classloader )
         ComponentHelper ph = (ComponentHelper) project.getReference(COMPONENT_HELPER_REFERENCE);
         if (ph != null) {
             return ph;
         }
         ph = new ComponentHelper();
         ph.setProject(project);
 
         project.addReference(COMPONENT_HELPER_REFERENCE, ph);
         return ph;
     }
 
     /**
      * Creates a new ComponentHelper instance.
      */
     protected ComponentHelper() {
     }
 
     /**
      * Set the next chained component helper.
      *
      * @param next the next chained component helper.
      */
     public void setNext(ComponentHelper next) {
         this.next = next;
     }
 
     /**
      * Get the next chained component helper.
      *
      * @return the next chained component helper.
      */
     public ComponentHelper getNext() {
         return next;
     }
 
     /**
      * Sets the project for this component helper.
      *
      * @param project the project for this helper.
      */
     public void setProject(Project project) {
         this.project = project;
         antTypeTable = new AntTypeTable(project);
     }
 
     /**
      * @return A copy of the CheckedNamespace.
      */
     private synchronized Set getCheckedNamespace() {
         return (Set) checkedNamespaces.clone();
     }
 
     /**
      * @return A deep copy of the restrictredDefinition
      */
     private Map getRestrictedDefinition() {
         Map result = new HashMap();
         synchronized (restrictedDefinitions) {
             for(Iterator i = restrictedDefinitions.entrySet().iterator();
                          i.hasNext();) {
                 Map.Entry entry = (Map.Entry) i.next();
                 List entryVal = (List) entry.getValue();
                 synchronized (entryVal) {
                     //copy the entryVal
                     entryVal = new ArrayList(entryVal);
                 }
                 Object entryKey = entry.getKey();                                    
                 result.put(entryKey, entryVal);
             }
         }
         return result;
     }
 
     
     /**
      * Used with creating child projects. Each child
      * project inherits the component definitions
      * from its parent.
      * @param helper the component helper of the parent project.
      */
     public void initSubProject(ComponentHelper helper) {
         // add the types of the parent project
         AntTypeTable typeTable = (AntTypeTable) helper.antTypeTable.clone();
         synchronized (antTypeTable) { 
             for (Iterator i = typeTable.values().iterator(); i.hasNext();) {
                 AntTypeDefinition def = (AntTypeDefinition) i.next();
                 antTypeTable.put(def.getName(), def);
             }
         }
         // add the parsed namespaces of the parent project
         Set inheritedCheckedNamespace = helper.getCheckedNamespace();
         synchronized (this) {
             checkedNamespaces.addAll(inheritedCheckedNamespace);
         }
         Map inheritedRestrictedDef = helper.getRestrictedDefinition();
         synchronized (restrictedDefinitions) {
             restrictedDefinitions.putAll(inheritedRestrictedDef);
         }
     }
 
     /**
      * Factory method to create the components.
      *
      * This should be called by UnknownElement.
      *
      * @param ue The Unknown Element creating this component.
      * @param ns Namespace URI. Also available as ue.getNamespace().
      * @param componentType The component type,
      *                       Also available as ue.getComponentName().
      * @return the created component.
      * @throws BuildException if an error occurs.
      */
     public Object createComponent(UnknownElement ue, String ns, String componentType)
             throws BuildException {
         Object component = createComponent(componentType);
         if (component instanceof Task) {
             Task task = (Task) component;
             task.setLocation(ue.getLocation());
             task.setTaskType(componentType);
             task.setTaskName(ue.getTaskName());
             task.setOwningTarget(ue.getOwningTarget());
             task.init();
         }
         return component;
     }
 
     /**
      * Create an object for a component.
      *
      * @param componentName the name of the component, if
      *                      the component is in a namespace, the
      *                      name is prefixed with the namespace uri and ":".
      * @return the class if found or null if not.
      */
     public Object createComponent(String componentName) {
         AntTypeDefinition def = getDefinition(componentName);
         return def == null ? null : def.create(project);
     }
 
     /**
      * Return the class of the component name.
      *
      * @param componentName the name of the component, if
      *                      the component is in a namespace, the
      *                      name is prefixed with the namespace uri and ":".
      * @return the class if found or null if not.
      */
     public Class getComponentClass(String componentName) {
         AntTypeDefinition def = getDefinition(componentName);
         return def == null ? null : def.getExposedClass(project);
     }
 
     /**
      * Return the antTypeDefinition for a componentName.
      * @param componentName the name of the component.
      * @return the ant definition or null if not present.
      */
     public AntTypeDefinition getDefinition(String componentName) {
         checkNamespace(componentName);
         return antTypeTable.getDefinition(componentName);
     }
 
     /**
      * This method is initialization code implementing the original ant component
      * loading from /org/apache/tools/ant/taskdefs/default.properties
      * and /org/apache/tools/ant/types/default.properties.
      */
     public void initDefaultDefinitions() {
         initTasks();
         initTypes();
     }
 
     /**
      * Adds a new task definition to the project.
      * Attempting to override an existing definition with an
      * equivalent one (i.e. with the same classname) results in
      * a verbose log message. Attempting to override an existing definition
      * with a different one results in a warning log message.
      *
      * @param taskName The name of the task to add.
      *                 Must not be <code>null</code>.
      * @param taskClass The full name of the class implementing the task.
      *                  Must not be <code>null</code>.
      *
      * @exception BuildException if the class is unsuitable for being an Ant
      *                           task. An error level message is logged before
      *                           this exception is thrown.
      *
      * @see #checkTaskClass(Class)
      */
     public void addTaskDefinition(String taskName, Class taskClass) {
         checkTaskClass(taskClass);
         AntTypeDefinition def = new AntTypeDefinition();
         def.setName(taskName);
         def.setClassLoader(taskClass.getClassLoader());
         def.setClass(taskClass);
         def.setAdapterClass(TaskAdapter.class);
         def.setClassName(taskClass.getName());
         def.setAdaptToClass(Task.class);
         updateDataTypeDefinition(def);
     }
 
     /**
      * Checks whether or not a class is suitable for serving as Ant task.
      * Ant task implementation classes must be public, concrete, and have
      * a no-arg constructor.
      *
      * @param taskClass The class to be checked.
      *                  Must not be <code>null</code>.
      *
      * @exception BuildException if the class is unsuitable for being an Ant
      *                           task. An error level message is logged before
      *                           this exception is thrown.
      */
     public void checkTaskClass(final Class taskClass) throws BuildException {
         if (!Modifier.isPublic(taskClass.getModifiers())) {
             final String message = taskClass + " is not public";
             project.log(message, Project.MSG_ERR);
             throw new BuildException(message);
         }
         if (Modifier.isAbstract(taskClass.getModifiers())) {
             final String message = taskClass + " is abstract";
             project.log(message, Project.MSG_ERR);
             throw new BuildException(message);
         }
         try {
             taskClass.getConstructor((Class[]) null);
             // don't have to check for public, since
             // getConstructor finds public constructors only.
         } catch (NoSuchMethodException e) {
             final String message = "No public no-arg constructor in " + taskClass;
             project.log(message, Project.MSG_ERR);
             throw new BuildException(message);
         }
         if (!Task.class.isAssignableFrom(taskClass)) {
             TaskAdapter.checkTaskClass(taskClass, project);
         }
     }
 
     /**
      * Returns the current task definition hashtable. The returned hashtable is
      * "live" and so should not be modified.  Also, the returned table may be 
-     * modifed asynchronously.
+     * modified asynchronously.
      *
      * @return a map of from task name to implementing class
      *         (String to Class).
      */
     public Hashtable getTaskDefinitions() {
         synchronized (taskClassDefinitions) {
             synchronized (antTypeTable) {
                 if (rebuildTaskClassDefinitions) {
                     taskClassDefinitions.clear();
                     for (Iterator i = antTypeTable.keySet().iterator(); i.hasNext();) {
                         String name = (String) i.next();
                         Class clazz = antTypeTable.getExposedClass(name);
                         if (clazz == null) {
                             continue;
                         }
                         if (Task.class.isAssignableFrom(clazz)) {
                             taskClassDefinitions.put(name, antTypeTable.getTypeClass(name));
                         }
                     }
                     rebuildTaskClassDefinitions = false;
                 }
             }
         }
         return taskClassDefinitions;
     }
 
     /**
      * Returns the current type definition hashtable. The returned hashtable is
      * "live" and so should not be modified.
      *
      * @return a map of from type name to implementing class
      *         (String to Class).
      */
     public Hashtable getDataTypeDefinitions() {
         synchronized (typeClassDefinitions) {
             synchronized (antTypeTable) {
                 if (rebuildTypeClassDefinitions) {
                     typeClassDefinitions.clear();
                     for (Iterator i = antTypeTable.keySet().iterator(); i.hasNext();) {
                         String name = (String) i.next();
                         Class clazz = antTypeTable.getExposedClass(name);
                         if (clazz == null) {
                             continue;
                         }
                         if (!(Task.class.isAssignableFrom(clazz))) {
                             typeClassDefinitions.put(name, antTypeTable.getTypeClass(name));
                         }
                     }
                     rebuildTypeClassDefinitions = false;
                 }
             }
         }
         return typeClassDefinitions;
     }
 
     /**
      * This returns a list of restricted definitions for a name.
      * The returned List is "live" and so should not be modified.  
-     * Also, the returned list may be modifed asynchronously.  
+     * Also, the returned list may be modified asynchronously.  
      * Any access must be guarded with a lock on the list itself.
      * 
      * @param componentName the name to use.
      * @return the list of restricted definitions for a particular name.
      */
     public List getRestrictedDefinitions(String componentName) {
         synchronized (restrictedDefinitions) {
             return (List) restrictedDefinitions.get(componentName);
         }
     }
 
     /**
      * Adds a new datatype definition.
      * Attempting to override an existing definition with an
      * equivalent one (i.e. with the same classname) results in
      * a verbose log message. Attempting to override an existing definition
      * with a different one results in a warning log message, but the
      * definition is changed.
      *
      * @param typeName The name of the datatype.
      *                 Must not be <code>null</code>.
      * @param typeClass The full name of the class implementing the datatype.
      *                  Must not be <code>null</code>.
      */
     public void addDataTypeDefinition(String typeName, Class typeClass) {
         AntTypeDefinition def = new AntTypeDefinition();
         def.setName(typeName);
         def.setClass(typeClass);
         updateDataTypeDefinition(def);
         project.log(" +User datatype: " + typeName + "     " + typeClass.getName(),
                 Project.MSG_DEBUG);
     }
 
     /**
      * Describe <code>addDataTypeDefinition</code> method here.
      *
      * @param def an <code>AntTypeDefinition</code> value.
      */
     public void addDataTypeDefinition(AntTypeDefinition def) {
         if (!def.isRestrict()) {
            updateDataTypeDefinition(def);
         } else {
             updateRestrictedDefinition(def);
         }
     }
 
     /**
      * Returns the current datatype definition hashtable. The returned
      * hashtable is "live" and so should not be modified.
      *
      * @return a map of from datatype name to implementing class
      *         (String to Class).
      */
     public Hashtable getAntTypeTable() {
         return antTypeTable;
     }
 
     /**
      * Creates a new instance of a task.
      *
      *  Called from Project.createTask(), which can be called by tasks.
      *
      * @param taskType The name of the task to create an instance of.
      *                 Must not be <code>null</code>.
      *
      * @return an instance of the specified task, or <code>null</code> if
      *         the task name is not recognised.
      *
      * @exception BuildException if the task name is recognised but task
      *                           creation fails.
      */
     public Task createTask(String taskType) throws BuildException {
         Task task = createNewTask(taskType);
         if (task == null && taskType.equals(ANT_PROPERTY_TASK)) {
             // quick fix for Ant.java use of property before
             // initializing the project
             addTaskDefinition(ANT_PROPERTY_TASK, org.apache.tools.ant.taskdefs.Property.class);
             task = createNewTask(taskType);
         }
         return task;
     }
 
     /**
      * Creates a new instance of a task.
      * @since ant1.6
      * @param taskType The name of the task to create an instance of.
      *                 Must not be <code>null</code>.
      *
      * @return an instance of the specified task, or <code>null</code> if
      *         the task name is not recognised.
      *
      * @exception BuildException if the task name is recognised but task
      *                           creation fails.
      */
     private Task createNewTask(String taskType) throws BuildException {
         Class c = getComponentClass(taskType);
         if (c == null || !(Task.class.isAssignableFrom(c))) {
             return null;
         }
         Object obj = createComponent(taskType);
         if (obj == null) {
             return null;
         }
         if (!(obj instanceof Task)) {
             throw new BuildException("Expected a Task from '" + taskType
                     + "' but got an instance of " + obj.getClass().getName() + " instead");
         }
         Task task = (Task) obj;
         task.setTaskType(taskType);
 
         // set default value, can be changed by the user
         task.setTaskName(taskType);
 
         project.log("   +Task: " + taskType, Project.MSG_DEBUG);
         return task;
     }
 
     /**
      * Creates a new instance of a data type.
      *
      * @param typeName The name of the data type to create an instance of.
      *                 Must not be <code>null</code>.
      *
      * @return an instance of the specified data type, or <code>null</code> if
      *         the data type name is not recognised.
      *
      * @exception BuildException if the data type name is recognised but
      *                           instance creation fails.
      */
     public Object createDataType(String typeName) throws BuildException {
         return createComponent(typeName);
     }
 
     /**
      * Returns a description of the type of the given element.
      * <p>
      * This is useful for logging purposes.
      *
      * @param element The element to describe.
      *                Must not be <code>null</code>.
      *
      * @return a description of the element type.
      *
      * @since Ant 1.6
      */
     public String getElementName(Object element) {
         return getElementName(element, false);
     }
 
     /**
      * Returns a description of the type of the given element.
      * <p>
      * This is useful for logging purposes.
      *
      * @param o     The element to describe.
      *              Must not be <code>null</code>.
      * @param brief whether to use a brief description.
      * @return a description of the element type.
      *
      * @since Ant 1.7
      */
     public String getElementName(Object o, boolean brief) {
         //  PR: I do not know what to do if the object class
         //      has multiple defines
         //      but this is for logging only...
         Class elementClass = o.getClass();
         String elementClassname = elementClass.getName();
         synchronized (antTypeTable) {
             for (Iterator i = antTypeTable.values().iterator(); i.hasNext();) {
                 AntTypeDefinition def = (AntTypeDefinition) i.next();
                 if (elementClassname.equals(def.getClassName())
                         && (elementClass == def.getExposedClass(project))) {
                     String name = def.getName();
                     return brief ? name : "The <" + name + "> type";
                 }
             }
         }
         return getUnmappedElementName(o.getClass(), brief);
     }
 
     /**
      * Convenient way to get some element name even when you may not have a
      * Project context.
      * @param p       The optional Project instance.
      * @param o       The element to describe.
      *                Must not be <code>null</code>.
      * @param brief   whether to use a brief description.
      * @return a description of the element type.
      * @since Ant 1.7
      */
     public static String getElementName(Project p, Object o, boolean brief) {
         if (p == null) {
             p = Project.getProject(o);
         }
         return p == null ? getUnmappedElementName(o.getClass(), brief) : getComponentHelper(p)
                 .getElementName(o, brief);
     }
 
     private static String getUnmappedElementName(Class c, boolean brief) {
         if (brief) {
             String name = c.getName();
             return name.substring(name.lastIndexOf('.') + 1);
         }
         return c.toString();
     }
 
     /**
      * Check if definition is a valid definition--it may be a
      * definition of an optional task that does not exist.
      * @param def the definition to test.
      * @return true if exposed type of definition is present.
      */
     private boolean validDefinition(AntTypeDefinition def) {
         return !(def.getTypeClass(project) == null || def.getExposedClass(project) == null);
     }
 
     /**
      * Check if two definitions are the same.
      * @param def  the new definition.
      * @param old the old definition.
      * @return true if the two definitions are the same.
      */
     private boolean sameDefinition(AntTypeDefinition def, AntTypeDefinition old) {
         boolean defValid = validDefinition(def);
         boolean sameValidity = (defValid == validDefinition(old));
         //must have same validity; then if they are valid they must also be the same:
         return sameValidity && (!defValid || def.sameDefinition(old, project));
     }
 
     /**
       * update the restricted definition table with a new or
       * modified definition.
       */
     private void updateRestrictedDefinition(AntTypeDefinition def) {
         String name = def.getName();
         List list = null;
         synchronized (restrictedDefinitions) {
             list = (List) restrictedDefinitions.get(name);
             if (list == null) {
                 list = new ArrayList();
                 restrictedDefinitions.put(name, list);
             }
         }
         // Check if the classname is already present and remove it
         // if it is
         synchronized (list) {
             for (Iterator i = list.iterator(); i.hasNext();) {
                 AntTypeDefinition current = (AntTypeDefinition) i.next();
                 if (current.getClassName().equals(def.getClassName())) {
                     i.remove();
                     break;
                 }
             }
             list.add(def);
         }
     }
 
     /**
      * Update the component definition table with a new or
      * modified definition.
      * @param def the definition to update or insert.
      */
     private void updateDataTypeDefinition(AntTypeDefinition def) {
         String name = def.getName();
         synchronized (antTypeTable) {
             rebuildTaskClassDefinitions = true;
             rebuildTypeClassDefinitions = true;
             AntTypeDefinition old = antTypeTable.getDefinition(name);
             if (old != null) {
                 if (sameDefinition(def, old)) {
                     return;
                 }
                 Class oldClass = antTypeTable.getExposedClass(name);
                 boolean isTask = oldClass != null && Task.class.isAssignableFrom(oldClass);
                 project.log("Trying to override old definition of "
                         + (isTask ? "task " : "datatype ") + name, (def.similarDefinition(old,
                         project)) ? Project.MSG_VERBOSE : Project.MSG_WARN);
             }
             project.log(" +Datatype " + name + " " + def.getClassName(), Project.MSG_DEBUG);
             antTypeTable.put(name, def);
         }
     }
 
     /**
      * Called at the start of processing an antlib.
      * @param uri the uri that is associated with this antlib.
      */
     public void enterAntLib(String uri) {
         antLibCurrentUri = uri;
         antLibStack.push(uri);
     }
 
     /**
      * @return the current antlib uri.
      */
     public String getCurrentAntlibUri() {
         return antLibCurrentUri;
     }
 
     /**
      * Called at the end of processing an antlib.
      */
     public void exitAntLib() {
         antLibStack.pop();
         antLibCurrentUri = (antLibStack.size() == 0) ? null : (String) antLibStack.peek();
     }
 
     /**
      * Load ant's tasks.
      */
     private void initTasks() {
         ClassLoader classLoader = getClassLoader(null);
         Properties props = getDefaultDefinitions(false);
         Enumeration e = props.propertyNames();
         while (e.hasMoreElements()) {
             String name = (String) e.nextElement();
             String className = props.getProperty(name);
             AntTypeDefinition def = new AntTypeDefinition();
             def.setName(name);
             def.setClassName(className);
             def.setClassLoader(classLoader);
             def.setAdaptToClass(Task.class);
             def.setAdapterClass(TaskAdapter.class);
             antTypeTable.put(name, def);
         }
     }
 
     private ClassLoader getClassLoader(ClassLoader classLoader) {
         String buildSysclasspath = project.getProperty(MagicNames.BUILD_SYSCLASSPATH);
         if (project.getCoreLoader() != null
             && !(BUILD_SYSCLASSPATH_ONLY.equals(buildSysclasspath))) {
             classLoader = project.getCoreLoader();
         }
         return classLoader;
     }
 
     /**
      * Load default task or type definitions - just the names,
      *  no class loading.
      * Caches results between calls to reduce overhead.
      * @param type true for typedefs, false for taskdefs
      * @return a mapping from definition names to class names
      * @throws BuildException if there was some problem loading
      *                        or parsing the definitions list
      */
     private static synchronized Properties getDefaultDefinitions(boolean type)
             throws BuildException {
         int idx = type ? 1 : 0;
         if (defaultDefinitions[idx] == null) {
             String resource = type ? MagicNames.TYPEDEFS_PROPERTIES_RESOURCE
                     : MagicNames.TASKDEF_PROPERTIES_RESOURCE;
             String errorString = type ? ERROR_NO_TYPE_LIST_LOAD : ERROR_NO_TASK_LIST_LOAD;
             InputStream in = null;
             try {
                 in = ComponentHelper.class.getResourceAsStream(resource);
                 if (in == null) {
                     throw new BuildException(errorString);
                 }
                 Properties p = new Properties();
                 p.load(in);
                 defaultDefinitions[idx] = p;
             } catch (IOException e) {
                 throw new BuildException(errorString, e);
             } finally {
                 FileUtils.close(in);
             }
         }
         return defaultDefinitions[idx];
     }
 
     /**
      * Load ant's datatypes.
      */
     private void initTypes() {
         ClassLoader classLoader = getClassLoader(null);
         Properties props = getDefaultDefinitions(true);
         Enumeration e = props.propertyNames();
         while (e.hasMoreElements()) {
             String name = (String) e.nextElement();
             String className = props.getProperty(name);
             AntTypeDefinition def = new AntTypeDefinition();
             def.setName(name);
             def.setClassName(className);
             def.setClassLoader(classLoader);
             antTypeTable.put(name, def);
         }
     }
 
     /**
      * Called for each component name, check if the
      * associated URI has been examined for antlibs.
      * @param componentName the name of the component, which should include a URI
      *                      prefix if it is in a namespace
      */
     private synchronized void checkNamespace(String componentName) {
         String uri = ProjectHelper.extractUriFromComponentName(componentName);
         if ("".equals(uri)) {
             uri = ProjectHelper.ANT_CORE_URI;
         }
         if (!uri.startsWith(ProjectHelper.ANTLIB_URI)) {
             return; // namespace that does not contain antlib
         }
         if (checkedNamespaces.contains(uri)) {
             return; // Already processed
         }
         checkedNamespaces.add(uri);
 
         if (antTypeTable.size() == 0) {
             // Project instance doesn't know the tasks and types
             // defined in defaults.properties, likely created by the
             // user - without those definitions it cannot parse antlib
             // files as taskdef, typedef and friends are unknown
             initDefaultDefinitions();
         }
         Typedef definer = new Typedef();
         definer.setProject(project);
         definer.init();
         definer.setURI(uri);
         //there to stop error messages being "null"
         definer.setTaskName(uri);
         //if this is left out, bad things happen. like all build files break
         //on the first element encountered.
         definer.setResource(Definer.makeResourceFromURI(uri));
         // a fishing expedition :- ignore errors if antlib not present
         definer.setOnError(new Typedef.OnError(Typedef.OnError.POLICY_IGNORE));
         definer.execute();
     }
 
     /**
      * Handler called to do decent diagnosis on instantiation failure.
      * @param componentName component name.
      * @param type component type, used in error messages
      * @return a string containing as much diagnostics info as possible.
      */
     public String diagnoseCreationFailure(String componentName, String type) {
         StringWriter errorText = new StringWriter();
         PrintWriter out = new PrintWriter(errorText);
         out.println("Problem: failed to create " + type + " " + componentName);
         //class of problem
         boolean lowlevel = false;
         boolean jars = false;
         boolean definitions = false;
         boolean antTask;
         String home = System.getProperty(Launcher.USER_HOMEDIR);
         File libDir = new File(home, Launcher.USER_LIBDIR);
         String antHomeLib;
         boolean probablyIDE = false;
         String anthome = System.getProperty(MagicNames.ANT_HOME);
         if (anthome != null) {
             File antHomeLibDir = new File(anthome, "lib");
             antHomeLib = antHomeLibDir.getAbsolutePath();
         } else {
             //running under an IDE that doesn't set ANT_HOME
             probablyIDE = true;
             antHomeLib = "ANT_HOME" + File.separatorChar + "lib";
         }
         StringBuffer dirListingText = new StringBuffer();
         final String tab = "        -";
         dirListingText.append(tab);
         dirListingText.append(antHomeLib);
         dirListingText.append('\n');
         if (probablyIDE) {
             dirListingText.append(tab);
             dirListingText.append("the IDE Ant configuration dialogs");
         } else {
             dirListingText.append(tab);
             dirListingText.append(libDir);
             dirListingText.append('\n');
             dirListingText.append(tab);
             dirListingText.append("a directory added on the command line with the -lib argument");
         }
         String dirListing = dirListingText.toString();
 
         //look up the name
         AntTypeDefinition def = getDefinition(componentName);
         if (def == null) {
             //not a known type
             printUnknownDefinition(out, componentName, dirListing);
             definitions = true;
         } else {
             //we are defined, so it is an instantiation problem
             final String classname = def.getClassName();
             antTask = classname.startsWith("org.apache.tools.ant.");
             boolean optional = classname.startsWith("org.apache.tools.ant.taskdefs.optional");
             optional |= classname.startsWith("org.apache.tools.ant.types.optional");
 
             //start with instantiating the class.
             Class clazz = null;
             try {
                 clazz = def.innerGetTypeClass();
             } catch (ClassNotFoundException e) {
                 jars = true;
                 if (!optional) {
                     definitions = true;
                 }
                 printClassNotFound(out, classname, optional, dirListing);
             } catch (NoClassDefFoundError ncdfe) {
                 jars = true;
                 printNotLoadDependentClass(out, optional, ncdfe, dirListing);
             }
             //here we successfully loaded the class or failed.
             if (clazz != null) {
                 //success: proceed with more steps
                 try {
                     def.innerCreateAndSet(clazz, project);
                     //hey, there is nothing wrong with us
                     out.println("The component could be instantiated.");
                 } catch (NoSuchMethodException e) {
                     lowlevel = true;
                     out.println("Cause: The class " + classname
                             + " has no compatible constructor.");
 
                 } catch (InstantiationException e) {
                     lowlevel = true;
                     out.println("Cause: The class " + classname
                             + " is abstract and cannot be instantiated.");
                 } catch (IllegalAccessException e) {
                     lowlevel = true;
                     out.println("Cause: The constructor for " + classname
                             + " is private and cannot be invoked.");
                 } catch (InvocationTargetException ex) {
                     lowlevel = true;
                     Throwable t = ex.getTargetException();
                     out.println("Cause: The constructor threw the exception");
                     out.println(t.toString());
                     t.printStackTrace(out);
                 }  catch (NoClassDefFoundError ncdfe) {
                     jars = true;
                     out.println("Cause:  A class needed by class " + classname
                             + " cannot be found: ");
                     out.println("       " + ncdfe.getMessage());
                     out.println("Action: Determine what extra JAR files are"
                             + " needed, and place them in:");
                     out.println(dirListing);
                 }
             }
             out.println();
             out.println("Do not panic, this is a common problem.");
             if (definitions) {
                 out.println("It may just be a typographical error in the build file "
                         + "or the task/type declaration.");
             }
             if (jars) {
                 out.println("The commonest cause is a missing JAR.");
             }
             if (lowlevel) {
                 out.println("This is quite a low level problem, which may need "
                         + "consultation with the author of the task.");
                 if (antTask) {
                     out.println("This may be the Ant team. Please file a "
                             + "defect or contact the developer team.");
                 } else {
                     out.println("This does not appear to be a task bundled with Ant.");
                     out.println("Please take it up with the supplier of the third-party " + type
                             + ".");
                     out.println("If you have written it yourself, you probably have a bug to fix.");
                 }
             } else {
                 out.println();
                 out.println("This is not a bug; it is a configuration problem");
             }
         }
         out.flush();
         out.close();
         return errorText.toString();
     }
 
     /**
      * Print unknown definition.forking
      */
     private void printUnknownDefinition(PrintWriter out, String componentName, String dirListing) {
         boolean isAntlib = componentName.indexOf(MagicNames.ANTLIB_PREFIX) == 0;
         String uri = ProjectHelper.extractUriFromComponentName(componentName);
         out.println("Cause: The name is undefined.");
         out.println("Action: Check the spelling.");
         out.println("Action: Check that any custom tasks/types have been declared.");
         out.println("Action: Check that any <presetdef>/<macrodef>"
                 + " declarations have taken place.");
         if (uri.length() > 0) {
             List matches = antTypeTable.findMatches(uri);
             if (matches.size() > 0) {
                 out.println();
                 out.println("The definitions in the namespace " + uri + " are:");
                 for (Iterator it = matches.iterator(); it.hasNext();) {
                     AntTypeDefinition def = (AntTypeDefinition) it.next();
                     String local = ProjectHelper.extractNameFromComponentName(def.getName());
                     out.println("    " + local);
                 }
             } else {
                 out.println("No types or tasks have been defined in this namespace yet");
                 if (isAntlib) {
                     out.println();
                     out.println("This appears to be an antlib declaration. ");
                     out.println("Action: Check that the implementing library exists in one of:");
                     out.println(dirListing);
                 }
             }
         }
     }
 
     /**
      * Print class not found.
      */
     private void printClassNotFound(PrintWriter out, String classname, boolean optional,
             String dirListing) {
         out.println("Cause: the class " + classname + " was not found.");
         if (optional) {
             out.println("        This looks like one of Ant's optional components.");
             out.println("Action: Check that the appropriate optional JAR exists in");
             out.println(dirListing);
         } else {
             out.println("Action: Check that the component has been correctly declared");
             out.println("        and that the implementing JAR is in one of:");
             out.println(dirListing);
         }
     }
 
     /**
      * Print could not load dependent class.
      */
     private void printNotLoadDependentClass(PrintWriter out, boolean optional,
             NoClassDefFoundError ncdfe, String dirListing) {
         out.println("Cause: Could not load a dependent class "
                     +  ncdfe.getMessage());
         if (optional) {
             out.println("       It is not enough to have Ant's optional JARs");
             out.println("       you need the JAR files that the" + " optional tasks depend upon.");
             out.println("       Ant's optional task dependencies are" + " listed in the manual.");
         } else {
             out.println("       This class may be in a separate JAR" + " that is not installed.");
         }
         out.println("Action: Determine what extra JAR files are"
                 + " needed, and place them in one of:");
         out.println(dirListing);
     }
 
     /**
      * Map that contains the component definitions.
      */
     private static class AntTypeTable extends Hashtable {
         private static final long serialVersionUID = -3060442320477772028L;
         private Project project;
 
         AntTypeTable(Project project) {
             this.project = project;
         }
 
         AntTypeDefinition getDefinition(String key) {
             return (AntTypeDefinition) (super.get(key));
         }
 
         public Object get(Object key) {
             return getTypeClass((String) key);
         }
 
         Class getTypeClass(String name) {
             AntTypeDefinition def = getDefinition(name);
             return (def == null) ? null : def.getTypeClass(project);
         }
 
         Class getExposedClass(String name) {
             AntTypeDefinition def = getDefinition(name);
             return def == null ? null : def.getExposedClass(project);
         }
 
         public synchronized boolean contains(Object clazz) {
             boolean found = false;
             if (clazz instanceof Class) {
                 for (Iterator i = values().iterator(); i.hasNext() && !found;) {
                     found = (((AntTypeDefinition) (i.next())).getExposedClass(project) == clazz);
                 }
             }
             return found;
         }
 
         public boolean containsValue(Object value) {
             return contains(value);
         }
 
         /**
          * Create a list of all definitions that match a prefix, usually the URI
          * of a library
          * @param prefix prefix to match off
          * @return the (possibly empty) list of definitions
          */
         public synchronized List/*<AntTypeDefinition>*/ findMatches(String prefix) {
             ArrayList matches = new ArrayList();
             for (Iterator i = values().iterator(); i.hasNext();) {
                 AntTypeDefinition def = (AntTypeDefinition) (i.next());
                 if (def.getName().startsWith(prefix)) {
                     matches.add(def);
                 }
             }
             return matches;
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/ProjectHelper.java b/src/main/org/apache/tools/ant/ProjectHelper.java
index 599aa0b62..7b61160ba 100644
--- a/src/main/org/apache/tools/ant/ProjectHelper.java
+++ b/src/main/org/apache/tools/ant/ProjectHelper.java
@@ -1,609 +1,609 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant;
 
 import java.io.File;
 import java.util.Hashtable;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Vector;
 
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.util.LoaderUtils;
 import org.xml.sax.AttributeList;
 
 /**
  * Configures a Project (complete with Targets and Tasks) based on
  * a build file. It'll rely on a plugin to do the actual processing
  * of the file.
  * <p>
  * This class also provide static wrappers for common introspection.
  */
 public class ProjectHelper {
     /** The URI for ant name space */
     public static final String ANT_CORE_URI    = "antlib:org.apache.tools.ant";
 
     /** The URI for antlib current definitions */
     public static final String ANT_CURRENT_URI      = "ant:current";
 
     /** The URI for defined types/tasks - the format is antlib:<package> */
     public static final String ANTLIB_URI     = "antlib:";
 
     /** Polymorphic attribute  */
     public static final String ANT_TYPE = "ant-type";
 
     /**
      * Name of JVM system property which provides the name of the
      * ProjectHelper class to use.
      */
     public static final String HELPER_PROPERTY = MagicNames.PROJECT_HELPER_CLASS;
 
     /**
      * The service identifier in jars which provide Project Helper
      * implementations.
      */
     public static final String SERVICE_ID = MagicNames.PROJECT_HELPER_SERVICE;
 
     /**
      * name of project helper reference that we add to a project
      */
     public static final String PROJECTHELPER_REFERENCE = MagicNames.REFID_PROJECT_HELPER;
 
     /**
      * Configures the project with the contents of the specified build file.
      *
      * @param project The project to configure. Must not be <code>null</code>.
      * @param buildFile A build file giving the project's configuration.
      *                  Must not be <code>null</code>.
      *
      * @exception BuildException if the configuration is invalid or cannot be read
      */
     public static void configureProject(Project project, File buildFile) throws BuildException {
         FileResource resource = new FileResource(buildFile);
         ProjectHelper helper = ProjectHelperRepository.getInstance().getProjectHelperForBuildFile(resource);
         project.addReference(PROJECTHELPER_REFERENCE, helper);
         helper.parse(project, buildFile);
     }
 
     /**
      * Possible value for target's onMissingExtensionPoint attribute. It determines how to deal with
      * targets that want to extend missing extension-points.
      * <p>
      * This class behaves like a Java 1.5 Enum class.
      * 
      * @since 1.8.2
      */
     public final static class OnMissingExtensionPoint {
 
         /** fail if the extension-point is not defined */
         public static final OnMissingExtensionPoint FAIL = new OnMissingExtensionPoint(
                 "fail");
 
         /** warn if the extension-point is not defined */
         public static final OnMissingExtensionPoint WARN = new OnMissingExtensionPoint(
                 "warn");
 
         /** ignore the extensionOf attribute if the extension-point is not defined */
         public static final OnMissingExtensionPoint IGNORE = new OnMissingExtensionPoint(
                 "ignore");
 
         private static final OnMissingExtensionPoint[] values = new OnMissingExtensionPoint[] {
                                 FAIL, WARN, IGNORE };
 
         private final String name;
 
         private OnMissingExtensionPoint(String name) {
             this.name = name;
         }
 
         public String name() {
             return name;
         }
 
         public String toString() {
             return name;
         }
 
         public static OnMissingExtensionPoint valueOf(String name) {
             if (name == null) {
                 throw new NullPointerException();
             }
             for (int i = 0; i < values.length; i++) {
                 if (name.equals(values[i].name())) {
                     return values[i];
                 }
             }
             throw new IllegalArgumentException(
                     "Unknown onMissingExtensionPoint " + name);
         }
     }
 
     /** Default constructor */
     public ProjectHelper() {
     }
 
     // -------------------- Common properties  --------------------
     // The following properties are required by import ( and other tasks
     // that read build files using ProjectHelper ).
 
     private Vector importStack = new Vector();
     private List extensionStack = new LinkedList();
 
     /**
      *  Import stack.
      *  Used to keep track of imported files. Error reporting should
      *  display the import path.
      *
      * @return the stack of import source objects.
      */
     public Vector getImportStack() {
         return importStack;
     }
 
     /**
      * Extension stack.
      * Used to keep track of targets that extend extension points.
      *
      * @return a list of three element string arrays where the first
      * element is the name of the extensionpoint, the second the name
      * of the target and the third the name of the enum like class
      * {@link OnMissingExtensionPoint}.
      */
     public List<String[]> getExtensionStack() {
         return extensionStack;
     }
 
     private final static ThreadLocal targetPrefix = new ThreadLocal() {
             protected Object initialValue() {
                 return (String) null;
             }
         };
 
     /**
      * The prefix to prepend to imported target names.
      *
      * <p>May be set by &lt;import&gt;'s as attribute.</p>
      *
      * @return the configured prefix or null
      *
      * @since Ant 1.8.0
      */
     public static String getCurrentTargetPrefix() {
         return (String) targetPrefix.get();
     }
 
     /**
      * Sets the prefix to prepend to imported target names.
      *
      * @since Ant 1.8.0
      */
     public static void setCurrentTargetPrefix(String prefix) {
         targetPrefix.set(prefix);
     }
 
     private final static ThreadLocal prefixSeparator = new ThreadLocal() {
             protected Object initialValue() {
                 return ".";
             }
         };
 
     /**
      * The separator between the prefix and the target name.
      *
-     * <p>May be set by &lt;import&gt;'s prefixSeperator attribute.</p>
+     * <p>May be set by &lt;import&gt;'s prefixSeparator attribute.</p>
      *
      * @since Ant 1.8.0
      */
     public static String getCurrentPrefixSeparator() {
         return (String) prefixSeparator.get();
     }
 
     /**
      * Sets the separator between the prefix and the target name.
      *
      * @since Ant 1.8.0
      */
     public static void setCurrentPrefixSeparator(String sep) {
         prefixSeparator.set(sep);
     }
 
     private final static ThreadLocal inIncludeMode = new ThreadLocal() {
             protected Object initialValue() {
                 return Boolean.FALSE;
             }
         };
 
     /**
      * Whether the current file should be read in include as opposed
      * to import mode.
      *
      * <p>In include mode included targets are only known by their
      * prefixed names and their depends lists get rewritten so that
      * all dependencies get the prefix as well.</p>
      *
      * <p>In import mode imported targets are known by an adorned as
      * well as a prefixed name and the unadorned target may be
      * overwritten in the importing build file.  The depends list of
      * the imported targets is not modified at all.</p>
      *
      * @since Ant 1.8.0
      */
     public static boolean isInIncludeMode() {
         return inIncludeMode.get() == Boolean.TRUE;
     }
 
     /**
      * Sets whether the current file should be read in include as
      * opposed to import mode.
      *
      * @since Ant 1.8.0
      */
     public static void setInIncludeMode(boolean includeMode) {
         inIncludeMode.set(includeMode ? Boolean.TRUE : Boolean.FALSE);
     }
 
     // --------------------  Parse method  --------------------
     /**
      * Parses the project file, configuring the project as it goes.
      *
      * @param project The project for the resulting ProjectHelper to configure.
      *                Must not be <code>null</code>.
      * @param source The source for XML configuration. A helper must support
      *               at least File, for backward compatibility. Helpers may
      *               support URL, InputStream, etc or specialized types.
      *
      * @since Ant1.5
      * @exception BuildException if the configuration is invalid or cannot
      *                           be read
      */
     public void parse(Project project, Object source) throws BuildException {
         throw new BuildException("ProjectHelper.parse() must be implemented "
             + "in a helper plugin " + this.getClass().getName());
     }
 
     /**
      * Get the first project helper found in the classpath
      * 
      * @return an project helper, never <code>null</code>
      * @see org.apache.tools.ant.ProjectHelperRepository#getHelpers()
      */
     public static ProjectHelper getProjectHelper() {
         return (ProjectHelper) ProjectHelperRepository.getInstance().getHelpers().next();
     }
 
     /**
      * JDK1.1 compatible access to the context class loader. Cut & paste from JAXP.
      *
      * @deprecated since 1.6.x.
      *             Use LoaderUtils.getContextClassLoader()
      *
      * @return the current context class loader, or <code>null</code>
      * if the context class loader is unavailable.
      */
     public static ClassLoader getContextClassLoader() {
         return LoaderUtils.isContextLoaderAvailable() ? LoaderUtils.getContextClassLoader() : null;
     }
 
     // -------------------- Static utils, used by most helpers ----------------
 
     /**
      * Configures an object using an introspection handler.
      *
      * @param target The target object to be configured.
      *               Must not be <code>null</code>.
      * @param attrs  A list of attributes to configure within the target.
      *               Must not be <code>null</code>.
      * @param project The project containing the target.
      *                Must not be <code>null</code>.
      *
      * @deprecated since 1.6.x.
      *             Use IntrospectionHelper for each property.
      *
      * @exception BuildException if any of the attributes can't be handled by
      *                           the target
      */
     public static void configure(Object target, AttributeList attrs,
                                  Project project) throws BuildException {
         if (target instanceof TypeAdapter) {
             target = ((TypeAdapter) target).getProxy();
         }
         IntrospectionHelper ih = IntrospectionHelper.getHelper(project, target.getClass());
 
         for (int i = 0, length = attrs.getLength(); i < length; i++) {
             // reflect these into the target
             String value = replaceProperties(project, attrs.getValue(i), project.getProperties());
             try {
                 ih.setAttribute(project, target, attrs.getName(i).toLowerCase(Locale.ENGLISH), value);
             } catch (BuildException be) {
                 // id attribute must be set externally
                 if (!attrs.getName(i).equals("id")) {
                     throw be;
                 }
             }
         }
     }
 
     /**
      * Adds the content of #PCDATA sections to an element.
      *
      * @param project The project containing the target.
      *                Must not be <code>null</code>.
      * @param target  The target object to be configured.
      *                Must not be <code>null</code>.
      * @param buf A character array of the text within the element.
      *            Will not be <code>null</code>.
      * @param start The start element in the array.
      * @param count The number of characters to read from the array.
      *
      * @exception BuildException if the target object doesn't accept text
      */
     public static void addText(Project project, Object target, char[] buf,
         int start, int count) throws BuildException {
         addText(project, target, new String(buf, start, count));
     }
 
     /**
      * Adds the content of #PCDATA sections to an element.
      *
      * @param project The project containing the target.
      *                Must not be <code>null</code>.
      * @param target  The target object to be configured.
      *                Must not be <code>null</code>.
      * @param text    Text to add to the target.
      *                May be <code>null</code>, in which case this
      *                method call is a no-op.
      *
      * @exception BuildException if the target object doesn't accept text
      */
     public static void addText(Project project, Object target, String text)
         throws BuildException {
 
         if (text == null) {
             return;
         }
         if (target instanceof TypeAdapter) {
             target = ((TypeAdapter) target).getProxy();
         }
         IntrospectionHelper.getHelper(project, target.getClass()).addText(project, target, text);
     }
 
     /**
      * Stores a configured child element within its parent object.
      *
      * @param project Project containing the objects.
      *                May be <code>null</code>.
      * @param parent  Parent object to add child to.
      *                Must not be <code>null</code>.
      * @param child   Child object to store in parent.
      *                Should not be <code>null</code>.
      * @param tag     Name of element which generated the child.
      *                May be <code>null</code>, in which case
      *                the child is not stored.
      */
     public static void storeChild(Project project, Object parent, Object child, String tag) {
         IntrospectionHelper ih = IntrospectionHelper.getHelper(project, parent.getClass());
         ih.storeElement(project, parent, child, tag);
     }
 
     /**
      * Replaces <code>${xxx}</code> style constructions in the given value with
      * the string value of the corresponding properties.
      *
      * @param project The project containing the properties to replace.
      *                Must not be <code>null</code>.
      *
      * @param value The string to be scanned for property references.
      *              May be <code>null</code>.
      *
      * @exception BuildException if the string contains an opening
      *                           <code>${</code> without a closing
      *                           <code>}</code>
      * @return the original string with the properties replaced, or
      *         <code>null</code> if the original string is <code>null</code>.
      *
      * @deprecated since 1.6.x.
      *             Use project.replaceProperties().
      * @since 1.5
      */
      public static String replaceProperties(Project project, String value) throws BuildException {
         // needed since project properties are not accessible
          return project.replaceProperties(value);
      }
 
     /**
      * Replaces <code>${xxx}</code> style constructions in the given value
      * with the string value of the corresponding data types.
      *
      * @param project The container project. This is used solely for
      *                logging purposes. Must not be <code>null</code>.
      * @param value The string to be scanned for property references.
      *              May be <code>null</code>, in which case this
      *              method returns immediately with no effect.
      * @param keys  Mapping (String to String) of property names to their
      *              values. Must not be <code>null</code>.
      *
      * @exception BuildException if the string contains an opening
      *                           <code>${</code> without a closing
      *                           <code>}</code>
      * @return the original string with the properties replaced, or
      *         <code>null</code> if the original string is <code>null</code>.
      * @deprecated since 1.6.x.
      *             Use PropertyHelper.
      */
      public static String replaceProperties(Project project, String value, Hashtable keys)
              throws BuildException {
         PropertyHelper ph = PropertyHelper.getPropertyHelper(project);
         return ph.replaceProperties(null, value, keys);
     }
 
     /**
      * Parses a string containing <code>${xxx}</code> style property
      * references into two lists. The first list is a collection
      * of text fragments, while the other is a set of string property names.
      * <code>null</code> entries in the first list indicate a property
      * reference from the second list.
      *
      * <p>As of Ant 1.8.0 this method is never invoked by any code
      * inside of Ant itself.</p>
      *
      * @param value     Text to parse. Must not be <code>null</code>.
      * @param fragments List to add text fragments to.
      *                  Must not be <code>null</code>.
      * @param propertyRefs List to add property names to.
      *                     Must not be <code>null</code>.
      *
      * @deprecated since 1.6.x.
      *             Use PropertyHelper.
      * @exception BuildException if the string contains an opening
      *                           <code>${</code> without a closing <code>}</code>
      */
     public static void parsePropertyString(String value, Vector fragments, Vector propertyRefs)
             throws BuildException {
         PropertyHelper.parsePropertyStringDefault(value, fragments, propertyRefs);
     }
 
     /**
      * Map a namespaced {uri,name} to an internal string format.
      * For BC purposes the names from the ant core uri will be
      * mapped to "name", other names will be mapped to
      * uri + ":" + name.
-     * @param uri   The namepace URI
+     * @param uri   The namespace URI
      * @param name  The localname
      * @return      The stringified form of the ns name
      */
     public static String genComponentName(String uri, String name) {
         if (uri == null || uri.equals("") || uri.equals(ANT_CORE_URI)) {
             return name;
         }
         return uri + ":" + name;
     }
 
     /**
      * extract a uri from a component name
      *
      * @param componentName  The stringified form for {uri, name}
      * @return               The uri or "" if not present
      */
     public static String extractUriFromComponentName(String componentName) {
         if (componentName == null) {
             return "";
         }
         int index = componentName.lastIndexOf(':');
         if (index == -1) {
             return "";
         }
         return componentName.substring(0, index);
     }
 
     /**
      * extract the element name from a component name
      *
      * @param componentName  The stringified form for {uri, name}
      * @return               The element name of the component
      */
     public static String extractNameFromComponentName(String componentName) {
         int index = componentName.lastIndexOf(':');
         if (index == -1) {
             return componentName;
         }
         return componentName.substring(index + 1);
     }
 
     /**
      * Add location to build exception.
      * @param ex the build exception, if the build exception
      *           does not include
      * @param newLocation the location of the calling task (may be null)
      * @return a new build exception based in the build exception with
      *         location set to newLocation. If the original exception
      *         did not have a location, just return the build exception
      */
     public static BuildException addLocationToBuildException(
             BuildException ex, Location newLocation) {
         if (ex.getLocation() == null || ex.getMessage() == null) {
             return ex;
         }
         String errorMessage
             = "The following error occurred while executing this line:"
             + System.getProperty("line.separator")
             + ex.getLocation().toString()
             + ex.getMessage();
         if (newLocation == null) {
             return new BuildException(errorMessage, ex);
         }
         return new BuildException(errorMessage, ex, newLocation);
     }
 
     /**
      * Whether this instance of ProjectHelper can parse an Antlib
      * descriptor given by the URL and return its content as an
      * UnknownElement ready to be turned into an Antlib task.
      *
      * <p>This method should not try to parse the content of the
      * descriptor, the URL is only given as an argument to allow
      * subclasses to decide whether they can support a given URL
      * scheme or not.</p>
      *
      * <p>Subclasses that return true in this method must also
      * override {@link #parseAntlibDescriptor
      * parseAntlibDescriptor}.</p>
      *
      * <p>This implementation returns false.</p>
      *
      * @since Ant 1.8.0
      */
     public boolean canParseAntlibDescriptor(Resource r) {
         return false;
     }
 
     /**
      * Parse the given URL as an antlib descriptor and return the
      * content as something that can be turned into an Antlib task.
      *
      * @since ant 1.8.0
      */
     public UnknownElement parseAntlibDescriptor(Project containingProject,
                                                 Resource source) {
         throw new BuildException("can't parse antlib descriptors");
     }
 
     /**
      * Check if the helper supports the kind of file. Some basic check on the
      * extension's file should be done here.
      * 
      * @param buildFile
      *            the file expected to be parsed (never <code>null</code>)
      * @return true if the helper supports it
      * @since Ant 1.8.0
      */
     public boolean canParseBuildFile(Resource buildFile) {
         return true;
     }
 
     /**
      * The file name of the build script to be parsed if none specified on the command line
      * 
      * @return the name of the default file (never <code>null</code>)
      * @since Ant 1.8.0
      */
     public String getDefaultBuildFile() {
         return Main.DEFAULT_BUILD_FILENAME;
     }
 }
diff --git a/src/main/org/apache/tools/ant/filters/FixCrLfFilter.java b/src/main/org/apache/tools/ant/filters/FixCrLfFilter.java
index 1b88d5f0d..e1920d1d1 100644
--- a/src/main/org/apache/tools/ant/filters/FixCrLfFilter.java
+++ b/src/main/org/apache/tools/ant/filters/FixCrLfFilter.java
@@ -1,1008 +1,1008 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.filters;
 
 import java.io.IOException;
 import java.io.Reader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.condition.Os;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 
 /**
  * Converts text to local OS formatting conventions, as well as repair text
  * damaged by misconfigured or misguided editors or file transfer programs.
  * <p>
  * This filter can take the following arguments:
  * <ul>
  * <li>eof
  * <li>eol
  * <li>fixlast
  * <li>javafiles
  * <li>tab
  * <li>tablength
  * </ul>
  * None of which are required.
  * <p>
  * This version generalises the handling of EOL characters, and allows for
  * CR-only line endings (the standard on Mac systems prior to OS X). Tab
  * handling has also been generalised to accommodate any tabwidth from 2 to 80,
  * inclusive. Importantly, it can leave untouched any literal TAB characters
  * embedded within Java string or character constants.
  * <p>
  * <em>Caution:</em> run with care on carefully formatted files. This may
  * sound obvious, but if you don't specify asis, presume that your files are
  * going to be modified. If "tabs" is "add" or "remove", whitespace characters
  * may be added or removed as necessary. Similarly, for EOLs, eol="asis"
  * actually means convert to your native O/S EOL convention while eol="crlf" or
  * cr="add" can result in CR characters being removed in one special case
  * accommodated, i.e., CRCRLF is regarded as a single EOL to handle cases where
  * other programs have converted CRLF into CRCRLF.
  *
  * <P>
  * Example:
  *
  * <pre>
  * &lt;&lt;fixcrlf tab=&quot;add&quot; eol=&quot;crlf&quot; eof=&quot;asis&quot;/&gt;
  * </pre>
  *
  * Or:
  *
  * <pre>
  * &lt;filterreader classname=&quot;org.apache.tools.ant.filters.FixCrLfFilter&quot;&gt;
  *   &lt;param eol=&quot;crlf&quot; tab=&quot;asis&quot;/&gt;
  *  &lt;/filterreader&gt;
  * </pre>
  *
  */
 public final class FixCrLfFilter extends BaseParamFilterReader implements ChainableReader {
     private static final int DEFAULT_TAB_LENGTH = 8;
     private static final int MIN_TAB_LENGTH = 2;
     private static final int MAX_TAB_LENGTH = 80;
     private static final char CTRLZ = '\u001A';
 
     private int tabLength = DEFAULT_TAB_LENGTH;
 
     private CrLf eol;
 
     private AddAsisRemove ctrlz;
 
     private AddAsisRemove tabs;
 
     private boolean javafiles = false;
 
     private boolean fixlast = true;
 
     private boolean initialized = false;
 
     /**
      * Constructor for "dummy" instances.
      *
      * @see BaseFilterReader#BaseFilterReader()
      */
     public FixCrLfFilter() {
         super();
     }
 
     /**
      * Create a new filtered reader.
      *
      * @param in
      *            A Reader object providing the underlying stream. Must not be
      *            <code>null</code>.
      * @throws IOException on error.
      */
     public FixCrLfFilter(final Reader in) throws IOException {
         super(in);
     }
 
     // Instance initializer: Executes just after the super() call in this
     // class's constructor.
     {
         tabs = AddAsisRemove.ASIS;
         if (Os.isFamily("mac") && !Os.isFamily("unix")) {
             ctrlz = AddAsisRemove.REMOVE;
             setEol(CrLf.MAC);
         } else if (Os.isFamily("dos")) {
             ctrlz = AddAsisRemove.ASIS;
             setEol(CrLf.DOS);
         } else {
             ctrlz = AddAsisRemove.REMOVE;
             setEol(CrLf.UNIX);
         }
     }
 
     /**
      * Create a new FixCrLfFilter using the passed in Reader for instantiation.
      *
      * @param rdr
      *            A Reader object providing the underlying stream. Must not be
      *            <code>null</code>.
      *
      * @return a new filter based on this configuration, but filtering the
      *         specified reader.
      */
     public Reader chain(final Reader rdr) {
         try {
             FixCrLfFilter newFilter = new FixCrLfFilter(rdr);
 
             newFilter.setJavafiles(getJavafiles());
             newFilter.setEol(getEol());
             newFilter.setTab(getTab());
             newFilter.setTablength(getTablength());
             newFilter.setEof(getEof());
             newFilter.setFixlast(getFixlast());
             newFilter.initInternalFilters();
 
             return newFilter;
         } catch (IOException e) {
             throw new BuildException(e);
         }
     }
 
     /**
      * Get how DOS EOF (control-z) characters are being handled.
      *
      * @return values:
      *         <ul>
      *         <li>add: ensure that there is an eof at the end of the file
      *         <li>asis: leave eof characters alone
      *         <li>remove: remove any eof character found at the end
      *         </ul>
      */
     public AddAsisRemove getEof() {
         // Return copy so that the call must call setEof() to change the state
         // of fixCRLF
         return ctrlz.newInstance();
     }
 
     /**
      * Get how EndOfLine characters are being handled.
      *
      * @return values:
      *         <ul>
      *         <li>asis: convert line endings to your O/S convention
      *         <li>cr: convert line endings to CR
      *         <li>lf: convert line endings to LF
      *         <li>crlf: convert line endings to CRLF
      *         </ul>
      */
     public CrLf getEol() {
         // Return copy so that the call must call setEol() to change the state
         // of fixCRLF
         return eol.newInstance();
     }
 
     /**
      * Get whether a missing EOL be added to the final line of the stream.
      *
      * @return true if a filtered file will always end with an EOL
      */
     public boolean getFixlast() {
         return fixlast;
     }
 
     /**
      * Get whether the stream is to be treated as though it contains Java
      * source.
      * <P>
-     * This attribute is only used in assocation with the &quot;<i><b>tab</b></i>&quot;
+     * This attribute is only used in association with the &quot;<i><b>tab</b></i>&quot;
      * attribute. Tabs found in Java literals are protected from changes by this
      * filter.
      *
      * @return true if whitespace in Java character and string literals is
      *         ignored.
      */
     public boolean getJavafiles() {
         return javafiles;
     }
 
     /**
      * Return how tab characters are being handled.
      *
      * @return values:
      *         <ul>
      *         <li>add: convert sequences of spaces which span a tab stop to
      *         tabs
      *         <li>asis: leave tab and space characters alone
      *         <li>remove: convert tabs to spaces
      *         </ul>
      */
     public AddAsisRemove getTab() {
         // Return copy so that the caller must call setTab() to change the state
         // of fixCRLF.
         return tabs.newInstance();
     }
 
     /**
      * Get the tab length to use.
      *
      * @return the length of tab in spaces
      */
     public int getTablength() {
         return tabLength;
     }
 
     private static String calculateEolString(CrLf eol) {
         // Calculate the EOL string per the current config
         if (eol == CrLf.ASIS) {
             return System.getProperty("line.separator");
         }
         if (eol == CrLf.CR || eol == CrLf.MAC) {
             return "\r";
         }
         if (eol == CrLf.CRLF || eol == CrLf.DOS) {
             return "\r\n";
         }
         // assume (eol == CrLf.LF || eol == CrLf.UNIX)
         return "\n";
     }
 
     /**
      * Wrap the input stream with the internal filters necessary to perform the
      * configuration settings.
      */
     private void initInternalFilters() {
 
         // If I'm removing an EOF character, do so first so that the other
         // filters don't see that character.
         in = (ctrlz == AddAsisRemove.REMOVE) ? new RemoveEofFilter(in) : in;
 
         // Change all EOL characters to match the calculated EOL string. If
         // configured to do so, append a trailing EOL so that the file ends on
         // a EOL.
         in = new NormalizeEolFilter(in, calculateEolString(eol), getFixlast());
 
         if (tabs != AddAsisRemove.ASIS) {
             // If filtering Java source, prevent changes to whitespace in
             // character and string literals.
             if (getJavafiles()) {
                 in = new MaskJavaTabLiteralsFilter(in);
             }
             // Add/Remove tabs
             in = (tabs == AddAsisRemove.ADD) ? (Reader) new AddTabFilter(in, getTablength())
                     : (Reader) new RemoveTabFilter(in, getTablength());
         }
         // Add missing EOF character
         in = (ctrlz == AddAsisRemove.ADD) ? new AddEofFilter(in) : in;
         initialized = true;
     }
 
     /**
      * Return the next character in the filtered stream.
      *
      * @return the next character in the resulting stream, or -1 if the end of
      *         the resulting stream has been reached.
      *
      * @exception IOException
      *                if the underlying stream throws an IOException during
      *                reading.
      */
     public synchronized int read() throws IOException {
         if (!initialized) {
             initInternalFilters();
         }
         return in.read();
     }
 
     /**
      * Specify how DOS EOF (control-z) characters are to be handled.
      *
      * @param attr
      *            valid values:
      *            <ul>
      *            <li>add: ensure that there is an eof at the end of the file
      *            <li>asis: leave eof characters alone
      *            <li>remove: remove any eof character found at the end
      *            </ul>
      */
     public void setEof(AddAsisRemove attr) {
         ctrlz = attr.resolve();
     }
 
     /**
      * Specify how end of line (EOL) characters are to be handled.
      *
      * @param attr
      *            valid values:
      *            <ul>
      *            <li>asis: convert line endings to your O/S convention
      *            <li>cr: convert line endings to CR
      *            <li>lf: convert line endings to LF
      *            <li>crlf: convert line endings to CRLF
      *            </ul>
      */
     public void setEol(CrLf attr) {
         eol = attr.resolve();
     }
 
     /**
      * Specify whether a missing EOL will be added to the final line of input.
      *
      * @param fixlast
      *            if true a missing EOL will be appended.
      */
     public void setFixlast(boolean fixlast) {
         this.fixlast = fixlast;
     }
 
     /**
      * Indicate whether this stream contains Java source.
      *
      * This attribute is only used in assocation with the &quot;<i><b>tab</b></i>&quot;
      * attribute.
      *
      * @param javafiles
      *            set to true to prevent this filter from changing tabs found in
      *            Java literals.
      */
     public void setJavafiles(boolean javafiles) {
         this.javafiles = javafiles;
     }
 
     /**
      * Specify how tab characters are to be handled.
      *
      * @param attr
      *            valid values:
      *            <ul>
      *            <li>add: convert sequences of spaces which span a tab stop to
      *            tabs
      *            <li>asis: leave tab and space characters alone
      *            <li>remove: convert tabs to spaces
      *            </ul>
      */
     public void setTab(AddAsisRemove attr) {
         tabs = attr.resolve();
     }
 
     /**
      * Specify tab length in characters.
      *
      * @param tabLength
      *            specify the length of tab in spaces. Valid values are between
      *            2 and 80 inclusive. The default for this parameter is 8.
      * @throws IOException on error.
      */
     public void setTablength(int tabLength) throws IOException {
         if (tabLength < MIN_TAB_LENGTH
             || tabLength > MAX_TAB_LENGTH) {
             throw new IOException(
                 "tablength must be between " + MIN_TAB_LENGTH
                 + " and " + MAX_TAB_LENGTH);
         }
         this.tabLength = tabLength;
     }
 
     /**
      * This filter reader redirects all read I/O methods through its own read()
      * method.
      *
      * <P>
      * The input stream is already buffered by the copy task so this doesn't
      * significantly impact performance while it makes writing the individual
      * fix filters much easier.
      * </P>
      */
     private static class SimpleFilterReader extends Reader {
         private static final int PREEMPT_BUFFER_LENGTH = 16;
         private Reader in;
 
         private int[] preempt = new int[PREEMPT_BUFFER_LENGTH];
 
         private int preemptIndex = 0;
 
         public SimpleFilterReader(Reader in) {
             this.in = in;
         }
 
         public void push(char c) {
             push((int) c);
         }
 
         public void push(int c) {
             try {
                 preempt[preemptIndex++] = c;
             } catch (ArrayIndexOutOfBoundsException e) {
                 int[] p2 = new int[preempt.length * 2];
                 System.arraycopy(preempt, 0, p2, 0, preempt.length);
                 preempt = p2;
                 push(c);
             }
         }
 
         public void push(char[] cs, int start, int length) {
             for (int i = start + length - 1; i >= start;) {
                 push(cs[i--]);
             }
         }
 
         public void push(char[] cs) {
             push(cs, 0, cs.length);
         }
 
         public void push(String s) {
             push(s.toCharArray());
         }
 
         /**
          * Does this filter want to block edits on the last character returned
          * by read()?
          */
         public boolean editsBlocked() {
             return in instanceof SimpleFilterReader && ((SimpleFilterReader) in).editsBlocked();
         }
 
         public int read() throws java.io.IOException {
             return preemptIndex > 0 ? preempt[--preemptIndex] : in.read();
         }
 
         public void close() throws java.io.IOException {
             in.close();
         }
 
         public void reset() throws IOException {
             in.reset();
         }
 
         public boolean markSupported() {
             return in.markSupported();
         }
 
         public boolean ready() throws java.io.IOException {
             return in.ready();
         }
 
         public void mark(int i) throws java.io.IOException {
             in.mark(i);
         }
 
         public long skip(long i) throws java.io.IOException {
             return in.skip(i);
         }
 
         public int read(char[] buf) throws java.io.IOException {
             return read(buf, 0, buf.length);
         }
 
         public int read(char[] buf, int start, int length) throws java.io.IOException {
             int count = 0;
             int c = 0;
 
             // CheckStyle:InnerAssignment OFF - leave alone
             while (length-- > 0 && (c = this.read()) != -1) {
                 buf[start++] = (char) c;
                 count++;
             }
             // if at EOF with no characters in the buffer, return EOF
             return (count == 0 && c == -1) ? -1 : count;
         }
     }
 
     private static class MaskJavaTabLiteralsFilter extends SimpleFilterReader {
         private boolean editsBlocked = false;
 
         private static final int JAVA = 1;
 
         private static final int IN_CHAR_CONST = 2;
 
         private static final int IN_STR_CONST = 3;
 
         private static final int IN_SINGLE_COMMENT = 4;
 
         private static final int IN_MULTI_COMMENT = 5;
 
         private static final int TRANS_TO_COMMENT = 6;
 
         private static final int TRANS_FROM_MULTI = 8;
 
         private int state;
 
         public MaskJavaTabLiteralsFilter(Reader in) {
             super(in);
             state = JAVA;
         }
 
         public boolean editsBlocked() {
             return editsBlocked || super.editsBlocked();
         }
 
         public int read() throws IOException {
             int thisChar = super.read();
             // Mask, block from being edited, all characters in constants.
             editsBlocked = (state == IN_CHAR_CONST || state == IN_STR_CONST);
 
             switch (state) {
             case JAVA:
                 // The current character is always emitted.
                 switch (thisChar) {
                 case '\'':
                     state = IN_CHAR_CONST;
                     break;
                 case '"':
                     state = IN_STR_CONST;
                     break;
                 case '/':
                     state = TRANS_TO_COMMENT;
                     break;
                 default:
                     // Fall tru
                 }
                 break;
             case IN_CHAR_CONST:
                 switch (thisChar) {
                 case '\'':
                     state = JAVA;
                     break;
                 default:
                     // Fall tru
                 }
                 break;
             case IN_STR_CONST:
                 switch (thisChar) {
                 case '"':
                     state = JAVA;
                     break;
                 default:
                     // Fall tru
                 }
                 break;
             case IN_SINGLE_COMMENT:
                 // The current character is always emitted.
                 switch (thisChar) {
                 case '\n':
                 case '\r': // EOL
                     state = JAVA;
                     break;
                 default:
                     // Fall tru
                 }
                 break;
             case IN_MULTI_COMMENT:
                 // The current character is always emitted.
                 switch (thisChar) {
                 case '*':
                     state = TRANS_FROM_MULTI;
                     break;
                 default:
                     // Fall tru
                 }
                 break;
             case TRANS_TO_COMMENT:
                 // The current character is always emitted.
                 switch (thisChar) {
                 case '*':
                     state = IN_MULTI_COMMENT;
                     break;
                 case '/':
                     state = IN_SINGLE_COMMENT;
                     break;
                 case '\'':
                     state = IN_CHAR_CONST;
                     break;
                 case '"':
                     state = IN_STR_CONST;
                     break;
                 default:
                     state = JAVA;
                 }
                 break;
             case TRANS_FROM_MULTI:
                 // The current character is always emitted.
                 switch (thisChar) {
                 case '/':
                     state = JAVA;
                     break;
                 default:
                     // Fall tru
                 }
                 break;
             default:
                 // Fall tru
             }
             return thisChar;
         }
     }
 
     private static class NormalizeEolFilter extends SimpleFilterReader {
         private boolean previousWasEOL;
 
         private boolean fixLast;
 
         private int normalizedEOL = 0;
 
         private char[] eol = null;
 
         public NormalizeEolFilter(Reader in, String eolString, boolean fixLast) {
             super(in);
             eol = eolString.toCharArray();
             this.fixLast = fixLast;
         }
 
         public int read() throws IOException {
             int thisChar = super.read();
 
             if (normalizedEOL == 0) {
                 int numEOL = 0;
                 boolean atEnd = false;
                 switch (thisChar) {
                 case CTRLZ:
                     int c = super.read();
                     if (c == -1) {
                         atEnd = true;
                         if (fixLast && !previousWasEOL) {
                             numEOL = 1;
                             push(thisChar);
                         }
                     } else {
                         push(c);
                     }
                     break;
                 case -1:
                     atEnd = true;
                     if (fixLast && !previousWasEOL) {
                         numEOL = 1;
                     }
                     break;
                 case '\n':
                     // EOL was "\n"
                     numEOL = 1;
                     break;
                 case '\r':
                     numEOL = 1;
                     int c1 = super.read();
                     int c2 = super.read();
 
                     if (c1 == '\r' && c2 == '\n') {
                         // EOL was "\r\r\n"
                     } else if (c1 == '\r') {
                         // EOL was "\r\r" - handle as two consecutive "\r" and
                         // "\r"
                         numEOL = 2;
                         push(c2);
                     } else if (c1 == '\n') {
                         // EOL was "\r\n"
                         push(c2);
                     } else {
                         // EOL was "\r"
                         push(c2);
                         push(c1);
                     }
                 default:
                     // Fall tru
                 }
                 if (numEOL > 0) {
                     while (numEOL-- > 0) {
                         push(eol);
                         normalizedEOL += eol.length;
                     }
                     previousWasEOL = true;
                     thisChar = read();
                 } else if (!atEnd) {
                     previousWasEOL = false;
                 }
             } else {
                 normalizedEOL--;
             }
             return thisChar;
         }
     }
 
     private static class AddEofFilter extends SimpleFilterReader {
         private int lastChar = -1;
 
         public AddEofFilter(Reader in) {
             super(in);
         }
 
         public int read() throws IOException {
             int thisChar = super.read();
 
             // if source is EOF but last character was NOT ctrl-z, return ctrl-z
             if (thisChar == -1) {
                 if (lastChar != CTRLZ) {
                     lastChar = CTRLZ;
                     return lastChar;
                 }
             } else {
                 lastChar = thisChar;
             }
             return thisChar;
         }
     }
 
     private static class RemoveEofFilter extends SimpleFilterReader {
         private int lookAhead = -1;
 
         public RemoveEofFilter(Reader in) {
             super(in);
 
             try {
                 lookAhead = in.read();
             } catch (IOException e) {
                 lookAhead = -1;
             }
         }
 
         public int read() throws IOException {
             int lookAhead2 = super.read();
 
             // If source at EOF and lookAhead is ctrl-z, return EOF (NOT ctrl-z)
             if (lookAhead2 == -1 && lookAhead == CTRLZ) {
                 return -1;
             }
             // Return current look-ahead
             int i = lookAhead;
             lookAhead = lookAhead2;
             return i;
         }
     }
 
     private static class AddTabFilter extends SimpleFilterReader {
         private int columnNumber = 0;
 
         private int tabLength = 0;
 
         public AddTabFilter(Reader in, int tabLength) {
             super(in);
             this.tabLength = tabLength;
         }
 
         public int read() throws IOException {
             int c = super.read();
 
             switch (c) {
             case '\r':
             case '\n':
                 columnNumber = 0;
                 break;
             case ' ':
                 columnNumber++;
                 if (!editsBlocked()) {
                     int colNextTab = ((columnNumber + tabLength - 1) / tabLength) * tabLength;
                     int countSpaces = 1;
                     int numTabs = 0;
 
                     scanWhitespace: while ((c = super.read()) != -1) {
                         switch (c) {
                         case ' ':
                             if (++columnNumber == colNextTab) {
                                 numTabs++;
                                 countSpaces = 0;
                                 colNextTab += tabLength;
                             } else {
                                 countSpaces++;
                             }
                             break;
                         case '\t':
                             columnNumber = colNextTab;
                             numTabs++;
                             countSpaces = 0;
                             colNextTab += tabLength;
                             break;
                         default:
                             push(c);
                             break scanWhitespace;
                         }
                     }
                     while (countSpaces-- > 0) {
                         push(' ');
                         columnNumber--;
                     }
                     while (numTabs-- > 0) {
                         push('\t');
                         columnNumber -= tabLength;
                     }
                     c = super.read();
                     switch (c) {
                     case ' ':
                         columnNumber++;
                         break;
                     case '\t':
                         columnNumber += tabLength;
                         break;
                     default:
                         // Fall tru
                     }
                 }
                 break;
             case '\t':
                 columnNumber = ((columnNumber + tabLength - 1) / tabLength) * tabLength;
                 break;
             default:
                 columnNumber++;
             }
             return c;
         }
     }
 
     private static class RemoveTabFilter extends SimpleFilterReader {
         private int columnNumber = 0;
 
         private int tabLength = 0;
 
         public RemoveTabFilter(Reader in, int tabLength) {
             super(in);
 
             this.tabLength = tabLength;
         }
 
         public int read() throws IOException {
             int c = super.read();
 
             switch (c) {
             case '\r':
             case '\n':
                 columnNumber = 0;
                 break;
             case '\t':
                 int width = tabLength - columnNumber % tabLength;
 
                 if (!editsBlocked()) {
                     for (; width > 1; width--) {
                         push(' ');
                     }
                     c = ' ';
                 }
                 columnNumber += width;
                 break;
             default:
                 columnNumber++;
             }
             return c;
         }
     }
 
     /**
      * Enumerated attribute with the values "asis", "add" and "remove".
      */
     public static class AddAsisRemove extends EnumeratedAttribute {
         private static final AddAsisRemove ASIS = newInstance("asis");
 
         private static final AddAsisRemove ADD = newInstance("add");
 
         private static final AddAsisRemove REMOVE = newInstance("remove");
 
         /** {@inheritDoc}. */
         public String[] getValues() {
             return new String[] {"add", "asis", "remove"};
         }
 
         /**
          * Equality depending in the index.
          * @param other the object to test equality against.
          * @return true if the object has the same index as this.
          */
         public boolean equals(Object other) {
             return other instanceof AddAsisRemove
                     && getIndex() == ((AddAsisRemove) other).getIndex();
         }
 
         /**
          * Hashcode depending on the index.
          * @return the index as the hashcode.
          */
         public int hashCode() {
             return getIndex();
         }
 
         AddAsisRemove resolve() throws IllegalStateException {
             if (this.equals(ASIS)) {
                 return ASIS;
             }
             if (this.equals(ADD)) {
                 return ADD;
             }
             if (this.equals(REMOVE)) {
                 return REMOVE;
             }
             throw new IllegalStateException("No replacement for " + this);
         }
 
         // Works like clone() but doesn't show up in the Javadocs
         private AddAsisRemove newInstance() {
             return newInstance(getValue());
         }
 
         /**
          * Create an instance of this enumerated value based on the string value.
          * @param value the value to use.
          * @return an enumerated instance.
          */
         public static AddAsisRemove newInstance(String value) {
             AddAsisRemove a = new AddAsisRemove();
             a.setValue(value);
             return a;
         }
     }
 
     /**
      * Enumerated attribute with the values "asis", "cr", "lf" and "crlf".
      */
     public static class CrLf extends EnumeratedAttribute {
         private static final CrLf ASIS = newInstance("asis");
 
         private static final CrLf CR = newInstance("cr");
 
         private static final CrLf CRLF = newInstance("crlf");
 
         private static final CrLf DOS = newInstance("dos");
 
         private static final CrLf LF = newInstance("lf");
 
         private static final CrLf MAC = newInstance("mac");
 
         private static final CrLf UNIX = newInstance("unix");
 
         /**
          * @see EnumeratedAttribute#getValues
          */
         /** {@inheritDoc}. */
         public String[] getValues() {
             return new String[] {"asis", "cr", "lf", "crlf", "mac", "unix", "dos"};
         }
 
         /**
          * Equality depending in the index.
          * @param other the object to test equality against.
          * @return true if the object has the same index as this.
          */
         public boolean equals(Object other) {
             return other instanceof CrLf && getIndex() == ((CrLf) other).getIndex();
         }
 
         /**
          * Hashcode depending on the index.
          * @return the index as the hashcode.
          */
         public int hashCode() {
             return getIndex();
         }
 
         CrLf resolve() {
             if (this.equals(ASIS)) {
                 return ASIS;
             }
             if (this.equals(CR) || this.equals(MAC)) {
                 return CR;
             }
             if (this.equals(CRLF) || this.equals(DOS)) {
                 return CRLF;
             }
             if (this.equals(LF) || this.equals(UNIX)) {
                 return LF;
             }
             throw new IllegalStateException("No replacement for " + this);
         }
 
         // Works like clone() but doesn't show up in the Javadocs
         private CrLf newInstance() {
             return newInstance(getValue());
         }
 
         /**
          * Create an instance of this enumerated value based on the string value.
          * @param value the value to use.
          * @return an enumerated instance.
          */
         public static CrLf newInstance(String value) {
             CrLf c = new CrLf();
             c.setValue(value);
             return c;
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/filters/SortFilter.java b/src/main/org/apache/tools/ant/filters/SortFilter.java
index 8c3261fd9..7c5099190 100644
--- a/src/main/org/apache/tools/ant/filters/SortFilter.java
+++ b/src/main/org/apache/tools/ant/filters/SortFilter.java
@@ -1,375 +1,375 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.filters;
 
 import java.io.IOException;
 import java.io.Reader;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.types.Parameter;
 
 /**
  * <p>
  * Sort a file before and/or after the file.
  * </p>
  * 
  * <p>
  * Examples:
  * </p>
  * 
  * <pre>
  *   &lt;copy todir=&quot;build&quot;&gt;
  *       &lt;fileset dir=&quot;input&quot; includes=&quot;*.txt&quot;/&gt;
  *       &lt;filterchain&gt;
  *           &lt;sortfilter/&gt;
  *       &lt;/filterchain&gt;
  *   &lt;/copy&gt;
  * </pre>
  * 
  * <p>
  * Sort all files <code>*.txt</code> from <i>src</i> location and copy
  * them into <i>build</i> location. The lines of each file are sorted
  * in ascendant order comparing the lines via the
  * <code>String.compareTo(Object o)</code> method.
  * </p>
  * 
  * <pre>
  *   &lt;copy todir=&quot;build&quot;&gt;
  *       &lt;fileset dir=&quot;input&quot; includes=&quot;*.txt&quot;/&gt;
  *       &lt;filterchain&gt;
  *           &lt;sortfilter reverse=&quot;true&quot;/&gt;
  *       &lt;/filterchain&gt;
  *   &lt;/copy&gt;
  * </pre>
  * 
  * <p>
  * Sort all files <code>*.txt</code> from <i>src</i> location into reverse
  * order and copy them into <i>build</i> location. If reverse parameter has
  * value <code>true</code> (default value), then the output line of the files
  * will be in ascendant order.
  * </p>
  * 
  * <pre>
  *   &lt;copy todir=&quot;build&quot;&gt;
  *       &lt;fileset dir=&quot;input&quot; includes=&quot;*.txt&quot;/&gt;
  *       &lt;filterchain&gt;
  *           &lt;filterreader classname=&quot;org.apache.tools.ant.filters.SortFilter&quot;&gt;
  *             &lt;param name=&quot;comparator&quot; value=&quot;org.apache.tools.ant.filters.EvenFirstCmp&quot;/&gt;
  *           &lt;/filterreader&gt;
  *       &lt;/filterchain&gt;
  *   &lt;/copy&gt;
  * </pre>
  * 
  * <p>
  * Sort all files <code>*.txt</code> from <i>src</i> location using as
  * sorting criterium <code>EvenFirstCmp</code> class, that sorts the file
  * lines putting even lines first then odd lines for example. The modified files
- * are copied into <i>build</i> location. The <code>EventFirstCmp</code>,
+ * are copied into <i>build</i> location. The <code>EvenFirstCmp</code>,
  * has to an instanciable class via <code>Class.newInstance()</code>,
  * therefore in case of inner class has to be <em>static</em>. It also has to
  * implement <code>java.util.Comparator</code> interface, for example:
  * </p>
  * 
  * <pre>
  *         package org.apache.tools.ant.filters;
  *         ...(omitted)
  *           public final class EvenFirstCmp implements &lt;b&gt;Comparator&lt;/b&gt; {
  *             public int compare(Object o1, Object o2) {
  *             ...(omitted)
  *             }
  *           }
  * </pre>
  * 
  * <p>The example above is equivalent to:</p>
  * 
  * <blockquote><pre>
  *   &lt;componentdef name="evenfirst"
  *                 classname="org.apache.tools.ant.filters.EvenFirstCmp&quot;/&gt;
  *   &lt;copy todir=&quot;build&quot;&gt;
  *       &lt;fileset dir=&quot;input&quot; includes=&quot;*.txt&quot;/&gt;
  *       &lt;filterchain&gt;
  *           &lt;sortfilter&gt;
  *               &lt;evenfirst/&gt;
  *           &lt;/sortfilter&gt;
  *       &lt;/filterchain&gt;
  *   &lt;/copy&gt;
  * </pre></blockquote>
  * 
  * <p> If parameter <code>comparator</code> is present, then
  * <code>reverse</code> parameter will not be taken into account.  </p>
  * 
  * @since Ant 1.8.0
  */
 public final class SortFilter extends BaseParamFilterReader
     implements ChainableReader {
 
     /** Parameter name for reverse order. */
     private static final String REVERSE_KEY = "reverse";
 
     /**
      * Parameter name for specifying the comparator criteria via class that
      * implement <code>java.util.Comparator</code> interface.
      */
     private static final String COMPARATOR_KEY = "comparator";
 
     /**
      * Instance of comparator class to be used for sorting.
      */
     private Comparator comparator = null;
 
     /**
      * Controls if the sorting process will be in ascendant/descendant order. If
      * If has value <code>true</code>, then the line of the file will be
      * sorted on descendant order. Default value: <code>false</code>. It will
      * be considered only if <code>comparator</code> is <code>null</code>.
      */
     private boolean reverse;
 
     /**
      * Stores the lines to be sorted.
      */
     private List lines;
 
     /**
      * Remaining line to be read from this filter, or <code>null</code> if the
      * next call to <code>read()</code> should read the original stream to
      * find the next matching line.
      */
     private String line = null;
 
     private Iterator iterator = null;
 
     /**
      * Constructor for "dummy" instances.
      * 
      * @see BaseFilterReader#BaseFilterReader()
      */
     public SortFilter() {
         super();
     }
 
     /**
      * Creates a new filtered reader.
      * 
      * @param in
      *            A Reader object providing the underlying stream. Must not be
      *            <code>null</code>.
      */
     public SortFilter(final Reader in) {
         super(in);
     }
 
     /**
      * Returns the next character in the filtered stream. If the desired number
      * of lines have already been read, the resulting stream is effectively at
      * an end. Otherwise, the next character from the underlying stream is read
      * and returned.
      * 
      * @return the next character in the resulting stream, or -1 if the end of
      *         the resulting stream has been reached
      * 
      * @exception IOException
      *                if the underlying stream throws an IOException during
      *                reading
      */
     public int read() throws IOException {
         if (!getInitialized()) {
             initialize();
             setInitialized(true);
         }
 
         int ch = -1;
         if (line != null) {
             /*
              * We are on the state: "reading the current line", lines are
              * already sorted
              */
             ch = line.charAt(0);
             if (line.length() == 1) {
                 line = null;
             } else {
                 line = line.substring(1);
             }
         } else {
             if (lines == null) {
                 // We read all lines and sort them
                 lines = new ArrayList();
                 for (line = readLine(); line != null; line = readLine()) {
                     lines.add(line);
                 }
                 sort();
                 iterator = lines.iterator();
             }
 
             if (iterator.hasNext()) {
                 line = (String) iterator.next();
             } else {
                 line = null;
                 lines = null;
                 iterator = null;
             }
             if (line != null) {
                 return read();
             }
         }
         return ch;
     }
 
     /**
      * Creates a new SortReader using the passed in Reader for instantiation.
      * 
      * @param rdr
      *            A Reader object providing the underlying stream. Must not be
      *            <code>null</code>.
      * 
      * @return a new filter based on this configuration, but filtering the
      *         specified reader
      */
     public Reader chain(final Reader rdr) {
         SortFilter newFilter = new SortFilter(rdr);
         newFilter.setReverse(isReverse());
         newFilter.setComparator(getComparator());
         newFilter.setInitialized(true);
         return newFilter;
     }
 
     /**
      * Returns <code>true</code> if the sorting process will be in reverse
      * order, otherwise the sorting process will be in ascendant order.
      * 
      * @return <code>true</code> if the sorting process will be in reverse
      *         order, otherwise the sorting process will be in ascendant order.
      */
     public boolean isReverse() {
         return reverse;
     }
 
     /**
      * Sets the sorting process will be in ascendant (<code>reverse=false</code>)
      * or to descendant (<code>reverse=true</code>).
      * 
      * @param reverse
      *            Boolean representing reverse ordering process.
      */
     public void setReverse(boolean reverse) {
         this.reverse = reverse;
     }
 
     /**
      * Returns the comparator to be used for sorting.
      * 
      * @return the comparator
      */
     public Comparator getComparator() {
         return comparator;
     }
 
     /**
      * Set the comparator to be used as sorting criterium.
      * 
      * @param comparator
      *            the comparator to set
      */
     public void setComparator(Comparator comparator) {
         this.comparator = comparator;
     }
 
     /**
      * Set the comparator to be used as sorting criterium as nested element.
      * 
      * @param comparator
      *            the comparator to set
      */
     public void add(Comparator comparator) {
         if (this.comparator != null && comparator != null) {
             throw new BuildException("can't have more than one comparator");
         }
         setComparator(comparator);
     }
 
     /**
      * Scans the parameters list
      */
     private void initialize() throws IOException {
         // get parameters
         Parameter[] params = getParameters();
         if (params != null) {
             for (int i = 0; i < params.length; i++) {
                 final String paramName = params[i].getName();
                 if (REVERSE_KEY.equals(paramName)) {
                     setReverse(Boolean.valueOf(params[i].getValue())
                                .booleanValue());
                     continue;
                 }
                 if (COMPARATOR_KEY.equals(paramName)) {
                     try {
                         String className = (String) params[i].getValue();
                         setComparator((Comparator) (Class.forName(className)
                                                     .newInstance()));
                         continue;
                     } catch (InstantiationException e) {
                         throw new BuildException(e);
                     } catch (IllegalAccessException e) {
                         /*
                          * Probably a inner non-static class, this this case is
                          * not considered
                          */
                         throw new BuildException(e);
                     } catch (ClassNotFoundException e) {
                         throw new BuildException(e);
                     } catch (ClassCastException e) {
                         throw new BuildException("Value of comparator attribute"
                                                  + " should implement"
                                                  + " java.util.Comparator"
                                                  + " interface");
                     } catch (Exception e) {
                         throw new BuildException(e);
                     }
                 }
             }
         }
     }
 
     /**
      * Sorts the read lines (<code>lines</code>)acording to the sorting
      * criteria defined by the user.
      * 
      */
     private void sort() {
         if (comparator == null) {
             if (reverse) {
                 Collections.sort(lines, new Comparator() {
                         public int compare(Object o1, Object o2) {
                             String s1 = (String) o1;
                             String s2 = (String) o2;
                             return (-s1.compareTo(s2));
                         }
                     });
             } else {
                 Collections.sort(lines);
             }
         } else {
             Collections.sort(lines, comparator);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/filters/TabsToSpaces.java b/src/main/org/apache/tools/ant/filters/TabsToSpaces.java
index 453899c90..ea6125136 100644
--- a/src/main/org/apache/tools/ant/filters/TabsToSpaces.java
+++ b/src/main/org/apache/tools/ant/filters/TabsToSpaces.java
@@ -1,154 +1,154 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.filters;
 
 import java.io.IOException;
 import java.io.Reader;
 import org.apache.tools.ant.types.Parameter;
 
 /**
  * Converts tabs to spaces.
  *
  * Example:
  *
- * <pre>&lt;tabtospaces tablength=&quot;8&quot;/&gt;</pre>
+ * <pre>&lt;tabstospaces tablength=&quot;8&quot;/&gt;</pre>
  *
  * Or:
  *
  * <pre>&lt;filterreader classname=&quot;org.apache.tools.ant.filters.TabsToSpaces&quot;&gt;
  *   &lt;param name=&quot;tablength&quot; value=&quot;8&quot;/&gt;
  * &lt;/filterreader&gt;</pre>
  *
  */
 public final class TabsToSpaces
     extends BaseParamFilterReader
     implements ChainableReader {
     /** The default tab length. */
     private static final int DEFAULT_TAB_LENGTH = 8;
 
     /** Parameter name for the length of a tab. */
     private static final String TAB_LENGTH_KEY = "tablength";
 
     /** Tab length in this filter. */
     private int tabLength = DEFAULT_TAB_LENGTH;
 
     /** The number of spaces still to be read to represent the last-read tab. */
     private int spacesRemaining = 0;
 
     /**
      * Constructor for "dummy" instances.
      *
      * @see BaseFilterReader#BaseFilterReader()
      */
     public TabsToSpaces() {
         super();
     }
 
     /**
      * Creates a new filtered reader.
      *
      * @param in A Reader object providing the underlying stream.
      *           Must not be <code>null</code>.
      */
     public TabsToSpaces(final Reader in) {
         super(in);
     }
 
     /**
      * Returns the next character in the filtered stream, converting tabs
      * to the specified number of spaces.
      *
      * @return the next character in the resulting stream, or -1
      * if the end of the resulting stream has been reached
      *
      * @exception IOException if the underlying stream throws an IOException
      * during reading
      */
     public int read() throws IOException {
         if (!getInitialized()) {
             initialize();
             setInitialized(true);
         }
 
         int ch = -1;
 
         if (spacesRemaining > 0) {
             spacesRemaining--;
             ch = ' ';
         } else {
             ch = in.read();
             if (ch == '\t') {
                 spacesRemaining = tabLength - 1;
                 ch = ' ';
             }
         }
         return ch;
     }
 
     /**
      * Sets the tab length.
      *
      * @param tabLength the number of spaces to be used when converting a tab.
      */
     public void setTablength(final int tabLength) {
         this.tabLength = tabLength;
     }
 
     /**
      * Returns the tab length.
      *
      * @return the number of spaces used when converting a tab
      */
     private int getTablength() {
         return tabLength;
     }
 
     /**
      * Creates a new TabsToSpaces using the passed in
      * Reader for instantiation.
      *
      * @param rdr A Reader object providing the underlying stream.
      *            Must not be <code>null</code>.
      *
      * @return a new filter based on this configuration, but filtering
      *         the specified reader
      */
     public Reader chain(final Reader rdr) {
         TabsToSpaces newFilter = new TabsToSpaces(rdr);
         newFilter.setTablength(getTablength());
         newFilter.setInitialized(true);
         return newFilter;
     }
 
     /**
      * Parses the parameters to set the tab length.
      */
     private void initialize() {
         Parameter[] params = getParameters();
         if (params != null) {
             for (int i = 0; i < params.length; i++) {
                 if (params[i] != null) {
                     if (TAB_LENGTH_KEY.equals(params[i].getName())) {
                         tabLength = Integer.parseInt(params[i].getValue());
                         break;
                     }
                 }
             }
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/helper/ProjectHelper2.java b/src/main/org/apache/tools/ant/helper/ProjectHelper2.java
index fc204c5af..bda99346e 100644
--- a/src/main/org/apache/tools/ant/helper/ProjectHelper2.java
+++ b/src/main/org/apache/tools/ant/helper/ProjectHelper2.java
@@ -1,1257 +1,1257 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.helper;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.ExtensionPoint;
 import org.apache.tools.ant.Location;
 import org.apache.tools.ant.MagicNames;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectHelper;
 import org.apache.tools.ant.RuntimeConfigurable;
 import org.apache.tools.ant.Target;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.UnknownElement;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.URLProvider;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.JAXPUtils;
 import org.apache.tools.zip.ZipFile;
 import org.xml.sax.Attributes;
 import org.xml.sax.InputSource;
 import org.xml.sax.Locator;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXParseException;
 import org.xml.sax.XMLReader;
 import org.xml.sax.helpers.DefaultHandler;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.URL;
 import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Stack;
 
 /**
  * Sax2 based project reader
  *
  */
 public class ProjectHelper2 extends ProjectHelper {
 
     /** Reference holding the (ordered) target Vector */
     public static final String REFID_TARGETS = "ant.targets";
 
     /* Stateless */
 
     // singletons - since all state is in the context
     private static AntHandler elementHandler = new ElementHandler();
     private static AntHandler targetHandler = new TargetHandler();
     private static AntHandler mainHandler = new MainHandler();
     private static AntHandler projectHandler = new ProjectHandler();
 
     /** Specific to ProjectHelper2 so not a true Ant "magic name:" */
     private static final String REFID_CONTEXT = "ant.parsing.context";
 
     /**
      * helper for path -> URI and URI -> path conversions.
      */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Whether this instance of ProjectHelper can parse an Antlib
      * descriptor given by the URL and return its content as an
      * UnknownElement ready to be turned into an Antlib task.
      *
      * <p>This implementation returns true.</p>
      *
      * @since Ant 1.8.0
      */
     public boolean canParseAntlibDescriptor(Resource resource) {
         return true;
     }
 
     /**
      * Parse the given URL as an antlib descriptor and return the
      * content as something that can be turned into an Antlib task.
      *
      * <p>simply delegates to {@link #parseUnknownElement
      * parseUnknownElement} if the resource provides an URL and throws
      * an exception otherwise.</p>
      *
      * @since Ant 1.8.0
      */
     public UnknownElement parseAntlibDescriptor(Project containingProject,
                                                 Resource resource) {
         URLProvider up = resource.as(URLProvider.class);
         if (up == null) {
             throw new BuildException("Unsupported resource type: " + resource);
         }
         return parseUnknownElement(containingProject, up.getURL());
     }
 
     /**
      * Parse an unknown element from a url
      *
      * @param project the current project
      * @param source  the url containing the task
      * @return a configured task
      * @exception BuildException if an error occurs
      */
     public UnknownElement parseUnknownElement(Project project, URL source)
         throws BuildException {
         Target dummyTarget = new Target();
         dummyTarget.setProject(project);
 
         AntXMLContext context = new AntXMLContext(project);
         context.addTarget(dummyTarget);
         context.setImplicitTarget(dummyTarget);
 
         parse(context.getProject(), source, new RootHandler(context, elementHandler));
         Task[] tasks = dummyTarget.getTasks();
         if (tasks.length != 1) {
             throw new BuildException("No tasks defined");
         }
         return (UnknownElement) tasks[0];
     }
 
     /**
      * Parse a source xml input.
      *
      * @param project the current project
      * @param source  the xml source
      * @exception BuildException if an error occurs
      */
     public void parse(Project project, Object source) throws BuildException {
         getImportStack().addElement(source);
         AntXMLContext context = null;
         context = (AntXMLContext) project.getReference(REFID_CONTEXT);
         if (context == null) {
             context = new AntXMLContext(project);
             project.addReference(REFID_CONTEXT, context);
             project.addReference(REFID_TARGETS, context.getTargets());
         }
         if (getImportStack().size() > 1) {
             // we are in an imported file.
             context.setIgnoreProjectTag(true);
             Target currentTarget = context.getCurrentTarget();
             Target currentImplicit = context.getImplicitTarget();
             Map    currentTargets = context.getCurrentTargets();
             try {
                 Target newCurrent = new Target();
                 newCurrent.setProject(project);
                 newCurrent.setName("");
                 context.setCurrentTarget(newCurrent);
                 context.setCurrentTargets(new HashMap());
                 context.setImplicitTarget(newCurrent);
                 parse(project, source, new RootHandler(context, mainHandler));
                 newCurrent.execute();
             } finally {
                 context.setCurrentTarget(currentTarget);
                 context.setImplicitTarget(currentImplicit);
                 context.setCurrentTargets(currentTargets);
             }
         } else {
             // top level file
             context.setCurrentTargets(new HashMap());
             parse(project, source, new RootHandler(context, mainHandler));
             // Execute the top-level target
             context.getImplicitTarget().execute();
 
             // resolve extensionOf attributes
             for (String[] extensionInfo : getExtensionStack()) {
                 String tgName = extensionInfo[0];
                 String name = extensionInfo[1];
                 OnMissingExtensionPoint missingBehaviour = OnMissingExtensionPoint
                         .valueOf(extensionInfo[2]);
                 Hashtable projectTargets = project.getTargets();
                 if (!projectTargets.containsKey(tgName)) {
                     String message = "can't add target " + name
                         + " to extension-point " + tgName
                         + " because the extension-point is unknown.";
                     if (missingBehaviour == OnMissingExtensionPoint.FAIL) {
                         throw new BuildException(message);
                     } else if (missingBehaviour == OnMissingExtensionPoint.WARN) {
                         Target target = (Target) projectTargets.get(name);
                         context.getProject().log(target,
                                                  "Warning: " + message,
                                                  Project.MSG_WARN);
                     }
                 } else {
                     Target t = (Target) projectTargets.get(tgName);
                     if (!(t instanceof ExtensionPoint)) {
                         throw new BuildException("referenced target "
                                                  + tgName
                                                  + " is not an extension-point");
                     }
                     t.addDependency(name);
                 }
             }
         }
     }
 
     /**
      * Parses the project file, configuring the project as it goes.
      *
      * @param project the current project
      * @param source  the xml source
      * @param handler the root handler to use (contains the current context)
      * @exception BuildException if the configuration is invalid or cannot
      *                           be read
      */
     public void parse(Project project, Object source, RootHandler handler) throws BuildException {
 
         AntXMLContext context = handler.context;
 
         File buildFile = null;
         URL  url = null;
         String buildFileName = null;
 
         if (source instanceof File) {
             buildFile = (File) source;
         } else if (source instanceof URL) {
             url = (URL) source;
         } else if (source instanceof Resource) {
             FileProvider fp =
                 ((Resource) source).as(FileProvider.class);
             if (fp != null) {
                 buildFile = fp.getFile();
             } else {
                 URLProvider up =
                     ((Resource) source).as(URLProvider.class);
                 if (up != null) {
                     url = up.getURL();
                 }
             }
         }
         if (buildFile != null) {
             buildFile = FILE_UTILS.normalize(buildFile.getAbsolutePath());
             context.setBuildFile(buildFile);
             buildFileName = buildFile.toString();
         } else if (url != null) {
             try {
                 context.setBuildFile((File) null);
                 context.setBuildFile(url);
             } catch (java.net.MalformedURLException ex) {
                 throw new BuildException(ex);
             }
             buildFileName = url.toString();
         } else {
             throw new BuildException("Source " + source.getClass().getName()
                                      + " not supported by this plugin");
         }
         InputStream inputStream = null;
         InputSource inputSource = null;
         ZipFile zf = null;
 
         try {
             /**
              * SAX 2 style parser used to parse the given file.
              */
             XMLReader parser = JAXPUtils.getNamespaceXMLReader();
 
             String uri = null;
             if (buildFile != null) {
                 uri = FILE_UTILS.toURI(buildFile.getAbsolutePath());
                 inputStream = new FileInputStream(buildFile);
             } else {
                 uri = url.toString();
                 int pling = -1;
                 if (uri.startsWith("jar:file")
                     && (pling = uri.indexOf("!/")) > -1) {
                     zf = new ZipFile(org.apache.tools.ant.launch.Locator
                                      .fromJarURI(uri), "UTF-8");
                     inputStream =
                         zf.getInputStream(zf.getEntry(uri.substring(pling + 1)));
                 } else {
                     inputStream = url.openStream();
                 }
             }
 
             inputSource = new InputSource(inputStream);
             if (uri != null) {
                 inputSource.setSystemId(uri);
             }
             project.log("parsing buildfile " + buildFileName + " with URI = "
                         + uri + (zf != null ? " from a zip file" : ""),
                         Project.MSG_VERBOSE);
 
             DefaultHandler hb = handler;
 
             parser.setContentHandler(hb);
             parser.setEntityResolver(hb);
             parser.setErrorHandler(hb);
             parser.setDTDHandler(hb);
             parser.parse(inputSource);
         } catch (SAXParseException exc) {
             Location location = new Location(exc.getSystemId(), exc.getLineNumber(), exc
                                              .getColumnNumber());
 
             Throwable t = exc.getException();
             if (t instanceof BuildException) {
                 BuildException be = (BuildException) t;
                 if (be.getLocation() == Location.UNKNOWN_LOCATION) {
                     be.setLocation(location);
                 }
                 throw be;
             }
             throw new BuildException(exc.getMessage(), t == null ? exc : t, location);
         } catch (SAXException exc) {
             Throwable t = exc.getException();
             if (t instanceof BuildException) {
                 throw (BuildException) t;
             }
             throw new BuildException(exc.getMessage(), t == null ? exc : t);
         } catch (FileNotFoundException exc) {
             throw new BuildException(exc);
         } catch (UnsupportedEncodingException exc) {
             throw new BuildException("Encoding of project file " + buildFileName + " is invalid.",
                                      exc);
         } catch (IOException exc) {
             throw new BuildException("Error reading project file " + buildFileName + ": "
                                      + exc.getMessage(), exc);
         } finally {
             FileUtils.close(inputStream);
             ZipFile.closeQuietly(zf);
         }
     }
 
     /**
      * Returns main handler
      * @return main handler
      */
     protected static AntHandler getMainHandler() {
         return mainHandler;
     }
 
     /**
      * Sets main handler
      * @param handler  new main handler
      */
     protected static void setMainHandler(AntHandler handler) {
         mainHandler = handler;
     }
 
     /**
      * Returns project handler
      * @return project handler
      */
     protected static AntHandler getProjectHandler() {
         return projectHandler;
     }
 
     /**
      * Sets project handler
      * @param handler  new project handler
      */
     protected static void setProjectHandler(AntHandler handler) {
         projectHandler = handler;
     }
 
     /**
      * Returns target handler
      * @return target handler
      */
     protected static AntHandler getTargetHandler() {
         return targetHandler;
     }
 
     /**
      * Sets target handler
      * @param handler  new target handler
      */
     protected static void setTargetHandler(AntHandler handler) {
         targetHandler = handler;
     }
 
     /**
      * Returns element handler
      * @return element handler
      */
     protected static AntHandler getElementHandler() {
         return elementHandler;
     }
 
     /**
      * Sets element handler
      * @param handler  new element handler
      */
     protected static void setElementHandler(AntHandler handler) {
         elementHandler = handler;
     }
 
     /**
      * The common superclass for all SAX event handlers used to parse
      * the configuration file.
      *
      * The context will hold all state information. At each time
      * there is one active handler for the current element. It can
      * use onStartChild() to set an alternate handler for the child.
      */
     public static class AntHandler  {
         /**
          * Handles the start of an element. This base implementation does
          * nothing.
          *
          * @param uri the namespace URI for the tag
          * @param tag The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name of the element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The context that this element is in.
          *
          * @exception SAXParseException if this method is not overridden, or in
          *                              case of error in an overridden version
          */
         public void onStartElement(String uri, String tag, String qname, Attributes attrs,
                                    AntXMLContext context) throws SAXParseException {
         }
 
         /**
          * Handles the start of an element. This base implementation just
          * throws an exception - you must override this method if you expect
          * child elements.
          *
          * @param uri The namespace uri for this element.
          * @param tag The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The current context.
          * @return a handler (in the derived classes)
          *
          * @exception SAXParseException if this method is not overridden, or in
          *                              case of error in an overridden version
          */
         public AntHandler onStartChild(String uri, String tag, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             throw new SAXParseException("Unexpected element \"" + qname + " \"", context
                                         .getLocator());
         }
 
         /**
          * Handle the end of a element.
          *
          * @param uri the namespace uri of the element
          * @param tag the tag of the element
          * @param qname the qualified name of the element
          * @param context the current context
          * @exception SAXParseException if an error occurs
          */
         public void onEndChild(String uri, String tag, String qname, AntXMLContext context)
             throws SAXParseException {
         }
 
         /**
          * This method is called when this element and all elements nested into it have been
          * handled. I.e., this happens at the &lt;/end_tag_of_the_element&gt;.
          * @param uri the namespace uri for this element
          * @param tag the element name
          * @param context the current context
          */
         public void onEndElement(String uri, String tag, AntXMLContext context) {
         }
 
         /**
          * Handles text within an element. This base implementation just
          * throws an exception, you must override it if you expect content.
          *
          * @param buf A character array of the text within the element.
          *            Will not be <code>null</code>.
          * @param start The start element in the array.
          * @param count The number of characters to read from the array.
          * @param context The current context.
          *
          * @exception SAXParseException if this method is not overridden, or in
          *                              case of error in an overridden version
          */
         public void characters(char[] buf, int start, int count, AntXMLContext context)
             throws SAXParseException {
             String s = new String(buf, start, count).trim();
 
             if (s.length() > 0) {
                 throw new SAXParseException("Unexpected text \"" + s + "\"", context.getLocator());
             }
         }
 
         /**
          * Will be called every time a namespace is reached.
          * It'll verify if the ns was processed, and if not load the task definitions.
          * @param uri The namespace uri.
          */
         protected void checkNamespace(String uri) {
         }
     }
 
     /**
      * Handler for ant processing. Uses a stack of AntHandlers to
      * implement each element ( the original parser used a recursive behavior,
      * with the implicit execution stack )
      */
     public static class RootHandler extends DefaultHandler {
         private Stack antHandlers = new Stack();
         private AntHandler currentHandler = null;
         private AntXMLContext context;
 
         /**
          * Creates a new RootHandler instance.
          *
          * @param context The context for the handler.
          * @param rootHandler The handler for the root element.
          */
         public RootHandler(AntXMLContext context, AntHandler rootHandler) {
             currentHandler = rootHandler;
             antHandlers.push(currentHandler);
             this.context = context;
         }
 
         /**
          * Returns the current ant handler object.
          * @return the current ant handler.
          */
         public AntHandler getCurrentAntHandler() {
             return currentHandler;
         }
 
         /**
          * Resolves file: URIs relative to the build file.
          *
          * @param publicId The public identifier, or <code>null</code>
          *                 if none is available. Ignored in this
          *                 implementation.
          * @param systemId The system identifier provided in the XML
          *                 document. Will not be <code>null</code>.
          * @return an inputsource for this identifier
          */
         public InputSource resolveEntity(String publicId, String systemId) {
 
             context.getProject().log("resolving systemId: " + systemId, Project.MSG_VERBOSE);
 
             if (systemId.startsWith("file:")) {
                 String path = FILE_UTILS.fromURI(systemId);
 
                 File file = new File(path);
                 if (!file.isAbsolute()) {
                     file = FILE_UTILS.resolveFile(context.getBuildFileParent(), path);
                     context.getProject().log(
                                              "Warning: '" + systemId + "' in " + context.getBuildFile()
                                              + " should be expressed simply as '" + path.replace('\\', '/')
                                              + "' for compliance with other XML tools", Project.MSG_WARN);
                 }
                 context.getProject().log("file=" + file, Project.MSG_DEBUG);
                 try {
                     InputSource inputSource = new InputSource(new FileInputStream(file));
                     inputSource.setSystemId(FILE_UTILS.toURI(file.getAbsolutePath()));
                     return inputSource;
                 } catch (FileNotFoundException fne) {
                     context.getProject().log(file.getAbsolutePath() + " could not be found",
                                              Project.MSG_WARN);
                 }
 
             }
             // use default if not file or file not found
             context.getProject().log("could not resolve systemId", Project.MSG_DEBUG);
             return null;
         }
 
         /**
          * Handles the start of a project element. A project handler is created
          * and initialised with the element name and attributes.
          *
          * @param uri The namespace uri for this element.
          * @param tag The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          *
          * @exception org.xml.sax.SAXParseException if the tag given is not
          *                              <code>"project"</code>
          */
         public void startElement(String uri, String tag, String qname, Attributes attrs)
             throws SAXParseException {
             AntHandler next = currentHandler.onStartChild(uri, tag, qname, attrs, context);
             antHandlers.push(currentHandler);
             currentHandler = next;
             currentHandler.onStartElement(uri, tag, qname, attrs, context);
         }
 
         /**
          * Sets the locator in the project helper for future reference.
          *
          * @param locator The locator used by the parser.
          *                Will not be <code>null</code>.
          */
         public void setDocumentLocator(Locator locator) {
             context.setLocator(locator);
         }
 
         /**
          * Handles the end of an element. Any required clean-up is performed
          * by the onEndElement() method and then the original handler is restored to the parser.
          *
          * @param uri  The namespace URI for this element.
          * @param name The name of the element which is ending.
          *             Will not be <code>null</code>.
          * @param qName The qualified name for this element.
          *
          * @exception SAXException in case of error (not thrown in this implementation)
          */
         public void endElement(String uri, String name, String qName) throws SAXException {
             currentHandler.onEndElement(uri, name, context);
             AntHandler prev = (AntHandler) antHandlers.pop();
             currentHandler = prev;
             if (currentHandler != null) {
                 currentHandler.onEndChild(uri, name, qName, context);
             }
         }
 
         /**
          * Handle text within an element, calls currentHandler.characters.
          *
          * @param buf  A character array of the test.
          * @param start The start offset in the array.
          * @param count The number of characters to read.
          * @exception SAXParseException if an error occurs
          */
         public void characters(char[] buf, int start, int count) throws SAXParseException {
             currentHandler.characters(buf, start, count, context);
         }
 
         /**
          * Start a namespace prefix to uri mapping
          *
          * @param prefix the namespace prefix
          * @param uri the namespace uri
          */
         public void startPrefixMapping(String prefix, String uri) {
             context.startPrefixMapping(prefix, uri);
         }
 
         /**
-         * End a namepace prefix to uri mapping
+         * End a namespace prefix to uri mapping
          *
          * @param prefix the prefix that is not mapped anymore
          */
         public void endPrefixMapping(String prefix) {
             context.endPrefixMapping(prefix);
         }
     }
 
     /**
      * The main handler - it handles the &lt;project&gt; tag.
      *
      * @see org.apache.tools.ant.helper.ProjectHelper2.AntHandler
      */
     public static class MainHandler extends AntHandler {
 
         /**
          * Handle the project tag
          *
          * @param uri The namespace uri.
          * @param name The element tag.
          * @param qname The element qualified name.
          * @param attrs The attributes of the element.
          * @param context The current context.
          * @return The project handler that handles subelements of project
          * @exception SAXParseException if the qualified name is not "project".
          */
         public AntHandler onStartChild(String uri, String name, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             if (name.equals("project")
                 && (uri.equals("") || uri.equals(ANT_CORE_URI))) {
                 return ProjectHelper2.projectHandler;
             }
             if (name.equals(qname)) {
                 throw new SAXParseException("Unexpected element \"{" + uri
                                             + "}" + name + "\" {" + ANT_CORE_URI + "}" + name, context.getLocator());
             }
             throw new SAXParseException("Unexpected element \"" + qname
                                         + "\" " + name, context.getLocator());
         }
     }
 
     /**
      * Handler for the top level "project" element.
      */
     public static class ProjectHandler extends AntHandler {
 
         /**
          * Initialisation routine called after handler creation
          * with the element name and attributes. The attributes which
          * this handler can deal with are: <code>"default"</code>,
          * <code>"name"</code>, <code>"id"</code> and <code>"basedir"</code>.
          *
          * @param uri The namespace URI for this element.
          * @param tag Name of the element which caused this handler
          *            to be created. Should not be <code>null</code>.
          *            Ignored in this implementation.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element which caused this
          *              handler to be created. Must not be <code>null</code>.
          * @param context The current context.
          *
          * @exception SAXParseException if an unexpected attribute is
          *            encountered or if the <code>"default"</code> attribute
          *            is missing.
          */
         public void onStartElement(String uri, String tag, String qname, Attributes attrs,
                                    AntXMLContext context) throws SAXParseException {
             String baseDir = null;
             boolean nameAttributeSet = false;
 
             Project project = context.getProject();
             // Set the location of the implicit target associated with the project tag
             context.getImplicitTarget().setLocation(new Location(context.getLocator()));
 
             /** XXX I really don't like this - the XML processor is still
              * too 'involved' in the processing. A better solution (IMO)
              * would be to create UE for Project and Target too, and
              * then process the tree and have Project/Target deal with
              * its attributes ( similar with Description ).
              *
              * If we eventually switch to ( or add support for ) DOM,
              * things will work smoothly - UE can be avoided almost completely
              * ( it could still be created on demand, for backward compatibility )
              */
 
             for (int i = 0; i < attrs.getLength(); i++) {
                 String attrUri = attrs.getURI(i);
                 if (attrUri != null && !attrUri.equals("") && !attrUri.equals(uri)) {
                     continue; // Ignore attributes from unknown uris
                 }
                 String key = attrs.getLocalName(i);
                 String value = attrs.getValue(i);
 
                 if (key.equals("default")) {
                     if (value != null && !value.equals("")) {
                         if (!context.isIgnoringProjectTag()) {
                             project.setDefault(value);
                         }
                     }
                 } else if (key.equals("name")) {
                     if (value != null) {
                         context.setCurrentProjectName(value);
                         nameAttributeSet = true;
                         if (!context.isIgnoringProjectTag()) {
                             project.setName(value);
                             project.addReference(value, project);
                         } else if (isInIncludeMode()) {
                             if (!"".equals(value)
                                 && (getCurrentTargetPrefix() == null
                                     || getCurrentTargetPrefix().length() == 0)
                                 ) {
                                 // help nested include tasks
                                 setCurrentTargetPrefix(value);
                             }
                         }
                     }
                 } else if (key.equals("id")) {
                     if (value != null) {
                         // What's the difference between id and name ?
                         if (!context.isIgnoringProjectTag()) {
                             project.addReference(value, project);
                         }
                     }
                 } else if (key.equals("basedir")) {
                     if (!context.isIgnoringProjectTag()) {
                         baseDir = value;
                     }
                 } else {
                     // XXX ignore attributes in a different NS ( maybe store them ? )
                     throw new SAXParseException("Unexpected attribute \"" + attrs.getQName(i)
                                                 + "\"", context.getLocator());
                 }
             }
 
             // XXX Move to Project ( so it is shared by all helpers )
             String antFileProp =
                 MagicNames.ANT_FILE + "." + context.getCurrentProjectName();
             String dup = project.getProperty(antFileProp);
             String typeProp =
                 MagicNames.ANT_FILE_TYPE + "." + context.getCurrentProjectName();
             String dupType = project.getProperty(typeProp);
             if (dup != null && nameAttributeSet) {
                 Object dupFile = null;
                 Object contextFile = null;
                 if (MagicNames.ANT_FILE_TYPE_URL.equals(dupType)) {
                     try {
                         dupFile = new URL(dup);
                     } catch (java.net.MalformedURLException mue) {
                         throw new BuildException("failed to parse "
                                                  + dup + " as URL while looking"
                                                  + " at a duplicate project"
                                                  + " name.", mue);
                     }
                     contextFile = context.getBuildFileURL();
                 } else {
                     dupFile = new File(dup);
                     contextFile = context.getBuildFile();
                 }
 
                 if (context.isIgnoringProjectTag() && !dupFile.equals(contextFile)) {
                     project.log("Duplicated project name in import. Project "
                                 + context.getCurrentProjectName() + " defined first in " + dup
                                 + " and again in " + contextFile, Project.MSG_WARN);
                 }
             }
             if (nameAttributeSet) {
                 if (context.getBuildFile() != null) {
                     project.setUserProperty(antFileProp,
                                             context.getBuildFile().toString());
                     project.setUserProperty(typeProp,
                                             MagicNames.ANT_FILE_TYPE_FILE);
                 } else if (context.getBuildFileURL() != null) {
                     project.setUserProperty(antFileProp,
                                             context.getBuildFileURL().toString());
                     project.setUserProperty(typeProp,
                                             MagicNames.ANT_FILE_TYPE_URL);
                 }
             }
             if (context.isIgnoringProjectTag()) {
                 // no further processing
                 return;
             }
             // set explicitly before starting ?
             if (project.getProperty("basedir") != null) {
                 project.setBasedir(project.getProperty("basedir"));
             } else {
                 // Default for baseDir is the location of the build file.
                 if (baseDir == null) {
                     project.setBasedir(context.getBuildFileParent().getAbsolutePath());
                 } else {
                     // check whether the user has specified an absolute path
                     if ((new File(baseDir)).isAbsolute()) {
                         project.setBasedir(baseDir);
                     } else {
                         project.setBaseDir(FILE_UTILS.resolveFile(context.getBuildFileParent(),
                                                                   baseDir));
                     }
                 }
             }
             project.addTarget("", context.getImplicitTarget());
             context.setCurrentTarget(context.getImplicitTarget());
         }
 
         /**
          * Handles the start of a top-level element within the project. An
          * appropriate handler is created and initialised with the details
          * of the element.
          *
          * @param uri The namespace URI for this element.
          * @param name The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The context for this element.
          * @return a target or an element handler.
          *
          * @exception org.xml.sax.SAXParseException if the tag given is not
          *            <code>"taskdef"</code>, <code>"typedef"</code>,
          *            <code>"property"</code>, <code>"target"</code>,
          *            <code>"extension-point"</code>
          *            or a data type definition
          */
         public AntHandler onStartChild(String uri, String name, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             return (name.equals("target") || name.equals("extension-point"))
                 && (uri.equals("") || uri.equals(ANT_CORE_URI))
                 ? ProjectHelper2.targetHandler : ProjectHelper2.elementHandler;
         }
     }
 
     /**
      * Handler for "target" and "extension-point" elements.
      */
     public static class TargetHandler extends AntHandler {
 
         /**
          * Initialisation routine called after handler creation
          * with the element name and attributes. The attributes which
          * this handler can deal with are: <code>"name"</code>,
          * <code>"depends"</code>, <code>"if"</code>,
          * <code>"unless"</code>, <code>"id"</code> and
          * <code>"description"</code>.
          *
          * @param uri The namespace URI for this element.
          * @param tag Name of the element which caused this handler
          *            to be created. Should not be <code>null</code>.
          *            Ignored in this implementation.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element which caused this
          *              handler to be created. Must not be <code>null</code>.
          * @param context The current context.
          *
          * @exception SAXParseException if an unexpected attribute is encountered
          *            or if the <code>"name"</code> attribute is missing.
          */
         public void onStartElement(String uri, String tag, String qname, Attributes attrs,
                                    AntXMLContext context) throws SAXParseException {
             String name = null;
             String depends = "";
             String extensionPoint = null;
             OnMissingExtensionPoint extensionPointMissing = null;
 
             Project project = context.getProject();
             Target target = "target".equals(tag)
                 ? new Target() : new ExtensionPoint();
             target.setProject(project);
             target.setLocation(new Location(context.getLocator()));
             context.addTarget(target);
 
             for (int i = 0; i < attrs.getLength(); i++) {
                 String attrUri = attrs.getURI(i);
                 if (attrUri != null && !attrUri.equals("") && !attrUri.equals(uri)) {
                     continue; // Ignore attributes from unknown uris
                 }
                 String key = attrs.getLocalName(i);
                 String value = attrs.getValue(i);
 
                 if (key.equals("name")) {
                     name = value;
                     if ("".equals(name)) {
                         throw new BuildException("name attribute must " + "not be empty");
                     }
                 } else if (key.equals("depends")) {
                     depends = value;
                 } else if (key.equals("if")) {
                     target.setIf(value);
                 } else if (key.equals("unless")) {
                     target.setUnless(value);
                 } else if (key.equals("id")) {
                     if (value != null && !value.equals("")) {
                         context.getProject().addReference(value, target);
                     }
                 } else if (key.equals("description")) {
                     target.setDescription(value);
                 } else if (key.equals("extensionOf")) {
                     extensionPoint = value;
                 } else if (key.equals("onMissingExtensionPoint")) {
                     try {
                         extensionPointMissing = OnMissingExtensionPoint.valueOf(value);
                     } catch (IllegalArgumentException e) {
                         throw new BuildException("Invalid onMissingExtensionPoint " + value);
                     }
                 } else {
                     throw new SAXParseException("Unexpected attribute \"" + key + "\"", context
                                                 .getLocator());
                 }
             }
 
             if (name == null) {
                 throw new SAXParseException("target element appears without a name attribute",
                                             context.getLocator());
             }
 
             String prefix = null;
             boolean isInIncludeMode =
                 context.isIgnoringProjectTag() && isInIncludeMode();
             String sep = getCurrentPrefixSeparator();
 
             if (isInIncludeMode) {
                 prefix = getTargetPrefix(context);
                 if (prefix == null) {
                     throw new BuildException("can't include build file "
                                              + context.getBuildFileURL()
                                              + ", no as attribute has been given"
                                              + " and the project tag doesn't"
                                              + " specify a name attribute");
                 }
                 name = prefix + sep + name;
             }
 
             // Check if this target is in the current build file
             if (context.getCurrentTargets().get(name) != null) {
                 throw new BuildException("Duplicate target '" + name + "'",
                                          target.getLocation());
             }
             Hashtable projectTargets = project.getTargets();
             boolean   usedTarget = false;
             // If the name has not already been defined define it
             if (projectTargets.containsKey(name)) {
                 project.log("Already defined in main or a previous import, ignore " + name,
                             Project.MSG_VERBOSE);
             } else {
                 target.setName(name);
                 context.getCurrentTargets().put(name, target);
                 project.addOrReplaceTarget(name, target);
                 usedTarget = true;
             }
 
             if (depends.length() > 0) {
                 if (!isInIncludeMode) {
                     target.setDepends(depends);
                 } else {
                     for (Iterator iter =
                              Target.parseDepends(depends, name, "depends")
                              .iterator();
                          iter.hasNext(); ) {
                         target.addDependency(prefix + sep + iter.next());
                     }
                 }
             }
             if (!isInIncludeMode && context.isIgnoringProjectTag()
                 && (prefix = getTargetPrefix(context)) != null) {
                 // In an imported file (and not completely
                 // ignoring the project tag or having a preconfigured prefix)
                 String newName = prefix + sep + name;
                 Target newTarget = usedTarget ? new Target(target) : target;
                 newTarget.setName(newName);
                 context.getCurrentTargets().put(newName, newTarget);
                 project.addOrReplaceTarget(newName, newTarget);
             }
             if (extensionPointMissing != null && extensionPoint == null) {
                 throw new BuildException("onMissingExtensionPoint attribute cannot " +
                                          "be specified unless extensionOf is specified", 
                                          target.getLocation());
 
             }
             if (extensionPoint != null) {
                 ProjectHelper helper =
                     (ProjectHelper) context.getProject().
                     getReference(ProjectHelper.PROJECTHELPER_REFERENCE);
                 for (String tgName : Target.parseDepends(extensionPoint, name, "extensionOf")) {
                     if (isInIncludeMode()) {
                         tgName = prefix + sep + tgName;
                     }
                     if (extensionPointMissing == null) {
                         extensionPointMissing = OnMissingExtensionPoint.FAIL;
                     }
                     // defer extensionpoint resolution until the full
                     // import stack has been processed
                     helper.getExtensionStack().add(new String[] {
                             tgName, name, extensionPointMissing.name() });
                 }
             }
         }
 
         private String getTargetPrefix(AntXMLContext context) {
             String configuredValue = getCurrentTargetPrefix();
             if (configuredValue != null && configuredValue.length() == 0) {
                 configuredValue = null;
             }
             if (configuredValue != null) {
                 return configuredValue;
             }
 
             String projectName = context.getCurrentProjectName();
             if ("".equals(projectName)) {
                 projectName = null;
             }
 
             return projectName;
         }
 
         /**
          * Handles the start of an element within a target.
          *
          * @param uri The namespace URI for this element.
          * @param name The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The current context.
          * @return an element handler.
          *
          * @exception SAXParseException if an error occurs when initialising
          *                              the appropriate child handler
          */
         public AntHandler onStartChild(String uri, String name, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             return ProjectHelper2.elementHandler;
         }
 
         /**
          * Handle the end of the project, sets the current target of the
          * context to be the implicit target.
          *
          * @param uri The namespace URI of the element.
          * @param tag The name of the element.
          * @param context The current context.
          */
         public void onEndElement(String uri, String tag, AntXMLContext context) {
             context.setCurrentTarget(context.getImplicitTarget());
         }
     }
 
     /**
      * Handler for all project elements ( tasks, data types )
      */
     public static class ElementHandler extends AntHandler {
 
         /**
          * Constructor.
          */
         public ElementHandler() {
         }
 
         /**
          * Initialisation routine called after handler creation
          * with the element name and attributes. This configures
          * the element with its attributes and sets it up with
          * its parent container (if any). Nested elements are then
          * added later as the parser encounters them.
          *
          * @param uri The namespace URI for this element.
          * @param tag Name of the element which caused this handler
          *            to be created. Must not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element which caused this
          *              handler to be created. Must not be <code>null</code>.
          * @param context The current context.
          *
          * @exception SAXParseException in case of error (not thrown in
          *                              this implementation)
          */
         public void onStartElement(String uri, String tag, String qname, Attributes attrs,
                                    AntXMLContext context) throws SAXParseException {
             RuntimeConfigurable parentWrapper = context.currentWrapper();
             Object parent = null;
 
             if (parentWrapper != null) {
                 parent = parentWrapper.getProxy();
             }
 
             /* UnknownElement is used for tasks and data types - with
                delayed eval */
             UnknownElement task = new UnknownElement(tag);
             task.setProject(context.getProject());
             task.setNamespace(uri);
             task.setQName(qname);
             task.setTaskType(ProjectHelper.genComponentName(task.getNamespace(), tag));
             task.setTaskName(qname);
 
             Location location = new Location(context.getLocator().getSystemId(), context
                                              .getLocator().getLineNumber(), context.getLocator().getColumnNumber());
             task.setLocation(location);
             task.setOwningTarget(context.getCurrentTarget());
 
             if (parent != null) {
                 // Nested element
                 ((UnknownElement) parent).addChild(task);
             }  else {
                 // Task included in a target ( including the default one ).
                 context.getCurrentTarget().addTask(task);
             }
 
             context.configureId(task, attrs);
 
             // container.addTask(task);
             // This is a nop in UE: task.init();
 
             RuntimeConfigurable wrapper = new RuntimeConfigurable(task, task.getTaskName());
 
             for (int i = 0; i < attrs.getLength(); i++) {
                 String name = attrs.getLocalName(i);
                 String attrUri = attrs.getURI(i);
                 if (attrUri != null && !attrUri.equals("") && !attrUri.equals(uri)) {
                     name = attrUri + ":" + attrs.getQName(i);
                 }
                 String value = attrs.getValue(i);
                 // PR: Hack for ant-type value
                 //  an ant-type is a component name which can
                 // be namespaced, need to extract the name
                 // and convert from qualified name to uri/name
                 if (ANT_TYPE.equals(name)
                     || (ANT_CORE_URI.equals(attrUri)
                         && ANT_TYPE.equals(attrs.getLocalName(i)))) {
                     name = ANT_TYPE;
                     int index = value.indexOf(":");
                     if (index >= 0) {
                         String prefix = value.substring(0, index);
                         String mappedUri = context.getPrefixMapping(prefix);
                         if (mappedUri == null) {
                             throw new BuildException("Unable to find XML NS prefix \"" + prefix
                                                      + "\"");
                         }
                         value = ProjectHelper.genComponentName(mappedUri, value
                                                                .substring(index + 1));
                     }
                 }
                 wrapper.setAttribute(name, value);
             }
             if (parentWrapper != null) {
                 parentWrapper.addChild(wrapper);
             }
             context.pushWrapper(wrapper);
         }
 
         /**
          * Adds text to the task, using the wrapper
          *
          * @param buf A character array of the text within the element.
          *            Will not be <code>null</code>.
          * @param start The start element in the array.
          * @param count The number of characters to read from the array.
          * @param context The current context.
          *
          * @exception SAXParseException if the element doesn't support text
          *
          * @see ProjectHelper#addText(Project,java.lang.Object,char[],int,int)
          */
         public void characters(char[] buf, int start, int count,
                                AntXMLContext context) throws SAXParseException {
             RuntimeConfigurable wrapper = context.currentWrapper();
             wrapper.addText(buf, start, count);
         }
 
         /**
          * Handles the start of an element within a target. Task containers
          * will always use another task handler, and all other tasks
          * will always use a nested element handler.
          *
          * @param uri The namespace URI for this element.
          * @param tag The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The current context.
          * @return The handler for elements.
          *
          * @exception SAXParseException if an error occurs when initialising
          *                              the appropriate child handler
          */
         public AntHandler onStartChild(String uri, String tag, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             return ProjectHelper2.elementHandler;
         }
 
         /**
          * Handles the end of the element. This pops the wrapper from
          * the context.
          *
          * @param uri The namespace URI for the element.
          * @param tag The name of the element.
          * @param context The current context.
          */
         public void onEndElement(String uri, String tag, AntXMLContext context) {
             context.popWrapper();
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/listener/MailLogger.java b/src/main/org/apache/tools/ant/listener/MailLogger.java
index a31152a54..1be1a2288 100644
--- a/src/main/org/apache/tools/ant/listener/MailLogger.java
+++ b/src/main/org/apache/tools/ant/listener/MailLogger.java
@@ -1,410 +1,410 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.listener;
 
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintStream;
 import java.util.Hashtable;
 import java.util.Vector;
 import java.util.Properties;
 import java.util.Enumeration;
 import java.util.StringTokenizer;
 
 import org.apache.tools.ant.BuildEvent;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DefaultLogger;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.email.EmailAddress;
 import org.apache.tools.ant.taskdefs.email.Message;
 import org.apache.tools.ant.taskdefs.email.Mailer;
 import org.apache.tools.ant.util.ClasspathUtils;
 import org.apache.tools.ant.util.DateUtils;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.StringUtils;
 import org.apache.tools.mail.MailMessage;
 
 /**
  *  Buffers log messages from DefaultLogger, and sends an e-mail with the
  *  results. The following Project properties are used to send the mail.
  *  <ul>
  *    <li> MailLogger.mailhost [default: localhost] - Mail server to use</li>
  *    <li> MailLogger.port [default: 25] - Default port for SMTP </li>
- *    <li> Maillogger.user [no default] - user name for SMPT auth
+ *    <li> Maillogger.user [no default] - user name for SMTP auth
  *    (requires JavaMail)</li>
- *    <li> Maillogger.password [no default] - password for SMPT auth
+ *    <li> Maillogger.password [no default] - password for SMTP auth
  *    (requires JavaMail)</li>
  *    <li> Maillogger.ssl [default: false] - on or true if ssl is
  *    needed (requires JavaMail)</li>
  *    <li> MailLogger.from [required] - Mail "from" address</li>
  *    <li> MailLogger.from [no default] - Mail "replyto" address(es),
  *    comma-separated</li>
  *    <li> MailLogger.failure.notify [default: true] - Send build failure
  *    e-mails?</li>
  *    <li> MailLogger.success.notify [default: true] - Send build success
  *    e-mails?</li>
  *    <li> MailLogger.failure.to [required if failure mail to be sent] - Address
  *    to send failure messages to</li>
  *    <li> MailLogger.success.to [required if success mail to be sent] - Address
  *    to send success messages to</li>
  *    <li> MailLogger.failure.subject [default: "Build Failure"] - Subject of
  *    failed build</li>
  *    <li> MailLogger.success.subject [default: "Build Success"] - Subject of
  *    successful build</li>
  *    <li> MailLogger.failure.body [default: none] - fixed text of
  *    mail body for a failed build, default is to send the logfile</li>
  *    <li> MailLogger.success.body [default: none] - fixed text of
  *    mail body for a successful build, default is to send the logfile</li>
  *    <li> MailLogger.mimeType [default: text/plain] - MIME-Type of email</li>
  *    <li> MailLogger.charset [no default] - character set of email</li>
  *    <li> Maillogger.starttls.enable [default: false] - on or true if
  *    STARTTLS should be supported (requires JavaMail)</li>
  *    <li> MailLogger.properties.file [no default] - Filename of
  *    properties file that will override other values.</li>
  *  </ul>
  *  These properties are set using standard Ant property setting mechanisms
  *  (&lt;property&gt;, command-line -D, etc). Ant properties can be overridden
  *  by specifying the filename of a properties file in the <i>
  *  MailLogger.properties.file property</i> . Any properties defined in that
  *  file will override Ant properties.
  *
  */
 public class MailLogger extends DefaultLogger {
     /** Buffer in which the message is constructed prior to sending */
     private StringBuffer buffer = new StringBuffer();
 
     private static final String DEFAULT_MIME_TYPE = "text/plain";
 
     /**
      *  Sends an e-mail with the log results.
      *
      * @param event the build finished event
      */
     public void buildFinished(BuildEvent event) {
         super.buildFinished(event);
 
         Project project = event.getProject();
         Hashtable properties = project.getProperties();
 
         // overlay specified properties file (if any), which overrides project
         // settings
         Properties fileProperties = new Properties();
         String filename = (String) properties.get("MailLogger.properties.file");
         if (filename != null) {
             InputStream is = null;
             try {
                 is = new FileInputStream(filename);
                 fileProperties.load(is);
             } catch (IOException ioe) {
                 // ignore because properties file is not required
             } finally {
                 FileUtils.close(is);
             }
         }
 
         for (Enumeration e = fileProperties.keys(); e.hasMoreElements();) {
             String key = (String) e.nextElement();
             String value = fileProperties.getProperty(key);
             properties.put(key, project.replaceProperties(value));
         }
 
         boolean success = (event.getException() == null);
         String prefix = success ? "success" : "failure";
 
         try {
             boolean notify = Project.toBoolean(getValue(properties,
                     prefix + ".notify", "on"));
 
             if (!notify) {
                 return;
             }
             Values values = new Values()
                 .mailhost(getValue(properties, "mailhost", "localhost"))
                 .port(Integer.parseInt(
                           getValue(
                               properties, "port",
                               String.valueOf(MailMessage.DEFAULT_PORT))))
                 .user(getValue(properties, "user", ""))
                 .password(getValue(properties, "password", ""))
                 .ssl(Project.toBoolean(getValue(properties,
                                                 "ssl", "off")))
                 .starttls(Project.toBoolean(getValue(properties,
                                                      "starttls.enable", "off")))
                 .from(getValue(properties, "from", null))
                 .replytoList(getValue(properties, "replyto", ""))
                 .toList(getValue(properties, prefix + ".to", null))
                 .mimeType(getValue(properties, "mimeType", DEFAULT_MIME_TYPE))
                 .charset(getValue(properties, "charset", ""))
                 .body(getValue(properties, prefix + ".body", ""))
                 .subject(getValue(
                              properties, prefix + ".subject",
                              (success) ? "Build Success" : "Build Failure"));
             if (values.user().equals("")
                 && values.password().equals("")
                 && !values.ssl() && !values.starttls()) {
                 sendMail(values, buffer.substring(0));
             } else {
                 sendMimeMail(
                     event.getProject(), values, buffer.substring(0));
             }
         } catch (Exception e) {
             System.out.println("MailLogger failed to send e-mail!");
             e.printStackTrace(System.err);
         }
     }
 
     private static class Values {
         private String mailhost;
         public String mailhost() {
             return mailhost;
         }
         public Values mailhost(String mailhost) {
             this.mailhost = mailhost;
             return this;
         }
         private int port;
         public int port() {
             return port;
         }
         public Values port(int port) {
             this.port = port;
             return this;
         }
         private String user;
         public String user() {
             return user;
         }
         public Values user(String user) {
             this.user = user;
             return this;
         }
         private String password;
         public String password() {
             return password;
         }
         public Values password(String password) {
             this.password = password;
             return this;
         }
         private boolean ssl;
         public boolean ssl() {
             return ssl;
         }
         public Values ssl(boolean ssl) {
             this.ssl = ssl;
             return this;
         }
         private String from;
         public String from() {
             return from;
         }
         public Values from(String from) {
             this.from = from;
             return this;
         }
         private String replytoList;
         public String replytoList() {
             return replytoList;
         }
         public Values replytoList(String replytoList) {
             this.replytoList = replytoList;
             return this;
         }
         private String toList;
         public String toList() {
             return toList;
         }
         public Values toList(String toList) {
             this.toList = toList;
             return this;
         }
         private String subject;
         public String subject() {
             return subject;
         }
         public Values subject(String subject) {
             this.subject = subject;
             return this;
         }
         private String charset;
         public String charset() {
             return charset;
         }
         public Values charset(String charset) {
             this.charset = charset;
             return this;
         }
         private String mimeType;
         public String mimeType() {
             return mimeType;
         }
         public Values mimeType(String mimeType) {
             this.mimeType = mimeType;
             return this;
         }
         private String body;
         public String body() {
             return body;
         }
         public Values body(String body) {
             this.body = body;
             return this;
         }
         private boolean starttls;
         public boolean starttls() {
             return starttls;
         }
         public Values starttls(boolean starttls) {
             this.starttls = starttls;
             return this;
         }
     }
 
     /**
      *  Receives and buffers log messages.
      *
      * @param message the message being logger
      */
     protected void log(String message) {
         buffer.append(message).append(StringUtils.LINE_SEP);
     }
 
 
     /**
      *  Gets the value of a property.
      *
      * @param  properties     Properties to obtain value from
      * @param  name           suffix of property name. "MailLogger." will be
      *      prepended internally.
      * @param  defaultValue   value returned if not present in the properties.
      *      Set to null to make required.
      * @return                The value of the property, or default value.
      * @exception  Exception  thrown if no default value is specified and the
      *      property is not present in properties.
      */
     private String getValue(Hashtable properties, String name,
                             String defaultValue) throws Exception {
         String propertyName = "MailLogger." + name;
         String value = (String) properties.get(propertyName);
 
         if (value == null) {
             value = defaultValue;
         }
 
         if (value == null) {
             throw new Exception("Missing required parameter: " + propertyName);
         }
 
         return value;
     }
 
 
     /**
      *  Send the mail
      * @param  values           the various values.
      * @param  message          mail body
      * @exception  IOException  thrown if sending message fails
      */
     private void sendMail(Values values, String message) throws IOException {
         MailMessage mailMessage = new MailMessage(
             values.mailhost(), values.port());
         mailMessage.setHeader("Date", DateUtils.getDateForHeader());
 
         mailMessage.from(values.from());
         if (!values.replytoList().equals("")) {
             StringTokenizer t = new StringTokenizer(
                 values.replytoList(), ", ", false);
             while (t.hasMoreTokens()) {
                 mailMessage.replyto(t.nextToken());
             }
         }
         StringTokenizer t = new StringTokenizer(values.toList(), ", ", false);
         while (t.hasMoreTokens()) {
             mailMessage.to(t.nextToken());
         }
 
         mailMessage.setSubject(values.subject());
 
         if (values.charset().length() > 0) {
             mailMessage.setHeader("Content-Type", values.mimeType()
                                   + "; charset=\"" + values.charset() + "\"");
         } else {
             mailMessage.setHeader("Content-Type", values.mimeType());
         }
 
         PrintStream ps = mailMessage.getPrintStream();
         ps.println(values.body().length() > 0 ? values.body() : message);
 
         mailMessage.sendAndClose();
     }
     /**
      *  Send the mail  (MimeMail)
      * @param  project          current ant project
      * @param  values           various values
      * @param  message          mail body
      */
     private void sendMimeMail(Project project, Values values, String message) {
         Mailer mailer = null;
         try {
             mailer = (Mailer) ClasspathUtils.newInstance(
                     "org.apache.tools.ant.taskdefs.email.MimeMailer",
                     MailLogger.class.getClassLoader(), Mailer.class);
         } catch (BuildException e) {
             Throwable t = e.getCause() == null ? e : e.getCause();
             log("Failed to initialise MIME mail: " + t.getMessage());
             return;
         }
         // convert the replyTo string into a vector of emailaddresses
         Vector replyToList = vectorizeEmailAddresses(values.replytoList());
         mailer.setHost(values.mailhost());
         mailer.setPort(values.port());
         mailer.setUser(values.user());
         mailer.setPassword(values.password());
         mailer.setSSL(values.ssl());
         mailer.setEnableStartTLS(values.starttls());
         Message mymessage =
             new Message(values.body().length() > 0 ? values.body() : message);
         mymessage.setProject(project);
         mymessage.setMimeType(values.mimeType());
         if (values.charset().length() > 0) {
             mymessage.setCharset(values.charset());
         }
         mailer.setMessage(mymessage);
         mailer.setFrom(new EmailAddress(values.from()));
         mailer.setReplyToList(replyToList);
         Vector toList = vectorizeEmailAddresses(values.toList());
         mailer.setToList(toList);
         mailer.setCcList(new Vector());
         mailer.setBccList(new Vector());
         mailer.setFiles(new Vector());
         mailer.setSubject(values.subject());
         mailer.setHeaders(new Vector());
         mailer.send();
     }
     private Vector vectorizeEmailAddresses(String listString) {
         Vector emailList = new Vector();
         StringTokenizer tokens = new StringTokenizer(listString, ",");
         while (tokens.hasMoreTokens()) {
             emailList.addElement(new EmailAddress(tokens.nextToken()));
         }
         return emailList;
     }
 }
 
 
diff --git a/src/main/org/apache/tools/ant/property/LocalProperties.java b/src/main/org/apache/tools/ant/property/LocalProperties.java
index 367261637..e36a1dff0 100644
--- a/src/main/org/apache/tools/ant/property/LocalProperties.java
+++ b/src/main/org/apache/tools/ant/property/LocalProperties.java
@@ -1,152 +1,152 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.property;
 
 import org.apache.tools.ant.PropertyHelper;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.MagicNames;
 
 /**
  * Thread local class containing local properties.
  * @since Ant 1.8.0
  */
 public class LocalProperties
     extends InheritableThreadLocal
     implements PropertyHelper.PropertyEvaluator,
     PropertyHelper.PropertySetter {
 
     /**
      * Get a localproperties for the given project.
-     * @param project the project to retieve the localproperties for.
+     * @param project the project to retrieve the localproperties for.
      * @return the localproperties.
      */
     public static synchronized LocalProperties get(Project project) {
         LocalProperties l = (LocalProperties) project.getReference(
             MagicNames.REFID_LOCAL_PROPERTIES);
         if (l == null) {
             l = new LocalProperties();
             project.addReference(MagicNames.REFID_LOCAL_PROPERTIES, l);
             PropertyHelper.getPropertyHelper(project).add(l);
         }
         return l;
     }
 
     // --------------------------------------------------
     //
     //  Thread stuff
     //
     // --------------------------------------------------
 
     /**
      * Construct a new LocalProperties object.
      */
     private LocalProperties() {
     }
 
     /**
      * Get the initial value.
      * @return a new localproperties stack.
      */
     protected synchronized Object initialValue() {
         return new LocalPropertyStack();
     }
 
     private LocalPropertyStack current() {
         return (LocalPropertyStack) get();
     }
 
     // --------------------------------------------------
     //
     //  Local property adding and scoping
     //
     // --------------------------------------------------
 
     /**
      * Add a local property to the current scope.
      * @param property the property name to add.
      */
     public void addLocal(String property) {
         current().addLocal(property);
     }
 
     /** enter the scope */
     public void enterScope() {
         current().enterScope();
     }
 
     /** exit the scope */
     public void exitScope() {
         current().exitScope();
     }
 
     // --------------------------------------------------
     //
     //  Copy - used in parallel to make a new stack
     //
     // --------------------------------------------------
 
     /**
      * Copy the stack for a parallel thread.
      * To be called from the parallel thread itself.
      */
     public void copy() {
         set(current().copy());
     }
 
     // --------------------------------------------------
     //
     //  PropertyHelper delegate methods
     //
     // --------------------------------------------------
 
     /**
      * Evaluate a property.
      * @param property the property's String "identifier".
      * @param helper the invoking PropertyHelper.
      * @return Object value.
      */
     public Object evaluate(String property, PropertyHelper helper) {
         return current().evaluate(property, helper);
     }
 
     /**
      * Set a *new" property.
      * @param property the property's String "identifier".
      * @param value    the value to set.
      * @param propertyHelper the invoking PropertyHelper.
      * @return true if this entity 'owns' the property.
      */
     public boolean setNew(
         String property, Object value, PropertyHelper propertyHelper) {
         return current().setNew(property, value, propertyHelper);
     }
 
     /**
      * Set a property.
      * @param property the property's String "identifier".
      * @param value    the value to set.
      * @param propertyHelper the invoking PropertyHelper.
      * @return true if this entity 'owns' the property.
      */
     public boolean set(
         String property, Object value, PropertyHelper propertyHelper) {
         return current().set(property, value, propertyHelper);
     }
 }
 
 
diff --git a/src/main/org/apache/tools/ant/property/LocalPropertyStack.java b/src/main/org/apache/tools/ant/property/LocalPropertyStack.java
index dd6f97adc..1cba3f519 100644
--- a/src/main/org/apache/tools/ant/property/LocalPropertyStack.java
+++ b/src/main/org/apache/tools/ant/property/LocalPropertyStack.java
@@ -1,151 +1,151 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.property;
 
 
 import java.util.LinkedList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
 import org.apache.tools.ant.PropertyHelper;
 
 /**
  * A stack of local property maps.
  * There is a map for each scope (target, sequential, macro).
  * @since Ant 1.8.0
  */
 public class LocalPropertyStack {
     private LinkedList stack = new LinkedList();
 
     // --------------------------------------------------
     //
     //  Local property adding and scoping
     //
     // --------------------------------------------------
 
     /**
      * Add a local property.
-     * @param property the name of the local proeprty.
+     * @param property the name of the local property.
      */
     public void addLocal(String property) {
         if (!stack.isEmpty()) {
             ((Map) stack.getFirst()).put(property, NullReturn.NULL);
         }
     }
 
     /**
      * Enter the local scope.
      */
     public void enterScope() {
         stack.addFirst(new HashMap());
     }
 
     /**
      * Exit the local scope.
      */
     public void exitScope() {
         ((HashMap) stack.removeFirst()).clear();
     }
 
     // --------------------------------------------------
     //
     //  Copy - used in parallel to make a new stack
     //
     // --------------------------------------------------
 
     /**
      * Copy the stack for a parallel thread.
      * @return a copy.
      */
     public LocalPropertyStack copy() {
         LocalPropertyStack ret = new LocalPropertyStack();
         ret.stack.addAll(stack);
         return ret;
     }
 
     // --------------------------------------------------
     //
     //  PropertyHelper delegate methods
     //
     // --------------------------------------------------
 
     /**
      * Evaluate a property.
      * @param property the property's String "identifier".
      * @param helper the invoking PropertyHelper.
      * @return Object value.
      */
     public Object evaluate(String property, PropertyHelper helper) {
         for (Iterator i = stack.iterator(); i.hasNext();) {
             Map map = (Map) i.next();
             Object ret = map.get(property);
             if (ret != null) {
                 return ret;
             }
         }
         return null;
     }
 
     /**
      * Set a *new" property.
      * @param property the property's String "identifier".
      * @param value    the value to set.
      * @param propertyHelper the invoking PropertyHelper.
      * @return true if this entity 'owns' the property.
      */
     public boolean setNew(
         String property, Object value, PropertyHelper propertyHelper) {
         Map map = getMapForProperty(property);
         if (map == null) {
             return false;
         }
         Object currValue = map.get(property);
         if (currValue == NullReturn.NULL) {
             map.put(property, value);
         }
         return true;
     }
 
     /**
      * Set a property.
      * @param property the property's String "identifier".
      * @param value    the value to set.
      * @param propertyHelper the invoking PropertyHelper.
      * @return true if this entity 'owns' the property.
      */
     public boolean set(String property, Object value, PropertyHelper propertyHelper) {
         Map map = getMapForProperty(property);
         if (map == null) {
             return false;
         }
         map.put(property, value);
         return true;
     }
 
     private Map getMapForProperty(String property) {
         for (Iterator i = stack.iterator(); i.hasNext();) {
             Map map = (Map) i.next();
             if (map.get(property) != null) {
                 return map;
             }
         }
         return null;
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/Ant.java b/src/main/org/apache/tools/ant/taskdefs/Ant.java
index 463453347..0ea9e2b89 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Ant.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Ant.java
@@ -1,843 +1,843 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.lang.reflect.Method;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Vector;
 import java.util.Set;
 import java.util.HashSet;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.BuildListener;
 import org.apache.tools.ant.DefaultLogger;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectComponent;
 import org.apache.tools.ant.ProjectHelper;
 import org.apache.tools.ant.Target;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.MagicNames;
 import org.apache.tools.ant.Main;
 import org.apache.tools.ant.types.PropertySet;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.VectorSet;
 
 /**
  * Build a sub-project.
  *
  *  <pre>
  *  &lt;target name=&quot;foo&quot; depends=&quot;init&quot;&gt;
  *    &lt;ant antfile=&quot;build.xml&quot; target=&quot;bar&quot; &gt;
  *      &lt;property name=&quot;property1&quot; value=&quot;aaaaa&quot; /&gt;
  *      &lt;property name=&quot;foo&quot; value=&quot;baz&quot; /&gt;
  *    &lt;/ant&gt;</span>
  *  &lt;/target&gt;</span>
  *
  *  &lt;target name=&quot;bar&quot; depends=&quot;init&quot;&gt;
  *    &lt;echo message=&quot;prop is ${property1} ${foo}&quot; /&gt;
  *  &lt;/target&gt;
  * </pre>
  *
  *
  * @since Ant 1.1
  *
  * @ant.task category="control"
  */
 public class Ant extends Task {
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /** the basedir where is executed the build file */
     private File dir = null;
 
     /**
      * the build.xml file (can be absolute) in this case dir will be
      * ignored
      */
     private String antFile = null;
 
     /** the output */
     private String output = null;
 
     /** should we inherit properties from the parent ? */
     private boolean inheritAll = true;
 
     /** should we inherit references from the parent ? */
     private boolean inheritRefs = false;
 
     /** the properties to pass to the new project */
     private Vector properties = new Vector();
 
     /** the references to pass to the new project */
     private Vector references = new Vector();
 
     /** the temporary project created to run the build file */
     private Project newProject;
 
     /** The stream to which output is to be written. */
     private PrintStream out = null;
 
     /** the sets of properties to pass to the new project */
     private Vector propertySets = new Vector();
 
     /** the targets to call on the new project */
     private Vector targets = new Vector();
 
     /** whether the target attribute was specified **/
     private boolean targetAttributeSet = false;
 
     /**
      * Whether the basedir of the new project should be the same one
      * as it would be when running the build file directly -
      * independent of dir and/or inheritAll settings.
      *
      * @since Ant 1.8.0
      */
     private boolean useNativeBasedir = false;
 
     /**
      * simple constructor
      */
     public Ant() {
         //default
     }
 
     /**
      * create a task bound to its creator
      * @param owner owning task
      */
     public Ant(Task owner) {
         bindToOwner(owner);
     }
 
     /**
      * Whether the basedir of the new project should be the same one
      * as it would be when running the build file directly -
      * independent of dir and/or inheritAll settings.
      *
      * @since Ant 1.8.0
      */
     public void setUseNativeBasedir(boolean b) {
         useNativeBasedir = b;
     }
 
     /**
      * If true, pass all properties to the new Ant project.
      * Defaults to true.
      * @param value if true pass all properties to the new Ant project.
      */
     public void setInheritAll(boolean value) {
         inheritAll = value;
     }
 
     /**
      * If true, pass all references to the new Ant project.
      * Defaults to false.
      * @param value if true, pass all references to the new Ant project
      */
     public void setInheritRefs(boolean value) {
         inheritRefs = value;
     }
 
     /**
      * Creates a Project instance for the project to call.
      */
     public void init() {
         newProject = getProject().createSubProject();
         newProject.setJavaVersionProperty();
     }
 
     /**
      * Called in execute or createProperty (via getNewProject())
      * if newProject is null.
      *
      * <p>This can happen if the same instance of this task is run
      * twice as newProject is set to null at the end of execute (to
      * save memory and help the GC).</p>
      * <p>calls init() again</p>
      *
      */
     private void reinit() {
         init();
     }
 
     /**
      * Attaches the build listeners of the current project to the new
      * project, configures a possible logfile, transfers task and
      * data-type definitions, transfers properties (either all or just
      * the ones specified as user properties to the current project,
      * depending on inheritall), transfers the input handler.
      */
     private void initializeProject() {
         newProject.setInputHandler(getProject().getInputHandler());
 
         Iterator iter = getBuildListeners();
         while (iter.hasNext()) {
             newProject.addBuildListener((BuildListener) iter.next());
         }
 
         if (output != null) {
             File outfile = null;
             if (dir != null) {
                 outfile = FILE_UTILS.resolveFile(dir, output);
             } else {
                 outfile = getProject().resolveFile(output);
             }
             try {
                 out = new PrintStream(new FileOutputStream(outfile));
                 DefaultLogger logger = new DefaultLogger();
                 logger.setMessageOutputLevel(Project.MSG_INFO);
                 logger.setOutputPrintStream(out);
                 logger.setErrorPrintStream(out);
                 newProject.addBuildListener(logger);
             } catch (IOException ex) {
                 log("Ant: Can't set output to " + output);
             }
         }
         // set user-defined properties
         if (useNativeBasedir) {
             addAlmostAll(getProject().getUserProperties(), PropertyType.USER);
         } else {
             getProject().copyUserProperties(newProject);
         }
 
         if (!inheritAll) {
            // set Ant's built-in properties separately,
            // because they are not being inherited.
            newProject.initProperties();
 
         } else {
             // set all properties from calling project
             addAlmostAll(getProject().getProperties(), PropertyType.PLAIN);
         }
 
         Enumeration e = propertySets.elements();
         while (e.hasMoreElements()) {
             PropertySet ps = (PropertySet) e.nextElement();
             addAlmostAll(ps.getProperties(), PropertyType.PLAIN);
         }
     }
 
     /**
      * Handles output.
      * Send it the the new project if is present, otherwise
      * call the super class.
      * @param outputToHandle The string output to output.
      * @see Task#handleOutput(String)
      * @since Ant 1.5
      */
     public void handleOutput(String outputToHandle) {
         if (newProject != null) {
             newProject.demuxOutput(outputToHandle, false);
         } else {
             super.handleOutput(outputToHandle);
         }
     }
 
     /**
      * Handles input.
-     * Deleate to the created project, if present, otherwise
+     * Delegate to the created project, if present, otherwise
      * call the super class.
      * @param buffer the buffer into which data is to be read.
      * @param offset the offset into the buffer at which data is stored.
      * @param length the amount of data to read.
      *
      * @return the number of bytes read.
      *
      * @exception IOException if the data cannot be read.
      * @see Task#handleInput(byte[], int, int)
      * @since Ant 1.6
      */
     public int handleInput(byte[] buffer, int offset, int length)
         throws IOException {
         if (newProject != null) {
             return newProject.demuxInput(buffer, offset, length);
         }
         return super.handleInput(buffer, offset, length);
     }
 
     /**
      * Handles output.
      * Send it the the new project if is present, otherwise
      * call the super class.
      * @param toFlush The string to output.
      * @see Task#handleFlush(String)
      * @since Ant 1.5.2
      */
     public void handleFlush(String toFlush) {
         if (newProject != null) {
             newProject.demuxFlush(toFlush, false);
         } else {
             super.handleFlush(toFlush);
         }
     }
 
     /**
      * Handle error output.
      * Send it the the new project if is present, otherwise
      * call the super class.
      * @param errorOutputToHandle The string to output.
      *
      * @see Task#handleErrorOutput(String)
      * @since Ant 1.5
      */
     public void handleErrorOutput(String errorOutputToHandle) {
         if (newProject != null) {
             newProject.demuxOutput(errorOutputToHandle, true);
         } else {
             super.handleErrorOutput(errorOutputToHandle);
         }
     }
 
     /**
      * Handle error output.
      * Send it the the new project if is present, otherwise
      * call the super class.
      * @param errorOutputToFlush The string to output.
      * @see Task#handleErrorFlush(String)
      * @since Ant 1.5.2
      */
     public void handleErrorFlush(String errorOutputToFlush) {
         if (newProject != null) {
             newProject.demuxFlush(errorOutputToFlush, true);
         } else {
             super.handleErrorFlush(errorOutputToFlush);
         }
     }
 
     /**
      * Do the execution.
      * @throws BuildException if a target tries to call itself;
      * probably also if a BuildException is thrown by the new project.
      */
     public void execute() throws BuildException {
         File savedDir = dir;
         String savedAntFile = antFile;
         Vector locals = new VectorSet(targets);
         try {
             getNewProject();
 
             if (dir == null && inheritAll) {
                 dir = getProject().getBaseDir();
             }
 
             initializeProject();
 
             if (dir != null) {
                 if (!useNativeBasedir) {
                     newProject.setBaseDir(dir);
                     if (savedDir != null) {
                         // has been set explicitly
                         newProject.setInheritedProperty(MagicNames.PROJECT_BASEDIR,
                                                         dir.getAbsolutePath());
                     }
                 }
             } else {
                 dir = getProject().getBaseDir();
             }
 
             overrideProperties();
 
             if (antFile == null) {
                 antFile = getDefaultBuildFile();
             }
 
             File file = FILE_UTILS.resolveFile(dir, antFile);
             antFile = file.getAbsolutePath();
 
             log("calling target(s) "
                 + ((locals.size() > 0) ? locals.toString() : "[default]")
                 + " in build file " + antFile, Project.MSG_VERBOSE);
             newProject.setUserProperty(MagicNames.ANT_FILE , antFile);
 
             String thisAntFile = getProject().getProperty(MagicNames.ANT_FILE);
             // Are we trying to call the target in which we are defined (or
             // the build file if this is a top level task)?
             if (thisAntFile != null
                 && file.equals(getProject().resolveFile(thisAntFile))
                 && getOwningTarget() != null) {
 
                 if (getOwningTarget().getName().equals("")) {
                     if (getTaskName().equals("antcall")) {
                         throw new BuildException("antcall must not be used at"
                                                  + " the top level.");
                     }
                     throw new BuildException(getTaskName() + " task at the"
                                 + " top level must not invoke"
                                 + " its own build file.");
                 }
             }
 
             try {
                 ProjectHelper.configureProject(newProject, file);
             } catch (BuildException ex) {
                 throw ProjectHelper.addLocationToBuildException(
                     ex, getLocation());
             }
 
             if (locals.size() == 0) {
                 String defaultTarget = newProject.getDefaultTarget();
                 if (defaultTarget != null) {
                     locals.add(defaultTarget);
                 }
             }
 
             if (newProject.getProperty(MagicNames.ANT_FILE)
                 .equals(getProject().getProperty(MagicNames.ANT_FILE))
                 && getOwningTarget() != null) {
 
                 String owningTargetName = getOwningTarget().getName();
 
                 if (locals.contains(owningTargetName)) {
                     throw new BuildException(getTaskName() + " task calling "
                                              + "its own parent target.");
                 }
                 boolean circular = false;
                 for (Iterator it = locals.iterator();
                      !circular && it.hasNext();) {
                     Target other =
                         (Target) (getProject().getTargets().get(it.next()));
                     circular |= (other != null
                                  && other.dependsOn(owningTargetName));
                 }
                 if (circular) {
                     throw new BuildException(getTaskName()
                                              + " task calling a target"
                                              + " that depends on"
                                              + " its parent target \'"
                                              + owningTargetName
                                              + "\'.");
                 }
             }
 
             addReferences();
 
             if (locals.size() > 0 && !(locals.size() == 1
                                        && "".equals(locals.get(0)))) {
                 BuildException be = null;
                 try {
                     log("Entering " + antFile + "...", Project.MSG_VERBOSE);
                     newProject.fireSubBuildStarted();
                     newProject.executeTargets(locals);
                 } catch (BuildException ex) {
                     be = ProjectHelper
                         .addLocationToBuildException(ex, getLocation());
                     throw be;
                 } finally {
                     log("Exiting " + antFile + ".", Project.MSG_VERBOSE);
                     newProject.fireSubBuildFinished(be);
                 }
             }
         } finally {
             // help the gc
             newProject = null;
             Enumeration e = properties.elements();
             while (e.hasMoreElements()) {
                 Property p = (Property) e.nextElement();
                 p.setProject(null);
             }
 
             if (output != null && out != null) {
                 try {
                     out.close();
                 } catch (final Exception ex) {
                     //ignore
                 }
             }
             dir = savedDir;
             antFile = savedAntFile;
         }
     }
 
     /**
      * Get the default build file name to use when launching the task.
      * <p>
      * This function may be overrided by providers of custom ProjectHelper so they can implement easily their sub
      * launcher.
      * 
      * @return the name of the default file
      * @since Ant 1.8.0
      */
     protected String getDefaultBuildFile() {
         return Main.DEFAULT_BUILD_FILENAME;
     }
 
     /**
      * Override the properties in the new project with the one
      * explicitly defined as nested elements here.
      * @throws BuildException under unknown circumstances.
      */
     private void overrideProperties() throws BuildException {
         // remove duplicate properties - last property wins
         // Needed for backward compatibility
         Set set = new HashSet();
         for (int i = properties.size() - 1; i >= 0; --i) {
             Property p = (Property) properties.get(i);
             if (p.getName() != null && !p.getName().equals("")) {
                 if (set.contains(p.getName())) {
                     properties.remove(i);
                 } else {
                     set.add(p.getName());
                 }
             }
         }
         Enumeration e = properties.elements();
         while (e.hasMoreElements()) {
             Property p = (Property) e.nextElement();
             p.setProject(newProject);
             p.execute();
         }
         if (useNativeBasedir) {
             addAlmostAll(getProject().getInheritedProperties(),
                          PropertyType.INHERITED);
         } else {
             getProject().copyInheritedProperties(newProject);
         }
     }
 
     /**
      * Add the references explicitly defined as nested elements to the
      * new project.  Also copy over all references that don't override
      * existing references in the new project if inheritrefs has been
      * requested.
      * @throws BuildException if a reference does not have a refid.
      */
     private void addReferences() throws BuildException {
         Hashtable thisReferences
             = (Hashtable) getProject().getReferences().clone();
         Hashtable newReferences = newProject.getReferences();
         Enumeration e;
         if (references.size() > 0) {
             for (e = references.elements(); e.hasMoreElements();) {
                 Reference ref = (Reference) e.nextElement();
                 String refid = ref.getRefId();
                 if (refid == null) {
                     throw new BuildException("the refid attribute is required"
                                              + " for reference elements");
                 }
                 if (!thisReferences.containsKey(refid)) {
                     log("Parent project doesn't contain any reference '"
                         + refid + "'",
                         Project.MSG_WARN);
                     continue;
                 }
 
                 thisReferences.remove(refid);
                 String toRefid = ref.getToRefid();
                 if (toRefid == null) {
                     toRefid = refid;
                 }
                 copyReference(refid, toRefid);
             }
         }
 
         // Now add all references that are not defined in the
         // subproject, if inheritRefs is true
         if (inheritRefs) {
             for (e = thisReferences.keys(); e.hasMoreElements();) {
                 String key = (String) e.nextElement();
                 if (newReferences.containsKey(key)) {
                     continue;
                 }
                 copyReference(key, key);
                 newProject.inheritIDReferences(getProject());
             }
         }
     }
 
     /**
      * Try to clone and reconfigure the object referenced by oldkey in
      * the parent project and add it to the new project with the key newkey.
      *
      * <p>If we cannot clone it, copy the referenced object itself and
      * keep our fingers crossed.</p>
      * @param oldKey the reference id in the current project.
      * @param newKey the reference id in the new project.
      */
     private void copyReference(String oldKey, String newKey) {
         Object orig = getProject().getReference(oldKey);
         if (orig == null) {
             log("No object referenced by " + oldKey + ". Can't copy to "
                 + newKey,
                 Project.MSG_WARN);
             return;
         }
 
         Class c = orig.getClass();
         Object copy = orig;
         try {
             Method cloneM = c.getMethod("clone", new Class[0]);
             if (cloneM != null) {
                 copy = cloneM.invoke(orig, new Object[0]);
                 log("Adding clone of reference " + oldKey, Project.MSG_DEBUG);
             }
         } catch (Exception e) {
             // not Clonable
         }
 
 
         if (copy instanceof ProjectComponent) {
             ((ProjectComponent) copy).setProject(newProject);
         } else {
             try {
                 Method setProjectM =
                     c.getMethod("setProject", new Class[] {Project.class});
                 if (setProjectM != null) {
                     setProjectM.invoke(copy, new Object[] {newProject});
                 }
             } catch (NoSuchMethodException e) {
                 // ignore this if the class being referenced does not have
                 // a set project method.
             } catch (Exception e2) {
                 String msg = "Error setting new project instance for "
                     + "reference with id " + oldKey;
                 throw new BuildException(msg, e2, getLocation());
             }
         }
         newProject.addReference(newKey, copy);
     }
 
     /**
      * Copies all properties from the given table to the new project -
      * omitting those that have already been set in the new project as
      * well as properties named basedir or ant.file.
      * @param props properties <code>Hashtable</code> to copy to the
      * new project.
      * @param the type of property to set (a plain Ant property, a
      * user property or an inherited property).
      * @since Ant 1.8.0
      */
     private void addAlmostAll(Hashtable props, PropertyType type) {
         Enumeration e = props.keys();
         while (e.hasMoreElements()) {
             String key = e.nextElement().toString();
             if (MagicNames.PROJECT_BASEDIR.equals(key)
                 || MagicNames.ANT_FILE.equals(key)) {
                 // basedir and ant.file get special treatment in execute()
                 continue;
             }
 
             String value = props.get(key).toString();
             if (type == PropertyType.PLAIN) {
                 // don't re-set user properties, avoid the warning message
                 if (newProject.getProperty(key) == null) {
                     // no user property
                     newProject.setNewProperty(key, value);
                 }
             } else if (type == PropertyType.USER) {
                 newProject.setUserProperty(key, value);
             } else if (type == PropertyType.INHERITED) {
                 newProject.setInheritedProperty(key, value);
             }
         }
     }
 
     /**
      * The directory to use as a base directory for the new Ant project.
      * Defaults to the current project's basedir, unless inheritall
      * has been set to false, in which case it doesn't have a default
      * value. This will override the basedir setting of the called project.
      * @param dir new directory as <code>File</code>.
      */
     public void setDir(File dir) {
         this.dir = dir;
     }
 
     /**
      * The build file to use. Defaults to "build.xml". This file is expected
      * to be a filename relative to the dir attribute given.
      * @param antFile the <code>String</code> build file name.
      */
     public void setAntfile(String antFile) {
         // @note: it is a string and not a file to handle relative/absolute
         // otherwise a relative file will be resolved based on the current
         // basedir.
         this.antFile = antFile;
     }
 
     /**
      * The target of the new Ant project to execute.
      * Defaults to the new project's default target.
      * @param targetToAdd the name of the target to invoke.
      */
     public void setTarget(String targetToAdd) {
         if (targetToAdd.equals("")) {
             throw new BuildException("target attribute must not be empty");
         }
         targets.add(targetToAdd);
         targetAttributeSet = true;
     }
 
     /**
      * Set the filename to write the output to. This is relative to the value
      * of the dir attribute if it has been set or to the base directory of the
      * current project otherwise.
      * @param outputFile the name of the file to which the output should go.
      */
     public void setOutput(String outputFile) {
         this.output = outputFile;
     }
 
     /**
      * Property to pass to the new project.
      * The property is passed as a 'user property'.
      * @return the created <code>Property</code> object.
      */
     public Property createProperty() {
         Property p = new Property(true, getProject());
         p.setProject(getNewProject());
         p.setTaskName("property");
         properties.addElement(p);
         return p;
     }
 
     /**
      * Add a Reference element identifying a data type to carry
      * over to the new project.
      * @param ref <code>Reference</code> to add.
      */
     public void addReference(Reference ref) {
         references.addElement(ref);
     }
 
     /**
      * Add a target to this Ant invocation.
      * @param t the <code>TargetElement</code> to add.
      * @since Ant 1.6.3
      */
     public void addConfiguredTarget(TargetElement t) {
         if (targetAttributeSet) {
             throw new BuildException(
                 "nested target is incompatible with the target attribute");
         }
         String name = t.getName();
         if (name.equals("")) {
             throw new BuildException("target name must not be empty");
         }
         targets.add(name);
     }
 
     /**
      * Add a set of properties to pass to the new project.
      *
      * @param ps <code>PropertySet</code> to add.
      * @since Ant 1.6
      */
     public void addPropertyset(PropertySet ps) {
         propertySets.addElement(ps);
     }
 
     /**
      * Get the (sub)-Project instance currently in use.
      * @return Project
      * @since Ant 1.7
      */
     protected Project getNewProject() {
         if (newProject == null) {
             reinit();
         }
         return newProject;
     }
 
     /**
      * @since Ant 1.6.2
      */
     private Iterator getBuildListeners() {
         return getProject().getBuildListeners().iterator();
     }
 
     /**
      * Helper class that implements the nested &lt;reference&gt;
      * element of &lt;ant&gt; and &lt;antcall&gt;.
      */
     public static class Reference
         extends org.apache.tools.ant.types.Reference {
 
         /** Creates a reference to be configured by Ant. */
         public Reference() {
                 super();
         }
 
         private String targetid = null;
 
         /**
          * Set the id that this reference to be stored under in the
          * new project.
          *
          * @param targetid the id under which this reference will be passed to
          *        the new project. */
         public void setToRefid(String targetid) {
             this.targetid = targetid;
         }
 
         /**
          * Get the id under which this reference will be stored in the new
          * project.
          *
          * @return the id of the reference in the new project.
          */
         public String getToRefid() {
             return targetid;
         }
     }
 
     /**
      * Helper class that implements the nested &lt;target&gt;
      * element of &lt;ant&gt; and &lt;antcall&gt;.
      * @since Ant 1.6.3
      */
     public static class TargetElement {
         private String name;
 
         /**
          * Default constructor.
          */
         public TargetElement() {
                 //default
         }
 
         /**
          * Set the name of this TargetElement.
          * @param name   the <code>String</code> target name.
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * Get the name of this TargetElement.
          * @return <code>String</code>.
          */
         public String getName() {
             return name;
         }
     }
 
     private static final class PropertyType {
         private PropertyType() {}
         private static final PropertyType PLAIN = new PropertyType();
         private static final PropertyType INHERITED = new PropertyType();
         private static final PropertyType USER = new PropertyType();
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/AntlibDefinition.java b/src/main/org/apache/tools/ant/taskdefs/AntlibDefinition.java
index 3ef31e36e..eef333459 100644
--- a/src/main/org/apache/tools/ant/taskdefs/AntlibDefinition.java
+++ b/src/main/org/apache/tools/ant/taskdefs/AntlibDefinition.java
@@ -1,81 +1,81 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.ProjectHelper;
 import org.apache.tools.ant.Task;
 
 /**
  * Base class for tasks that that can be used in antlibs.
  * For handling uri and class loading.
  *
  * @since Ant 1.6
  */
 public class AntlibDefinition extends Task {
 
     private String uri = "";
     private ClassLoader antlibClassLoader;
 
     /**
      * The URI for this definition.
      * If the URI is "antlib:org.apache.tools.ant",
      * (this is the default uri)
      * the uri will be set to "".
      * URIs that start with "ant:" are reserved
      * and are not allowed in this context.
      * @param uri the namespace URI
      * @throws BuildException if a reserved URI is used
      */
     public void setURI(String uri) throws BuildException {
         if (uri.equals(ProjectHelper.ANT_CORE_URI)) {
             uri = "";
         }
         if (uri.startsWith("ant:")) {
             throw new BuildException("Attempt to use a reserved URI " + uri);
         }
         this.uri = uri;
     }
 
     /**
      * The URI for this definition.
-     * @return The URI for this defintion.
+     * @return The URI for this definition.
      */
     public String getURI() {
         return uri;
     }
 
     /**
      * Set the class loader of the loading object
      *
      * @param classLoader a <code>ClassLoader</code> value
      */
     public void setAntlibClassLoader(ClassLoader classLoader) {
         this.antlibClassLoader = classLoader;
     }
 
     /**
      * The current antlib classloader
      * @return the antlib classloader for the definition, this
      *         is null if the definition is not used in an antlib.
      */
     public ClassLoader getAntlibClassLoader() {
         return antlibClassLoader;
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Apt.java b/src/main/org/apache/tools/ant/taskdefs/Apt.java
index 241594e2a..6827a6abb 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Apt.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Apt.java
@@ -1,267 +1,267 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.compilers.AptExternalCompilerAdapter;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.util.JavaEnvUtils;
 
 import java.util.Vector;
 import java.io.File;
 
 /**
  * Apt Task for running the Annotation processing tool for JDK 1.5.  It derives
  * from the existing Javac task, and forces the compiler based on whether we're
  * executing internally, or externally.
  *
  * @since Ant 1.7
  */
 
 
 public class Apt
         extends Javac {
     private boolean compile = true;
     private String factory;
     private Path factoryPath;
     private Vector options = new Vector();
     private File preprocessDir;
     /** The name of the apt tool. */
     public static final String EXECUTABLE_NAME = "apt";
     /** An warning message when ignoring compiler attribute. */
     public static final String ERROR_IGNORING_COMPILER_OPTION
         = "Ignoring compiler attribute for the APT task, as it is fixed";
     /** A warning message if used with java < 1.5. */
     public static final String ERROR_WRONG_JAVA_VERSION
         = "Apt task requires Java 1.5+";
 
     /**
      * exposed for debug messages
      */
     public static final String WARNING_IGNORING_FORK =
         "Apt only runs in its own JVM; fork=false option ignored";
 
     /**
      * The nested option element.
      */
     public static final class Option {
         private String name;
         private String value;
 
         /** Constructor for Option */
         public Option() {
             //default
         }
 
         /**
          * Get the name attribute.
          * @return the name attribute.
          */
         public String getName() {
             return name;
         }
 
         /**
          * Set the name attribute.
          * @param name the name of the option.
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * Get the value attribute.
          * @return the value attribute.
          */
         public String getValue() {
             return value;
         }
 
         /**
          * Set the value attribute.
          * @param value the value of the option.
          */
         public void setValue(String value) {
             this.value = value;
         }
     }
 
     /**
-     * Construtor for Apt task.
+     * Constructor for Apt task.
      * This sets the apt compiler adapter as the compiler in the super class.
      */
     public Apt() {
         super();
         super.setCompiler(AptExternalCompilerAdapter.class.getName());
         super.setFork(true);
     }
 
     /**
      * Get the name of the apt executable.
      *
      * @return the name of the executable.
      */
     public String getAptExecutable() {
         String exe = getExecutable();
         return exe != null ? exe :
             JavaEnvUtils.getJdkExecutable(EXECUTABLE_NAME);
     }
 
     /**
      * Set the compiler.
      * This is not allowed and a warning log message is made.
      * @param compiler not used.
      */
     public void setCompiler(String compiler) {
         log(ERROR_IGNORING_COMPILER_OPTION, Project.MSG_WARN);
     }
 
     /**
      * Set the fork attribute.
      * Non-forking APT is highly classpath dependent and appears to be too
      * brittle to work. The sole reason this attribute is retained
      * is the superclass does it
      * @param fork if false; warn the option is ignored.
      */
     public void setFork(boolean fork) {
         if (!fork) {
             log(WARNING_IGNORING_FORK, Project.MSG_WARN);
         }
     }
 
     /**
      * Get the compiler class name.
      * @return the compiler class name.
      */
     public String getCompiler() {
         return super.getCompiler();
     }
 
     /**
      * Get the compile option for the apt compiler.
      * If this is false the "-nocompile" argument will be used.
      * @return the value of the compile option.
      */
     public boolean isCompile() {
         return compile;
     }
 
     /**
      * Set the compile option for the apt compiler.
      * Default value is true.
      * @param compile if true set the compile option.
      */
     public void setCompile(boolean compile) {
         this.compile = compile;
     }
 
     /**
      * Get the factory option for the apt compiler.
      * If this is non-null the "-factory" argument will be used.
      * @return the value of the factory option.
      */
     public String getFactory() {
         return factory;
     }
 
     /**
      * Set the factory option for the apt compiler.
      * Default value is null.
      * @param factory the classname of the factory.
      */
     public void setFactory(String factory) {
         this.factory = factory;
     }
 
     /**
      * Add a reference to a path to the factoryPath attribute.
      * @param ref a reference to a path.
      */
     public void setFactoryPathRef(Reference ref) {
         createFactoryPath().setRefid(ref);
     }
 
     /**
      * Add a path to the factoryPath attribute.
      * @return a path to be configured.
      */
     public Path createFactoryPath() {
         if (factoryPath == null) {
             factoryPath = new Path(getProject());
         }
         return factoryPath.createPath();
     }
 
     /**
      * Get the factory path attribute.
      * If this is not null, the "-factorypath" argument will be used.
      * The default value is null.
      * @return the factory path attribute.
      */
     public Path getFactoryPath() {
         return factoryPath;
     }
 
     /**
      * Create a nested option.
      * @return an option to be configured.
      */
     public Option createOption() {
         Option opt = new Option();
         options.add(opt);
         return opt;
     }
 
     /**
      * Get the options to the compiler.
      * Each option will use '"-E" name ["=" value]' argument.
      * @return the options.
      */
     public Vector getOptions() {
         return options;
     }
 
     /**
      * Get the preprocessdir attribute.
      * This corresponds to the "-s" argument.
      * The default value is null.
      * @return the preprocessdir attribute.
      */
     public File getPreprocessDir() {
         return preprocessDir;
     }
 
     /**
      * Set the preprocessdir attribute.
      * @param preprocessDir where to place processor generated source files.
      */
     public void setPreprocessDir(File preprocessDir) {
         this.preprocessDir = preprocessDir;
     }
 
     /**
      * Do the compilation.
      * @throws BuildException on error.
      */
     public void execute()
             throws BuildException {
         super.execute();
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Available.java b/src/main/org/apache/tools/ant/taskdefs/Available.java
index 2061e5f17..8e13eafbd 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Available.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Available.java
@@ -1,513 +1,513 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.PropertyHelper;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.condition.Condition;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.StringUtils;
 
 /**
  * Will set the given property if the requested resource is available at
  * runtime. This task may also be used as a condition by the condition task.
  *
  * @since Ant 1.1
  *
  * @ant.task category="control"
  */
 public class Available extends Task implements Condition {
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     private String property;
     private String classname;
     private String filename;
     private File file;
     private Path filepath;
     private String resource;
     private FileDir type;
     private Path classpath;
     private AntClassLoader loader;
     private Object value = "true";
     private boolean isTask = false;
     private boolean ignoreSystemclasses = false;
     private boolean searchParents   = false;
 
     /**
      * Set the searchParents attribute.
      * This controls the behaviour of the the "file" type.
      * If true, the path, parent path and grandparent path are
-     * searched for the file. If false, only the path is seached.
+     * searched for the file. If false, only the path is searched.
      * The default value is false.
      * @param searchParents the value to set.
      */
     public void setSearchParents(boolean  searchParents) {
         this.searchParents = searchParents;
     }
 
     /**
      * Set the classpath to be used when searching for classes and resources.
      *
      * @param classpath an Ant Path object containing the search path.
      */
     public void setClasspath(Path classpath) {
         createClasspath().append(classpath);
     }
 
     /**
      * Classpath to be used when searching for classes and resources.
      *
      * @return an empty Path instance to be configured by Ant.
      */
     public Path createClasspath() {
         if (this.classpath == null) {
             this.classpath = new Path(getProject());
         }
         return this.classpath.createPath();
     }
 
     /**
      * Set the classpath by reference.
      *
      * @param r a Reference to a Path instance to be used as the classpath
      *          value.
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * Set the path to use when looking for a file.
      *
      * @param filepath a Path instance containing the search path for files.
      */
     public void setFilepath(Path filepath) {
         createFilepath().append(filepath);
     }
 
     /**
      * Path to search for file resources.
      *
      * @return a new Path instance which Ant will configure with a file search
      *         path.
      */
     public Path createFilepath() {
         if (this.filepath == null) {
             this.filepath = new Path(getProject());
         }
         return this.filepath.createPath();
     }
 
     /**
      * Set the name of the property which will be set if the particular resource
      * is available.
      *
      * @param property the name of the property to set.
      */
     public void setProperty(String property) {
         this.property = property;
     }
 
     /**
      * Set the value to be given to the property if the desired resource is
      * available.
      *
      * @param value the value to be given.
      */
     public void setValue(Object value) {
         this.value = value;
     }
 
     /**
      * Set the value to be given to the property if the desired resource is
      * available.
      *
      * @param value the value to be given.
      */
     public void setValue(String value) {
         setValue((Object) value);
     }
 
     /**
      * Set a classname of a class which must be available to set the given
      * property.
      *
      * @param classname the name of the class required.
      */
     public void setClassname(String classname) {
         if (!"".equals(classname)) {
             this.classname = classname;
         }
     }
 
     /**
      * Set the file which must be present in the file system to set the given
      * property.
      *
      * @param file the name of the file which is required.
      */
     public void setFile(File file) {
         this.file = file;
         this.filename = FILE_UTILS.removeLeadingPath(getProject().getBaseDir(), file);
     }
 
     /**
      * Set the name of a Java resource which is required to set the property.
      *
      * @param resource the name of a resource which is required to be available.
      */
     public void setResource(String resource) {
         this.resource = resource;
     }
 
     /**
      * @deprecated since 1.5.x.
      *             setType(String) is deprecated and is replaced with
      *             setType(Available.FileDir) to make Ant's Introspection
      *             mechanism do the work and also to encapsulate operations on
      *             the type in its own class.
      * @param type the type of resource
      */
     public void setType(String type) {
         log("DEPRECATED - The setType(String) method has been deprecated."
             + " Use setType(Available.FileDir) instead.",
             Project.MSG_WARN);
         this.type = new FileDir();
         this.type.setValue(type);
     }
 
     /**
      * Set what type of file is required - either directory or file.
      *
      * @param type an instance of the FileDir enumeratedAttribute indicating
      *             whether the file required is to be a directory or a plain
      *             file.
      */
     public void setType(FileDir type) {
         this.type = type;
     }
 
     /**
      * Set whether the search for classes should ignore the runtime classes and
      * just use the given classpath.
      *
      * @param ignore true if system classes are to be ignored.
      */
     public void setIgnoresystemclasses(boolean ignore) {
         this.ignoreSystemclasses = ignore;
     }
 
     /**
      * Entry point when operating as a task.
      *
      * @exception BuildException if the task is not configured correctly.
      */
     public void execute() throws BuildException {
         if (property == null) {
             throw new BuildException("property attribute is required",
                                      getLocation());
         }
 
         isTask = true;
         try {
             if (eval()) {
                 PropertyHelper ph = PropertyHelper.getPropertyHelper(getProject());
                 Object oldvalue = ph.getProperty(property);
                 if (null != oldvalue && !oldvalue.equals(value)) {
                     log("DEPRECATED - <available> used to override an existing"
                         + " property."
                         + StringUtils.LINE_SEP
                         + "  Build file should not reuse the same property"
                         + " name for different values.",
                         Project.MSG_WARN);
                 }
                 // NB: this makes use of Project#setProperty rather than Project#setNewProperty
                 //     due to backwards compatiblity reasons
                 ph.setProperty(property, value, true);
             }
         } finally {
             isTask = false;
         }
     }
 
     /**
      * Evaluate the availability of a resource.
      *
      * @return boolean is the resource is available.
      * @exception BuildException if the condition is not configured correctly
      */
     public boolean eval() throws BuildException {
         try {
             if (classname == null && file == null && resource == null) {
                 throw new BuildException("At least one of (classname|file|"
                                          + "resource) is required", getLocation());
             }
             if (type != null) {
                 if (file == null) {
                     throw new BuildException("The type attribute is only valid "
                                              + "when specifying the file "
                                              + "attribute.", getLocation());
                 }
             }
             if (classpath != null) {
                 classpath.setProject(getProject());
                 this.loader = getProject().createClassLoader(classpath);
             }
             String appendix = "";
             if (isTask) {
                 appendix = " to set property " + property;
             } else {
                 setTaskName("available");
             }
             if ((classname != null) && !checkClass(classname)) {
                 log("Unable to load class " + classname + appendix,
                     Project.MSG_VERBOSE);
                 return false;
             }
             if ((file != null) && !checkFile()) {
                 StringBuffer buf = new StringBuffer("Unable to find ");
                 if (type != null) {
                     buf.append(type).append(' ');
                 }
                 buf.append(filename).append(appendix);
                 log(buf.toString(), Project.MSG_VERBOSE);
                 return false;
             }
             if ((resource != null) && !checkResource(resource)) {
                 log("Unable to load resource " + resource + appendix,
                     Project.MSG_VERBOSE);
                 return false;
             }
         } finally {
             if (loader != null) {
                 loader.cleanup();
                 loader = null;
             }
             if (!isTask) {
                 setTaskName(null);
             }
         }
         return true;
     }
 
     /**
      * Search for file/directory either relative to project's
      * basedir or in the path given as filepath.
      *
      * <p>filepath can be a list of directory and/or file names (gen'd
      * via <fileset>)</p>
      *
      * <p>look for:</p><ul>
      *   <li>full-pathname specified == path in list</li>
      *   <li>full-pathname specified == parent dir of path in list</li>
      *   <li>simple name specified   == path in list</li>
      *   <li>simple name specified   == path in list + name</li>
      *   <li>simple name specified   == parent dir + name</li>
      *   <li>simple name specified   == parent of parent dir + name</li>
      * </ul>
      */
     private boolean checkFile() {
         if (filepath == null) {
             return checkFile(file, filename);
         } else {
             String[] paths = filepath.list();
             for (int i = 0; i < paths.length; ++i) {
                 log("Searching " + paths[i], Project.MSG_VERBOSE);
                 File path = new File(paths[i]);
 
                 // **   full-pathname specified == path in list
                 // **   simple name specified   == path in list
                 if (path.exists()
                     && (filename.equals(paths[i])
                         || filename.equals(path.getName()))) {
                     if (type == null) {
                         log("Found: " + path, Project.MSG_VERBOSE);
                         return true;
                     } else if (type.isDir()
                                && path.isDirectory()) {
                         log("Found directory: " + path, Project.MSG_VERBOSE);
                         return true;
                     } else if (type.isFile()
                                && path.isFile()) {
                         log("Found file: " + path, Project.MSG_VERBOSE);
                         return true;
                     }
                     // not the requested type
                     return false;
                 }
                 File parent = path.getParentFile();
                 // **   full-pathname specified == parent dir of path in list
                 if (parent != null && parent.exists()
                     && filename.equals(parent.getAbsolutePath())) {
                     if (type == null) {
                         log("Found: " + parent, Project.MSG_VERBOSE);
                         return true;
                     } else if (type.isDir()) {
                         log("Found directory: " + parent, Project.MSG_VERBOSE);
                         return true;
                     }
                     // not the requested type
                     return false;
                 }
                 // **   simple name specified   == path in list + name
                 if (path.exists() && path.isDirectory()) {
                     if (checkFile(new File(path, filename),
                                   filename + " in " + path)) {
                         return true;
                     }
                 }
 
                 // **   simple name specified   == parent dir + name
                 while (searchParents && parent != null && parent.exists()) {
                     if (checkFile(new File(parent, filename),
                                   filename + " in " + parent)) {
                         return true;
                     }
                     parent = parent.getParentFile();
                 }
             }
         }
         return false;
     }
 
     /**
      * Check if a given file exists and matches the required type.
      */
     private boolean checkFile(File f, String text) {
         if (type != null) {
             if (type.isDir()) {
                 if (f.isDirectory()) {
                     log("Found directory: " + text, Project.MSG_VERBOSE);
                 }
                 return f.isDirectory();
             } else if (type.isFile()) {
                 if (f.isFile()) {
                     log("Found file: " + text, Project.MSG_VERBOSE);
                 }
                 return f.isFile();
             }
         }
         if (f.exists()) {
             log("Found: " + text, Project.MSG_VERBOSE);
         }
         return f.exists();
     }
 
     /**
      * Check if a given resource can be loaded.
      */
     private boolean checkResource(String resource) {
         if (loader != null) {
             return (loader.getResourceAsStream(resource) != null);
         } else {
             ClassLoader cL = this.getClass().getClassLoader();
             if (cL != null) {
                 return (cL.getResourceAsStream(resource) != null);
             } else {
                 return
                     (ClassLoader.getSystemResourceAsStream(resource) != null);
             }
         }
     }
 
     /**
      * Check if a given class can be loaded.
      */
     private boolean checkClass(String classname) {
         try {
             if (ignoreSystemclasses) {
                 loader = getProject().createClassLoader(classpath);
                 loader.setParentFirst(false);
                 loader.addJavaLibraries();
                 try {
                     loader.findClass(classname);
                 } catch (SecurityException se) {
                     // class found but restricted name; this is
                     // actually the case we're looking for in JDK 1.3+,
                     // so catch the exception and return
                     return true;
                 }
             } else if (loader != null) {
                 loader.loadClass(classname);
             } else {
                 ClassLoader l = this.getClass().getClassLoader();
                 // Can return null to represent the bootstrap class loader.
                 // see API docs of Class.getClassLoader.
                 if (l != null) {
                     Class.forName(classname, true, l);
                 } else {
                     Class.forName(classname);
                 }
             }
             return true;
         } catch (ClassNotFoundException e) {
             log("class \"" + classname + "\" was not found",
                 Project.MSG_DEBUG);
             return false;
         } catch (NoClassDefFoundError e) {
             log("Could not load dependent class \"" + e.getMessage()
                 + "\" for class \"" + classname + "\"",
                 Project.MSG_DEBUG);
             return false;
         }
     }
 
     /**
      * EnumeratedAttribute covering the file types to be checked for, either
      * file or dir.
      */
     public static class FileDir extends EnumeratedAttribute {
 
         private static final String[] VALUES = {"file", "dir"};
 
         /**
          * @see EnumeratedAttribute#getValues
          */
         /** {@inheritDoc}. */
         public String[] getValues() {
             return VALUES;
         }
 
         /**
          * Indicate if the value specifies a directory.
          *
          * @return true if the value specifies a directory.
          */
         public boolean isDir() {
             return "dir".equalsIgnoreCase(getValue());
         }
 
         /**
          * Indicate if the value specifies a file.
          *
          * @return true if the value specifies a file.
          */
         public boolean isFile() {
             return "file".equalsIgnoreCase(getValue());
         }
 
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/CallTarget.java b/src/main/org/apache/tools/ant/taskdefs/CallTarget.java
index a6b3f673e..524855525 100644
--- a/src/main/org/apache/tools/ant/taskdefs/CallTarget.java
+++ b/src/main/org/apache/tools/ant/taskdefs/CallTarget.java
@@ -1,255 +1,255 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.IOException;
 
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.types.PropertySet;
 
 /**
  * Call another target in the same project.
  *
  *  <pre>
  *    &lt;target name="foo"&gt;
  *      &lt;antcall target="bar"&gt;
  *        &lt;param name="property1" value="aaaaa" /&gt;
  *        &lt;param name="foo" value="baz" /&gt;
  *       &lt;/antcall&gt;
  *    &lt;/target&gt;
  *
  *    &lt;target name="bar" depends="init"&gt;
  *      &lt;echo message="prop is ${property1} ${foo}" /&gt;
  *    &lt;/target&gt;
  * </pre>
  *
  * <p>This only works as expected if neither property1 nor foo are
  * defined in the project itself.
  *
  *
  * @since Ant 1.2
  *
  * @ant.task name="antcall" category="control"
  */
 public class CallTarget extends Task {
 
     private Ant callee;
     // must match the default value of Ant#inheritAll
     private boolean inheritAll = true;
     // must match the default value of Ant#inheritRefs
     private boolean inheritRefs = false;
 
     private boolean targetSet = false;
 
     /**
      * If true, pass all properties to the new Ant project.
      * Defaults to true.
      * @param inherit <code>boolean</code> flag.
      */
     public void setInheritAll(boolean inherit) {
        inheritAll = inherit;
     }
 
     /**
      * If true, pass all references to the new Ant project.
      * Defaults to false.
      * @param inheritRefs <code>boolean</code> flag.
      */
     public void setInheritRefs(boolean inheritRefs) {
         this.inheritRefs = inheritRefs;
     }
 
     /**
      * Initialize this task by creating new instance of the ant task and
      * configuring it by calling its own init method.
      */
     public void init() {
         callee = new Ant(this);
         callee.init();
     }
 
     /**
      * Delegate the work to the ant task instance, after setting it up.
      * @throws BuildException on validation failure or if the target didn't
      * execute.
      */
     public void execute() throws BuildException {
         if (callee == null) {
             init();
         }
         if (!targetSet) {
             throw new BuildException(
                 "Attribute target or at least one nested target is required.",
                  getLocation());
         }
         callee.setAntfile(getProject().getProperty("ant.file"));
         callee.setInheritAll(inheritAll);
         callee.setInheritRefs(inheritRefs);
         callee.execute();
     }
 
     /**
      * Create a new Property to pass to the invoked target(s).
      * @return a <code>Property</code> object.
      */
     public Property createParam() {
         if (callee == null) {
             init();
         }
         return callee.createProperty();
     }
 
     /**
      * Reference element identifying a data type to carry
      * over to the invoked target.
      * @param r the specified <code>Ant.Reference</code>.
      * @since Ant 1.5
      */
     public void addReference(Ant.Reference r) {
         if (callee == null) {
             init();
         }
         callee.addReference(r);
     }
 
     /**
      * Set of properties to pass to the new project.
      * @param ps the <code>PropertySet</code> to pass.
      * @since Ant 1.6
      */
     public void addPropertyset(PropertySet ps) {
         if (callee == null) {
             init();
         }
         callee.addPropertyset(ps);
     }
 
     /**
      * Set target to execute.
      * @param target the name of the target to execute.
      */
     public void setTarget(String target) {
         if (callee == null) {
             init();
         }
         callee.setTarget(target);
         targetSet = true;
     }
 
     /**
      * Add a target to the list of targets to invoke.
      * @param t <code>Ant.TargetElement</code> representing the target.
      * @since Ant 1.6.3
      */
     public void addConfiguredTarget(Ant.TargetElement t) {
         if (callee == null) {
             init();
         }
         callee.addConfiguredTarget(t);
         targetSet = true;
     }
 
     /**
      * Handles output.
      * Send it the the new project if is present, otherwise
      * call the super class.
      * @param output The string output to output.
      * @see Task#handleOutput(String)
      * @since Ant 1.5
      */
     public void handleOutput(String output) {
         if (callee != null) {
             callee.handleOutput(output);
         } else {
             super.handleOutput(output);
         }
     }
 
     /**
      * Handles input.
-     * Deleate to the created project, if present, otherwise
+     * Delegate to the created project, if present, otherwise
      * call the super class.
      * @param buffer the buffer into which data is to be read.
      * @param offset the offset into the buffer at which data is stored.
      * @param length the amount of data to read.
      *
      * @return the number of bytes read.
      *
      * @exception IOException if the data cannot be read.
      * @see Task#handleInput(byte[], int, int)
      * @since Ant 1.6
      */
     public int handleInput(byte[] buffer, int offset, int length)
         throws IOException {
         if (callee != null) {
             return callee.handleInput(buffer, offset, length);
         }
         return super.handleInput(buffer, offset, length);
     }
 
     /**
      * Handles output.
      * Send it the the new project if is present, otherwise
      * call the super class.
      * @param output The string to output.
      * @see Task#handleFlush(String)
      * @since Ant 1.5.2
      */
     public void handleFlush(String output) {
         if (callee != null) {
             callee.handleFlush(output);
         } else {
             super.handleFlush(output);
         }
     }
 
     /**
      * Handle error output.
      * Send it the the new project if is present, otherwise
      * call the super class.
      * @param output The string to output.
      *
      * @see Task#handleErrorOutput(String)
      * @since Ant 1.5
      */
     public void handleErrorOutput(String output) {
         if (callee != null) {
             callee.handleErrorOutput(output);
         } else {
             super.handleErrorOutput(output);
         }
     }
 
     /**
      * Handle error output.
      * Send it the the new project if is present, otherwise
      * call the super class.
      * @param output The string to output.
      * @see Task#handleErrorFlush(String)
      * @since Ant 1.5.2
      */
     public void handleErrorFlush(String output) {
         if (callee != null) {
             callee.handleErrorFlush(output);
         } else {
             super.handleErrorFlush(output);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Componentdef.java b/src/main/org/apache/tools/ant/taskdefs/Componentdef.java
index 9352462a0..275c9f0d7 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Componentdef.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Componentdef.java
@@ -1,41 +1,41 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 /**
- * Adds a compenent definition to the current project.
+ * Adds a component definition to the current project.
  * used in the current project. Two attributes are needed, the name that identifies
- * this compenent uniquely, and the full name of the class (
+ * this component uniquely, and the full name of the class (
  * including the packages) that
  * implements this component.</p>
  * @since Ant 1.8
  * @ant.task category="internal"
  */
 public class Componentdef extends Definer {
 
     /**
      * Default constructor.
      * Creates a new ComponentDef instance.
      * Sets the restrict attribute to true.
      */
 
     public Componentdef() {
         setRestrict(true);
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/CopyPath.java b/src/main/org/apache/tools/ant/taskdefs/CopyPath.java
index 1e4ce9fee..5670215dc 100644
--- a/src/main/org/apache/tools/ant/taskdefs/CopyPath.java
+++ b/src/main/org/apache/tools/ant/taskdefs/CopyPath.java
@@ -1,214 +1,214 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Reference;
 
 import java.io.File;
 import java.io.IOException;
 
 /**
  * Copy the contents of a path to a destination, using the mapper of choice
  *
  * @since Ant 1.7.0
  *
  * @ant.task category="filesystem"
  * @deprecated this task should have never been released and was
  * obsoleted by ResourceCollection support in Copy available since Ant
  * 1.7.0.  Don't use it.
  */
 
 public class CopyPath extends Task {
 
     // Error messages
     /** No destdir attribute */
     public static final String ERROR_NO_DESTDIR = "No destDir specified";
 
     /** No path  */
     public static final String ERROR_NO_PATH = "No path specified";
 
     /** No mapper  */
     public static final String ERROR_NO_MAPPER = "No mapper specified";
 
     // fileutils
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     // --- Fields --
     private FileNameMapper mapper;
 
     private Path path;
 
     private File destDir;
 
     // TODO not read, yet in a public setter
     private long granularity = FILE_UTILS.getFileTimestampGranularity();
 
     private boolean preserveLastModified = false;
 
     /**
      * The dest dir attribute.
      * @param destDir the value of the destdir attribute.
      */
     public void setDestDir(File destDir) {
         this.destDir = destDir;
     }
 
     /**
      * add a mapper
      *
      * @param newmapper the mapper to add.
      */
     public void add(FileNameMapper newmapper) {
         if (mapper != null) {
             throw new BuildException("Only one mapper allowed");
         }
         mapper = newmapper;
     }
 
     /**
      * Set the path to be used when running the Java class.
      *
      * @param s
      *            an Ant Path object containing the path.
      */
     public void setPath(Path s) {
         createPath().append(s);
     }
 
     /**
      * Set the path to use by reference.
      *
      * @param r
      *            a reference to an existing path.
      */
     public void setPathRef(Reference r) {
         createPath().setRefid(r);
     }
 
     /**
      * Create a path.
      *
      * @return a path to be configured.
      */
     public Path createPath() {
         if (path == null) {
             path = new Path(getProject());
         }
         return path;
     }
 
     /**
      * Set the number of milliseconds leeway to give before deciding a
      * target is out of date.
      * TODO: This is not yet used.
      * @param granularity the granularity used to decide if a target is out of
      *                    date.
      */
     public void setGranularity(long granularity) {
         this.granularity = granularity;
     }
 
     /**
      * Give the copied files the same last modified time as the original files.
      * @param preserveLastModified if true preserve the modified time;
      *                             default is false.
      */
     public void setPreserveLastModified(boolean preserveLastModified) {
         this.preserveLastModified = preserveLastModified;
     }
 
     /**
      * Ensure we have a consistent and legal set of attributes, and set any
      * internal flags necessary based on different combinations of attributes.
      *
      * @throws BuildException
      *             if an error occurs.
      */
     protected void validateAttributes() throws BuildException {
         if (destDir == null) {
             throw new BuildException(ERROR_NO_DESTDIR);
         }
         if (mapper == null) {
             throw new BuildException(ERROR_NO_MAPPER);
         }
         if (path == null) {
             throw new BuildException(ERROR_NO_PATH);
         }
     }
 
     /**
-     * This is a very minimal derivative of the nomal copy logic.
+     * This is a very minimal derivative of the normal copy logic.
      *
      * @throws BuildException
      *             if something goes wrong with the build.
      */
     public void execute() throws BuildException {
         log("This task should have never been released and was"
             + " obsoleted by ResourceCollection support in <copy> available"
             + " since Ant 1.7.0.  Don't use it.",
             Project.MSG_ERR);
 
         validateAttributes();
         String[] sourceFiles = path.list();
         if (sourceFiles.length == 0) {
             log("Path is empty", Project.MSG_VERBOSE);
             return;
         }
 
         for (int sources = 0; sources < sourceFiles.length; sources++) {
 
             String sourceFileName = sourceFiles[sources];
             File sourceFile = new File(sourceFileName);
             String[] toFiles = (String[]) mapper.mapFileName(sourceFileName);
 
             for (int i = 0; i < toFiles.length; i++) {
                 String destFileName = toFiles[i];
                 File destFile = new File(destDir, destFileName);
 
                 if (sourceFile.equals(destFile)) {
                     log("Skipping self-copy of " + sourceFileName, Project.MSG_VERBOSE);
                     continue;
                 }
                 if (sourceFile.isDirectory()) {
                     log("Skipping directory " + sourceFileName);
                     continue;
                 }
                 try {
                     log("Copying " + sourceFile + " to " + destFile, Project.MSG_VERBOSE);
 
                     FILE_UTILS.copyFile(sourceFile, destFile, null, null, false,
                             preserveLastModified, null, null, getProject());
                 } catch (IOException ioe) {
                     String msg = "Failed to copy " + sourceFile + " to " + destFile + " due to "
                             + ioe.getMessage();
                     if (destFile.exists() && !destFile.delete()) {
                         msg += " and I couldn't delete the corrupt " + destFile;
                     }
                     throw new BuildException(msg, ioe, getLocation());
                 }
             }
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Definer.java b/src/main/org/apache/tools/ant/taskdefs/Definer.java
index e5ba9f85c..09bd5ea1f 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Definer.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Definer.java
@@ -1,654 +1,654 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Properties;
 
 import org.apache.tools.ant.AntTypeDefinition;
 import org.apache.tools.ant.ComponentHelper;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectHelper;
 import org.apache.tools.ant.MagicNames;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 
 /**
  * Base class for Taskdef and Typedef - handles all
  * the attributes for Typedef. The uri and class
  * handling is handled by DefBase
  *
  * @since Ant 1.4
  */
 public abstract class Definer extends DefBase {
 
     /**
      * the extension of an antlib file for autoloading.
      * {@value[
      */
     private static final String ANTLIB_XML = "/antlib.xml";
 
     private static class ResourceStack extends ThreadLocal {
         public Object initialValue() {
             return new HashMap();
         }
         Map getStack() {
             return (Map) get();
         }
     }
     private static ResourceStack resourceStack = new ResourceStack();
     private String name;
     private String classname;
     private File file;
     private String resource;
     private boolean restrict = false;
 
     private   int    format = Format.PROPERTIES;
     private   boolean definerSet = false;
     private   int         onError = OnError.FAIL;
     private   String      adapter;
     private   String      adaptTo;
 
     private   Class       adapterClass;
     private   Class       adaptToClass;
 
     /**
      * Enumerated type for onError attribute
      *
      * @see EnumeratedAttribute
      */
     public static class OnError extends EnumeratedAttribute {
         /** Enumerated values */
         public static final int  FAIL = 0, REPORT = 1, IGNORE = 2, FAIL_ALL = 3;
 
         /**
          * text value of onerror option {@value}
          */
         public static final String POLICY_FAIL = "fail";
         /**
          * text value of onerror option {@value}
          */
         public static final String POLICY_REPORT = "report";
         /**
          * text value of onerror option {@value}
          */
         public static final String POLICY_IGNORE = "ignore";
         /**
          * text value of onerror option {@value}
          */
         public static final String POLICY_FAILALL = "failall";
 
         /**
          * Constructor
          */
         public OnError() {
             super();
         }
 
         /**
          * Constructor using a string.
          * @param value the value of the attribute
          */
         public OnError(String value) {
             setValue(value);
         }
 
         /**
          * get the values
          * @return an array of the allowed values for this attribute.
          */
         public String[] getValues() {
             return new String[] {POLICY_FAIL, POLICY_REPORT, POLICY_IGNORE, POLICY_FAILALL};
         }
     }
 
     /**
      * Enumerated type for format attribute
      *
      * @see EnumeratedAttribute
      */
     public static class Format extends EnumeratedAttribute {
         /** Enumerated values */
         public static final int PROPERTIES = 0, XML = 1;
 
         /**
          * get the values
          * @return an array of the allowed values for this attribute.
          */
         public String[] getValues() {
             return new String[] {"properties", "xml"};
         }
     }
 
     /**
      * The restrict attribute.
      * If this is true, only use this definition in add(X).
      * @param restrict the value to set.
      */
      protected void setRestrict(boolean restrict) {
          this.restrict = restrict;
      }
 
 
     /**
      * What to do if there is an error in loading the class.
      * <dl>
      *   <li>error - throw build exception</li>
      *   <li>report - output at warning level</li>
      *   <li>ignore - output at debug level</li>
      * </dl>
      *
      * @param onError an <code>OnError</code> value
      */
     public void setOnError(OnError onError) {
         this.onError = onError.getIndex();
     }
 
     /**
      * Sets the format of the file or resource
      * @param format the enumerated value - xml or properties
      */
     public void setFormat(Format format) {
         this.format = format.getIndex();
     }
 
     /**
      * @return the name for this definition
      */
     public String getName() {
         return name;
     }
 
     /**
      * @return the file containing definitions
      */
     public File getFile() {
         return file;
     }
 
     /**
      * @return the resource containing definitions
      */
     public String getResource() {
         return resource;
     }
 
 
     /**
      * Run the definition.
      *
      * @exception BuildException if an error occurs
      */
     public void execute() throws BuildException {
         ClassLoader al = createLoader();
 
         if (!definerSet) {
             //we arent fully defined yet. this is an error unless
             //we are in an antlib, in which case the resource name is determined
             //automatically.
             //NB: URIs in the ant core package will be "" at this point.
             if (getURI() == null) {
                 throw new BuildException(
                         "name, file or resource attribute of "
                                 + getTaskName() + " is undefined",
                         getLocation());
             }
 
             if (getURI().startsWith(MagicNames.ANTLIB_PREFIX)) {
                 //convert the URI to a resource
                 String uri1 = getURI();
                 setResource(makeResourceFromURI(uri1));
             } else {
                 throw new BuildException(
                         "Only antlib URIs can be located from the URI alone,"
                                 + "not the URI " + getURI());
             }
         }
 
         if (name != null) {
             if (classname == null) {
                 throw new BuildException(
                     "classname attribute of " + getTaskName() + " element "
                     + "is undefined", getLocation());
             }
             addDefinition(al, name, classname);
         } else {
             if (classname != null) {
                 String msg = "You must not specify classname "
                     + "together with file or resource.";
                 throw new BuildException(msg, getLocation());
             }
             Enumeration/*<URL>*/ urls = null;
             if (file != null) {
                 final URL url = fileToURL();
                 if (url == null) {
                     return;
                 }
                 urls = new Enumeration() {
                     private boolean more = true;
                     public boolean hasMoreElements() {
                         return more;
                     }
                     public Object nextElement() throws NoSuchElementException {
                         if (more) {
                             more = false;
                             return url;
                         } else {
                             throw new NoSuchElementException();
                         }
                     }
                 };
             } else {
                 urls = resourceToURLs(al);
             }
 
             while (urls.hasMoreElements()) {
                 URL url = (URL) urls.nextElement();
 
                 int fmt = this.format;
                 if (url.toString().toLowerCase(Locale.ENGLISH).endsWith(".xml")) {
                     fmt = Format.XML;
                 }
 
                 if (fmt == Format.PROPERTIES) {
                     loadProperties(al, url);
                     break;
                 } else {
                     if (resourceStack.getStack().get(url) != null) {
                         log("Warning: Recursive loading of " + url
                             + " ignored"
                             + " at " + getLocation()
                             + " originally loaded at "
                             + resourceStack.getStack().get(url),
                             Project.MSG_WARN);
                     } else {
                         try {
                             resourceStack.getStack().put(url, getLocation());
                             loadAntlib(al, url);
                         } finally {
                             resourceStack.getStack().remove(url);
                         }
                     }
                 }
             }
         }
     }
 
     /**
      * This is where the logic to map from a URI to an antlib resource
      * is kept.
      * @param uri the xml namespace uri that to convert.
      * @return the name of a resource. It may not exist
      */
 
     public static String makeResourceFromURI(String uri) {
         String path = uri.substring(MagicNames.ANTLIB_PREFIX.length());
         String resource;
         if (path.startsWith("//")) {
             //handle new style full paths to an antlib, in which
             //all but the forward slashes are allowed.
             resource = path.substring("//".length());
             if (!resource.endsWith(".xml")) {
                 //if we haven't already named an XML file, it gets antlib.xml
                 resource = resource + ANTLIB_XML;
             }
         } else {
             //convert from a package to a path
             resource = path.replace('.', '/') + ANTLIB_XML;
         }
         return resource;
     }
 
     /**
      * Convert a file to a file: URL.
      *
      * @return the URL, or null if it isn't valid and the active error policy
      * is not to raise a fault
      * @throws BuildException if the file is missing/not a file and the
      * policy requires failure at this point.
      */
     private URL fileToURL() {
         String message = null;
         if (!(file.exists())) {
             message = "File " + file + " does not exist";
         }
         if (message == null && !(file.isFile())) {
             message = "File " + file + " is not a file";
         }
         if (message == null) {
             try {
                 return FileUtils.getFileUtils().getFileURL(file);
             } catch (Exception ex) {
                 message =
                     "File " + file + " cannot use as URL: "
                     + ex.toString();
             }
         }
         // Here if there is an error
         switch (onError) {
             case OnError.FAIL_ALL:
                 throw new BuildException(message);
             case OnError.FAIL:
                 // Fall Through
             case OnError.REPORT:
                 log(message, Project.MSG_WARN);
                 break;
             case OnError.IGNORE:
                 // log at a lower level
                 log(message, Project.MSG_VERBOSE);
                 break;
             default:
                 // Ignore the problem
                 break;
         }
         return null;
     }
 
     private Enumeration/*<URL>*/ resourceToURLs(ClassLoader classLoader) {
         Enumeration ret;
         try {
             ret = classLoader.getResources(resource);
         } catch (IOException e) {
             throw new BuildException(
                 "Could not fetch resources named " + resource,
                 e, getLocation());
         }
         if (!ret.hasMoreElements()) {
             String message = "Could not load definitions from resource "
                 + resource + ". It could not be found.";
             switch (onError) {
                 case OnError.FAIL_ALL:
                     throw new BuildException(message);
                 case OnError.FAIL:
                 case OnError.REPORT:
                     log(message, Project.MSG_WARN);
                     break;
                 case OnError.IGNORE:
                     log(message, Project.MSG_VERBOSE);
                     break;
                 default:
                     // Ignore the problem
                     break;
             }
         }
         return ret;
     }
 
     /**
      * Load type definitions as properties from a URL.
      *
      * @param al the classloader to use
      * @param url the url to get the definitions from
      */
     protected void loadProperties(ClassLoader al, URL url) {
         InputStream is = null;
         try {
             is = url.openStream();
             if (is == null) {
                 log("Could not load definitions from " + url,
                     Project.MSG_WARN);
                 return;
             }
             Properties props = new Properties();
             props.load(is);
             Enumeration keys = props.keys();
             while (keys.hasMoreElements()) {
                 name = ((String) keys.nextElement());
                 classname = props.getProperty(name);
                 addDefinition(al, name, classname);
             }
         } catch (IOException ex) {
             throw new BuildException(ex, getLocation());
         } finally {
             FileUtils.close(is);
         }
     }
 
     /**
      * Load an antlib from a URL.
      *
      * @param classLoader the classloader to use.
      * @param url the url to load the definitions from.
      */
     private void loadAntlib(ClassLoader classLoader, URL url) {
         try {
             Antlib antlib = Antlib.createAntlib(getProject(), url, getURI());
             antlib.setClassLoader(classLoader);
             antlib.setURI(getURI());
             antlib.execute();
         } catch (BuildException ex) {
             throw ProjectHelper.addLocationToBuildException(
                 ex, getLocation());
         }
     }
 
     /**
      * Name of the property file  to load
      * ant name/classname pairs from.
      * @param file the file
      */
     public void setFile(File file) {
         if (definerSet) {
             tooManyDefinitions();
         }
         definerSet = true;
         this.file = file;
     }
 
     /**
      * Name of the property resource to load
      * ant name/classname pairs from.
      * @param res the resource to use
      */
     public void setResource(String res) {
         if (definerSet) {
             tooManyDefinitions();
         }
         definerSet = true;
         this.resource = res;
     }
 
     /**
      * Antlib attribute, sets resource and uri.
      * uri is set the antlib value and, resource is set
      * to the antlib.xml resource in the classpath.
      * For example antlib="antlib:org.acme.bland.cola"
      * corresponds to uri="antlib:org.acme.bland.cola"
      * resource="org/acme/bland/cola/antlib.xml".
      * ASF Bugzilla Bug 31999
      * @param antlib the value to set.
      */
     public void setAntlib(String antlib) {
         if (definerSet) {
             tooManyDefinitions();
         }
         if (!antlib.startsWith("antlib:")) {
             throw new BuildException(
                 "Invalid antlib attribute - it must start with antlib:");
         }
         setURI(antlib);
         this.resource = antlib.substring("antlib:".length()).replace('.', '/')
             + "/antlib.xml";
         definerSet = true;
     }
 
     /**
      * Name of the definition
      * @param name the name of the definition
      */
     public void setName(String name) {
         if (definerSet) {
             tooManyDefinitions();
         }
         definerSet = true;
         this.name = name;
     }
 
     /**
      * Returns the classname of the object we are defining.
      * May be <code>null</code>.
      * @return the class name
      */
     public String getClassname() {
         return classname;
     }
 
     /**
      * The full class name of the object being defined.
      * Required, unless file or resource have
      * been specified.
      * @param classname the name of the class
      */
     public void setClassname(String classname) {
         this.classname = classname;
     }
 
     /**
      * Set the class name of the adapter class.
      * An adapter class is used to proxy the
      * definition class. It is used if the
      * definition class is not assignable to
      * the adaptto class, or if the adaptto
      * class is not present.
      *
      * @param adapter the name of the adapter class
      */
 
     public void setAdapter(String adapter) {
         this.adapter = adapter;
     }
 
     /**
      * Set the adapter class.
      *
      * @param adapterClass the class to use to adapt the definition class
      */
     protected void setAdapterClass(Class adapterClass) {
         this.adapterClass = adapterClass;
     }
 
     /**
      * Set the classname of the class that the definition
      * must be compatible with, either directly or
      * by use of the adapter class.
      *
      * @param adaptTo the name of the adaptto class
      */
     public void setAdaptTo(String adaptTo) {
         this.adaptTo = adaptTo;
     }
 
     /**
      * Set the class for adaptToClass, to be
      * used by derived classes, used instead of
      * the adaptTo attribute.
      *
-     * @param adaptToClass the class for adapto.
+     * @param adaptToClass the class for adaptor.
      */
     protected void setAdaptToClass(Class adaptToClass) {
         this.adaptToClass = adaptToClass;
     }
 
 
     /**
      * Add a definition using the attributes of Definer
      *
      * @param al the ClassLoader to use
      * @param name the name of the definition
      * @param classname the classname of the definition
      * @exception BuildException if an error occurs
      */
     protected void addDefinition(ClassLoader al, String name, String classname)
         throws BuildException {
         Class cl = null;
         try {
             try {
                 name = ProjectHelper.genComponentName(getURI(), name);
 
                 if (onError != OnError.IGNORE) {
                     cl = Class.forName(classname, true, al);
                 }
 
                 if (adapter != null) {
                     adapterClass = Class.forName(adapter, true, al);
                 }
 
                 if (adaptTo != null) {
                     adaptToClass = Class.forName(adaptTo, true, al);
                 }
 
                 AntTypeDefinition def = new AntTypeDefinition();
                 def.setName(name);
                 def.setClassName(classname);
                 def.setClass(cl);
                 def.setAdapterClass(adapterClass);
                 def.setAdaptToClass(adaptToClass);
                 def.setRestrict(restrict);
                 def.setClassLoader(al);
                 if (cl != null) {
                     def.checkClass(getProject());
                 }
                 ComponentHelper.getComponentHelper(getProject())
                         .addDataTypeDefinition(def);
             } catch (ClassNotFoundException cnfe) {
                 String msg = getTaskName() + " class " + classname
                         + " cannot be found"
                         + "\n using the classloader " + al;
                 throw new BuildException(msg, cnfe, getLocation());
             } catch (NoClassDefFoundError ncdfe) {
                 String msg = getTaskName() + " A class needed by class "
                         + classname + " cannot be found: " + ncdfe.getMessage()
                         + "\n using the classloader " + al;
                 throw new BuildException(msg, ncdfe, getLocation());
             }
         } catch (BuildException ex) {
             switch (onError) {
                 case OnError.FAIL_ALL:
                 case OnError.FAIL:
                     throw ex;
                 case OnError.REPORT:
                     log(ex.getLocation() + "Warning: " + ex.getMessage(),
                         Project.MSG_WARN);
                     break;
                 default:
                     log(ex.getLocation() + ex.getMessage(),
                         Project.MSG_DEBUG);
             }
         }
     }
 
     /**
      * handle too many definitions by raising an exception.
      * @throws BuildException always.
      */
     private void tooManyDefinitions() {
         throw new BuildException(
             "Only one of the attributes name, file and resource"
             + " can be set", getLocation());
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Get.java b/src/main/org/apache/tools/ant/taskdefs/Get.java
index 858cb073f..dcd7cfb2b 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Get.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Get.java
@@ -1,804 +1,804 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.net.HttpURLConnection;
 import java.net.URL;
 import java.net.URLConnection;
 import java.util.Date;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.resources.Resources;
 import org.apache.tools.ant.types.resources.URLProvider;
 import org.apache.tools.ant.types.resources.URLResource;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * Gets a particular file from a URL source.
  * Options include verbose reporting, timestamp based fetches and controlling
  * actions on failures. NB: access through a firewall only works if the whole
  * Java runtime is correctly configured.
  *
  * @since Ant 1.1
  *
  * @ant.task category="network"
  */
 public class Get extends Task {
     private static final int NUMBER_RETRIES = 3;
     private static final int DOTS_PER_LINE = 50;
     private static final int BIG_BUFFER_SIZE = 100 * 1024;
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
     private static final int REDIRECT_LIMIT = 25;
 
     private static final String HTTP = "http";
     private static final String HTTPS = "https";
 
     private Resources sources = new Resources();
     private File destination; // required
     private boolean verbose = false;
     private boolean useTimestamp = false; //off by default
     private boolean ignoreErrors = false;
     private String uname = null;
     private String pword = null;
     private long maxTime = 0;
     private int numberRetries = NUMBER_RETRIES;
     private boolean skipExisting = false;
     private boolean httpUseCaches = true; // on by default
     private Mapper mapperElement = null;
 
     /**
      * Does the work.
      *
      * @exception BuildException Thrown in unrecoverable error.
      */
     public void execute() throws BuildException {
         checkAttributes();
 
         for (Resource r : sources) {
             URLProvider up = r.as(URLProvider.class);
             URL source = up.getURL();
 
             File dest = destination;
             if (destination.isDirectory()) {
                 if (mapperElement == null) {
                     String path = source.getPath();
                     if (path.endsWith("/")) {
                         path = path.substring(0, path.length() - 1);
                     }
                     int slash = path.lastIndexOf("/");
                     if (slash > -1) {
                         path = path.substring(slash + 1);
                     }
                     dest = new File(destination, path);
                 } else {
                     FileNameMapper mapper = mapperElement.getImplementation();
                     String[] d = mapper.mapFileName(source.toString());
                     if (d == null) {
                         log("skipping " + r + " - mapper can't handle it",
                             Project.MSG_WARN);
                         continue;
                     } else if (d.length == 0) {
                         log("skipping " + r + " - mapper returns no file name",
                             Project.MSG_WARN);
                         continue;
                     } else if (d.length > 1) {
                         log("skipping " + r + " - mapper returns multiple file"
                             + " names", Project.MSG_WARN);
                         continue;
                     }
                     dest = new File(destination, d[0]);
                 }
             }
 
         //set up logging
         int logLevel = Project.MSG_INFO;
         DownloadProgress progress = null;
         if (verbose) {
             progress = new VerboseProgress(System.out);
         }
 
         //execute the get
         try {
             doGet(source, dest, logLevel, progress);
         } catch (IOException ioe) {
             log("Error getting " + source + " to " + dest);
             if (!ignoreErrors) {
                 throw new BuildException(ioe, getLocation());
             }
         }
         }
     }
 
     /**
      * make a get request, with the supplied progress and logging info.
      * All the other config parameters are set at the task level,
      * source, dest, ignoreErrors, etc.
      * @param logLevel level to log at, see {@link Project#log(String, int)}
      * @param progress progress callback; null for no-callbacks
      * @return true for a successful download, false otherwise.
      * The return value is only relevant when {@link #ignoreErrors} is true, as
      * when false all failures raise BuildExceptions.
      * @throws IOException for network trouble
      * @throws BuildException for argument errors, or other trouble when ignoreErrors
      * is false.
      * @deprecated only gets the first configured resource
      */
     public boolean doGet(int logLevel, DownloadProgress progress)
             throws IOException {
         checkAttributes();
         for (Resource r : sources) {
             URLProvider up = r.as(URLProvider.class);
             URL source = up.getURL();
             return doGet(source, destination, logLevel, progress);
         }
         /*NOTREACHED*/
         return false;
     }
 
     /**
      * make a get request, with the supplied progress and logging info.
      *
      * All the other config parameters like ignoreErrors are set at
      * the task level.
      * @param source the URL to get
      * @param dest the target file
      * @param logLevel level to log at, see {@link Project#log(String, int)}
      * @param progress progress callback; null for no-callbacks
      * @return true for a successful download, false otherwise.
      * The return value is only relevant when {@link #ignoreErrors} is true, as
      * when false all failures raise BuildExceptions.
      * @throws IOException for network trouble
      * @throws BuildException for argument errors, or other trouble when ignoreErrors
      * is false.
      * @since Ant 1.8.0
      */
     public boolean doGet(URL source, File dest, int logLevel,
                          DownloadProgress progress)
         throws IOException {
 
         if (dest.exists() && skipExisting) {
             log("Destination already exists (skipping): "
                 + dest.getAbsolutePath(), logLevel);
             return true;
         }
 
         //dont do any progress, unless asked
         if (progress == null) {
             progress = new NullProgress();
         }
         log("Getting: " + source, logLevel);
         log("To: " + dest.getAbsolutePath(), logLevel);
 
         //set the timestamp to the file date.
         long timestamp = 0;
 
         boolean hasTimestamp = false;
         if (useTimestamp && dest.exists()) {
             timestamp = dest.lastModified();
             if (verbose) {
                 Date t = new Date(timestamp);
                 log("local file date : " + t.toString(), logLevel);
             }
             hasTimestamp = true;
         }
 
         GetThread getThread = new GetThread(source, dest,
                                             hasTimestamp, timestamp, progress,
                                             logLevel);
         getThread.setDaemon(true);
         getProject().registerThreadTask(getThread, this);
         getThread.start();
         try {
             getThread.join(maxTime * 1000);
         } catch (InterruptedException ie) {
             log("interrupted waiting for GET to finish",
                 Project.MSG_VERBOSE);
         }
 
         if (getThread.isAlive()) {
             String msg = "The GET operation took longer than " + maxTime
                 + " seconds, stopping it.";
             if (ignoreErrors) {
                 log(msg);
             }
             getThread.closeStreams();
             if (!ignoreErrors) {
                 throw new BuildException(msg);
             }
             return false;
         }
 
         return getThread.wasSuccessful();
     }
 
     /**
      * Check the attributes.
      */
     private void checkAttributes() {
         if (sources.size() == 0) {
             throw new BuildException("at least one source is required",
                                      getLocation());
         }
         for (Resource r : sources) {
             URLProvider up = r.as(URLProvider.class);
             if (up == null) {
                 throw new BuildException("Only URLProvider resources are"
                                          + " supported", getLocation());
             }
         }
 
         if (destination == null) {
             throw new BuildException("dest attribute is required", getLocation());
         }
 
         if (destination.exists() && sources.size() > 1
             && !destination.isDirectory()) {
             throw new BuildException("The specified destination is not a"
                                      + " directory",
                                      getLocation());
         }
 
         if (destination.exists() && !destination.canWrite()) {
             throw new BuildException("Can't write to "
                                      + destination.getAbsolutePath(),
                                      getLocation());
         }
 
         if (sources.size() > 1 && !destination.exists()) {
             destination.mkdirs();
         }
     }
 
     /**
      * Set an URL to get.
      *
      * @param u URL for the file.
      */
     public void setSrc(URL u) {
         add(new URLResource(u));
     }
 
     /**
      * Adds URLs to get.
      * @since Ant 1.8.0
      */
     public void add(ResourceCollection rc) {
         sources.add(rc);
     }
 
     /**
      * Where to copy the source file.
      *
      * @param dest Path to file.
      */
     public void setDest(File dest) {
         this.destination = dest;
     }
 
     /**
      * If true, show verbose progress information.
      *
      * @param v if "true" then be verbose
      */
     public void setVerbose(boolean v) {
         verbose = v;
     }
 
     /**
      * If true, log errors but do not treat as fatal.
      *
      * @param v if "true" then don't report download errors up to ant
      */
     public void setIgnoreErrors(boolean v) {
         ignoreErrors = v;
     }
 
     /**
      * If true, conditionally download a file based on the timestamp
      * of the local copy.
      *
      * <p>In this situation, the if-modified-since header is set so
      * that the file is only fetched if it is newer than the local
      * file (or there is no local file) This flag is only valid on
      * HTTP connections, it is ignored in other cases.  When the flag
      * is set, the local copy of the downloaded file will also have
      * its timestamp set to the remote file time.</p>
      *
      * <p>Note that remote files of date 1/1/1970 (GMT) are treated as
      * 'no timestamp', and web servers often serve files with a
      * timestamp in the future by replacing their timestamp with that
      * of the current time. Also, inter-computer clock differences can
      * cause no end of grief.</p>
      * @param v "true" to enable file time fetching
      */
     public void setUseTimestamp(boolean v) {
         useTimestamp = v;
     }
 
 
     /**
      * Username for basic auth.
      *
      * @param u username for authentication
      */
     public void setUsername(String u) {
         this.uname = u;
     }
 
     /**
      * password for the basic authentication.
      *
      * @param p password for authentication
      */
     public void setPassword(String p) {
         this.pword = p;
     }
 
     /**
      * The time in seconds the download is allowed to take before
      * being terminated.
      *
      * @since Ant 1.8.0
      */
     public void setMaxTime(long maxTime) {
         this.maxTime = maxTime;
     }
 
     /**
      * The number of retries to attempt upon error, defaults to 3.
      *
      * @param r retry count
      *
      * @since Ant 1.8.0
      */
     public void setRetries(int r) {
         this.numberRetries = r;
     }
 
     /**
      * Skip files that already exist locally.
      *
      * @param s "true" to skip existing destination files
      *
      * @since Ant 1.8.0
      */
     public void setSkipExisting(boolean s) {
         this.skipExisting = s;
     }
 
     /**
      * HTTP connections only - control caching on the
      * HttpUrlConnection: httpConnection.setUseCaches(); if false, do
      * not allow caching on the HttpUrlConnection.
      *
      * <p>Defaults to true (allow caching, which is also the
      * HttpUrlConnection default value.</p>
      *
      * @since Ant 1.8.0
      */
     public void setHttpUseCaches(boolean httpUseCache) {
         this.httpUseCaches = httpUseCache;
     }
 
     /**
      * Define the mapper to map source to destination files.
      * @return a mapper to be configured.
      * @exception BuildException if more than one mapper is defined.
      * @since Ant 1.8.0
      */
     public Mapper createMapper() throws BuildException {
         if (mapperElement != null) {
             throw new BuildException("Cannot define more than one mapper",
                                      getLocation());
         }
         mapperElement = new Mapper(getProject());
         return mapperElement;
     }
 
     /**
      * Add a nested filenamemapper.
      * @param fileNameMapper the mapper to add.
      * @since Ant 1.8.0
      */
     public void add(FileNameMapper fileNameMapper) {
         createMapper().add(fileNameMapper);
     }
 
     /**
      * Provide this for Backward Compatibility.
      */
     protected static class Base64Converter
         extends org.apache.tools.ant.util.Base64Converter {
     }
 
     /**
      * Interface implemented for reporting
-     * progess of downloading.
+     * progress of downloading.
      */
     public interface DownloadProgress {
         /**
          * begin a download
          */
         void beginDownload();
 
         /**
          * tick handler
          *
          */
         void onTick();
 
         /**
          * end a download
          */
         void endDownload();
     }
 
     /**
      * do nothing with progress info
      */
     public static class NullProgress implements DownloadProgress {
 
         /**
          * begin a download
          */
         public void beginDownload() {
 
         }
 
         /**
          * tick handler
          *
          */
         public void onTick() {
         }
 
         /**
          * end a download
          */
         public void endDownload() {
 
         }
     }
 
     /**
      * verbose progress system prints to some output stream
      */
     public static class VerboseProgress implements DownloadProgress  {
         private int dots = 0;
         // CheckStyle:VisibilityModifier OFF - bc
         PrintStream out;
         // CheckStyle:VisibilityModifier ON
 
         /**
          * Construct a verbose progress reporter.
          * @param out the output stream.
          */
         public VerboseProgress(PrintStream out) {
             this.out = out;
         }
 
         /**
          * begin a download
          */
         public void beginDownload() {
             dots = 0;
         }
 
         /**
          * tick handler
          *
          */
         public void onTick() {
             out.print(".");
             if (dots++ > DOTS_PER_LINE) {
                 out.flush();
                 dots = 0;
             }
         }
 
         /**
          * end a download
          */
         public void endDownload() {
             out.println();
             out.flush();
         }
     }
 
     private class GetThread extends Thread {
 
         private final URL source;
         private final File dest;
         private final boolean hasTimestamp;
         private final long timestamp;
         private final DownloadProgress progress;
         private final int logLevel;
 
         private boolean success = false;
         private IOException ioexception = null;
         private BuildException exception = null;
         private InputStream is = null;
         private OutputStream os = null;
         private URLConnection connection;
         private int redirections = 0;
 
         GetThread(URL source, File dest,
                   boolean h, long t, DownloadProgress p, int l) {
             this.source = source;
             this.dest = dest;
             hasTimestamp = h;
             timestamp = t;
             progress = p;
             logLevel = l;
         }
 
         public void run() {
             try {
                 success = get();
             } catch (IOException ioex) {
                 ioexception = ioex;
             } catch (BuildException bex) {
                 exception = bex;
             }
         }
 
         private boolean get() throws IOException, BuildException {
 
             connection = openConnection(source);
 
             if (connection == null)
             {
                 return false;
             }
 
             boolean downloadSucceeded = downloadFile();
 
             //if (and only if) the use file time option is set, then
             //the saved file now has its timestamp set to that of the
             //downloaded file
             if (downloadSucceeded && useTimestamp)  {
                 updateTimeStamp();
             }
 
             return downloadSucceeded;
         }
 
 
         private boolean redirectionAllowed(URL aSource, URL aDest) {
             if (!(aSource.getProtocol().equals(aDest.getProtocol()) || (HTTP
                     .equals(aSource.getProtocol()) && HTTPS.equals(aDest
                     .getProtocol())))) {
                 String message = "Redirection detected from "
                         + aSource.getProtocol() + " to " + aDest.getProtocol()
                         + ". Protocol switch unsafe, not allowed.";
                 if (ignoreErrors) {
                     log(message, logLevel);
                     return false;
                 } else {
                     throw new BuildException(message);
                 }
             }
 
             redirections++;
             if (redirections > REDIRECT_LIMIT) {
                 String message = "More than " + REDIRECT_LIMIT
                         + " times redirected, giving up";
                 if (ignoreErrors) {
                     log(message, logLevel);
                     return false;
                 } else {
                     throw new BuildException(message);
                 }
             }
 
 
             return true;
         }
 
         private URLConnection openConnection(URL aSource) throws IOException {
 
             // set up the URL connection
             URLConnection connection = aSource.openConnection();
             // modify the headers
             // NB: things like user authentication could go in here too.
             if (hasTimestamp) {
                 connection.setIfModifiedSince(timestamp);
             }
             // prepare Java 1.1 style credentials
             if (uname != null || pword != null) {
                 String up = uname + ":" + pword;
                 String encoding;
                 // we do not use the sun impl for portability,
                 // and always use our own implementation for consistent
                 // testing
                 Base64Converter encoder = new Base64Converter();
                 encoding = encoder.encode(up.getBytes());
                 connection.setRequestProperty("Authorization", "Basic "
                         + encoding);
             }
 
             if (connection instanceof HttpURLConnection) {
                 ((HttpURLConnection) connection)
                         .setInstanceFollowRedirects(false);
                 ((HttpURLConnection) connection)
                         .setUseCaches(httpUseCaches);
             }
             // connect to the remote site (may take some time)
             try {
                 connection.connect();
             } catch (NullPointerException e) {
                 //bad URLs can trigger NPEs in some JVMs
                 throw new BuildException("Failed to parse " + source.toString(), e);
             }
 
             // First check on a 301 / 302 (moved) response (HTTP only)
             if (connection instanceof HttpURLConnection) {
                 HttpURLConnection httpConnection = (HttpURLConnection) connection;
                 int responseCode = httpConnection.getResponseCode();
                 if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || 
                         responseCode == HttpURLConnection.HTTP_MOVED_TEMP ||
                         responseCode == HttpURLConnection.HTTP_SEE_OTHER)
                 {
                     String newLocation = httpConnection.getHeaderField("Location");
                     String message = aSource
                             + (responseCode == HttpURLConnection.HTTP_MOVED_PERM ? " permanently"
                                     : "") + " moved to " + newLocation;
                     log(message, logLevel);
                     URL newURL = new URL(aSource, newLocation);
                     if (!redirectionAllowed(aSource, newURL))
                     {
                         return null;
                     }
                     return openConnection(newURL);
                 }
                 // next test for a 304 result (HTTP only)
                 long lastModified = httpConnection.getLastModified();
                 if (responseCode == HttpURLConnection.HTTP_NOT_MODIFIED
                         || (lastModified != 0 && hasTimestamp && timestamp >= lastModified)) {
                     // not modified so no file download. just return
                     // instead and trace out something so the user
                     // doesn't think that the download happened when it
                     // didn't
                     log("Not modified - so not downloaded", logLevel);
                     return null;
                 }
                 // test for 401 result (HTTP only)
                 if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
                     String message = "HTTP Authorization failure";
                     if (ignoreErrors) {
                         log(message, logLevel);
                         return null;
                     } else {
                         throw new BuildException(message);
                     }
                 }
             }
 
             //REVISIT: at this point even non HTTP connections may
             //support the if-modified-since behaviour -we just check
             //the date of the content and skip the write if it is not
             //newer. Some protocols (FTP) don't include dates, of
             //course.
             return connection;
         }
 
         private boolean downloadFile()
                 throws FileNotFoundException, IOException {
             for (int i = 0; i < numberRetries; i++) {
                 // this three attempt trick is to get round quirks in different
                 // Java implementations. Some of them take a few goes to bind
                 // property; we ignore the first couple of such failures.
                 try {
                     is = connection.getInputStream();
                     break;
                 } catch (IOException ex) {
                     log("Error opening connection " + ex, logLevel);
                 }
             }
             if (is == null) {
                 log("Can't get " + source + " to " + dest, logLevel);
                 if (ignoreErrors) {
                     return false;
                 }
                 throw new BuildException("Can't get " + source + " to " + dest,
                         getLocation());
             }
 
             os = new FileOutputStream(dest);
             progress.beginDownload();
             boolean finished = false;
             try {
                 byte[] buffer = new byte[BIG_BUFFER_SIZE];
                 int length;
                 while (!isInterrupted() && (length = is.read(buffer)) >= 0) {
                     os.write(buffer, 0, length);
                     progress.onTick();
                 }
                 finished = !isInterrupted();
             } finally {
                 FileUtils.close(os);
                 FileUtils.close(is);
 
                 // we have started to (over)write dest, but failed.
                 // Try to delete the garbage we'd otherwise leave
                 // behind.
                 if (!finished) {
                     dest.delete();
                 }
             }
             progress.endDownload();
             return true;
         }
 
         private void updateTimeStamp() {
             long remoteTimestamp = connection.getLastModified();
             if (verbose)  {
                 Date t = new Date(remoteTimestamp);
                 log("last modified = " + t.toString()
                     + ((remoteTimestamp == 0)
                        ? " - using current time instead"
                        : ""), logLevel);
             }
             if (remoteTimestamp != 0) {
                 FILE_UTILS.setFileLastModified(dest, remoteTimestamp);
             }
         }
 
         /**
          * Has the download completed successfully?
          *
          * <p>Re-throws any exception caught during executaion.</p>
          */
         boolean wasSuccessful() throws IOException, BuildException {
             if (ioexception != null) {
                 throw ioexception;
             }
             if (exception != null) {
                 throw exception;
             }
             return success;
         }
 
         /**
          * Closes streams, interrupts the download, may delete the
          * output file.
          */
         void closeStreams() {
             interrupt();
             FileUtils.close(os);
             FileUtils.close(is);
             if (!success && dest.exists()) {
                 dest.delete();
             }
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/HostInfo.java b/src/main/org/apache/tools/ant/taskdefs/HostInfo.java
index 0a15de749..52476879f 100644
--- a/src/main/org/apache/tools/ant/taskdefs/HostInfo.java
+++ b/src/main/org/apache/tools/ant/taskdefs/HostInfo.java
@@ -1,263 +1,263 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.net.Inet4Address;
 import java.net.Inet6Address;
 import java.net.InetAddress;
 import java.net.NetworkInterface;
 import java.util.Arrays;
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 
 /**
  * Sets properties to the host provided, or localhost if no information is
  * provided. The default properties are NAME, FQDN, ADDR4, ADDR6;
  * 
  * @since Ant 1.8
  * @ant.task category="utility"
  */
 
 
 public class HostInfo extends Task {
     private static final String DEF_REM_ADDR6 = "::";
 
     private static final String DEF_REM_ADDR4 = "0.0.0.0";
 
     private static final String DEF_LOCAL_ADDR6 = "::1";
 
     private static final String DEF_LOCAL_ADDR4 = "127.0.0.1";
 
     private static final String DEF_LOCAL_NAME = "localhost";
     private static final String DEF_DOMAIN = "localdomain";
 
     private static final String DOMAIN = "DOMAIN";
 
     private static final String NAME = "NAME";
 
     private static final String ADDR4 = "ADDR4";
 
     private static final String ADDR6 = "ADDR6";
 
     private String prefix = "";
 
     private String host;
 
     private InetAddress nameAddr;
 
     private InetAddress best6;
 
     private InetAddress best4;
 
     private List inetAddrs;
 
     /**
      * Set a prefix for the properties. If the prefix does not end with a "."
      * one is automatically added.
      * 
      * @param aPrefix
      *            the prefix to use.
      * @since Ant 1.8
      */
     public void setPrefix(String aPrefix) {
         prefix = aPrefix;
         if (!prefix.endsWith(".")) {
             prefix += ".";
         }
     }
 
     /**
      * Set the host to be retrieved.
      * 
      * @param aHost
      *            the name or the address of the host, data for the local host
-     *            will be retrieved if ommited.
+     *            will be retrieved if omitted.
      * @since Ant 1.8
      */
     public void setHost(String aHost) {
         host = aHost;
     }
 
     /**
      * set the properties.
      * 
      * @throws BuildException
      *             on error.
      */
     public void execute() throws BuildException {
         if (host == null || "".equals(host)) {
             executeLocal();
         } else {
             executeRemote();
         }
     }
 
     private void executeLocal() {
         try {
             Enumeration interfaces = NetworkInterface.getNetworkInterfaces();
             inetAddrs = new LinkedList();
             while (interfaces.hasMoreElements()) {
                 NetworkInterface currentif = (NetworkInterface) interfaces
                         .nextElement();
                 Enumeration addrs = currentif.getInetAddresses();
                 while (addrs.hasMoreElements())
                 {
                     inetAddrs.add(addrs.nextElement());
                 }
             }
             selectAddresses();
 
             if (nameAddr != null && hasHostName(nameAddr)) {
                 setDomainAndName(nameAddr.getCanonicalHostName());
             } else {
                 setProperty(DOMAIN, DEF_DOMAIN);
                 setProperty(NAME, DEF_LOCAL_NAME);
             }
             if (best4 != null) {
                 setProperty(ADDR4, best4.getHostAddress());
             } else {
                 setProperty(ADDR4, DEF_LOCAL_ADDR4);
             }
             if (best6 != null) {
                 setProperty(ADDR6, best6.getHostAddress());
             } else {
                 setProperty(ADDR6, DEF_LOCAL_ADDR6);
             }
         } catch (Exception e) {
             log("Error retrieving local host information", e, Project.MSG_WARN);
             setProperty(DOMAIN, DEF_DOMAIN);
             setProperty(NAME, DEF_LOCAL_NAME);
             setProperty(ADDR4, DEF_LOCAL_ADDR4);
             setProperty(ADDR6, DEF_LOCAL_ADDR6);
         }
     }
     
     private boolean hasHostName(InetAddress addr)
     {   
         return !addr.getHostAddress().equals(addr.getCanonicalHostName());
     }
 
     private void selectAddresses() {
         Iterator i = inetAddrs.iterator();
         while (i.hasNext()) {
             InetAddress current = (InetAddress) i.next();
             if (!current.isMulticastAddress()) {
                 if (current instanceof Inet4Address) {
                     best4 = selectBestAddress(best4, current);
                 } else if (current instanceof Inet6Address) {
                     best6 = selectBestAddress(best6, current);
                 }
             }
         }
         
         nameAddr = selectBestAddress(best4, best6);
     }
 
     private InetAddress selectBestAddress(InetAddress bestSoFar,
             InetAddress current) {
         InetAddress best = bestSoFar;
         if (best == null) {
             // none selected so far, so this one is better.
             best = current;
         } else {
             if (current == null || current.isLoopbackAddress()) {
                 // definitely not better than the previously selected address.
             } else if (current.isLinkLocalAddress()) {
                 // link local considered better than loopback
                 if (best.isLoopbackAddress()) {
                     best = current;
                 }
             } else if (current.isSiteLocalAddress()) {
                 // site local considered better than link local (and loopback)
                 // address with hostname resolved considered better than
                 // address without hostname
                 if (best.isLoopbackAddress()
                         || best.isLinkLocalAddress()
                         || (best.isSiteLocalAddress() && !hasHostName(best))) {
                     best = current;
                 }
             } else {
                 // current is a "Global address", considered better than 
                 // site local (and better than link local, loopback)
                 // address with hostname resolved considered better than
                 // address without hostname
                 if (best.isLoopbackAddress()
                         || best.isLinkLocalAddress()
                         || best.isSiteLocalAddress()
                         || !hasHostName(best)) {
                     best = current;
                 }
             }
         }
         return best;
     }
 
     private void executeRemote() {
         try {
             inetAddrs = Arrays.asList(InetAddress.getAllByName(host));
 
             selectAddresses();
 
             if (nameAddr != null && hasHostName(nameAddr)) {
                 setDomainAndName(nameAddr.getCanonicalHostName());
             } else {
                 setDomainAndName(host);
             }
             if (best4 != null) {
                 setProperty(ADDR4, best4.getHostAddress());
             } else {
                 setProperty(ADDR4, DEF_REM_ADDR4);
             }
             if (best6 != null) {
                 setProperty(ADDR6, best6.getHostAddress());
             } else {
                 setProperty(ADDR6, DEF_REM_ADDR6);
             }
         } catch (Exception e) {
             log("Error retrieving remote host information for host:" + host
                     + ".", e, Project.MSG_WARN);
             setDomainAndName(host);
             setProperty(ADDR4, DEF_REM_ADDR4);
             setProperty(ADDR6, DEF_REM_ADDR6);
         }
     }
 
     private void setDomainAndName(String fqdn)
     {
         int idx = fqdn.indexOf('.');
         if (idx > 0) {
             setProperty(NAME, fqdn.substring(0, idx));
             setProperty(DOMAIN, fqdn.substring(idx+1));
         } else {
             setProperty(NAME, fqdn);
             setProperty(DOMAIN, DEF_DOMAIN);
         }
     }
 
     private void setProperty(String name, String value) {
         getProject().setNewProperty(prefix + name, value);
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/JDBCTask.java b/src/main/org/apache/tools/ant/taskdefs/JDBCTask.java
index c0275a7cc..e60dc2559 100644
--- a/src/main/org/apache/tools/ant/taskdefs/JDBCTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/JDBCTask.java
@@ -1,529 +1,529 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.Driver;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Properties;
 
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Reference;
 
 /**
  * Handles JDBC configuration needed by SQL type tasks.
  * <p>
  * The following example class prints the contents of the first column of each row in TableName.
  *</p>
  *<code><pre>
 package examples;
 import java.sql.Connection;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.JDBCTask;
 
 public class SQLExampleTask extends JDBCTask {
 
     private String tableName;
 
     public void execute() throws BuildException {
         Connection conn = getConnection();
         Statement stmt=null;
         try {
             if (tableName == null) {
                 throw new BuildException("TableName must be specified",location);
             }
             String sql = "SELECT * FROM "+tableName;
             stmt= conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql);
             while (rs.next()) {
                 log(rs.getObject(1).toString());
             }
         } catch (SQLException e) {
 
         } finally {
             if (stmt != null) {
-                try {stmt.close();}catch (SQLException ingore) {}
+                try {stmt.close();}catch (SQLException ignore) {}
             }
             if (conn != null) {
-                try {conn.close();}catch (SQLException ingore) {}
+                try {conn.close();}catch (SQLException ignore) {}
             }
         }
     }
     public void setTableName(String tableName) {
         this.tableName = tableName;
     }
 
 }
 
 
 </pre></code>
 
 
 
  * @since Ant 1.5
  *
  */
 
 public abstract class JDBCTask extends Task {
     private static final int HASH_TABLE_SIZE = 3;
 
     /**
      * Used for caching loaders / driver. This is to avoid
      * getting an OutOfMemoryError when calling this task
      * multiple times in a row.
      */
     private static Hashtable loaderMap = new Hashtable(HASH_TABLE_SIZE);
 
     private boolean caching = true;
 
     private Path classpath;
 
     private AntClassLoader loader;
 
     /**
      * Autocommit flag. Default value is false
      */
     private boolean autocommit = false;
 
     /**
      * DB driver.
      */
     private String driver = null;
 
     /**
      * DB url.
      */
     private String url = null;
 
     /**
      * User name.
      */
     private String userId = null;
 
     /**
      * Password
      */
     private String password = null;
 
     /**
      * RDBMS Product needed for this SQL.
      **/
     private String rdbms = null;
 
     /**
      * RDBMS Version needed for this SQL.
      **/
     private String version = null;
 
     /**
      * whether the task fails when ant fails to connect to the database.
      * @since Ant 1.8.0
      */
     private boolean failOnConnectionError = true;
 
     /**
      * Additional properties to put into the JDBC connection string.
      *
      * @since Ant 1.8.0
      */
     private List/*<Property>*/ connectionProperties = new ArrayList();
 
     /**
      * Sets the classpath for loading the driver.
      * @param classpath The classpath to set
      */
     public void setClasspath(Path classpath) {
         this.classpath = classpath;
     }
 
     /**
      * Caching loaders / driver. This is to avoid
      * getting an OutOfMemoryError when calling this task
      * multiple times in a row; default: true
      * @param enable a <code>boolean</code> value
      */
     public void setCaching(boolean enable) {
         caching = enable;
     }
 
     /**
      * Add a path to the classpath for loading the driver.
      * @return a path to be configured
      */
     public Path createClasspath() {
         if (this.classpath == null) {
             this.classpath = new Path(getProject());
         }
         return this.classpath.createPath();
     }
 
     /**
      * Set the classpath for loading the driver
      * using the classpath reference.
      * @param r a reference to a classpath
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * Class name of the JDBC driver; required.
      * @param driver The driver to set
      */
     public void setDriver(String driver) {
         this.driver = driver.trim();
     }
 
     /**
      * Sets the database connection URL; required.
      * @param url The url to set
      */
     public void setUrl(String url) {
         this.url = url;
     }
 
     /**
      * Sets the password; required.
      * @param password The password to set
      */
     public void setPassword(String password) {
         this.password = password;
     }
 
     /**
      * Auto commit flag for database connection;
      * optional, default false.
      * @param autocommit The autocommit to set
      */
     public void setAutocommit(boolean autocommit) {
         this.autocommit = autocommit;
     }
 
     /**
      * Execute task only if the lower case product name
      * of the DB matches this
      * @param rdbms The rdbms to set
      */
     public void setRdbms(String rdbms) {
         this.rdbms = rdbms;
     }
 
     /**
      * Sets the version string, execute task only if
      * rdbms version match; optional.
      * @param version The version to set
      */
     public void setVersion(String version) {
         this.version = version;
     }
 
     /**
      * whether the task should cause the build to fail if it cannot
      * connect to the database.
      * @since Ant 1.8.0
      */
     public void setFailOnConnectionError(boolean b) {
         failOnConnectionError = b;
     }
 
     /**
      * Verify we are connected to the correct RDBMS
      * @param conn the jdbc connection
      * @return true if we are connected to the correct RDBMS
      */
     protected boolean isValidRdbms(Connection conn) {
         if (rdbms == null && version == null) {
             return true;
         }
 
         try {
             DatabaseMetaData dmd = conn.getMetaData();
 
             if (rdbms != null) {
                 String theVendor = dmd.getDatabaseProductName().toLowerCase();
 
                 log("RDBMS = " + theVendor, Project.MSG_VERBOSE);
                 if (theVendor == null || theVendor.indexOf(rdbms) < 0) {
                     log("Not the required RDBMS: " + rdbms, Project.MSG_VERBOSE);
                     return false;
                 }
             }
 
             if (version != null) {
                 String theVersion = dmd.getDatabaseProductVersion().toLowerCase(Locale.ENGLISH);
 
                 log("Version = " + theVersion, Project.MSG_VERBOSE);
                 if (theVersion == null
                         || !(theVersion.startsWith(version)
                         || theVersion.indexOf(" " + version) >= 0)) {
                     log("Not the required version: \"" + version + "\"", Project.MSG_VERBOSE);
                     return false;
                 }
             }
         } catch (SQLException e) {
             // Could not get the required information
             log("Failed to obtain required RDBMS information", Project.MSG_ERR);
             return false;
         }
 
         return true;
     }
 
     /**
      * Get the cache of loaders and drivers.
      * @return a hashtable
      */
     protected static Hashtable getLoaderMap() {
         return loaderMap;
     }
 
     /**
      * Get the classloader used to create a driver.
      * @return the classloader
      */
     protected AntClassLoader getLoader() {
         return loader;
     }
 
     /**
      * Additional properties to put into the JDBC connection string.
      *
      * @since Ant 1.8.0
      */
     public void addConnectionProperty(Property var) {
         connectionProperties.add(var);
     }
 
     /**
      * Creates a new Connection as using the driver, url, userid and password
      * specified.
      *
      * The calling method is responsible for closing the connection.
      *
      * @return Connection the newly created connection or null if the
      * connection failed and failOnConnectionError is false.
      * @throws BuildException if the UserId/Password/Url is not set or there
      * is no suitable driver or the driver fails to load.
      */
     protected Connection getConnection() throws BuildException {
         if (userId == null) {
             throw new BuildException("UserId attribute must be set!", getLocation());
         }
         if (password == null) {
             throw new BuildException("Password attribute must be set!", getLocation());
         }
         if (url == null) {
             throw new BuildException("Url attribute must be set!", getLocation());
         }
         try {
 
             log("connecting to " + getUrl(), Project.MSG_VERBOSE);
             Properties info = new Properties();
             info.put("user", getUserId());
             info.put("password", getPassword());
 
             for (Iterator props = connectionProperties.iterator();
                  props.hasNext(); ) {
                 Property p = (Property) props.next();
                 String name = p.getName();
                 String value = p.getValue();
                 if (name == null || value == null) {
                     log("Only name/value pairs are supported as connection"
                         + " properties.", Project.MSG_WARN);
                 } else {
                     log("Setting connection property " + name + " to " + value,
                         Project.MSG_VERBOSE);
                     info.put(name, value);
                 }
             }
 
             Connection conn = getDriver().connect(getUrl(), info);
 
             if (conn == null) {
                 // Driver doesn't understand the URL
                 throw new SQLException("No suitable Driver for " + url);
             }
 
             conn.setAutoCommit(autocommit);
             return conn;
         } catch (SQLException e) {
             // failed to connect
             if (!failOnConnectionError) {
                 log("Failed to connect: " + e.getMessage(), Project.MSG_WARN);
                 return null;
             } else {
                 throw new BuildException(e, getLocation());
             }
         }
 
     }
 
     /**
      * Gets an instance of the required driver.
      * Uses the ant class loader and the optionally the provided classpath.
      * @return Driver
      * @throws BuildException
      */
     private Driver getDriver() throws BuildException {
         if (driver == null) {
             throw new BuildException("Driver attribute must be set!", getLocation());
         }
 
         Driver driverInstance = null;
         try {
             Class dc;
             if (classpath != null) {
                 // check first that it is not already loaded otherwise
                 // consecutive runs seems to end into an OutOfMemoryError
                 // or it fails when there is a native library to load
                 // several times.
                 // this is far from being perfect but should work
                 // in most cases.
                 synchronized (loaderMap) {
                     if (caching) {
                         loader = (AntClassLoader) loaderMap.get(driver);
                     }
                     if (loader == null) {
                         log("Loading " + driver
                             + " using AntClassLoader with classpath "
                             + classpath, Project.MSG_VERBOSE);
                         loader = getProject().createClassLoader(classpath);
                         if (caching) {
                             loaderMap.put(driver, loader);
                         }
                     } else {
                         log("Loading " + driver
                             + " using a cached AntClassLoader.",
                                 Project.MSG_VERBOSE);
                     }
                 }
                 dc = loader.loadClass(driver);
             } else {
                 log("Loading " + driver + " using system loader.",
                     Project.MSG_VERBOSE);
                 dc = Class.forName(driver);
             }
             driverInstance = (Driver) dc.newInstance();
         } catch (ClassNotFoundException e) {
             throw new BuildException(
                     "Class Not Found: JDBC driver " + driver + " could not be loaded",
                     e,
                     getLocation());
         } catch (IllegalAccessException e) {
             throw new BuildException(
                     "Illegal Access: JDBC driver " + driver + " could not be loaded",
                     e,
                     getLocation());
         } catch (InstantiationException e) {
             throw new BuildException(
                     "Instantiation Exception: JDBC driver " + driver + " could not be loaded",
                     e,
                     getLocation());
         }
         return driverInstance;
     }
 
 
     /**
      * Set the caching attribute.
      * @param value a <code>boolean</code> value
      */
     public void isCaching(boolean value) {
         caching = value;
     }
 
     /**
      * Gets the classpath.
      * @return Returns a Path
      */
     public Path getClasspath() {
         return classpath;
     }
 
     /**
      * Gets the autocommit.
      * @return Returns a boolean
      */
     public boolean isAutocommit() {
         return autocommit;
     }
 
     /**
      * Gets the url.
      * @return Returns a String
      */
     public String getUrl() {
         return url;
     }
 
     /**
      * Gets the userId.
      * @return Returns a String
      */
     public String getUserId() {
         return userId;
     }
 
     /**
      * Set the user name for the connection; required.
      * @param userId The userId to set
      */
     public void setUserid(String userId) {
         this.userId = userId;
     }
 
     /**
      * Gets the password.
      * @return Returns a String
      */
     public String getPassword() {
         return password;
     }
 
     /**
      * Gets the rdbms.
      * @return Returns a String
      */
     public String getRdbms() {
         return rdbms;
     }
 
     /**
      * Gets the version.
      * @return Returns a String
      */
     public String getVersion() {
         return version;
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Java.java b/src/main/org/apache/tools/ant/taskdefs/Java.java
index e1553e8b0..9533d1b42 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Java.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Java.java
@@ -1,964 +1,964 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.ExitException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.ExitStatusException;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.types.CommandlineJava;
 import org.apache.tools.ant.types.Environment;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.PropertySet;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.types.Assertions;
 import org.apache.tools.ant.types.Permissions;
 import org.apache.tools.ant.types.RedirectorElement;
 import org.apache.tools.ant.taskdefs.condition.Os;
 import org.apache.tools.ant.util.KeepAliveInputStream;
 
 /**
  * Launcher for Java applications. Allows use of
  * the same JVM for the called application thus resulting in much
  * faster operation.
  *
  * @since Ant 1.1
  *
  * @ant.task category="java"
  */
 public class Java extends Task {
 
     private CommandlineJava cmdl = new CommandlineJava();
     private Environment env = new Environment();
     private boolean fork = false;
     private boolean newEnvironment = false;
     private File dir = null;
     private boolean failOnError = false;
     private Long timeout = null;
 
     //include locally for screening purposes
     private String inputString;
     private File input;
     private File output;
     private File error;
 
     // CheckStyle:VisibilityModifier OFF - bc
     protected Redirector redirector = new Redirector(this);
     protected RedirectorElement redirectorElement;
     // CheckStyle:VisibilityModifier ON
 
     private String resultProperty;
     private Permissions perm = null;
 
     private boolean spawn = false;
     private boolean incompatibleWithSpawn = false;
 
     private static final String TIMEOUT_MESSAGE = 
         "Timeout: killed the sub-process";
 
     /**
      * Normal constructor
      */
     public Java() {
     }
 
     /**
      * create a bound task
      * @param owner owner
      */
     public Java(Task owner) {
         bindToOwner(owner);
     }
 
     /**
      * Do the execution.
      * @throws BuildException if failOnError is set to true and the application
      * returns a nonzero result code.
      */
     public void execute() throws BuildException {
         File savedDir = dir;
         Permissions savedPermissions = perm;
 
         int err = -1;
         try {
             checkConfiguration();
             err = executeJava();
             if (err != 0) {
                 if (failOnError) {
                     throw new ExitStatusException("Java returned: " + err,
                             err,
                             getLocation());
                 } else {
                     log("Java Result: " + err, Project.MSG_ERR);
                 }
             }
             maybeSetResultPropertyValue(err);
         } finally {
             dir = savedDir;
             perm = savedPermissions;
         }
     }
 
     /**
      * Do the execution and return a return code.
      *
      * @return the return code from the execute java class if it was
      * executed in a separate VM (fork = "yes") or a security manager was
      * installed that prohibits ExitVM (default).
      *
      * @throws BuildException if required parameters are missing.
      */
     public int executeJava() throws BuildException {
         return executeJava(getCommandLine());
     }
 
     /**
      * Check configuration.
      * @throws BuildException if required parameters are missing.
      */
     protected void checkConfiguration() throws BuildException {
         String classname = getCommandLine().getClassname();
         if (classname == null && getCommandLine().getJar() == null) {
             throw new BuildException("Classname must not be null.");
         }
         if (!fork && getCommandLine().getJar() != null) {
             throw new BuildException("Cannot execute a jar in non-forked mode."
                                      + " Please set fork='true'. ");
         }
         if (spawn && !fork) {
             throw new BuildException("Cannot spawn a java process in non-forked mode."
                                      + " Please set fork='true'. ");
         }
         if (getCommandLine().getClasspath() != null
             && getCommandLine().getJar() != null) {
             log("When using 'jar' attribute classpath-settings are ignored. "
                 + "See the manual for more information.", Project.MSG_VERBOSE);
         }
         if (spawn && incompatibleWithSpawn) {
             getProject().log("spawn does not allow attributes related to input, "
             + "output, error, result", Project.MSG_ERR);
             getProject().log("spawn also does not allow timeout", Project.MSG_ERR);
             getProject().log("finally, spawn is not compatible "
                 + "with a nested I/O <redirector>", Project.MSG_ERR);
             throw new BuildException("You have used an attribute "
                 + "or nested element which is not compatible with spawn");
         }
         if (getCommandLine().getAssertions() != null && !fork) {
             log("Assertion statements are currently ignored in non-forked mode");
         }
         if (fork) {
             if (perm != null) {
                 log("Permissions can not be set this way in forked mode.", Project.MSG_WARN);
             }
             log(getCommandLine().describeCommand(), Project.MSG_VERBOSE);
         } else {
             if (getCommandLine().getVmCommand().size() > 1) {
                 log("JVM args ignored when same JVM is used.",
                     Project.MSG_WARN);
             }
             if (dir != null) {
                 log("Working directory ignored when same JVM is used.",
                     Project.MSG_WARN);
             }
             if (newEnvironment || null != env.getVariables()) {
                 log("Changes to environment variables are ignored when same "
                     + "JVM is used.", Project.MSG_WARN);
             }
             if (getCommandLine().getBootclasspath() != null) {
                 log("bootclasspath ignored when same JVM is used.",
                     Project.MSG_WARN);
             }
             if (perm == null) {
                 perm = new Permissions(true);
                 log("running " + this.getCommandLine().getClassname()
                     + " with default permissions (exit forbidden)", Project.MSG_VERBOSE);
             }
             log("Running in same VM " + getCommandLine().describeJavaCommand(),
                 Project.MSG_VERBOSE);
         }
         setupRedirector();
     }
 
     /**
      * Execute the specified CommandlineJava.
      * @param commandLine CommandLineJava instance.
      * @return the exit value of the process if forked, 0 otherwise.
      */
     protected int executeJava(CommandlineJava commandLine) {
         try {
             if (fork) {
                 if (!spawn) {
                     return fork(commandLine.getCommandline());
                 } else {
                     spawn(commandLine.getCommandline());
                     return 0;
                 }
             } else {
                 try {
                     run(commandLine);
                     return 0;
                 } catch (ExitException ex) {
                     return ex.getStatus();
                 }
             }
         } catch (BuildException e) {
             if (e.getLocation() == null && getLocation() != null) {
                 e.setLocation(getLocation());
             }
             if (failOnError) {
                 throw e;
             } else {
                 if (TIMEOUT_MESSAGE.equals(e.getMessage())) {
                     log(TIMEOUT_MESSAGE);
                 } else {
                     log(e);
                 }
                 return -1;
             }
         } catch (ThreadDeath t) {
             throw t; // cf. NB #47191
         } catch (Throwable t) {
             if (failOnError) {
                 throw new BuildException(t, getLocation());
             } else {
                 log(t);
                 return -1;
             }
         }
     }
 
     /**
      * Set whether or not you want the process to be spawned;
      * default is not spawned.
      * @param spawn if true you do not want Ant to wait for the end of the process.
      * @since Ant 1.6
      */
     public void setSpawn(boolean spawn) {
         this.spawn = spawn;
     }
 
     /**
      * Set the classpath to be used when running the Java class.
      *
      * @param s an Ant Path object containing the classpath.
      */
     public void setClasspath(Path s) {
         createClasspath().append(s);
     }
 
     /**
      * Add a path to the classpath.
      *
      * @return created classpath.
      */
     public Path createClasspath() {
         return getCommandLine().createClasspath(getProject()).createPath();
     }
 
     /**
      * Add a path to the bootclasspath.
      * @since Ant 1.6
      *
      * @return created bootclasspath.
      */
     public Path createBootclasspath() {
         return getCommandLine().createBootclasspath(getProject()).createPath();
     }
 
     /**
      * Set the permissions for the application run inside the same JVM.
      * @since Ant 1.6
      * @return Permissions.
      */
     public Permissions createPermissions() {
         perm = (perm == null) ? new Permissions() : perm;
         return perm;
     }
 
     /**
      * Set the classpath to use by reference.
      *
      * @param r a reference to an existing classpath.
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * Set the location of the JAR file to execute.
      *
      * @param jarfile the jarfile to execute.
      *
      * @throws BuildException if there is also a main class specified.
      */
     public void setJar(File jarfile) throws BuildException {
         if (getCommandLine().getClassname() != null) {
             throw new BuildException("Cannot use 'jar' and 'classname' "
                                      + "attributes in same command.");
         }
         getCommandLine().setJar(jarfile.getAbsolutePath());
     }
 
     /**
      * Set the Java class to execute.
      *
      * @param s the name of the main class.
      *
      * @throws BuildException if the jar attribute has been set.
      */
     public void setClassname(String s) throws BuildException {
         if (getCommandLine().getJar() != null) {
             throw new BuildException("Cannot use 'jar' and 'classname' "
                                      + "attributes in same command");
         }
         getCommandLine().setClassname(s);
     }
 
     /**
      * Deprecated: use nested arg instead.
      * Set the command line arguments for the class.
      *
      * @param s arguments.
      *
      * @ant.attribute ignore="true"
      */
     public void setArgs(String s) {
         log("The args attribute is deprecated. "
             + "Please use nested arg elements.", Project.MSG_WARN);
         getCommandLine().createArgument().setLine(s);
     }
 
     /**
      * If set, system properties will be copied to the cloned VM--as
      * well as the bootclasspath unless you have explicitly specified
-     * a bootclaspath.
+     * a bootclasspath.
      *
      * <p>Doesn't have any effect unless fork is true.</p>
      * @param cloneVm if true copy system properties.
      * @since Ant 1.7
      */
     public void setCloneVm(boolean cloneVm) {
         getCommandLine().setCloneVm(cloneVm);
     }
 
     /**
      * Add a command-line argument.
      *
      * @return created argument.
      */
     public Commandline.Argument createArg() {
         return getCommandLine().createArgument();
     }
 
     /**
      * Set the name of the property in which the return code of the
      * command should be stored. Only of interest if failonerror=false.
      *
      * @param resultProperty name of property.
      *
      * @since Ant 1.6
      */
     public void setResultProperty(String resultProperty) {
         this.resultProperty = resultProperty;
         incompatibleWithSpawn = true;
     }
 
     /**
      * Helper method to set result property to the
      * passed in value if appropriate.
      *
      * @param result the exit code
      */
     protected void maybeSetResultPropertyValue(int result) {
         String res = Integer.toString(result);
         if (resultProperty != null) {
             getProject().setNewProperty(resultProperty, res);
         }
     }
 
     /**
      * If true, execute in a new VM.
      *
      * @param s do you want to run Java in a new VM.
      */
     public void setFork(boolean s) {
         this.fork = s;
     }
 
     /**
      * Set the command line arguments for the JVM.
      *
      * @param s jvmargs.
      */
     public void setJvmargs(String s) {
         log("The jvmargs attribute is deprecated. "
             + "Please use nested jvmarg elements.", Project.MSG_WARN);
         getCommandLine().createVmArgument().setLine(s);
     }
 
     /**
      * Adds a JVM argument.
      *
      * @return JVM argument created.
      */
     public Commandline.Argument createJvmarg() {
         return getCommandLine().createVmArgument();
     }
 
     /**
      * Set the command used to start the VM (only if forking).
      *
      * @param s command to start the VM.
      */
     public void setJvm(String s) {
         getCommandLine().setVm(s);
     }
 
     /**
      * Add a system property.
      *
      * @param sysp system property.
      */
     public void addSysproperty(Environment.Variable sysp) {
         getCommandLine().addSysproperty(sysp);
     }
 
     /**
      * Add a set of properties as system properties.
      *
      * @param sysp set of properties to add.
      *
      * @since Ant 1.6
      */
     public void addSyspropertyset(PropertySet sysp) {
         getCommandLine().addSyspropertyset(sysp);
     }
 
     /**
      * If true, then fail if the command exits with a
      * returncode other than zero.
      *
      * @param fail if true fail the build when the command exits with a
      * nonzero returncode.
      */
     public void setFailonerror(boolean fail) {
         failOnError = fail;
         incompatibleWithSpawn |= fail;
     }
 
     /**
      * Set the working directory of the process.
      *
      * @param d working directory.
      *
      */
     public void setDir(File d) {
         this.dir = d;
     }
 
     /**
      * Set the File to which the output of the process is redirected.
      *
      * @param out the output File.
      */
     public void setOutput(File out) {
         this.output = out;
         incompatibleWithSpawn = true;
     }
 
     /**
      * Set the input to use for the task.
      *
      * @param input name of the input file.
      */
     public void setInput(File input) {
         if (inputString != null) {
             throw new BuildException("The \"input\" and \"inputstring\" "
                 + "attributes cannot both be specified");
         }
         this.input = input;
         incompatibleWithSpawn = true;
     }
 
     /**
      * Set the string to use as input.
      *
      * @param inputString the string which is used as the input source.
      */
     public void setInputString(String inputString) {
         if (input != null) {
             throw new BuildException("The \"input\" and \"inputstring\" "
                 + "attributes cannot both be specified");
         }
         this.inputString = inputString;
         incompatibleWithSpawn = true;
     }
 
     /**
      * Set whether error output of exec is logged. This is only useful
      * when output is being redirected and error output is desired in the
      * Ant log.
      *
      * @param logError get in the ant log the messages coming from stderr
      * in the case that fork = true.
      */
     public void setLogError(boolean logError) {
         redirector.setLogError(logError);
         incompatibleWithSpawn |= logError;
     }
 
     /**
      * Set the File to which the error stream of the process is redirected.
      *
      * @param error file getting the error stream.
      *
      * @since Ant 1.6
      */
     public void setError(File error) {
         this.error = error;
         incompatibleWithSpawn = true;
     }
 
     /**
      * Set the property name whose value should be set to the output of
      * the process.
      *
      * @param outputProp property name.
      *
      */
     public void setOutputproperty(String outputProp) {
         redirector.setOutputProperty(outputProp);
         incompatibleWithSpawn = true;
     }
 
     /**
      * Set the property name whose value should be set to the error of
      * the process.
      *
      * @param errorProperty property name.
      *
      * @since Ant 1.6
      */
     public void setErrorProperty(String errorProperty) {
         redirector.setErrorProperty(errorProperty);
         incompatibleWithSpawn = true;
     }
 
     /**
      * Corresponds to -mx or -Xmx depending on VM version.
      *
      * @param max max memory parameter.
      */
     public void setMaxmemory(String max) {
         getCommandLine().setMaxmemory(max);
     }
 
     /**
      * Set the JVM version.
      * @param value JVM version.
      */
     public void setJVMVersion(String value) {
         getCommandLine().setVmversion(value);
     }
 
     /**
      * Add an environment variable.
      *
      * <p>Will be ignored if we are not forking a new VM.
      *
      * @param var new environment variable.
      *
      * @since Ant 1.5
      */
     public void addEnv(Environment.Variable var) {
         env.addVariable(var);
     }
 
     /**
      * If true, use a completely new environment.
      *
      * <p>Will be ignored if we are not forking a new VM.
      *
      * @param newenv if true, use a completely new environment.
      *
      * @since Ant 1.5
      */
     public void setNewenvironment(boolean newenv) {
         newEnvironment = newenv;
     }
 
     /**
      * If true, append output to existing file.
      *
      * @param append if true, append output to existing file.
      *
      * @since Ant 1.5
      */
     public void setAppend(boolean append) {
         redirector.setAppend(append);
         incompatibleWithSpawn = true;
     }
 
     /**
      * Set the timeout in milliseconds after which the process will be killed.
      *
      * @param value timeout in milliseconds.
      *
      * @since Ant 1.5
      */
     public void setTimeout(Long value) {
         timeout = value;
         incompatibleWithSpawn |= timeout != null;
     }
 
     /**
      * Add assertions to enable in this program (if fork=true).
      * @param asserts assertion set.
      * @since Ant 1.6
      */
     public void addAssertions(Assertions asserts) {
         if (getCommandLine().getAssertions() != null) {
             throw new BuildException("Only one assertion declaration is allowed");
         }
         getCommandLine().setAssertions(asserts);
     }
 
     /**
      * Add a <code>RedirectorElement</code> to this task.
      * @param redirectorElement   <code>RedirectorElement</code>.
      */
     public void addConfiguredRedirector(RedirectorElement redirectorElement) {
         if (this.redirectorElement != null) {
             throw new BuildException("cannot have > 1 nested redirectors");
         }
         this.redirectorElement = redirectorElement;
         incompatibleWithSpawn = true;
     }
 
     /**
      * Pass output sent to System.out to specified output file.
      *
      * @param output a string of output on its way to the handlers.
      *
      * @since Ant 1.5
      */
     protected void handleOutput(String output) {
         if (redirector.getOutputStream() != null) {
             redirector.handleOutput(output);
         } else {
             super.handleOutput(output);
         }
     }
 
     /**
      * Handle an input request by this task.
      *
      * @param buffer the buffer into which data is to be read.
      * @param offset the offset into the buffer at which data is stored.
      * @param length the amount of data to read.
      *
      * @return the number of bytes read.
      *
      * @exception IOException if the data cannot be read.
      * @since Ant 1.6
      */
     public int handleInput(byte[] buffer, int offset, int length)
         throws IOException {
         // Should work whether or not redirector.inputStream == null:
         return redirector.handleInput(buffer, offset, length);
     }
 
     /**
      * Pass output sent to System.out to specified output file.
      *
      * @param output string of output on its way to its handlers.
      *
      * @since Ant 1.5.2
      */
     protected void handleFlush(String output) {
         if (redirector.getOutputStream() != null) {
             redirector.handleFlush(output);
         } else {
             super.handleFlush(output);
         }
     }
 
     /**
      * Handle output sent to System.err.
      *
      * @param output string of stderr.
      *
      * @since Ant 1.5
      */
     protected void handleErrorOutput(String output) {
         if (redirector.getErrorStream() != null) {
             redirector.handleErrorOutput(output);
         } else {
             super.handleErrorOutput(output);
         }
     }
 
     /**
      * Handle output sent to System.err and flush the stream.
      *
      * @param output string of stderr.
      *
      * @since Ant 1.5.2
      */
     protected void handleErrorFlush(String output) {
         if (redirector.getErrorStream() != null) {
             redirector.handleErrorFlush(output);
         } else {
             super.handleErrorFlush(output);
         }
     }
 
     /**
      * Set up properties on the redirector that we needed to store locally.
      */
     protected void setupRedirector() {
         redirector.setInput(input);
         redirector.setInputString(inputString);
         redirector.setOutput(output);
         redirector.setError(error);
         if (redirectorElement != null) {
             redirectorElement.configure(redirector);
         }
         if (!spawn && input == null && inputString == null) {
             // #24918: send standard input to the process by default.
             redirector.setInputStream(
                 new KeepAliveInputStream(getProject().getDefaultInputStream()));
         }
     }
 
     /**
      * Executes the given classname with the given arguments as it
      * were a command line application.
      * @param command CommandlineJava.
      */
     private void run(CommandlineJava command) throws BuildException {
         try {
             ExecuteJava exe = new ExecuteJava();
             exe.setJavaCommand(command.getJavaCommand());
             exe.setClasspath(command.getClasspath());
             exe.setSystemProperties(command.getSystemProperties());
             exe.setPermissions(perm);
             exe.setTimeout(timeout);
             redirector.createStreams();
             exe.execute(getProject());
             redirector.complete();
             if (exe.killedProcess()) {
                 throw new BuildException(TIMEOUT_MESSAGE);
             }
         } catch (IOException e) {
             throw new BuildException(e);
         }
     }
 
     /**
      * Executes the given classname with the given arguments in a separate VM.
      * @param command String[] of command-line arguments.
      */
     private int fork(String[] command) throws BuildException {
         Execute exe
             = new Execute(redirector.createHandler(), createWatchdog());
         setupExecutable(exe, command);
 
         try {
             int rc = exe.execute();
             redirector.complete();
             if (exe.killedProcess()) {
                 throw new BuildException(TIMEOUT_MESSAGE);
             }
             return rc;
         } catch (IOException e) {
             throw new BuildException(e, getLocation());
         }
     }
 
     /**
      * Executes the given classname with the given arguments in a separate VM.
      * @param command String[] of command-line arguments.
      */
     private void spawn(String[] command) throws BuildException {
         Execute exe = new Execute();
         setupExecutable(exe, command);
         try {
             exe.spawn();
         } catch (IOException e) {
             throw new BuildException(e, getLocation());
         }
     }
 
     /**
      * Do all configuration for an executable that
      * is common across the {@link #fork(String[])} and
      * {@link #spawn(String[])} methods.
      * @param exe executable.
      * @param command command to execute.
      */
     private void setupExecutable(Execute exe, String[] command) {
         exe.setAntRun(getProject());
         setupWorkingDir(exe);
         setupEnvironment(exe);
         setupCommandLine(exe, command);
     }
 
     /**
      * Set up our environment variables.
      * @param exe executable.
      */
     private void setupEnvironment(Execute exe) {
         String[] environment = env.getVariables();
         if (environment != null) {
             for (int i = 0; i < environment.length; i++) {
                 log("Setting environment variable: " + environment[i],
                     Project.MSG_VERBOSE);
             }
         }
         exe.setNewenvironment(newEnvironment);
         exe.setEnvironment(environment);
     }
 
     /**
      * Set the working dir of the new process.
      * @param exe executable.
      * @throws BuildException if the dir doesn't exist.
      */
     private void setupWorkingDir(Execute exe) {
         if (dir == null) {
             dir = getProject().getBaseDir();
         } else if (!dir.exists() || !dir.isDirectory()) {
             throw new BuildException(dir.getAbsolutePath()
                                      + " is not a valid directory",
                                      getLocation());
         }
         exe.setWorkingDirectory(dir);
     }
 
     /**
      * Set the command line for the exe.
      * On VMS, hands off to {@link #setupCommandLineForVMS(Execute, String[])}.
      * @param exe executable.
      * @param command command to execute.
      */
     private void setupCommandLine(Execute exe, String[] command) {
         //On VMS platform, we need to create a special java options file
         //containing the arguments and classpath for the java command.
         //The special file is supported by the "-V" switch on the VMS JVM.
         if (Os.isFamily("openvms")) {
             setupCommandLineForVMS(exe, command);
         } else {
             exe.setCommandline(command);
         }
     }
 
     /**
      * On VMS platform, we need to create a special java options file
      * containing the arguments and classpath for the java command.
      * The special file is supported by the "-V" switch on the VMS JVM.
      *
      * @param exe executable.
      * @param command command to execute.
      */
     private void setupCommandLineForVMS(Execute exe, String[] command) {
         ExecuteJava.setupCommandLineForVMS(exe, command);
     }
 
     /**
      * Executes the given classname with the given arguments as if it
      * were a command line application.
      *
      * @param classname the name of the class to run.
      * @param args  arguments for the class.
      * @throws BuildException in case of IOException in the execution.
      */
     protected void run(String classname, Vector args) throws BuildException {
         CommandlineJava cmdj = new CommandlineJava();
         cmdj.setClassname(classname);
         final int size = args.size();
         for (int i = 0; i < size; i++) {
             cmdj.createArgument().setValue((String) args.elementAt(i));
         }
         run(cmdj);
     }
 
     /**
      * Clear out the arguments to this java task.
      */
     public void clearArgs() {
         getCommandLine().clearJavaArgs();
     }
 
     /**
      * Create the Watchdog to kill a runaway process.
      *
      * @return new watchdog.
      *
      * @throws BuildException under unknown circumstances.
      *
      * @since Ant 1.5
      */
     protected ExecuteWatchdog createWatchdog() throws BuildException {
         if (timeout == null) {
             return null;
         }
         return new ExecuteWatchdog(timeout.longValue());
     }
 
     /**
      * Log the specified Throwable.
      * @param t the Throwable to log.
      * @since 1.6.2
      */
     private void log(Throwable t) {
         StringWriter sw = new StringWriter();
         PrintWriter w = new PrintWriter(sw);
         t.printStackTrace(w);
         w.close();
         log(sw.toString(), Project.MSG_ERR);
     }
 
     /**
      * Accessor to the command line.
      *
      * @return the current command line.
      * @since 1.6.3
      */
     public CommandlineJava getCommandLine() {
         return cmdl;
     }
 
     /**
      * Get the system properties of the command line.
      *
      * @return the current properties of this java invocation.
      * @since 1.6.3
      */
     public CommandlineJava.SysProperties getSysProperties() {
         return getCommandLine().getSystemProperties();
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Javac.java b/src/main/org/apache/tools/ant/taskdefs/Javac.java
index fb2fcbbad..b92f9faca 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Javac.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Javac.java
@@ -1,1262 +1,1262 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.MagicNames;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.compilers.CompilerAdapter;
 import org.apache.tools.ant.taskdefs.compilers.CompilerAdapterExtension;
 import org.apache.tools.ant.taskdefs.compilers.CompilerAdapterFactory;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.GlobPatternMapper;
 import org.apache.tools.ant.util.JavaEnvUtils;
 import org.apache.tools.ant.util.SourceFileScanner;
 import org.apache.tools.ant.util.facade.FacadeTaskHelper;
 
 /**
  * Compiles Java source files. This task can take the following
  * arguments:
  * <ul>
  * <li>sourcedir
  * <li>destdir
  * <li>deprecation
  * <li>classpath
  * <li>bootclasspath
  * <li>extdirs
  * <li>optimize
  * <li>debug
  * <li>encoding
  * <li>target
  * <li>depend
  * <li>verbose
  * <li>failonerror
  * <li>includeantruntime
  * <li>includejavaruntime
  * <li>source
  * <li>compiler
  * </ul>
  * Of these arguments, the <b>sourcedir</b> and <b>destdir</b> are required.
  * <p>
  * When this task executes, it will recursively scan the sourcedir and
  * destdir looking for Java source files to compile. This task makes its
  * compile decision based on timestamp.
  *
  *
  * @since Ant 1.1
  *
  * @ant.task category="java"
  */
 
 public class Javac extends MatchingTask {
 
     private static final String FAIL_MSG
         = "Compile failed; see the compiler error output for details.";
 
     private static final String JAVAC18 = "javac1.8";
     private static final String JAVAC17 = "javac1.7";
     private static final String JAVAC16 = "javac1.6";
     private static final String JAVAC15 = "javac1.5";
     private static final String JAVAC14 = "javac1.4";
     private static final String JAVAC13 = "javac1.3";
     private static final String JAVAC12 = "javac1.2";
     private static final String JAVAC11 = "javac1.1";
     private static final String MODERN = "modern";
     private static final String CLASSIC = "classic";
     private static final String EXTJAVAC = "extJavac";
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     private Path src;
     private File destDir;
     private Path compileClasspath;
     private Path compileSourcepath;
     private String encoding;
     private boolean debug = false;
     private boolean optimize = false;
     private boolean deprecation = false;
     private boolean depend = false;
     private boolean verbose = false;
     private String targetAttribute;
     private Path bootclasspath;
     private Path extdirs;
     private Boolean includeAntRuntime;
     private boolean includeJavaRuntime = false;
     private boolean fork = false;
     private String forkedExecutable = null;
     private boolean nowarn = false;
     private String memoryInitialSize;
     private String memoryMaximumSize;
     private FacadeTaskHelper facade = null;
 
     // CheckStyle:VisibilityModifier OFF - bc
     protected boolean failOnError = true;
     protected boolean listFiles = false;
     protected File[] compileList = new File[0];
     private Map/*<String,Long>*/ packageInfos = new HashMap();
     // CheckStyle:VisibilityModifier ON
 
     private String source;
     private String debugLevel;
     private File tmpDir;
     private String updatedProperty;
     private String errorProperty;
     private boolean taskSuccess = true; // assume the best
     private boolean includeDestClasses = true;
     private CompilerAdapter nestedAdapter = null;
 
     private boolean createMissingPackageInfoClass = true;
 
     /**
      * Javac task for compilation of Java files.
      */
     public Javac() {
         facade = new FacadeTaskHelper(assumedJavaVersion());
     }
 
     private String assumedJavaVersion() {
         if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_4)) {
             return JAVAC14;
         } else if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_5)) {
             return JAVAC15;
         } else if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_6)) {
             return JAVAC16;
         } else if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_7)) {
             return JAVAC17;
         } else if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_8)) {
             return JAVAC18;
         } else {
             return CLASSIC;
         }
     }
 
     /**
      * Get the value of debugLevel.
      * @return value of debugLevel.
      */
     public String getDebugLevel() {
         return debugLevel;
     }
 
     /**
      * Keyword list to be appended to the -g command-line switch.
      *
      * This will be ignored by all implementations except modern
      * and classic(ver >= 1.2). Legal values are none or a
      * comma-separated list of the following keywords: lines, vars,
      * and source. If debuglevel is not specified, by default, :none
      * will be appended to -g. If debug is not turned on, this attribute
      * will be ignored.
      *
      * @param v  Value to assign to debugLevel.
      */
     public void setDebugLevel(String  v) {
         this.debugLevel = v;
     }
 
     /**
      * Get the value of source.
      * @return value of source.
      */
     public String getSource() {
         return source != null
             ? source : getProject().getProperty(MagicNames.BUILD_JAVAC_SOURCE);
     }
 
     /**
      * Value of the -source command-line switch; will be ignored by
      * all implementations except modern, jikes and gcj (gcj uses
      * -fsource).
      *
      * <p>If you use this attribute together with jikes or gcj, you
      * must make sure that your version of jikes supports the -source
      * switch.</p>
      *
      * <p>Legal values are 1.3, 1.4, 1.5, and 5 - by default, no
      * -source argument will be used at all.</p>
      *
      * @param v  Value to assign to source.
      */
     public void setSource(String  v) {
         this.source = v;
     }
 
     /**
      * Adds a path for source compilation.
      *
      * @return a nested src element.
      */
     public Path createSrc() {
         if (src == null) {
             src = new Path(getProject());
         }
         return src.createPath();
     }
 
     /**
      * Recreate src.
      *
      * @return a nested src element.
      */
     protected Path recreateSrc() {
         src = null;
         return createSrc();
     }
 
     /**
      * Set the source directories to find the source Java files.
      * @param srcDir the source directories as a path
      */
     public void setSrcdir(Path srcDir) {
         if (src == null) {
             src = srcDir;
         } else {
             src.append(srcDir);
         }
     }
 
     /**
      * Gets the source dirs to find the source java files.
      * @return the source directories as a path
      */
     public Path getSrcdir() {
         return src;
     }
 
     /**
      * Set the destination directory into which the Java source
      * files should be compiled.
      * @param destDir the destination director
      */
     public void setDestdir(File destDir) {
         this.destDir = destDir;
     }
 
     /**
      * Gets the destination directory into which the java source files
      * should be compiled.
      * @return the destination directory
      */
     public File getDestdir() {
         return destDir;
     }
 
     /**
      * Set the sourcepath to be used for this compilation.
      * @param sourcepath the source path
      */
     public void setSourcepath(Path sourcepath) {
         if (compileSourcepath == null) {
             compileSourcepath = sourcepath;
         } else {
             compileSourcepath.append(sourcepath);
         }
     }
 
     /**
      * Gets the sourcepath to be used for this compilation.
      * @return the source path
      */
     public Path getSourcepath() {
         return compileSourcepath;
     }
 
     /**
      * Adds a path to sourcepath.
      * @return a sourcepath to be configured
      */
     public Path createSourcepath() {
         if (compileSourcepath == null) {
             compileSourcepath = new Path(getProject());
         }
         return compileSourcepath.createPath();
     }
 
     /**
      * Adds a reference to a source path defined elsewhere.
      * @param r a reference to a source path
      */
     public void setSourcepathRef(Reference r) {
         createSourcepath().setRefid(r);
     }
 
     /**
      * Set the classpath to be used for this compilation.
      *
      * @param classpath an Ant Path object containing the compilation classpath.
      */
     public void setClasspath(Path classpath) {
         if (compileClasspath == null) {
             compileClasspath = classpath;
         } else {
             compileClasspath.append(classpath);
         }
     }
 
     /**
      * Gets the classpath to be used for this compilation.
      * @return the class path
      */
     public Path getClasspath() {
         return compileClasspath;
     }
 
     /**
      * Adds a path to the classpath.
      * @return a class path to be configured
      */
     public Path createClasspath() {
         if (compileClasspath == null) {
             compileClasspath = new Path(getProject());
         }
         return compileClasspath.createPath();
     }
 
     /**
      * Adds a reference to a classpath defined elsewhere.
      * @param r a reference to a classpath
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * Sets the bootclasspath that will be used to compile the classes
      * against.
      * @param bootclasspath a path to use as a boot class path (may be more
      *                      than one)
      */
     public void setBootclasspath(Path bootclasspath) {
         if (this.bootclasspath == null) {
             this.bootclasspath = bootclasspath;
         } else {
             this.bootclasspath.append(bootclasspath);
         }
     }
 
     /**
      * Gets the bootclasspath that will be used to compile the classes
      * against.
      * @return the boot path
      */
     public Path getBootclasspath() {
         return bootclasspath;
     }
 
     /**
      * Adds a path to the bootclasspath.
      * @return a path to be configured
      */
     public Path createBootclasspath() {
         if (bootclasspath == null) {
             bootclasspath = new Path(getProject());
         }
         return bootclasspath.createPath();
     }
 
     /**
      * Adds a reference to a classpath defined elsewhere.
      * @param r a reference to a classpath
      */
     public void setBootClasspathRef(Reference r) {
         createBootclasspath().setRefid(r);
     }
 
     /**
      * Sets the extension directories that will be used during the
      * compilation.
      * @param extdirs a path
      */
     public void setExtdirs(Path extdirs) {
         if (this.extdirs == null) {
             this.extdirs = extdirs;
         } else {
             this.extdirs.append(extdirs);
         }
     }
 
     /**
      * Gets the extension directories that will be used during the
      * compilation.
      * @return the extension directories as a path
      */
     public Path getExtdirs() {
         return extdirs;
     }
 
     /**
      * Adds a path to extdirs.
      * @return a path to be configured
      */
     public Path createExtdirs() {
         if (extdirs == null) {
             extdirs = new Path(getProject());
         }
         return extdirs.createPath();
     }
 
     /**
      * If true, list the source files being handed off to the compiler.
      * @param list if true list the source files
      */
     public void setListfiles(boolean list) {
         listFiles = list;
     }
 
     /**
      * Get the listfiles flag.
      * @return the listfiles flag
      */
     public boolean getListfiles() {
         return listFiles;
     }
 
     /**
      * Indicates whether the build will continue
      * even if there are compilation errors; defaults to true.
      * @param fail if true halt the build on failure
      */
     public void setFailonerror(boolean fail) {
         failOnError = fail;
     }
 
     /**
      * @ant.attribute ignore="true"
      * @param proceed inverse of failoferror
      */
     public void setProceed(boolean proceed) {
         failOnError = !proceed;
     }
 
     /**
      * Gets the failonerror flag.
      * @return the failonerror flag
      */
     public boolean getFailonerror() {
         return failOnError;
     }
 
     /**
      * Indicates whether source should be
      * compiled with deprecation information; defaults to off.
      * @param deprecation if true turn on deprecation information
      */
     public void setDeprecation(boolean deprecation) {
         this.deprecation = deprecation;
     }
 
     /**
      * Gets the deprecation flag.
      * @return the deprecation flag
      */
     public boolean getDeprecation() {
         return deprecation;
     }
 
     /**
      * The initial size of the memory for the underlying VM
      * if javac is run externally; ignored otherwise.
      * Defaults to the standard VM memory setting.
      * (Examples: 83886080, 81920k, or 80m)
      * @param memoryInitialSize string to pass to VM
      */
     public void setMemoryInitialSize(String memoryInitialSize) {
         this.memoryInitialSize = memoryInitialSize;
     }
 
     /**
      * Gets the memoryInitialSize flag.
      * @return the memoryInitialSize flag
      */
     public String getMemoryInitialSize() {
         return memoryInitialSize;
     }
 
     /**
      * The maximum size of the memory for the underlying VM
      * if javac is run externally; ignored otherwise.
      * Defaults to the standard VM memory setting.
      * (Examples: 83886080, 81920k, or 80m)
      * @param memoryMaximumSize string to pass to VM
      */
     public void setMemoryMaximumSize(String memoryMaximumSize) {
         this.memoryMaximumSize = memoryMaximumSize;
     }
 
     /**
      * Gets the memoryMaximumSize flag.
      * @return the memoryMaximumSize flag
      */
     public String getMemoryMaximumSize() {
         return memoryMaximumSize;
     }
 
     /**
      * Set the Java source file encoding name.
      * @param encoding the source file encoding
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * Gets the java source file encoding name.
      * @return the source file encoding name
      */
     public String getEncoding() {
         return encoding;
     }
 
     /**
      * Indicates whether source should be compiled
      * with debug information; defaults to off.
      * @param debug if true compile with debug information
      */
     public void setDebug(boolean debug) {
         this.debug = debug;
     }
 
     /**
      * Gets the debug flag.
      * @return the debug flag
      */
     public boolean getDebug() {
         return debug;
     }
 
     /**
      * If true, compiles with optimization enabled.
      * @param optimize if true compile with optimization enabled
      */
     public void setOptimize(boolean optimize) {
         this.optimize = optimize;
     }
 
     /**
      * Gets the optimize flag.
      * @return the optimize flag
      */
     public boolean getOptimize() {
         return optimize;
     }
 
     /**
      * Enables dependency-tracking for compilers
      * that support this (jikes and classic).
      * @param depend if true enable dependency-tracking
      */
     public void setDepend(boolean depend) {
         this.depend = depend;
     }
 
     /**
      * Gets the depend flag.
      * @return the depend flag
      */
     public boolean getDepend() {
         return depend;
     }
 
     /**
      * If true, asks the compiler for verbose output.
      * @param verbose if true, asks the compiler for verbose output
      */
     public void setVerbose(boolean verbose) {
         this.verbose = verbose;
     }
 
     /**
      * Gets the verbose flag.
      * @return the verbose flag
      */
     public boolean getVerbose() {
         return verbose;
     }
 
     /**
      * Sets the target VM that the classes will be compiled for. Valid
      * values depend on the compiler, for jdk 1.4 the valid values are
      * "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "1.8", "5", "6", "7" and "8".
      * @param target the target VM
      */
     public void setTarget(String target) {
         this.targetAttribute = target;
     }
 
     /**
      * Gets the target VM that the classes will be compiled for.
      * @return the target VM
      */
     public String getTarget() {
         return targetAttribute != null
             ? targetAttribute
             : getProject().getProperty(MagicNames.BUILD_JAVAC_TARGET);
     }
 
     /**
      * If true, includes Ant's own classpath in the classpath.
      * @param include if true, includes Ant's own classpath in the classpath
      */
     public void setIncludeantruntime(boolean include) {
         includeAntRuntime = Boolean.valueOf(include);
     }
 
     /**
      * Gets whether or not the ant classpath is to be included in the classpath.
      * @return whether or not the ant classpath is to be included in the classpath
      */
     public boolean getIncludeantruntime() {
         return includeAntRuntime != null ? includeAntRuntime.booleanValue() : true;
     }
 
     /**
      * If true, includes the Java runtime libraries in the classpath.
      * @param include if true, includes the Java runtime libraries in the classpath
      */
     public void setIncludejavaruntime(boolean include) {
         includeJavaRuntime = include;
     }
 
     /**
      * Gets whether or not the java runtime should be included in this
      * task's classpath.
      * @return the includejavaruntime attribute
      */
     public boolean getIncludejavaruntime() {
         return includeJavaRuntime;
     }
 
     /**
      * If true, forks the javac compiler.
      *
      * @param f "true|false|on|off|yes|no"
      */
     public void setFork(boolean f) {
         fork = f;
     }
 
     /**
      * Sets the name of the javac executable.
      *
      * <p>Ignored unless fork is true or extJavac has been specified
      * as the compiler.</p>
      * @param forkExec the name of the executable
      */
     public void setExecutable(String forkExec) {
         forkedExecutable = forkExec;
     }
 
     /**
      * The value of the executable attribute, if any.
      *
      * @since Ant 1.6
      * @return the name of the java executable
      */
     public String getExecutable() {
         return forkedExecutable;
     }
 
     /**
      * Is this a forked invocation of JDK's javac?
      * @return true if this is a forked invocation
      */
     public boolean isForkedJavac() {
         return fork || EXTJAVAC.equalsIgnoreCase(getCompiler());
     }
 
     /**
      * The name of the javac executable to use in fork-mode.
      *
      * <p>This is either the name specified with the executable
      * attribute or the full path of the javac compiler of the VM Ant
      * is currently running in - guessed by Ant.</p>
      *
      * <p>You should <strong>not</strong> invoke this method if you
      * want to get the value of the executable command - use {@link
      * #getExecutable getExecutable} for this.</p>
      * @return the name of the javac executable
      */
     public String getJavacExecutable() {
         if (forkedExecutable == null && isForkedJavac()) {
             forkedExecutable = getSystemJavac();
         } else if (forkedExecutable != null && !isForkedJavac()) {
             forkedExecutable = null;
         }
         return forkedExecutable;
     }
 
     /**
      * If true, enables the -nowarn option.
      * @param flag if true, enable the -nowarn option
      */
     public void setNowarn(boolean flag) {
         this.nowarn = flag;
     }
 
     /**
      * Should the -nowarn option be used.
      * @return true if the -nowarn option should be used
      */
     public boolean getNowarn() {
         return nowarn;
     }
 
     /**
      * Adds an implementation specific command-line argument.
      * @return a ImplementationSpecificArgument to be configured
      */
     public ImplementationSpecificArgument createCompilerArg() {
         ImplementationSpecificArgument arg =
             new ImplementationSpecificArgument();
         facade.addImplementationArgument(arg);
         return arg;
     }
 
     /**
      * Get the additional implementation specific command line arguments.
      * @return array of command line arguments, guaranteed to be non-null.
      */
     public String[] getCurrentCompilerArgs() {
         String chosen = facade.getExplicitChoice();
         try {
             // make sure facade knows about magic properties and fork setting
             String appliedCompiler = getCompiler();
             facade.setImplementation(appliedCompiler);
 
             String[] result = facade.getArgs();
 
             String altCompilerName = getAltCompilerName(facade.getImplementation());
 
             if (result.length == 0 && altCompilerName != null) {
                 facade.setImplementation(altCompilerName);
                 result = facade.getArgs();
             }
 
             return result;
 
         } finally {
             facade.setImplementation(chosen);
         }
     }
 
     private String getAltCompilerName(String anImplementation) {
         if (JAVAC17.equalsIgnoreCase(anImplementation)
                 || JAVAC18.equalsIgnoreCase(anImplementation)
                 || JAVAC16.equalsIgnoreCase(anImplementation)
                 || JAVAC15.equalsIgnoreCase(anImplementation)
                 || JAVAC14.equalsIgnoreCase(anImplementation)
                 || JAVAC13.equalsIgnoreCase(anImplementation)) {
             return MODERN;
         }
         if (JAVAC12.equalsIgnoreCase(anImplementation)
                 || JAVAC11.equalsIgnoreCase(anImplementation)) {
             return CLASSIC;
         }
         if (MODERN.equalsIgnoreCase(anImplementation)) {
             String nextSelected = assumedJavaVersion();
             if (JAVAC17.equalsIgnoreCase(nextSelected)
                     || JAVAC18.equalsIgnoreCase(nextSelected)
                     || JAVAC16.equalsIgnoreCase(nextSelected)
                     || JAVAC15.equalsIgnoreCase(nextSelected)
                     || JAVAC14.equalsIgnoreCase(nextSelected)
                     || JAVAC13.equalsIgnoreCase(nextSelected)) {
                 return nextSelected;
             }
         }
         if (CLASSIC.equalsIgnoreCase(anImplementation)) {
             return assumedJavaVersion();
         }
         if (EXTJAVAC.equalsIgnoreCase(anImplementation)) {
             return assumedJavaVersion();
         }
         return null;
     }
 
     /**
      * Where Ant should place temporary files.
      *
      * @since Ant 1.6
      * @param tmpDir the temporary directory
      */
     public void setTempdir(File tmpDir) {
         this.tmpDir = tmpDir;
     }
 
     /**
      * Where Ant should place temporary files.
      *
      * @since Ant 1.6
      * @return the temporary directory
      */
     public File getTempdir() {
         return tmpDir;
     }
 
     /**
      * The property to set on compilation success.
      * This property will not be set if the compilation
      * fails, or if there are no files to compile.
      * @param updatedProperty the property name to use.
      * @since Ant 1.7.1.
      */
     public void setUpdatedProperty(String updatedProperty) {
         this.updatedProperty = updatedProperty;
     }
 
     /**
      * The property to set on compilation failure.
      * This property will be set if the compilation
      * fails.
      * @param errorProperty the property name to use.
      * @since Ant 1.7.1.
      */
     public void setErrorProperty(String errorProperty) {
         this.errorProperty = errorProperty;
     }
 
     /**
      * This property controls whether to include the
      * destination classes directory in the classpath
      * given to the compiler.
      * The default value is "true".
      * @param includeDestClasses the value to use.
      */
     public void setIncludeDestClasses(boolean includeDestClasses) {
         this.includeDestClasses = includeDestClasses;
     }
 
     /**
      * Get the value of the includeDestClasses property.
      * @return the value.
      */
     public boolean isIncludeDestClasses() {
         return includeDestClasses;
     }
 
     /**
      * Get the result of the javac task (success or failure).
      * @return true if compilation succeeded, or
-     *         was not neccessary, false if the compilation failed.
+     *         was not necessary, false if the compilation failed.
      */
     public boolean getTaskSuccess() {
         return taskSuccess;
     }
 
     /**
      * The classpath to use when loading the compiler implementation
      * if it is not a built-in one.
      *
      * @since Ant 1.8.0
      */
     public Path createCompilerClasspath() {
         return facade.getImplementationClasspath(getProject());
     }
 
     /**
      * Set the compiler adapter explicitly.
      * @since Ant 1.8.0
      */
     public void add(CompilerAdapter adapter) {
         if (nestedAdapter != null) {
             throw new BuildException("Can't have more than one compiler"
                                      + " adapter");
         }
         nestedAdapter = adapter;
     }
 
     /**
      * Whether package-info.class files will be created by Ant
      * matching package-info.java files that have been compiled but
      * didn't create class files themselves.
      *
      * @since Ant 1.8.3
      */
     public void setCreateMissingPackageInfoClass(boolean b) {
         createMissingPackageInfoClass = b;
     }
 
     /**
      * Executes the task.
      * @exception BuildException if an error occurs
      */
     public void execute() throws BuildException {
         checkParameters();
         resetFileLists();
 
         // scan source directories and dest directory to build up
         // compile lists
         String[] list = src.list();
         for (int i = 0; i < list.length; i++) {
             File srcDir = getProject().resolveFile(list[i]);
             if (!srcDir.exists()) {
                 throw new BuildException("srcdir \""
                                          + srcDir.getPath()
                                          + "\" does not exist!", getLocation());
             }
 
             DirectoryScanner ds = this.getDirectoryScanner(srcDir);
             String[] files = ds.getIncludedFiles();
 
             scanDir(srcDir, destDir != null ? destDir : srcDir, files);
         }
 
         compile();
         if (updatedProperty != null
             && taskSuccess
             && compileList.length != 0) {
             getProject().setNewProperty(updatedProperty, "true");
         }
     }
 
     /**
      * Clear the list of files to be compiled and copied..
      */
     protected void resetFileLists() {
         compileList = new File[0];
         packageInfos = new HashMap();
     }
 
     /**
      * Scans the directory looking for source files to be compiled.
      * The results are returned in the class variable compileList
      *
      * @param srcDir   The source directory
      * @param destDir  The destination directory
      * @param files    An array of filenames
      */
     protected void scanDir(File srcDir, File destDir, String[] files) {
         GlobPatternMapper m = new GlobPatternMapper();
         String[] extensions = findSupportedFileExtensions();
 
         for (int i = 0; i < extensions.length; i++) {
             m.setFrom(extensions[i]);
             m.setTo("*.class");
             SourceFileScanner sfs = new SourceFileScanner(this);
             File[] newFiles = sfs.restrictAsFiles(files, srcDir, destDir, m);
 
             if (newFiles.length > 0) {
                 lookForPackageInfos(srcDir, newFiles);
                 File[] newCompileList
                     = new File[compileList.length + newFiles.length];
                 System.arraycopy(compileList, 0, newCompileList, 0,
                                  compileList.length);
                 System.arraycopy(newFiles, 0, newCompileList,
                                  compileList.length, newFiles.length);
                 compileList = newCompileList;
             }
         }
     }
 
     private String[] findSupportedFileExtensions() {
         String compilerImpl = getCompiler();
         CompilerAdapter adapter =
             nestedAdapter != null ? nestedAdapter :
             CompilerAdapterFactory.getCompiler(compilerImpl, this,
                                                createCompilerClasspath());
         String[] extensions = null;
         if (adapter instanceof CompilerAdapterExtension) {
             extensions =
                 ((CompilerAdapterExtension) adapter).getSupportedFileExtensions();
         } 
 
         if (extensions == null) {
             extensions = new String[] { "java" };
         }
 
         // now process the extensions to ensure that they are the
         // right format
         for (int i = 0; i < extensions.length; i++) {
             if (!extensions[i].startsWith("*.")) {
                 extensions[i] = "*." + extensions[i];
             }
         }
         return extensions; 
     }
 
     /**
      * Gets the list of files to be compiled.
      * @return the list of files as an array
      */
     public File[] getFileList() {
         return compileList;
     }
 
     /**
      * Is the compiler implementation a jdk compiler
      *
      * @param compilerImpl the name of the compiler implementation
      * @return true if compilerImpl is "modern", "classic",
      * "javac1.1", "javac1.2", "javac1.3", "javac1.4", "javac1.5" or
      * "javac1.6".
      */
     protected boolean isJdkCompiler(String compilerImpl) {
         return MODERN.equals(compilerImpl)
             || CLASSIC.equals(compilerImpl)
             || JAVAC18.equals(compilerImpl)
             || JAVAC17.equals(compilerImpl)
             || JAVAC16.equals(compilerImpl)
             || JAVAC15.equals(compilerImpl)
             || JAVAC14.equals(compilerImpl)
             || JAVAC13.equals(compilerImpl)
             || JAVAC12.equals(compilerImpl)
             || JAVAC11.equals(compilerImpl);
     }
 
     /**
      * @return the executable name of the java compiler
      */
     protected String getSystemJavac() {
         return JavaEnvUtils.getJdkExecutable("javac");
     }
 
     /**
      * Choose the implementation for this particular task.
      * @param compiler the name of the compiler
      * @since Ant 1.5
      */
     public void setCompiler(String compiler) {
         facade.setImplementation(compiler);
     }
 
     /**
      * The implementation for this particular task.
      *
      * <p>Defaults to the build.compiler property but can be overridden
      * via the compiler and fork attributes.</p>
      *
      * <p>If fork has been set to true, the result will be extJavac
      * and not classic or java1.2 - no matter what the compiler
      * attribute looks like.</p>
      *
      * @see #getCompilerVersion
      * @return the compiler.
      * @since Ant 1.5
      */
     public String getCompiler() {
         String compilerImpl = getCompilerVersion();
         if (fork) {
             if (isJdkCompiler(compilerImpl)) {
                 compilerImpl = EXTJAVAC;
             } else {
                 log("Since compiler setting isn't classic or modern, "
                     + "ignoring fork setting.", Project.MSG_WARN);
             }
         }
         return compilerImpl;
     }
 
     /**
      * The implementation for this particular task.
      *
      * <p>Defaults to the build.compiler property but can be overridden
      * via the compiler attribute.</p>
      *
      * <p>This method does not take the fork attribute into
      * account.</p>
      *
      * @see #getCompiler
      * @return the compiler.
      *
      * @since Ant 1.5
      */
     public String getCompilerVersion() {
         facade.setMagicValue(getProject().getProperty("build.compiler"));
         return facade.getImplementation();
     }
 
     /**
      * Check that all required attributes have been set and nothing
      * silly has been entered.
      *
      * @since Ant 1.5
      * @exception BuildException if an error occurs
      */
     protected void checkParameters() throws BuildException {
         if (src == null) {
             throw new BuildException("srcdir attribute must be set!",
                                      getLocation());
         }
         if (src.size() == 0) {
             throw new BuildException("srcdir attribute must be set!",
                                      getLocation());
         }
 
         if (destDir != null && !destDir.isDirectory()) {
             throw new BuildException("destination directory \""
                                      + destDir
                                      + "\" does not exist "
                                      + "or is not a directory", getLocation());
         }
         if (includeAntRuntime == null && getProject().getProperty("build.sysclasspath") == null) {
             log(getLocation() + "warning: 'includeantruntime' was not set, " +
                     "defaulting to build.sysclasspath=last; set to false for repeatable builds",
                     Project.MSG_WARN);
         }
     }
 
     /**
      * Perform the compilation.
      *
      * @since Ant 1.5
      */
     protected void compile() {
         String compilerImpl = getCompiler();
 
         if (compileList.length > 0) {
             log("Compiling " + compileList.length + " source file"
                 + (compileList.length == 1 ? "" : "s")
                 + (destDir != null ? " to " + destDir : ""));
 
             if (listFiles) {
                 for (int i = 0; i < compileList.length; i++) {
                   String filename = compileList[i].getAbsolutePath();
                   log(filename);
                 }
             }
 
             CompilerAdapter adapter =
                 nestedAdapter != null ? nestedAdapter :
                 CompilerAdapterFactory.getCompiler(compilerImpl, this,
                                                    createCompilerClasspath());
 
             // now we need to populate the compiler adapter
             adapter.setJavac(this);
 
             // finally, lets execute the compiler!!
             if (adapter.execute()) {
                 // Success
                 if (createMissingPackageInfoClass) {
                     try {
                         generateMissingPackageInfoClasses(destDir != null
                                                           ? destDir
                                                           : getProject()
                                                           .resolveFile(src.list()[0]));
                     } catch (IOException x) {
                         // Should this be made a nonfatal warning?
                         throw new BuildException(x, getLocation());
                     }
                 }
             } else {
                 // Fail path
                 this.taskSuccess = false;
                 if (errorProperty != null) {
                     getProject().setNewProperty(
                         errorProperty, "true");
                 }
                 if (failOnError) {
                     throw new BuildException(FAIL_MSG, getLocation());
                 } else {
                     log(FAIL_MSG, Project.MSG_ERR);
                 }
             }
         }
     }
 
     /**
      * Adds an "compiler" attribute to Commandline$Attribute used to
      * filter command line attributes based on the current
      * implementation.
      */
     public class ImplementationSpecificArgument extends
         org.apache.tools.ant.util.facade.ImplementationSpecificArgument {
 
         /**
          * @param impl the name of the compiler
          */
         public void setCompiler(String impl) {
             super.setImplementation(impl);
         }
     }
 
     private void lookForPackageInfos(File srcDir, File[] newFiles) {
         for (int i = 0; i < newFiles.length; i++) {
             File f = newFiles[i];
             if (!f.getName().equals("package-info.java")) {
                 continue;
             }
             String path = FILE_UTILS.removeLeadingPath(srcDir, f).
                     replace(File.separatorChar, '/');
             String suffix = "/package-info.java";
             if (!path.endsWith(suffix)) {
                 log("anomalous package-info.java path: " + path, Project.MSG_WARN);
                 continue;
             }
             String pkg = path.substring(0, path.length() - suffix.length());
             packageInfos.put(pkg, new Long(f.lastModified()));
         }
     }
 
     /**
      * Ensure that every {@code package-info.java} produced a {@code package-info.class}.
      * Otherwise this task's up-to-date tracking mechanisms do not work.
      * @see <a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=43114">Bug #43114</a>
      */
     private void generateMissingPackageInfoClasses(File dest) throws IOException {
         for (Iterator i = packageInfos.entrySet().iterator(); i.hasNext(); ) {
             Map.Entry entry = (Map.Entry) i.next();
             String pkg = (String) entry.getKey();
             Long sourceLastMod = (Long) entry.getValue();
             File pkgBinDir = new File(dest, pkg.replace('/', File.separatorChar));
             pkgBinDir.mkdirs();
             File pkgInfoClass = new File(pkgBinDir, "package-info.class");
             if (pkgInfoClass.isFile() && pkgInfoClass.lastModified() >= sourceLastMod.longValue()) {
                 continue;
             }
             log("Creating empty " + pkgInfoClass);
             OutputStream os = new FileOutputStream(pkgInfoClass);
             try {
                 os.write(PACKAGE_INFO_CLASS_HEADER);
                 byte[] name = pkg.getBytes("UTF-8");
                 int length = name.length + /* "/package-info" */ 13;
                 os.write((byte) length / 256);
                 os.write((byte) length % 256);
                 os.write(name);
                 os.write(PACKAGE_INFO_CLASS_FOOTER);
             } finally {
                 os.close();
             }
         }
     }
     private static final byte[] PACKAGE_INFO_CLASS_HEADER = {
         (byte) 0xca, (byte) 0xfe, (byte) 0xba, (byte) 0xbe, 0x00, 0x00, 0x00,
         0x31, 0x00, 0x07, 0x07, 0x00, 0x05, 0x07, 0x00, 0x06, 0x01, 0x00, 0x0a,
         0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x01, 0x00,
         0x11, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x2d, 0x69, 0x6e, 0x66,
         0x6f, 0x2e, 0x6a, 0x61, 0x76, 0x61, 0x01
     };
     private static final byte[] PACKAGE_INFO_CLASS_FOOTER = {
         0x2f, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x2d, 0x69, 0x6e, 0x66,
         0x6f, 0x01, 0x00, 0x10, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e,
         0x67, 0x2f, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x02, 0x00, 0x00, 0x01,
         0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03,
         0x00, 0x00, 0x00, 0x02, 0x00, 0x04
     };
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Javadoc.java b/src/main/org/apache/tools/ant/taskdefs/Javadoc.java
index b91a06a66..93f93063e 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Javadoc.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Javadoc.java
@@ -64,2411 +64,2411 @@ import org.apache.tools.ant.util.JavaEnvUtils;
  *    <li>there is no control on arguments sanity since they are left
  *        to the Javadoc implementation.
  * </ul>
  *
  * <p>If no <code>doclet</code> is set, then the <code>version</code> and
  * <code>author</code> are by default <code>"yes"</code>.
  *
  * <p>Note: This task is run on another VM because the Javadoc code calls
  * <code>System.exit()</code> which would break Ant functionality.
  *
  * @since Ant 1.1
  *
  * @ant.task category="java"
  */
 public class Javadoc extends Task {
     // Whether *this VM* is 1.4+ (but also check executable != null).
 
     private static final boolean JAVADOC_5 = 
         !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_4);
 
     /**
      * Inner class used to manage doclet parameters.
      */
     public class DocletParam {
         /** The parameter name */
         private String name;
 
         /** The parameter value */
         private String value;
 
         /**
          * Set the name of the parameter.
          *
          * @param name the name of the doclet parameter
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * Get the parameter name.
          *
          * @return the parameter's name.
          */
         public String getName() {
             return name;
         }
 
         /**
          * Set the parameter value.
          *
          * Note that only string values are supported. No resolution of file
          * paths is performed.
          *
          * @param value the parameter value.
          */
         public void setValue(String value) {
             this.value = value;
         }
 
         /**
          * Get the parameter value.
          *
          * @return the parameter value.
          */
         public String getValue() {
             return value;
         }
     }
 
     /**
      * A project aware class used for Javadoc extensions which take a name
      * and a path such as doclet and taglet arguments.
      *
      */
     public static class ExtensionInfo extends ProjectComponent {
         /** The name of the extension */
         private String name;
 
         /** The optional path to use to load the extension */
         private Path path;
 
         /**
          * Set the name of the extension
          *
          * @param name the extension's name.
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * Get the name of the extension.
          *
          * @return the extension's name.
          */
         public String getName() {
             return name;
         }
 
         /**
          * Set the path to use when loading the component.
          *
          * @param path a Path instance containing the classpath to use.
          */
         public void setPath(Path path) {
             if (this.path == null) {
                 this.path = path;
             } else {
                 this.path.append(path);
             }
         }
 
         /**
          * Get the extension's path.
          *
          * @return the path to be used to load the extension.
          * May be <code>null</code>
          */
         public Path getPath() {
             return path;
         }
 
         /**
          * Create an empty nested path to be configured by Ant with the
          * classpath for the extension.
          *
          * @return a new Path instance to be configured.
          */
         public Path createPath() {
             if (path == null) {
                 path = new Path(getProject());
             }
             return path.createPath();
         }
 
         /**
          * Adds a reference to a CLASSPATH defined elsewhere.
          *
          * @param r the reference containing the path.
          */
         public void setPathRef(Reference r) {
             createPath().setRefid(r);
         }
     }
 
     /**
      * This class stores info about doclets.
      *
      */
     public class DocletInfo extends ExtensionInfo {
 
         /** Collection of doclet parameters. */
         private Vector params = new Vector();
 
         /**
          * Create a doclet parameter to be configured by Ant.
          *
          * @return a new DocletParam instance to be configured.
          */
         public DocletParam createParam() {
             DocletParam param = new DocletParam();
             params.addElement(param);
 
             return param;
         }
 
         /**
          * Get the doclet's parameters.
          *
          * @return an Enumeration of DocletParam instances.
          */
         public Enumeration getParams() {
             return params.elements();
         }
     }
 
     /**
      * Used to track info about the packages to be javadoc'd
      */
     public static class PackageName {
         /** The package name */
         private String name;
 
         /**
          * Set the name of the package
          *
          * @param name the package name.
          */
         public void setName(String name) {
             this.name = name.trim();
         }
 
         /**
          * Get the package name.
          *
          * @return the package's name.
          */
         public String getName() {
             return name;
         }
 
         /**
          * Return a string rep for this object.
          * @return the package name.
          */
         public String toString() {
             return getName();
         }
     }
 
     /**
      * This class is used to manage the source files to be processed.
      */
     public static class SourceFile {
         /** The source file */
         private File file;
 
         /**
          * Default constructor
          */
         public SourceFile() {
             //empty
         }
 
         /**
          * Constructor specifying the source file directly
          *
          * @param file the source file
          */
         public SourceFile(File file) {
             this.file = file;
         }
 
         /**
          * Set the source file.
          *
          * @param file the source file.
          */
         public void setFile(File file) {
             this.file = file;
         }
 
         /**
          * Get the source file.
          *
          * @return the source file.
          */
         public File getFile() {
             return file;
         }
     }
 
     /**
      * An HTML element in the Javadoc.
      *
      * This class is used for those Javadoc elements which contain HTML such as
      * footers, headers, etc.
      */
     public static class Html {
         /** The text for the element */
         private StringBuffer text = new StringBuffer();
 
         /**
          * Add text to the element.
          *
          * @param t the text to be added.
          */
         public void addText(String t) {
             text.append(t);
         }
 
         /**
          * Get the current text for the element.
          *
          * @return the current text.
          */
         public String getText() {
             return text.substring(0);
         }
     }
 
     /**
      * EnumeratedAttribute implementation supporting the Javadoc scoping
      * values.
      */
     public static class AccessType extends EnumeratedAttribute {
         /**
          * @return the allowed values for the access type.
          */
         public String[] getValues() {
             // Protected first so if any GUI tool offers a default
             // based on enum #0, it will be right.
             return new String[] {"protected", "public", "package", "private"};
         }
     }
 
     /**
      * Holds a collection of ResourceCollections.
      *
      * <p>A separate kind of container is needed since this task
      * contains special handling for FileSets that has to occur at
      * task runtime.</p>
      */
     public class ResourceCollectionContainer {
         private ArrayList rcs = new ArrayList();
         /**
          * Add a resource collection to the container.
          * @param rc the collection to add.
          */
         public void add(ResourceCollection rc) {
             rcs.add(rc);
         }
 
         /**
          * Get an iterator on the collection.
          * @return an iterator.
          */
         private Iterator iterator() {
             return rcs.iterator();
         }
     }
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /** The command line built to execute Javadoc. */
     private Commandline cmd = new Commandline();
 
     /**
      * Utility method to add an argument to the command line conditionally
      * based on the given flag.
      *
      * @param b the flag which controls if the argument is added.
      * @param arg the argument value.
      */
     private void addArgIf(boolean b, String arg) {
         if (b) {
             cmd.createArgument().setValue(arg);
         }
     }
 
     /**
      * Utility method to add a Javadoc argument.
      *
      * @param key the argument name.
      * @param value the argument value.
      */
     private void addArgIfNotEmpty(String key, String value) {
         if (value != null && value.length() != 0) {
             cmd.createArgument().setValue(key);
             cmd.createArgument().setValue(value);
         } else {
             log("Warning: Leaving out empty argument '" + key + "'",
                 Project.MSG_WARN);
         }
     }
 
     /**
      * Flag which indicates if the task should fail if there is a
      * Javadoc error.
      */
     private boolean failOnError = false;
     private Path sourcePath = null;
     private File destDir = null;
     private Vector sourceFiles = new Vector();
     private Vector packageNames = new Vector();
     private Vector excludePackageNames = new Vector(1);
     private boolean author = true;
     private boolean version = true;
     private DocletInfo doclet = null;
     private Path classpath = null;
     private Path bootclasspath = null;
     private String group = null;
     private String packageList = null;
     private Vector links = new Vector();
     private Vector groups = new Vector();
     private Vector tags = new Vector();
     private boolean useDefaultExcludes = true;
     private Html doctitle = null;
     private Html header = null;
     private Html footer = null;
     private Html bottom = null;
     private boolean useExternalFile = false;
     private String source = null;
     private boolean linksource = false;
     private boolean breakiterator = false;
     private String noqualifier;
     private boolean includeNoSourcePackages = false;
     private String executable = null;
     private boolean docFilesSubDirs = false;
     private String excludeDocFilesSubDir = null;
 
     private ResourceCollectionContainer nestedSourceFiles
         = new ResourceCollectionContainer();
     private Vector packageSets = new Vector();
 
     /**
      * Work around command line length limit by using an external file
      * for the sourcefiles.
      *
      * @param b true if an external file is to be used.
      */
     public void setUseExternalFile(boolean b) {
         useExternalFile = b;
     }
 
     /**
      * Sets whether default exclusions should be used or not.
      *
      * @param useDefaultExcludes "true"|"on"|"yes" when default exclusions
      *                           should be used, "false"|"off"|"no" when they
      *                           shouldn't be used.
      */
     public void setDefaultexcludes(boolean useDefaultExcludes) {
         this.useDefaultExcludes = useDefaultExcludes;
     }
 
     /**
      * Set the maximum memory to be used by the javadoc process
      *
      * @param max a string indicating the maximum memory according to the
      *        JVM conventions (e.g. 128m is 128 Megabytes)
      */
     public void setMaxmemory(String max) {
         cmd.createArgument().setValue("-J-Xmx" + max);
     }
 
     /**
      * Set an additional parameter on the command line
      *
      * @param add the additional command line parameter for the javadoc task.
      */
     public void setAdditionalparam(String add) {
         cmd.createArgument().setLine(add);
     }
 
     /**
      * Adds a command-line argument.
      * @return a command-line argument to configure
      * @since Ant 1.6
      */
     public Commandline.Argument createArg() {
         return cmd.createArgument();
     }
 
     /**
      * Specify where to find source file
      *
      * @param src a Path instance containing the various source directories.
      */
     public void setSourcepath(Path src) {
         if (sourcePath == null) {
             sourcePath = src;
         } else {
             sourcePath.append(src);
         }
     }
 
     /**
      * Create a path to be configured with the locations of the source
      * files.
      *
      * @return a new Path instance to be configured by the Ant core.
      */
     public Path createSourcepath() {
         if (sourcePath == null) {
             sourcePath = new Path(getProject());
         }
         return sourcePath.createPath();
     }
 
     /**
      * Adds a reference to a CLASSPATH defined elsewhere.
      *
      * @param r the reference containing the source path definition.
      */
     public void setSourcepathRef(Reference r) {
         createSourcepath().setRefid(r);
     }
 
     /**
      * Set the directory where the Javadoc output will be generated.
      *
      * @param dir the destination directory.
      */
     public void setDestdir(File dir) {
         destDir = dir;
         cmd.createArgument().setValue("-d");
         cmd.createArgument().setFile(destDir);
     }
 
     /**
      * Set the list of source files to process.
      *
      * @param src a comma separated list of source files.
      */
     public void setSourcefiles(String src) {
         StringTokenizer tok = new StringTokenizer(src, ",");
         while (tok.hasMoreTokens()) {
             String f = tok.nextToken();
             SourceFile sf = new SourceFile();
             sf.setFile(getProject().resolveFile(f.trim()));
             addSource(sf);
         }
     }
 
     /**
      * Add a single source file.
      *
      * @param sf the source file to be processed.
      */
     public void addSource(SourceFile sf) {
         sourceFiles.addElement(sf);
     }
 
     /**
      * Set the package names to be processed.
      *
      * @param packages a comma separated list of packages specs
      *        (may be wildcarded).
      *
      * @see #addPackage for wildcard information.
      */
     public void setPackagenames(String packages) {
         StringTokenizer tok = new StringTokenizer(packages, ",");
         while (tok.hasMoreTokens()) {
             String p = tok.nextToken();
             PackageName pn = new PackageName();
             pn.setName(p);
             addPackage(pn);
         }
     }
 
     /**
      * Add a single package to be processed.
      *
      * If the package name ends with &quot;.*&quot; the Javadoc task
      * will find and process all subpackages.
      *
      * @param pn the package name, possibly wildcarded.
      */
     public void addPackage(PackageName pn) {
         packageNames.addElement(pn);
     }
 
     /**
      * Set the list of packages to be excluded.
      *
      * @param packages a comma separated list of packages to be excluded.
      *        This may not include wildcards.
      */
     public void setExcludePackageNames(String packages) {
         StringTokenizer tok = new StringTokenizer(packages, ",");
         while (tok.hasMoreTokens()) {
             String p = tok.nextToken();
             PackageName pn = new PackageName();
             pn.setName(p);
             addExcludePackage(pn);
         }
     }
 
     /**
      * Add a package to be excluded from the Javadoc run.
      *
      * @param pn the name of the package (wildcards are not permitted).
      */
     public void addExcludePackage(PackageName pn) {
         excludePackageNames.addElement(pn);
     }
 
     /**
      * Specify the file containing the overview to be included in the generated
      * documentation.
      *
      * @param f the file containing the overview.
      */
     public void setOverview(File f) {
         cmd.createArgument().setValue("-overview");
         cmd.createArgument().setFile(f);
     }
 
     /**
      * Indicate whether only public classes and members are to be included in
      * the scope processed
      *
      * @param b true if scope is to be public.
      */
     public void setPublic(boolean b) {
         addArgIf(b, "-public");
     }
 
     /**
      * Indicate whether only protected and public classes and members are to
      * be included in the scope processed
      *
      * @param b true if scope is to be protected.
      */
     public void setProtected(boolean b) {
         addArgIf(b, "-protected");
     }
 
     /**
      * Indicate whether only package, protected and public classes and
      * members are to be included in the scope processed
      *
      * @param b true if scope is to be package level.
      */
     public void setPackage(boolean b) {
         addArgIf(b, "-package");
     }
 
     /**
      * Indicate whether all classes and
      * members are to be included in the scope processed
      *
      * @param b true if scope is to be private level.
      */
     public void setPrivate(boolean b) {
         addArgIf(b, "-private");
     }
 
     /**
      * Set the scope to be processed. This is an alternative to the
      * use of the setPublic, setPrivate, etc methods. It gives better build
      * file control over what scope is processed.
      *
      * @param at the scope to be processed.
      */
     public void setAccess(AccessType at) {
         cmd.createArgument().setValue("-" + at.getValue());
     }
 
     /**
      * Set the class that starts the doclet used in generating the
      * documentation.
      *
      * @param docletName the name of the doclet class.
      */
     public void setDoclet(String docletName) {
         if (doclet == null) {
             doclet = new DocletInfo();
             doclet.setProject(getProject());
         }
         doclet.setName(docletName);
     }
 
     /**
      * Set the classpath used to find the doclet class.
      *
      * @param docletPath the doclet classpath.
      */
     public void setDocletPath(Path docletPath) {
         if (doclet == null) {
             doclet = new DocletInfo();
             doclet.setProject(getProject());
         }
         doclet.setPath(docletPath);
     }
 
     /**
      * Set the classpath used to find the doclet class by reference.
      *
      * @param r the reference to the Path instance to use as the doclet
      *        classpath.
      */
     public void setDocletPathRef(Reference r) {
         if (doclet == null) {
             doclet = new DocletInfo();
             doclet.setProject(getProject());
         }
         doclet.createPath().setRefid(r);
     }
 
     /**
      * Create a doclet to be used in the documentation generation.
      *
      * @return a new DocletInfo instance to be configured.
      */
     public DocletInfo createDoclet() {
         if (doclet == null) {
             doclet = new DocletInfo();
         }
         return doclet;
     }
 
     /**
      * Add a taglet
      *
      * @param tagletInfo information about the taglet.
      */
     public void addTaglet(ExtensionInfo tagletInfo) {
         tags.addElement(tagletInfo);
     }
 
     /**
      * Indicate whether Javadoc should produce old style (JDK 1.1)
      * documentation.
      *
      * This is not supported by JDK 1.1 and has been phased out in JDK 1.4
      *
      * @param b if true attempt to generate old style documentation.
      */
     public void setOld(boolean b) {
         log("Javadoc 1.4 doesn't support the -1.1 switch anymore",
             Project.MSG_WARN);
     }
 
     /**
      * Set the classpath to be used for this Javadoc run.
      *
      * @param path an Ant Path object containing the compilation
      *        classpath.
      */
     public void setClasspath(Path path) {
         if (classpath == null) {
             classpath = path;
         } else {
             classpath.append(path);
         }
     }
 
     /**
      * Create a Path to be configured with the classpath to use
      *
      * @return a new Path instance to be configured with the classpath.
      */
     public Path createClasspath() {
         if (classpath == null) {
             classpath = new Path(getProject());
         }
         return classpath.createPath();
     }
 
     /**
      * Adds a reference to a CLASSPATH defined elsewhere.
      *
      * @param r the reference to an instance defining the classpath.
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * Set the boot classpath to use.
      *
      * @param path the boot classpath.
      */
     public void setBootclasspath(Path path) {
         if (bootclasspath == null) {
             bootclasspath = path;
         } else {
             bootclasspath.append(path);
         }
     }
 
     /**
      * Create a Path to be configured with the boot classpath
      *
      * @return a new Path instance to be configured with the boot classpath.
      */
     public Path createBootclasspath() {
         if (bootclasspath == null) {
             bootclasspath = new Path(getProject());
         }
         return bootclasspath.createPath();
     }
 
     /**
      * Adds a reference to a CLASSPATH defined elsewhere.
      *
      * @param r the reference to an instance defining the bootclasspath.
      */
     public void setBootClasspathRef(Reference r) {
         createBootclasspath().setRefid(r);
     }
 
     /**
      * Set the location of the extensions directories.
      *
      * @param path the string version of the path.
      * @deprecated since 1.5.x.
      *             Use the {@link #setExtdirs(Path)} version.
      */
     public void setExtdirs(String path) {
         cmd.createArgument().setValue("-extdirs");
         cmd.createArgument().setValue(path);
     }
 
     /**
      * Set the location of the extensions directories.
      *
      * @param path a path containing the extension directories.
      */
     public void setExtdirs(Path path) {
         cmd.createArgument().setValue("-extdirs");
         cmd.createArgument().setPath(path);
     }
 
     /**
      * Run javadoc in verbose mode
      *
      * @param b true if operation is to be verbose.
      */
     public void setVerbose(boolean b) {
         addArgIf(b, "-verbose");
     }
 
     /**
      * Set the local to use in documentation generation.
      *
      * @param locale the locale to use.
      */
     public void setLocale(String locale) {
         // createArgument(true) is necessary to make sure -locale
         // is the first argument (required in 1.3+).
         cmd.createArgument(true).setValue(locale);
         cmd.createArgument(true).setValue("-locale");
     }
 
     /**
      * Set the encoding name of the source files,
      *
      * @param enc the name of the encoding for the source files.
      */
     public void setEncoding(String enc) {
         cmd.createArgument().setValue("-encoding");
         cmd.createArgument().setValue(enc);
     }
 
     /**
      * Include the version tag in the generated documentation.
      *
      * @param b true if the version tag should be included.
      */
     public void setVersion(boolean b) {
         this.version = b;
     }
 
     /**
      * Generate the &quot;use&quot page for each package.
      *
      * @param b true if the use page should be generated.
      */
     public void setUse(boolean b) {
         addArgIf(b, "-use");
     }
 
 
     /**
      * Include the author tag in the generated documentation.
      *
      * @param b true if the author tag should be included.
      */
     public void setAuthor(boolean b) {
         author = b;
     }
 
     /**
      * Generate a split index
      *
      * @param b true if the index should be split into a file per letter.
      */
     public void setSplitindex(boolean b) {
         addArgIf(b, "-splitindex");
     }
 
     /**
      * Set the title to be placed in the HTML &lt;title&gt; tag of the
      * generated documentation.
      *
      * @param title the window title to use.
      */
     public void setWindowtitle(String title) {
         addArgIfNotEmpty("-windowtitle", title);
     }
 
     /**
      * Set the title of the generated overview page.
      *
      * @param doctitle the Document title.
      */
     public void setDoctitle(String doctitle) {
         Html h = new Html();
         h.addText(doctitle);
         addDoctitle(h);
     }
 
     /**
      * Add a document title to use for the overview page.
      *
      * @param text the HTML element containing the document title.
      */
     public void addDoctitle(Html text) {
         doctitle = text;
     }
 
     /**
      * Set the header text to be placed at the top of each output file.
      *
      * @param header the header text
      */
     public void setHeader(String header) {
         Html h = new Html();
         h.addText(header);
         addHeader(h);
     }
 
     /**
      * Set the header text to be placed at the top of each output file.
      *
      * @param text the header text
      */
     public void addHeader(Html text) {
         header = text;
     }
 
     /**
      * Set the footer text to be placed at the bottom of each output file.
      *
      * @param footer the footer text.
      */
     public void setFooter(String footer) {
         Html h = new Html();
         h.addText(footer);
         addFooter(h);
     }
 
     /**
      * Set the footer text to be placed at the bottom of each output file.
      *
      * @param text the footer text.
      */
     public void addFooter(Html text) {
         footer = text;
     }
 
     /**
      * Set the text to be placed at the bottom of each output file.
      *
      * @param bottom the bottom text.
      */
     public void setBottom(String bottom) {
         Html h = new Html();
         h.addText(bottom);
         addBottom(h);
     }
 
     /**
      * Set the text to be placed at the bottom of each output file.
      *
      * @param text the bottom text.
      */
     public void addBottom(Html text) {
         bottom = text;
     }
 
     /**
      * Link to docs at "url" using package list at "url2"
      * - separate the URLs by using a space character.
      *
      * @param src the offline link specification (url and package list)
      */
     public void setLinkoffline(String src) {
         LinkArgument le = createLink();
         le.setOffline(true);
         String linkOfflineError = "The linkoffline attribute must include"
             + " a URL and a package-list file location separated by a"
             + " space";
         if (src.trim().length() == 0) {
             throw new BuildException(linkOfflineError);
         }
         StringTokenizer tok = new StringTokenizer(src, " ", false);
         le.setHref(tok.nextToken());
 
         if (!tok.hasMoreTokens()) {
             throw new BuildException(linkOfflineError);
         }
         le.setPackagelistLoc(getProject().resolveFile(tok.nextToken()));
     }
 
     /**
      * Group specified packages together in overview page.
      *
      * @param src the group packages - a command separated list of group specs,
      *        each one being a group name and package specification separated
      *        by a space.
      */
     public void setGroup(String src) {
         group = src;
     }
 
     /**
      * Create links to Javadoc output at the given URL.
      * @param src the URL to link to
      */
     public void setLink(String src) {
         createLink().setHref(src);
     }
 
     /**
-     * Control deprecation infromation
+     * Control deprecation information
      *
      * @param b If true, do not include deprecated information.
      */
     public void setNodeprecated(boolean b) {
         addArgIf(b, "-nodeprecated");
     }
 
     /**
      * Control deprecated list generation
      *
      * @param b if true, do not generate deprecated list.
      */
     public void setNodeprecatedlist(boolean b) {
         addArgIf(b, "-nodeprecatedlist");
     }
 
     /**
      * Control class tree generation.
      *
      * @param b if true, do not generate class hierarchy.
      */
     public void setNotree(boolean b) {
         addArgIf(b, "-notree");
     }
 
     /**
      * Control generation of index.
      *
      * @param b if true, do not generate index.
      */
     public void setNoindex(boolean b) {
         addArgIf(b, "-noindex");
     }
 
     /**
      * Control generation of help link.
      *
      * @param b if true, do not generate help link
      */
     public void setNohelp(boolean b) {
         addArgIf(b, "-nohelp");
     }
 
     /**
      * Control generation of the navigation bar.
      *
      * @param b if true, do not generate navigation bar.
      */
     public void setNonavbar(boolean b) {
         addArgIf(b, "-nonavbar");
     }
 
     /**
      * Control warnings about serial tag.
      *
      * @param b if true, generate warning about the serial tag.
      */
     public void setSerialwarn(boolean b) {
         addArgIf(b, "-serialwarn");
     }
 
     /**
      * Specifies the CSS stylesheet file to use.
      *
      * @param f the file with the CSS to use.
      */
     public void setStylesheetfile(File f) {
         cmd.createArgument().setValue("-stylesheetfile");
         cmd.createArgument().setFile(f);
     }
 
     /**
      * Specifies the HTML help file to use.
      *
      * @param f the file containing help content.
      */
     public void setHelpfile(File f) {
         cmd.createArgument().setValue("-helpfile");
         cmd.createArgument().setFile(f);
     }
 
     /**
      * Output file encoding name.
      *
      * @param enc name of the encoding to use.
      */
     public void setDocencoding(String enc) {
         cmd.createArgument().setValue("-docencoding");
         cmd.createArgument().setValue(enc);
     }
 
     /**
      * The name of a file containing the packages to process.
      *
      * @param src the file containing the package list.
      */
     public void setPackageList(String src) {
         packageList = src;
     }
 
     /**
      * Create link to Javadoc output at the given URL.
      *
      * @return link argument to configure
      */
     public LinkArgument createLink() {
         LinkArgument la = new LinkArgument();
         links.addElement(la);
         return la;
     }
 
     /**
      * Represents a link triplet (href, whether link is offline,
      * location of the package list if off line)
      */
     public class LinkArgument {
         private String href;
         private boolean offline = false;
         private File packagelistLoc;
         private URL packagelistURL;
         private boolean resolveLink = false;
 
-        /** Constructor for LinkArguement */
+        /** Constructor for LinkArgument */
         public LinkArgument() {
             //empty
         }
 
         /**
          * Set the href attribute.
          * @param hr a <code>String</code> value
          */
         public void setHref(String hr) {
             href = hr;
         }
 
         /**
          * Get the href attribute.
          * @return the href attribute.
          */
         public String getHref() {
             return href;
         }
 
         /**
          * Set the packetlist location attribute.
          * @param src a <code>File</code> value
          */
         public void setPackagelistLoc(File src) {
             packagelistLoc = src;
         }
 
         /**
          * Get the packetList location attribute.
          * @return the packetList location attribute.
          */
         public File getPackagelistLoc() {
             return packagelistLoc;
         }
 
         /**
          * Set the packetlist location attribute.
          * @param src an <code>URL</code> value
          */
         public void setPackagelistURL(URL src) {
             packagelistURL = src;
         }
 
         /**
          * Get the packetList location attribute.
          * @return the packetList location attribute.
          */
         public URL getPackagelistURL() {
             return packagelistURL;
         }
 
         /**
          * Set the offline attribute.
          * @param offline a <code>boolean</code> value
          */
         public void setOffline(boolean offline) {
             this.offline = offline;
         }
 
         /**
          * Get the linkOffline attribute.
          * @return the linkOffline attribute.
          */
         public boolean isLinkOffline() {
             return offline;
         }
 
         /**
          * Sets whether Ant should resolve the link attribute relative
          * to the current basedir.
          * @param resolve a <code>boolean</code> value
          */
         public void setResolveLink(boolean resolve) {
             this.resolveLink = resolve;
         }
 
         /**
          * should Ant resolve the link attribute relative to the
          * current basedir?
          * @return the resolveLink attribute.
          */
         public boolean shouldResolveLink() {
             return resolveLink;
         }
 
     }
 
     /**
      * Creates and adds a -tag argument. This is used to specify
      * custom tags. This argument is only available for Javadoc 1.4,
      * and will generate a verbose message (and then be ignored)
      * when run on Java versions below 1.4.
      * @return tag argument to be configured
      */
     public TagArgument createTag() {
         TagArgument ta = new TagArgument();
         tags.addElement (ta);
         return ta;
     }
 
     /**
      * Scope element verbose names. (Defined here as fields
      * cannot be static in inner classes.) The first letter
      * from each element is used to build up the scope string.
      */
     static final String[] SCOPE_ELEMENTS = {
         "overview", "packages", "types", "constructors",
         "methods", "fields"
     };
 
     /**
      * Class representing a -tag argument.
      */
     public class TagArgument extends FileSet {
         /** Name of the tag. */
         private String name = null;
         /** Whether or not the tag is enabled. */
         private boolean enabled = true;
         /**
          * Scope string of the tag. This will form the middle
          * argument of the -tag parameter when the tag is enabled
          * (with an X prepended for and is parsed from human-readable form.
          */
         private String scope = "a";
 
         /** Sole constructor. */
         public TagArgument () {
             //empty
         }
 
         /**
          * Sets the name of the tag.
          *
          * @param name The name of the tag.
          *             Must not be <code>null</code> or empty.
          */
         public void setName (String name) {
             this.name = name;
         }
 
         /**
          * Sets the scope of the tag. This is in comma-separated
          * form, with each element being one of "all" (the default),
          * "overview", "packages", "types", "constructors", "methods",
          * "fields". The elements are treated in a case-insensitive
          * manner.
          *
          * @param verboseScope The scope of the tag.
          *                     Must not be <code>null</code>,
          *                     should not be empty.
          *
          * @exception BuildException if all is specified along with
          * other elements, if any elements are repeated, if no
          * elements are specified, or if any unrecognised elements are
          * specified.
          */
         public void setScope (String verboseScope) throws BuildException {
             verboseScope = verboseScope.toLowerCase(Locale.ENGLISH);
 
             boolean[] elements = new boolean[SCOPE_ELEMENTS.length];
 
             boolean gotAll = false;
             boolean gotNotAll = false;
 
             // Go through the tokens one at a time, updating the
             // elements array and issuing warnings where appropriate.
             StringTokenizer tok = new StringTokenizer (verboseScope, ",");
             while (tok.hasMoreTokens()) {
                 String next = tok.nextToken().trim();
                 if (next.equals("all")) {
                     if (gotAll) {
                         getProject().log ("Repeated tag scope element: all",
                                           Project.MSG_VERBOSE);
                     }
                     gotAll = true;
                 } else {
                     int i;
                     for (i = 0; i < SCOPE_ELEMENTS.length; i++) {
                         if (next.equals (SCOPE_ELEMENTS[i])) {
                             break;
                         }
                     }
                     if (i == SCOPE_ELEMENTS.length) {
                         throw new BuildException ("Unrecognised scope element: "
                                                   + next);
                     } else {
                         if (elements[i]) {
                             getProject().log ("Repeated tag scope element: "
                                               + next, Project.MSG_VERBOSE);
                         }
                         elements[i] = true;
                         gotNotAll = true;
                     }
                 }
             }
 
             if (gotNotAll && gotAll) {
                 throw new BuildException ("Mixture of \"all\" and other scope "
                                           + "elements in tag parameter.");
             }
             if (!gotNotAll && !gotAll) {
                 throw new BuildException ("No scope elements specified in tag "
                                           + "parameter.");
             }
             if (gotAll) {
                 this.scope = "a";
             } else {
                 StringBuffer buff = new StringBuffer (elements.length);
                 for (int i = 0; i < elements.length; i++) {
                     if (elements[i]) {
                         buff.append (SCOPE_ELEMENTS[i].charAt(0));
                     }
                 }
                 this.scope = buff.toString();
             }
         }
 
         /**
          * Sets whether or not the tag is enabled.
          *
          * @param enabled Whether or not this tag is enabled.
          */
         public void setEnabled (boolean enabled) {
             this.enabled = enabled;
         }
 
         /**
          * Returns the -tag parameter this argument represented.
          * @return the -tag parameter as a string
          * @exception BuildException if either the name or description
          *                           is <code>null</code> or empty.
          */
         public String getParameter() throws BuildException {
             if (name == null || name.equals("")) {
                 throw new BuildException ("No name specified for custom tag.");
             }
             if (getDescription() != null) {
                 return name + ":" + (enabled ? "" : "X")
                     + scope + ":" + getDescription();
             } else if (!enabled || !"a".equals(scope)) {
                 return name + ":" + (enabled ? "" : "X") + scope;
             } else {
                 return name;
             }
         }
     }
 
     /**
      * Separates packages on the overview page into whatever
      * groups you specify, one group per table.
      * @return a group argument to be configured
      */
     public GroupArgument createGroup() {
         GroupArgument ga = new GroupArgument();
         groups.addElement(ga);
         return ga;
     }
 
 
     /**
      * A class corresponding to the group nested element.
      */
     public class GroupArgument {
         private Html title;
         private Vector packages = new Vector();
 
         /** Constructor for GroupArgument */
         public GroupArgument() {
             //empty
         }
 
         /**
          * Set the title attribute using a string.
          * @param src a <code>String</code> value
          */
         public void setTitle(String src) {
             Html h = new Html();
             h.addText(src);
             addTitle(h);
         }
         /**
          * Set the title attribute using a nested Html value.
          * @param text a <code>Html</code> value
          */
         public void addTitle(Html text) {
             title = text;
         }
 
         /**
          * Get the title.
          * @return the title
          */
         public String getTitle() {
             return title != null ? title.getText() : null;
         }
 
         /**
          * Set the packages to Javadoc on.
          * @param src a comma separated list of packages
          */
         public void setPackages(String src) {
             StringTokenizer tok = new StringTokenizer(src, ",");
             while (tok.hasMoreTokens()) {
                 String p = tok.nextToken();
                 PackageName pn = new PackageName();
                 pn.setName(p);
                 addPackage(pn);
             }
         }
         /**
          * Add a package nested element.
-         * @param pn a nested element specifing the package.
+         * @param pn a nested element specifying the package.
          */
         public void addPackage(PackageName pn) {
             packages.addElement(pn);
         }
 
         /**
-         * Get the packages as a collon separated list.
+         * Get the packages as a colon separated list.
          * @return the packages as a string
          */
         public String getPackages() {
             StringBuffer p = new StringBuffer();
             final int size = packages.size();
             for (int i = 0; i < size; i++) {
                 if (i > 0) {
                     p.append(":");
                 }
                 p.append(packages.elementAt(i).toString());
             }
             return p.toString();
         }
     }
 
     /**
      * Charset for cross-platform viewing of generated documentation.
      * @param src the name of the charset
      */
     public void setCharset(String src) {
         this.addArgIfNotEmpty("-charset", src);
     }
 
     /**
      * Should the build process fail if Javadoc fails (as indicated by
      * a non zero return code)?
      *
      * <p>Default is false.</p>
      * @param b a <code>boolean</code> value
      */
     public void setFailonerror(boolean b) {
         failOnError = b;
     }
 
     /**
      * Enables the -source switch, will be ignored if Javadoc is not
      * the 1.4 version.
      * @param source a <code>String</code> value
      * @since Ant 1.5
      */
     public void setSource(String source) {
         this.source = source;
     }
 
     /**
      * Sets the actual executable command to invoke, instead of the binary
      * <code>javadoc</code> found in Ant's JDK.
      * @param executable the command to invoke.
      * @since Ant 1.6.3
      */
     public void setExecutable(String executable) {
         this.executable = executable;
     }
 
     /**
      * Adds a packageset.
      *
      * <p>All included directories will be translated into package
      * names be converting the directory separator into dots.</p>
      * @param packageSet a directory set
      * @since 1.5
      */
     public void addPackageset(DirSet packageSet) {
         packageSets.addElement(packageSet);
     }
 
     /**
      * Adds a fileset.
      *
      * <p>All included files will be added as sourcefiles.  The task
      * will automatically add
      * <code>includes=&quot;**&#47;*.java&quot;</code> to the
      * fileset.</p>
      * @param fs a file set
      * @since 1.5
      */
     public void addFileset(FileSet fs) {
         createSourceFiles().add(fs);
     }
 
     /**
      * Adds a container for resource collections.
      *
      * <p>All included files will be added as sourcefiles.</p>
      * @return the source files to configure.
      * @since 1.7
      */
     public ResourceCollectionContainer createSourceFiles() {
         return nestedSourceFiles;
     }
 
     /**
      * Enables the -linksource switch, will be ignored if Javadoc is not
      * the 1.4 version. Default is false
      * @param b a <code>String</code> value
      * @since Ant 1.6
      */
     public void setLinksource(boolean b) {
         this.linksource = b;
     }
 
     /**
      * Enables the -linksource switch, will be ignored if Javadoc is not
      * the 1.4 version. Default is false
      * @param b a <code>String</code> value
      * @since Ant 1.6
      */
     public void setBreakiterator(boolean b) {
         this.breakiterator = b;
     }
 
     /**
      * Enables the -noqualifier switch, will be ignored if Javadoc is not
      * the 1.4 version.
      * @param noqualifier the parameter to the -noqualifier switch
      * @since Ant 1.6
      */
     public void setNoqualifier(String noqualifier) {
         this.noqualifier = noqualifier;
     }
 
     /**
      * If set to true, Ant will also accept packages that only hold
      * package.html files but no Java sources.
      * @param b a <code>boolean</code> value.
      * @since Ant 1.6.3
      */
     public void setIncludeNoSourcePackages(boolean b) {
         this.includeNoSourcePackages = b;
     }
 
     /**
      * Enables deep-copying of <code>doc-files</code> directories.
      *
      * @since Ant 1.8.0
      */
     public void setDocFilesSubDirs(boolean b) {
         docFilesSubDirs = b;
     }
 
     /**
      * Colon-separated list of <code>doc-files</code> subdirectories
      * to skip if {@link #setDocFilesSubDirs docFilesSubDirs is true}.
      *
      * @since Ant 1.8.0
      */
     public void setExcludeDocFilesSubDir(String s) {
         excludeDocFilesSubDir = s;
     }
 
     /**
      * Execute the task.
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
         checkTaskName();
 
         Vector packagesToDoc = new Vector();
         Path sourceDirs = new Path(getProject());
 
         checkPackageAndSourcePath();
 
         if (sourcePath != null) {
             sourceDirs.addExisting(sourcePath);
         }
 
         parsePackages(packagesToDoc, sourceDirs);
         checkPackages(packagesToDoc, sourceDirs);
 
         Vector sourceFilesToDoc = (Vector) sourceFiles.clone();
         addSourceFiles(sourceFilesToDoc);
 
         checkPackagesToDoc(packagesToDoc, sourceFilesToDoc);
 
         log("Generating Javadoc", Project.MSG_INFO);
 
         Commandline toExecute = (Commandline) cmd.clone();
         if (executable != null) {
             toExecute.setExecutable(executable);
         } else {
             toExecute.setExecutable(JavaEnvUtils.getJdkExecutable("javadoc"));
         }
 
         //  Javadoc arguments
         generalJavadocArguments(toExecute);  // general Javadoc arguments
         doSourcePath(toExecute, sourceDirs); // sourcepath
         doDoclet(toExecute);   // arguments for default doclet
         doBootPath(toExecute); // bootpath
         doLinks(toExecute);    // links arguments
         doGroup(toExecute);    // group attribute
         doGroups(toExecute);  // groups attribute
         doDocFilesSubDirs(toExecute); // docfilessubdir attribute
 
         doJava14(toExecute);
         if (breakiterator && (doclet == null || JAVADOC_5)) {
             toExecute.createArgument().setValue("-breakiterator");
         }
         // If using an external file, write the command line options to it
         if (useExternalFile) {
             writeExternalArgs(toExecute);
         }
 
         File tmpList = null;
         FileWriter wr = null;
         try {
             /**
              * Write sourcefiles and package names to a temporary file
              * if requested.
              */
             BufferedWriter srcListWriter = null;
             if (useExternalFile) {
                 tmpList = FILE_UTILS.createTempFile("javadoc", "", null, true, true);
                 toExecute.createArgument()
                     .setValue("@" + tmpList.getAbsolutePath());
                 wr = new FileWriter(tmpList.getAbsolutePath(), true);
                 srcListWriter = new BufferedWriter(wr);
             }
 
             doSourceAndPackageNames(
                 toExecute, packagesToDoc, sourceFilesToDoc,
                 useExternalFile, tmpList, srcListWriter);
 
             if (useExternalFile) {
                 srcListWriter.flush();
             }
         } catch (IOException e) {
             tmpList.delete();
             throw new BuildException("Error creating temporary file",
                                      e, getLocation());
         } finally {
             FileUtils.close(wr);
         }
 
         if (packageList != null) {
             toExecute.createArgument().setValue("@" + packageList);
         }
         log(toExecute.describeCommand(), Project.MSG_VERBOSE);
 
         log("Javadoc execution", Project.MSG_INFO);
 
         JavadocOutputStream out = new JavadocOutputStream(Project.MSG_INFO);
         JavadocOutputStream err = new JavadocOutputStream(Project.MSG_WARN);
         Execute exe = new Execute(new PumpStreamHandler(out, err));
         exe.setAntRun(getProject());
 
         /*
          * No reason to change the working directory as all filenames and
          * path components have been resolved already.
          *
          * Avoid problems with command line length in some environments.
          */
         exe.setWorkingDirectory(null);
         try {
             exe.setCommandline(toExecute.getCommandline());
             int ret = exe.execute();
             if (ret != 0 && failOnError) {
                 throw new BuildException("Javadoc returned " + ret,
                                          getLocation());
             }
         } catch (IOException e) {
             throw new BuildException("Javadoc failed: " + e, e, getLocation());
         } finally {
             if (tmpList != null) {
                 tmpList.delete();
                 tmpList = null;
             }
 
             out.logFlush();
             err.logFlush();
             try {
                 out.close();
                 err.close();
             } catch (IOException e) {
                 // ignore
             }
         }
     }
 
     private void checkTaskName() {
         if ("javadoc2".equals(getTaskType())) {
             log("Warning: the task name <javadoc2> is deprecated."
                 + " Use <javadoc> instead.",
                 Project.MSG_WARN);
         }
     }
 
     private void checkPackageAndSourcePath() {
         if (packageList != null && sourcePath == null) {
             String msg = "sourcePath attribute must be set when "
                 + "specifying packagelist.";
             throw new BuildException(msg);
         }
     }
 
     private void checkPackages(Vector packagesToDoc, Path sourceDirs) {
         if (packagesToDoc.size() != 0 && sourceDirs.size() == 0) {
             String msg = "sourcePath attribute must be set when "
                 + "specifying package names.";
             throw new BuildException(msg);
         }
     }
 
     private void checkPackagesToDoc(
         Vector packagesToDoc, Vector sourceFilesToDoc) {
         if (packageList == null && packagesToDoc.size() == 0
             && sourceFilesToDoc.size() == 0) {
             throw new BuildException("No source files and no packages have "
                                      + "been specified.");
         }
     }
 
     private void doSourcePath(Commandline toExecute, Path sourceDirs) {
         if (sourceDirs.size() > 0) {
             toExecute.createArgument().setValue("-sourcepath");
             toExecute.createArgument().setPath(sourceDirs);
         }
     }
 
     private void generalJavadocArguments(Commandline toExecute) {
         if (doctitle != null) {
             toExecute.createArgument().setValue("-doctitle");
             toExecute.createArgument().setValue(expand(doctitle.getText()));
         }
         if (header != null) {
             toExecute.createArgument().setValue("-header");
             toExecute.createArgument().setValue(expand(header.getText()));
         }
         if (footer != null) {
             toExecute.createArgument().setValue("-footer");
             toExecute.createArgument().setValue(expand(footer.getText()));
         }
         if (bottom != null) {
             toExecute.createArgument().setValue("-bottom");
             toExecute.createArgument().setValue(expand(bottom.getText()));
         }
 
         if (classpath == null) {
             classpath = (new Path(getProject())).concatSystemClasspath("last");
         } else {
             classpath = classpath.concatSystemClasspath("ignore");
         }
 
         if (classpath.size() > 0) {
             toExecute.createArgument().setValue("-classpath");
             toExecute.createArgument().setPath(classpath);
         }
 
         if (version && doclet == null) {
             toExecute.createArgument().setValue("-version");
         }
         if (author && doclet == null) {
             toExecute.createArgument().setValue("-author");
         }
 
         if (doclet == null && destDir == null) {
             throw new BuildException("destdir attribute must be set!");
         }
     }
 
     private void doDoclet(Commandline toExecute) {
         if (doclet != null) {
             if (doclet.getName() == null) {
                 throw new BuildException("The doclet name must be "
                                          + "specified.", getLocation());
             } else {
                 toExecute.createArgument().setValue("-doclet");
                 toExecute.createArgument().setValue(doclet.getName());
                 if (doclet.getPath() != null) {
                     Path docletPath
                         = doclet.getPath().concatSystemClasspath("ignore");
                     if (docletPath.size() != 0) {
                         toExecute.createArgument().setValue("-docletpath");
                         toExecute.createArgument().setPath(docletPath);
                     }
                 }
                 for (Enumeration e = doclet.getParams();
                      e.hasMoreElements();) {
                     DocletParam param = (DocletParam) e.nextElement();
                     if (param.getName() == null) {
                         throw new BuildException("Doclet parameters must "
                                                  + "have a name");
                     }
 
                     toExecute.createArgument().setValue(param.getName());
                     if (param.getValue() != null) {
                         toExecute.createArgument()
                             .setValue(param.getValue());
                     }
                 }
             }
         }
     }
 
     private void writeExternalArgs(Commandline toExecute) {
         // If using an external file, write the command line options to it
         File optionsTmpFile = null;
         BufferedWriter optionsListWriter = null;
         try {
             optionsTmpFile = FILE_UTILS.createTempFile(
                 "javadocOptions", "", null, true, true);
             String[] listOpt = toExecute.getArguments();
             toExecute.clearArgs();
             toExecute.createArgument().setValue(
                 "@" + optionsTmpFile.getAbsolutePath());
             optionsListWriter = new BufferedWriter(
                 new FileWriter(optionsTmpFile.getAbsolutePath(), true));
             for (int i = 0; i < listOpt.length; i++) {
                 String string = listOpt[i];
                 if (string.startsWith("-J-")) {
                     toExecute.createArgument().setValue(string);
                 } else  {
                     if (string.startsWith("-")) {
                         optionsListWriter.write(string);
                         optionsListWriter.write(" ");
                     } else {
                         optionsListWriter.write(quoteString(string));
                         optionsListWriter.newLine();
                     }
                 }
             }
             optionsListWriter.close();
         } catch (IOException ex) {
             if (optionsTmpFile != null) {
                 optionsTmpFile.delete();
             }
             throw new BuildException(
                 "Error creating or writing temporary file for javadoc options",
                 ex, getLocation());
         } finally {
             FileUtils.close(optionsListWriter);
         }
     }
 
     private void doBootPath(Commandline toExecute) {
         Path bcp = new Path(getProject());
         if (bootclasspath != null) {
             bcp.append(bootclasspath);
         }
         bcp = bcp.concatSystemBootClasspath("ignore");
         if (bcp.size() > 0) {
             toExecute.createArgument().setValue("-bootclasspath");
             toExecute.createArgument().setPath(bcp);
         }
     }
 
     private void doLinks(Commandline toExecute) {
         if (links.size() != 0) {
             for (Enumeration e = links.elements(); e.hasMoreElements();) {
                 LinkArgument la = (LinkArgument) e.nextElement();
 
                 if (la.getHref() == null || la.getHref().length() == 0) {
                     log("No href was given for the link - skipping",
                         Project.MSG_VERBOSE);
                     continue;
                 }
                 String link = null;
                 if (la.shouldResolveLink()) {
                     File hrefAsFile =
                         getProject().resolveFile(la.getHref());
                     if (hrefAsFile.exists()) {
                         try {
                             link = FILE_UTILS.getFileURL(hrefAsFile)
                                 .toExternalForm();
                         } catch (MalformedURLException ex) {
                             // should be impossible
                             log("Warning: link location was invalid "
                                 + hrefAsFile, Project.MSG_WARN);
                         }
                     }
                 }
                 if (link == null) {
                     // is the href a valid URL
                     try {
                         URL base = new URL("file://.");
                         new URL(base, la.getHref());
                         link = la.getHref();
                     } catch (MalformedURLException mue) {
                         // ok - just skip
                         log("Link href \"" + la.getHref()
                             + "\" is not a valid url - skipping link",
                             Project.MSG_WARN);
                         continue;
                     }
                 }
 
                 if (la.isLinkOffline()) {
                     File packageListLocation = la.getPackagelistLoc();
                     URL packageListURL = la.getPackagelistURL();
                     if (packageListLocation == null
                         && packageListURL == null) {
                         throw new BuildException("The package list"
                                                  + " location for link "
                                                  + la.getHref()
                                                  + " must be provided "
                                                  + "because the link is "
                                                  + "offline");
                     }
                     if (packageListLocation != null) {
                         File packageListFile =
                             new File(packageListLocation, "package-list");
                         if (packageListFile.exists()) {
                             try {
                                 packageListURL =
                                     FILE_UTILS.getFileURL(packageListLocation);
                             } catch (MalformedURLException ex) {
                                 log("Warning: Package list location was "
                                     + "invalid " + packageListLocation,
                                     Project.MSG_WARN);
                             }
                         } else {
                             log("Warning: No package list was found at "
                                 + packageListLocation, Project.MSG_VERBOSE);
                         }
                     }
                     if (packageListURL != null) {
                         toExecute.createArgument().setValue("-linkoffline");
                         toExecute.createArgument().setValue(link);
                         toExecute.createArgument()
                             .setValue(packageListURL.toExternalForm());
                     }
                 } else {
                     toExecute.createArgument().setValue("-link");
                     toExecute.createArgument().setValue(link);
                 }
             }
         }
     }
 
     private void doGroup(Commandline toExecute) {
         // add the single group arguments
         // Javadoc 1.2 rules:
         //   Multiple -group args allowed.
         //   Each arg includes 3 strings: -group [name] [packagelist].
         //   Elements in [packagelist] are colon-delimited.
         //   An element in [packagelist] may end with the * wildcard.
 
         // Ant javadoc task rules for group attribute:
         //   Args are comma-delimited.
         //   Each arg is 2 space-delimited strings.
         //   E.g., group="XSLT_Packages org.apache.xalan.xslt*,
         //                XPath_Packages org.apache.xalan.xpath*"
         if (group != null) {
             StringTokenizer tok = new StringTokenizer(group, ",", false);
             while (tok.hasMoreTokens()) {
                 String grp = tok.nextToken().trim();
                 int space = grp.indexOf(" ");
                 if (space > 0) {
                     String name = grp.substring(0, space);
                     String pkgList = grp.substring(space + 1);
                     toExecute.createArgument().setValue("-group");
                     toExecute.createArgument().setValue(name);
                     toExecute.createArgument().setValue(pkgList);
                 }
             }
         }
     }
 
     // add the group arguments
     private void doGroups(Commandline toExecute) {
         if (groups.size() != 0) {
             for (Enumeration e = groups.elements(); e.hasMoreElements();) {
                 GroupArgument ga = (GroupArgument) e.nextElement();
                 String title = ga.getTitle();
                 String packages = ga.getPackages();
                 if (title == null || packages == null) {
                     throw new BuildException("The title and packages must "
                                              + "be specified for group "
                                              + "elements.");
                 }
                 toExecute.createArgument().setValue("-group");
                 toExecute.createArgument().setValue(expand(title));
                 toExecute.createArgument().setValue(packages);
             }
         }
     }
 
     // Do java1.4 arguments
     private void doJava14(Commandline toExecute) {
         for (Enumeration e = tags.elements(); e.hasMoreElements();) {
             Object element = e.nextElement();
             if (element instanceof TagArgument) {
                 TagArgument ta = (TagArgument) element;
                 File tagDir = ta.getDir(getProject());
                 if (tagDir == null) {
                     // The tag element is not used as a fileset,
                     // but specifies the tag directly.
                     toExecute.createArgument().setValue ("-tag");
                     toExecute.createArgument()
                         .setValue (ta.getParameter());
                 } else {
                     // The tag element is used as a
                     // fileset. Parse all the files and create
                     // -tag arguments.
                     DirectoryScanner tagDefScanner =
                         ta.getDirectoryScanner(getProject());
                     String[] files = tagDefScanner.getIncludedFiles();
                     for (int i = 0; i < files.length; i++) {
                         File tagDefFile = new File(tagDir, files[i]);
                         try {
                             BufferedReader in
                                 = new BufferedReader(
                                     new FileReader(tagDefFile)
                                                      );
                             String line = null;
                             while ((line = in.readLine()) != null) {
                                 toExecute.createArgument()
                                     .setValue("-tag");
                                 toExecute.createArgument()
                                     .setValue(line);
                             }
                             in.close();
                         } catch (IOException ioe) {
                             throw new BuildException(
                                 "Couldn't read "
                                 + " tag file from "
                                 + tagDefFile.getAbsolutePath(), ioe);
                         }
                     }
                 }
             } else {
                 ExtensionInfo tagletInfo = (ExtensionInfo) element;
                 toExecute.createArgument().setValue("-taglet");
                 toExecute.createArgument().setValue(tagletInfo
                                                     .getName());
                 if (tagletInfo.getPath() != null) {
                     Path tagletPath = tagletInfo.getPath()
                         .concatSystemClasspath("ignore");
                     if (tagletPath.size() != 0) {
                         toExecute.createArgument()
                             .setValue("-tagletpath");
                         toExecute.createArgument().setPath(tagletPath);
                     }
                 }
             }
         }
 
         String sourceArg = source != null ? source
             : getProject().getProperty(MagicNames.BUILD_JAVAC_SOURCE);
         if (sourceArg != null) {
             toExecute.createArgument().setValue("-source");
             toExecute.createArgument().setValue(sourceArg);
         }
 
         if (linksource && doclet == null) {
             toExecute.createArgument().setValue("-linksource");
         }
         if (noqualifier != null && doclet == null) {
             toExecute.createArgument().setValue("-noqualifier");
             toExecute.createArgument().setValue(noqualifier);
         }
     }
 
     private void doDocFilesSubDirs(Commandline toExecute) {
         if (docFilesSubDirs) {
             toExecute.createArgument().setValue("-docfilessubdirs");
             if (excludeDocFilesSubDir != null
                 && excludeDocFilesSubDir.trim().length() > 0) {
                 toExecute.createArgument().setValue("-excludedocfilessubdir");
                 toExecute.createArgument().setValue(excludeDocFilesSubDir);
             }
         }
     }
 
     private void doSourceAndPackageNames(
         Commandline toExecute,
         Vector packagesToDoc,
         Vector sourceFilesToDoc,
         boolean useExternalFile,
         File    tmpList,
         BufferedWriter srcListWriter)
         throws IOException {
         Enumeration e = packagesToDoc.elements();
         while (e.hasMoreElements()) {
             String packageName = (String) e.nextElement();
             if (useExternalFile) {
                 srcListWriter.write(packageName);
                 srcListWriter.newLine();
             } else {
                 toExecute.createArgument().setValue(packageName);
             }
         }
 
         e = sourceFilesToDoc.elements();
         while (e.hasMoreElements()) {
             SourceFile sf = (SourceFile) e.nextElement();
             String sourceFileName = sf.getFile().getAbsolutePath();
             if (useExternalFile) {
                 // XXX what is the following doing?
                 //     should it run if !javadoc4 && executable != null?
                 if (sourceFileName.indexOf(" ") > -1) {
                     String name = sourceFileName;
                     if (File.separatorChar == '\\') {
                         name = sourceFileName.replace(File.separatorChar, '/');
                     }
                     srcListWriter.write("\"" + name + "\"");
                 } else {
                     srcListWriter.write(sourceFileName);
                 }
                 srcListWriter.newLine();
             } else {
                 toExecute.createArgument().setValue(sourceFileName);
             }
         }
     }
 
     /**
      * Quote a string to place in a @ file.
      * @param str the string to quote
      * @return the quoted string, if there is no need to quote the string,
      *         return the original string.
      */
     private String quoteString(final String str) {
         if (!containsWhitespace(str)
             && str.indexOf('\'') == -1
             && str.indexOf('"') == -1) {
             return str;
         }
         if (str.indexOf('\'') == -1) {
             return quoteString(str, '\'');
         } else {
             return quoteString(str, '"');
         }
     }
 
     private boolean containsWhitespace(final String s) {
         final int len = s.length();
         for (int i = 0; i < len; i++) {
             if (Character.isWhitespace(s.charAt(i))) {
                 return true;
             }
         }
         return false;
     }
 
     private String quoteString(final String str, final char delim) {
         StringBuffer buf = new StringBuffer(str.length() * 2);
         buf.append(delim);
         final int len = str.length();
         boolean lastCharWasCR = false;
         for (int i = 0; i < len; i++) {
             char c = str.charAt(i);
             if (c == delim) { // can't put the non-constant delim into a case
                 buf.append('\\').append(c);
                 lastCharWasCR = false;
             } else {
                 switch (c) {
                 case '\\':
                     buf.append("\\\\");
                     lastCharWasCR = false;
                     break;
                 case '\r':
                     // insert a line continuation marker
                     buf.append("\\\r");
                     lastCharWasCR = true;
                     break;
                 case '\n':
                     // insert a line continuation marker unless this
                     // is a \r\n sequence in which case \r already has
                     // created the marker
                     if (!lastCharWasCR) {
                         buf.append("\\\n");
                     } else {
                         buf.append("\n");
                     }
                     lastCharWasCR = false;
                     break;
                 default:
                     buf.append(c);
                     lastCharWasCR = false;
                     break;
                 }
             }
         }
         buf.append(delim);
         return buf.toString();
     }
 
     /**
      * Add the files matched by the nested source files to the Vector
      * as SourceFile instances.
      *
      * @since 1.7
      */
     private void addSourceFiles(Vector sf) {
         Iterator e = nestedSourceFiles.iterator();
         while (e.hasNext()) {
             ResourceCollection rc = (ResourceCollection) e.next();
             if (!rc.isFilesystemOnly()) {
                 throw new BuildException("only file system based resources are"
                                          + " supported by javadoc");
             }
             if (rc instanceof FileSet) {
                 FileSet fs = (FileSet) rc;
                 if (!fs.hasPatterns() && !fs.hasSelectors()) {
                     FileSet fs2 = (FileSet) fs.clone();
                     fs2.createInclude().setName("**/*.java");
                     if (includeNoSourcePackages) {
                         fs2.createInclude().setName("**/package.html");
                     }
                     rc = fs2;
                 }
             }
             for (Resource r : rc) {
                 sf.addElement(new SourceFile(r.as(FileProvider.class).getFile()));
             }
         }
     }
 
     /**
      * Add the directories matched by the nested dirsets to the Vector
      * and the base directories of the dirsets to the Path.  It also
      * handles the packages and excludepackages attributes and
      * elements.
      *
      * @since 1.5
      */
     private void parsePackages(Vector pn, Path sp) {
         HashSet addedPackages = new HashSet();
         Vector dirSets = (Vector) packageSets.clone();
 
         // for each sourcePath entry, add a directoryset with includes
         // taken from packagenames attribute and nested package
         // elements and excludes taken from excludepackages attribute
         // and nested excludepackage elements
         if (sourcePath != null) {
             PatternSet ps = new PatternSet();
             ps.setProject(getProject());
             if (packageNames.size() > 0) {
                 Enumeration e = packageNames.elements();
                 while (e.hasMoreElements()) {
                     PackageName p = (PackageName) e.nextElement();
                     String pkg = p.getName().replace('.', '/');
                     if (pkg.endsWith("*")) {
                         pkg += "*";
                     }
                     ps.createInclude().setName(pkg);
                 }
             } else {
                 ps.createInclude().setName("**");
             }
 
             Enumeration e = excludePackageNames.elements();
             while (e.hasMoreElements()) {
                 PackageName p = (PackageName) e.nextElement();
                 String pkg = p.getName().replace('.', '/');
                 if (pkg.endsWith("*")) {
                     pkg += "*";
                 }
                 ps.createExclude().setName(pkg);
             }
 
 
             String[] pathElements = sourcePath.list();
             for (int i = 0; i < pathElements.length; i++) {
                 File dir = new File(pathElements[i]);
                 if (dir.isDirectory()) {
                     DirSet ds = new DirSet();
                     ds.setProject(getProject());
                     ds.setDefaultexcludes(useDefaultExcludes);
                     ds.setDir(dir);
                     ds.createPatternSet().addConfiguredPatternset(ps);
                     dirSets.addElement(ds);
                 } else {
                     log("Skipping " + pathElements[i]
                         + " since it is no directory.", Project.MSG_WARN);
                 }
             }
         }
 
         Enumeration e = dirSets.elements();
         while (e.hasMoreElements()) {
             DirSet ds = (DirSet) e.nextElement();
             File baseDir = ds.getDir(getProject());
             log("scanning " + baseDir + " for packages.", Project.MSG_DEBUG);
             DirectoryScanner dsc = ds.getDirectoryScanner(getProject());
             String[] dirs = dsc.getIncludedDirectories();
             boolean containsPackages = false;
             for (int i = 0; i < dirs.length; i++) {
                 // are there any java files in this directory?
                 File pd = new File(baseDir, dirs[i]);
                 String[] files = pd.list(new FilenameFilter () {
                         public boolean accept(File dir1, String name) {
                             return name.endsWith(".java")
                                 || (includeNoSourcePackages
                                     && name.equals("package.html"));
                         }
                     });
 
                 if (files.length > 0) {
                     if ("".equals(dirs[i])) {
                         log(baseDir
                             + " contains source files in the default package,"
                             + " you must specify them as source files"
                             + " not packages.",
                             Project.MSG_WARN);
                     } else {
                         containsPackages = true;
                         String packageName =
                             dirs[i].replace(File.separatorChar, '.');
                         if (!addedPackages.contains(packageName)) {
                             addedPackages.add(packageName);
                             pn.addElement(packageName);
                         }
                     }
                 }
             }
             if (containsPackages) {
                 // We don't need to care for duplicates here,
                 // Path.list does it for us.
                 sp.createPathElement().setLocation(baseDir);
             } else {
                 log(baseDir + " doesn\'t contain any packages, dropping it.",
                     Project.MSG_VERBOSE);
             }
         }
     }
 
     private class JavadocOutputStream extends LogOutputStream {
         JavadocOutputStream(int level) {
             super(Javadoc.this, level);
         }
 
         //
         // Override the logging of output in order to filter out Generating
         // messages.  Generating messages are set to a priority of VERBOSE
         // unless they appear after what could be an informational message.
         //
         private String queuedLine = null;
         protected void processLine(String line, int messageLevel) {
             if (messageLevel == Project.MSG_INFO
                 && line.startsWith("Generating ")) {
                 if (queuedLine != null) {
                     super.processLine(queuedLine, Project.MSG_VERBOSE);
                 }
                 queuedLine = line;
             } else {
                 if (queuedLine != null) {
                     if (line.startsWith("Building ")) {
                         super.processLine(queuedLine, Project.MSG_VERBOSE);
                     } else {
                         super.processLine(queuedLine, Project.MSG_INFO);
                     }
                     queuedLine = null;
                 }
                 super.processLine(line, messageLevel);
             }
         }
 
 
         protected void logFlush() {
             if (queuedLine != null) {
                 super.processLine(queuedLine, Project.MSG_VERBOSE);
                 queuedLine = null;
             }
         }
     }
 
     /**
      * Convenience method to expand properties.
      * @param content the string to expand
      * @return the converted string
      */
     protected String expand(String content) {
         return getProject().replaceProperties(content);
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/MatchingTask.java b/src/main/org/apache/tools/ant/taskdefs/MatchingTask.java
index ec4fa6a07..51d9d2601 100644
--- a/src/main/org/apache/tools/ant/taskdefs/MatchingTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/MatchingTask.java
@@ -1,445 +1,445 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.util.Enumeration;
 import java.util.StringTokenizer;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.PatternSet;
 import org.apache.tools.ant.types.selectors.AndSelector;
 import org.apache.tools.ant.types.selectors.ContainsRegexpSelector;
 import org.apache.tools.ant.types.selectors.ContainsSelector;
 import org.apache.tools.ant.types.selectors.DateSelector;
 import org.apache.tools.ant.types.selectors.DependSelector;
 import org.apache.tools.ant.types.selectors.DepthSelector;
 import org.apache.tools.ant.types.selectors.DifferentSelector;
 import org.apache.tools.ant.types.selectors.ExtendSelector;
 import org.apache.tools.ant.types.selectors.FileSelector;
 import org.apache.tools.ant.types.selectors.FilenameSelector;
 import org.apache.tools.ant.types.selectors.MajoritySelector;
 import org.apache.tools.ant.types.selectors.NoneSelector;
 import org.apache.tools.ant.types.selectors.NotSelector;
 import org.apache.tools.ant.types.selectors.OrSelector;
 import org.apache.tools.ant.types.selectors.PresentSelector;
 import org.apache.tools.ant.types.selectors.SelectSelector;
 import org.apache.tools.ant.types.selectors.SelectorContainer;
 import org.apache.tools.ant.types.selectors.SizeSelector;
 import org.apache.tools.ant.types.selectors.TypeSelector;
 import org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector;
 
 /**
  * This is an abstract task that should be used by all those tasks that
  * require to include or exclude files based on pattern matching.
  *
  * @since Ant 1.1
  */
 
 public abstract class MatchingTask extends Task implements SelectorContainer {
 
     // CheckStyle:VisibilityModifier OFF - bc
     protected FileSet fileset = new FileSet();
     // CheckStyle:VisibilityModifier ON
 
     /** {@inheritDoc}. */
     public void setProject(Project project) {
         super.setProject(project);
         fileset.setProject(project);
     }
 
     /**
      * add a name entry on the include list
      * @return a NameEntry object to be configured
      */
     public PatternSet.NameEntry createInclude() {
         return fileset.createInclude();
     }
 
     /**
      * add a name entry on the include files list
      * @return an NameEntry object to be configured
      */
     public PatternSet.NameEntry createIncludesFile() {
         return fileset.createIncludesFile();
     }
 
     /**
      * add a name entry on the exclude list
      * @return an NameEntry object to be configured
      */
     public PatternSet.NameEntry createExclude() {
         return fileset.createExclude();
     }
 
     /**
      * add a name entry on the include files list
      * @return an NameEntry object to be configured
      */
     public PatternSet.NameEntry createExcludesFile() {
         return fileset.createExcludesFile();
     }
 
     /**
      * add a set of patterns
      * @return PatternSet object to be configured
      */
     public PatternSet createPatternSet() {
         return fileset.createPatternSet();
     }
 
     /**
      * Sets the set of include patterns. Patterns may be separated by a comma
      * or a space.
      *
      * @param includes the string containing the include patterns
      */
     public void setIncludes(String includes) {
         fileset.setIncludes(includes);
     }
 
     // CheckStyle:MethodNameCheck OFF - bc
     /**
      * Set this to be the items in the base directory that you want to be
      * included. You can also specify "*" for the items (ie: items="*")
      * and it will include all the items in the base directory.
      *
      * @param itemString the string containing the files to include.
      */
     public void XsetItems(String itemString) {
         log("The items attribute is deprecated. "
             + "Please use the includes attribute.", Project.MSG_WARN);
         if (itemString == null || itemString.equals("*")
             || itemString.equals(".")) {
             createInclude().setName("**");
         } else {
             StringTokenizer tok = new StringTokenizer(itemString, ", ");
             while (tok.hasMoreTokens()) {
                 String pattern = tok.nextToken().trim();
                 if (pattern.length() > 0) {
                     createInclude().setName(pattern + "/**");
                 }
             }
         }
     }
 
     /**
      * Sets the set of exclude patterns. Patterns may be separated by a comma
      * or a space.
      *
      * @param excludes the string containing the exclude patterns
      */
     public void setExcludes(String excludes) {
         fileset.setExcludes(excludes);
     }
 
     /**
      * List of filenames and directory names to not include. They should be
      * either , or " " (space) separated. The ignored files will be logged.
      *
      * @param ignoreString the string containing the files to ignore.
      */
     public void XsetIgnore(String ignoreString) {
         log("The ignore attribute is deprecated."
             + "Please use the excludes attribute.", Project.MSG_WARN);
         if (ignoreString != null && ignoreString.length() > 0) {
             StringTokenizer tok = new StringTokenizer(ignoreString, ", ",
                                                       false);
             while (tok.hasMoreTokens()) {
                 createExclude().setName("**/" + tok.nextToken().trim() + "/**");
             }
         }
     }
 
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Sets whether default exclusions should be used or not.
      *
      * @param useDefaultExcludes "true"|"on"|"yes" when default exclusions
      *                           should be used, "false"|"off"|"no" when they
      *                           shouldn't be used.
      */
     public void setDefaultexcludes(boolean useDefaultExcludes) {
         fileset.setDefaultexcludes(useDefaultExcludes);
     }
 
     /**
      * Returns the directory scanner needed to access the files to process.
      * @param baseDir the base directory to use with the fileset
      * @return a directory scanner
      */
     protected DirectoryScanner getDirectoryScanner(File baseDir) {
         fileset.setDir(baseDir);
         return fileset.getDirectoryScanner(getProject());
     }
 
     /**
      * Sets the name of the file containing the includes patterns.
      *
      * @param includesfile A string containing the filename to fetch
      * the include patterns from.
      */
     public void setIncludesfile(File includesfile) {
         fileset.setIncludesfile(includesfile);
     }
 
     /**
      * Sets the name of the file containing the includes patterns.
      *
      * @param excludesfile A string containing the filename to fetch
      * the include patterns from.
      */
     public void setExcludesfile(File excludesfile) {
         fileset.setExcludesfile(excludesfile);
     }
 
     /**
      * Sets case sensitivity of the file system
      *
      * @param isCaseSensitive "true"|"on"|"yes" if file system is case
      *                           sensitive, "false"|"off"|"no" when not.
      */
     public void setCaseSensitive(boolean isCaseSensitive) {
         fileset.setCaseSensitive(isCaseSensitive);
     }
 
     /**
      * Sets whether or not symbolic links should be followed.
      *
      * @param followSymlinks whether or not symbolic links should be followed
      */
     public void setFollowSymlinks(boolean followSymlinks) {
         fileset.setFollowSymlinks(followSymlinks);
     }
 
     /**
      * Indicates whether there are any selectors here.
      *
      * @return whether any selectors are in this container
      */
     public boolean hasSelectors() {
         return fileset.hasSelectors();
     }
 
     /**
      * Gives the count of the number of selectors in this container
      *
      * @return the number of selectors in this container
      */
     public int selectorCount() {
         return fileset.selectorCount();
     }
 
     /**
      * Returns the set of selectors as an array.
      * @param p the current project
      * @return an array of selectors in this container
      */
     public FileSelector[] getSelectors(Project p) {
         return fileset.getSelectors(p);
     }
 
     /**
      * Returns an enumerator for accessing the set of selectors.
      *
      * @return an enumerator that goes through each of the selectors
      */
     public Enumeration selectorElements() {
         return fileset.selectorElements();
     }
 
     /**
      * Add a new selector into this container.
      *
      * @param selector the new selector to add
      */
     public void appendSelector(FileSelector selector) {
         fileset.appendSelector(selector);
     }
 
     /* Methods below all add specific selectors */
 
     /**
      * add a "Select" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addSelector(SelectSelector selector) {
         fileset.addSelector(selector);
     }
 
     /**
      * add an "And" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addAnd(AndSelector selector) {
         fileset.addAnd(selector);
     }
 
     /**
      * add an "Or" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addOr(OrSelector selector) {
         fileset.addOr(selector);
     }
 
     /**
      * add a "Not" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addNot(NotSelector selector) {
         fileset.addNot(selector);
     }
 
     /**
      * add a "None" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addNone(NoneSelector selector) {
         fileset.addNone(selector);
     }
 
     /**
      * add a majority selector entry on the selector list
      * @param selector the selector to add
      */
     public void addMajority(MajoritySelector selector) {
         fileset.addMajority(selector);
     }
 
     /**
      * add a selector date entry on the selector list
      * @param selector the selector to add
      */
     public void addDate(DateSelector selector) {
         fileset.addDate(selector);
     }
 
     /**
      * add a selector size entry on the selector list
      * @param selector the selector to add
      */
     public void addSize(SizeSelector selector) {
         fileset.addSize(selector);
     }
 
     /**
      * add a selector filename entry on the selector list
      * @param selector the selector to add
      */
     public void addFilename(FilenameSelector selector) {
         fileset.addFilename(selector);
     }
 
     /**
      * add an extended selector entry on the selector list
      * @param selector the selector to add
      */
     public void addCustom(ExtendSelector selector) {
         fileset.addCustom(selector);
     }
 
     /**
      * add a contains selector entry on the selector list
      * @param selector the selector to add
      */
     public void addContains(ContainsSelector selector) {
         fileset.addContains(selector);
     }
 
     /**
      * add a present selector entry on the selector list
      * @param selector the selector to add
      */
     public void addPresent(PresentSelector selector) {
         fileset.addPresent(selector);
     }
 
     /**
      * add a depth selector entry on the selector list
      * @param selector the selector to add
      */
     public void addDepth(DepthSelector selector) {
         fileset.addDepth(selector);
     }
 
     /**
      * add a depends selector entry on the selector list
      * @param selector the selector to add
      */
     public void addDepend(DependSelector selector) {
         fileset.addDepend(selector);
     }
 
     /**
      * add a regular expression selector entry on the selector list
      * @param selector the selector to add
      */
     public void addContainsRegexp(ContainsRegexpSelector selector) {
         fileset.addContainsRegexp(selector);
     }
 
     /**
      * add a type selector entry on the type list
      * @param selector the selector to add
      * @since ant 1.6
      */
     public void addDifferent(DifferentSelector selector) {
         fileset.addDifferent(selector);
     }
 
     /**
      * add a type selector entry on the type list
      * @param selector the selector to add
      * @since ant 1.6
      */
     public void addType(TypeSelector selector) {
         fileset.addType(selector);
     }
 
     /**
      * add the modified selector
      * @param selector the selector to add
      * @since ant 1.6
      */
     public void addModified(ModifiedSelector selector) {
         fileset.addModified(selector);
     }
 
     /**
-     * add an arbitary selector
+     * add an arbitrary selector
      * @param selector the selector to add
      * @since Ant 1.6
      */
     public void add(FileSelector selector) {
         fileset.add(selector);
     }
 
     /**
      * Accessor for the implicit fileset.
      * @return the implicit fileset
      * @since Ant 1.5.2
      */
     protected final FileSet getImplicitFileSet() {
         return fileset;
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Recorder.java b/src/main/org/apache/tools/ant/taskdefs/Recorder.java
index 44d5543ad..c2237ec7d 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Recorder.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Recorder.java
@@ -1,323 +1,323 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Map;
 import org.apache.tools.ant.BuildEvent;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.SubBuildListener;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.LogLevel;
 
 /**
  * Adds a listener to the current build process that records the
  * output to a file.
  * <p>Several recorders can exist at the same time.  Each recorder is
  * associated with a file.  The filename is used as a unique identifier for
  * the recorders.  The first call to the recorder task with an unused filename
  * will create a recorder (using the parameters provided) and add it to the
  * listeners of the build.  All subsequent calls to the recorder task using
  * this filename will modify that recorders state (recording or not) or other
  * properties (like logging level).</p>
  * <p>Some technical issues: the file's print stream is flushed for &quot;finished&quot;
  * events (buildFinished, targetFinished and taskFinished), and is closed on
  * a buildFinished event.</p>
  * @see RecorderEntry
  * @version 0.5
  * @since Ant 1.4
  * @ant.task name="record" category="utility"
  */
 public class Recorder extends Task implements SubBuildListener {
 
     //////////////////////////////////////////////////////////////////////
     // ATTRIBUTES
 
     /** The name of the file to record to. */
     private String filename = null;
     /**
      * Whether or not to append. Need Boolean to record an unset state (null).
      */
     private Boolean append = null;
     /**
      * Whether to start or stop recording. Need Boolean to record an unset
      * state (null).
      */
     private Boolean start = null;
     /** The level to log at. A level of -1 means not initialized yet. */
     private int loglevel = -1;
     /** Strip task banners if true.  */
     private boolean emacsMode = false;
     /** The list of recorder entries. */
     private static Hashtable recorderEntries = new Hashtable();
 
     //////////////////////////////////////////////////////////////////////
     // CONSTRUCTORS / INITIALIZERS
 
     /**
      * Overridden so we can add the task as build listener.
      *
      * @since Ant 1.7
      */
     public void init() {
         getProject().addBuildListener(this);
     }
 
     //////////////////////////////////////////////////////////////////////
     // ACCESSOR METHODS
 
     /**
      * Sets the name of the file to log to, and the name of the recorder
      * entry.
      *
      * @param fname File name of logfile.
      */
     public void setName(String fname) {
         filename = fname;
     }
 
 
     /**
      * Sets the action for the associated recorder entry.
      *
      * @param action The action for the entry to take: start or stop.
      */
     public void setAction(ActionChoices action) {
         if (action.getValue().equalsIgnoreCase("start")) {
             start = Boolean.TRUE;
         } else {
             start = Boolean.FALSE;
         }
     }
 
 
     /**
      * Whether or not the logger should append to a previous file.
      * @param append if true, append to a previous file.
      */
     public void setAppend(boolean append) {
         this.append = (append ? Boolean.TRUE : Boolean.FALSE);
     }
 
 
     /**
      * Set emacs mode.
      * @param emacsMode if true use emacs mode
      */
     public void setEmacsMode(boolean emacsMode) {
         this.emacsMode = emacsMode;
     }
 
 
     /**
      * Sets the level to which this recorder entry should log to.
      * @param level the level to set.
      * @see VerbosityLevelChoices
      */
     public void setLoglevel(VerbosityLevelChoices level) {
         loglevel = level.getLevel();
     }
 
     //////////////////////////////////////////////////////////////////////
     // CORE / MAIN BODY
 
     /**
      * The main execution.
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
         if (filename == null) {
             throw new BuildException("No filename specified");
         }
 
         getProject().log("setting a recorder for name " + filename,
             Project.MSG_DEBUG);
 
         // get the recorder entry
         RecorderEntry recorder = getRecorder(filename, getProject());
         // set the values on the recorder
         recorder.setMessageOutputLevel(loglevel);
         recorder.setEmacsMode(emacsMode);
         if (start != null) {
             if (start.booleanValue()) {
                 recorder.reopenFile();
                 recorder.setRecordState(start);
             } else {
                 recorder.setRecordState(start);
                 recorder.closeFile();
             }
         }
     }
 
     //////////////////////////////////////////////////////////////////////
     // INNER CLASSES
 
     /**
      * A list of possible values for the <code>setAction()</code> method.
      * Possible values include: start and stop.
      */
     public static class ActionChoices extends EnumeratedAttribute {
         private static final String[] VALUES = {"start", "stop"};
 
         /**
          * @see EnumeratedAttribute#getValues()
          */
         /** {@inheritDoc}. */
         public String[] getValues() {
             return VALUES;
         }
     }
 
 
     /**
      * A list of possible values for the <code>setLoglevel()</code> method.
      * Possible values include: error, warn, info, verbose, debug.
      */
     public static class VerbosityLevelChoices extends LogLevel {
     }
 
 
     /**
      * Gets the recorder that's associated with the passed in name. If the
      * recorder doesn't exist, then a new one is created.
-     * @param name the name of the recoder
+     * @param name the name of the recorder
      * @param proj the current project
      * @return a recorder
      * @throws BuildException on error
      */
     protected RecorderEntry getRecorder(String name, Project proj)
          throws BuildException {
         Object o = recorderEntries.get(name);
         RecorderEntry entry;
 
         if (o == null) {
             // create a recorder entry
             entry = new RecorderEntry(name);
 
             if (append == null) {
                 entry.openFile(false);
             } else {
                 entry.openFile(append.booleanValue());
             }
             entry.setProject(proj);
             recorderEntries.put(name, entry);
         } else {
             entry = (RecorderEntry) o;
         }
         return entry;
     }
 
     /**
      * Empty implementation required by SubBuildListener interface.
      * @param event ignored.
      * @since Ant 1.7
      */
     public void buildStarted(BuildEvent event) {
     }
 
     /**
      * Empty implementation required by SubBuildListener interface.
      * @param event ignored.
      * @since Ant 1.7
      */
     public void subBuildStarted(BuildEvent event) {
     }
 
     /**
      * Empty implementation required by SubBuildListener interface.
      * @param event ignored.
      * @since Ant 1.7
      */
     public void targetStarted(BuildEvent event) {
     }
 
     /**
      * Empty implementation required by SubBuildListener interface.
      * @param event ignored.
      * @since Ant 1.7
      */
     public void targetFinished(BuildEvent event) {
     }
 
     /**
      * Empty implementation required by SubBuildListener interface.
      * @param event ignored.
      * @since Ant 1.7
      */
     public void taskStarted(BuildEvent event) {
     }
 
     /**
      * Empty implementation required by SubBuildListener interface.
      * @param event ignored.
      * @since Ant 1.7
      */
     public void taskFinished(BuildEvent event) {
     }
 
     /**
      * Empty implementation required by SubBuildListener interface.
      * @param event ignored.
      * @since Ant 1.7
      */
     public void messageLogged(BuildEvent event) {
     }
 
     /**
      * Cleans recorder registry.
      * @param event ignored.
      * @since Ant 1.7
      */
     public void buildFinished(BuildEvent event) {
         cleanup();
     }
 
     /**
      * Cleans recorder registry, if this is the subbuild the task has
      * been created in.
      * @param event ignored.
      * @since Ant 1.7
      */
     public void subBuildFinished(BuildEvent event) {
         if (event.getProject() == getProject()) {
             cleanup();
         }
     }
 
     /**
      * cleans recorder registry and removes itself from BuildListener list.
      *
      * @since Ant 1.7
      */
     private void cleanup() {
         Hashtable entries = (Hashtable) recorderEntries.clone();
         Iterator itEntries = entries.entrySet().iterator();
         while (itEntries.hasNext()) {
             Map.Entry entry = (Map.Entry) itEntries.next();
             RecorderEntry re = (RecorderEntry) entry.getValue();
             if (re.getProject() == getProject()) {
                 recorderEntries.remove(entry.getKey());
             }
         }
         getProject().removeBuildListener(this);
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/Retry.java b/src/main/org/apache/tools/ant/taskdefs/Retry.java
index 89ca6ebd2..5f9c812c8 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Retry.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Retry.java
@@ -1,119 +1,119 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.TaskContainer;
 import org.apache.tools.ant.util.StringUtils;
 
 /**
  * Retries the nested task a set number of times
  * @since Ant 1.7.1
  */
 public class Retry extends Task implements TaskContainer {
 
     /**
      * task to execute n times
      */
     private Task nestedTask;
 
     /**
      * set retryCount to 1 by default
      */
     private int retryCount = 1;
 
     /**
      * The time to wait between retries in milliseconds, default to 0.
      */
     private int retryDelay = 0;
 
     /**
      * set the task
      * @param t the task to retry.
      */
     public synchronized void addTask(Task t) {
         if (nestedTask != null) {
             throw new BuildException(
                 "The retry task container accepts a single nested task"
                 + " (which may be a sequential task container)");
         }
         nestedTask = t;
     }
 
     /**
      * set the number of times to retry the task
      * @param n the number to use.
      */
     public void setRetryCount(int n) {
         retryCount = n;
     }
 
     /**
-     * set the delay between retries (in miliseconds)
+     * set the delay between retries (in milliseconds)
      * @param n the time between retries.
      * @since Ant 1.8.3
      */
     public void setRetryDelay(int retryDelay) {
         if (retryDelay < 0) {
             throw new BuildException("delay must be a non-negative number");
         }
         this.retryDelay = retryDelay;
     }
 
     /**
      * perform the work
      * @throws BuildException if there is an error.
      */
     public void execute() throws BuildException {
         StringBuffer errorMessages = new StringBuffer();
         for (int i = 0; i <= retryCount; i++) {
             try {
                 nestedTask.perform();
                 break;
             } catch (Exception e) {
                 errorMessages.append(e.getMessage());
                 if (i >= retryCount) {
                     StringBuffer exceptionMessage = new StringBuffer();
                     exceptionMessage.append("Task [").append(nestedTask.getTaskName());
                     exceptionMessage.append("] failed after [").append(retryCount);
                     exceptionMessage.append("] attempts; giving up.").append(StringUtils.LINE_SEP);
                     exceptionMessage.append("Error messages:").append(StringUtils.LINE_SEP);
                     exceptionMessage.append(errorMessages);
                     throw new BuildException(exceptionMessage.toString(), getLocation());
                 }
                 String msg;
                 if (retryDelay > 0) {
                     msg = "Attempt [" + i + "]: error occurred; retrying after " + retryDelay + " ms...";
                 } else {
                     msg = "Attempt [" + i + "]: error occurred; retrying...";
                 }
                 log(msg, e, Project.MSG_INFO);
                 errorMessages.append(StringUtils.LINE_SEP);
                 if (retryDelay > 0) {
                     try {
                         Thread.sleep(retryDelay);
                     } catch (InterruptedException ie) {
                         // Ignore Exception
                     }
                 }
             }
         }
     }
 }
\ No newline at end of file
diff --git a/src/main/org/apache/tools/ant/taskdefs/Rmic.java b/src/main/org/apache/tools/ant/taskdefs/Rmic.java
index 13a6d3bf1..7b5b200d9 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Rmic.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Rmic.java
@@ -1,846 +1,846 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 import java.rmi.Remote;
 import java.util.Vector;
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.rmic.RmicAdapter;
 import org.apache.tools.ant.taskdefs.rmic.RmicAdapterFactory;
 import org.apache.tools.ant.types.FilterSetCollection;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.SourceFileScanner;
 import org.apache.tools.ant.util.StringUtils;
 import org.apache.tools.ant.util.facade.FacadeTaskHelper;
 
 /**
  * Runs the rmic compiler against classes.</p>
  * <p>Rmic can be run on a single class (as specified with the classname
  * attribute) or a number of classes at once (all classes below base that
  * are neither _Stub nor _Skel classes).  If you want to rmic a single
  * class and this class is a class nested into another class, you have to
  * specify the classname in the form <code>Outer$$Inner</code> instead of
  * <code>Outer.Inner</code>.</p>
  * <p>It is possible to refine the set of files that are being rmiced. This can
  * be done with the <i>includes</i>, <i>includesfile</i>, <i>excludes</i>,
  * <i>excludesfile</i> and <i>defaultexcludes</i>
  * attributes. With the <i>includes</i> or <i>includesfile</i> attribute you
  * specify the files you want to have included by using patterns. The
  * <i>exclude</i> or <i>excludesfile</i> attribute is used to specify
  * the files you want to have excluded. This is also done with patterns. And
  * finally with the <i>defaultexcludes</i> attribute, you can specify whether
  * you want to use default exclusions or not. See the section on
  * directory based tasks</a>, on how the
  * inclusion/exclusion of files works, and how to write patterns.</p>
  * <p>This task forms an implicit FileSet and
  * supports all attributes of <code>&lt;fileset&gt;</code>
  * (<code>dir</code> becomes <code>base</code>) as well as the nested
  * <code>&lt;include&gt;</code>, <code>&lt;exclude&gt;</code> and
  * <code>&lt;patternset&gt;</code> elements.</p>
  * <p>It is possible to use different compilers. This can be selected
  * with the &quot;build.rmic&quot; property or the <code>compiler</code>
  * attribute. <a name="compilervalues">There are three choices</a>:</p>
  * <ul>
  *   <li>sun (the standard compiler of the JDK)</li>
  *   <li>kaffe (the standard compiler of
  *       {@link <a href="http://www.kaffe.org">Kaffe</a>})</li>
  *   <li>weblogic</li>
  * </ul>
  *
  * <p> The <a href="http://dione.zcu.cz/~toman40/miniRMI/">miniRMI</a>
  * project contains a compiler implementation for this task as well,
  * please consult miniRMI's documentation to learn how to use it.</p>
  *
  * @since Ant 1.1
  *
  * @ant.task category="java"
  */
 
 public class Rmic extends MatchingTask {
 
     /** rmic failed message */
     public static final String ERROR_RMIC_FAILED
         = "Rmic failed; see the compiler error output for details.";
 
     private File baseDir;
     private File destDir;
     private String classname;
     private File sourceBase;
     private String stubVersion;
     private Path compileClasspath;
     private Path extDirs;
     private boolean verify = false;
     private boolean filtering = false;
 
     private boolean iiop = false;
     private String  iiopOpts;
     private boolean idl  = false;
     private String  idlOpts;
     private boolean debug  = false;
     private boolean includeAntRuntime = true;
     private boolean includeJavaRuntime = false;
 
     private Vector compileList = new Vector();
 
     private AntClassLoader loader = null;
 
     private FacadeTaskHelper facade;
     /** unable to verify message */
     public static final String ERROR_UNABLE_TO_VERIFY_CLASS = "Unable to verify class ";
     /** could not be found message */
     public static final String ERROR_NOT_FOUND = ". It could not be found.";
     /** not defined message */
     public static final String ERROR_NOT_DEFINED = ". It is not defined.";
     /** loaded error message */
     public static final String ERROR_LOADING_CAUSED_EXCEPTION = ". Loading caused Exception: ";
     /** base not exists message */
     public static final String ERROR_NO_BASE_EXISTS = "base or destdir does not exist: ";
     /** base not a directory message */
     public static final String ERROR_NOT_A_DIR = "base or destdir is not a directory:";
     /** base attribute not set message */
     public static final String ERROR_BASE_NOT_SET = "base or destdir attribute must be set!";
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     private String executable = null;
 
     private boolean listFiles = false;
 
     private RmicAdapter nestedAdapter = null;
 
     /**
      * Constructor for Rmic.
      */
     public Rmic() {
         facade = new FacadeTaskHelper(RmicAdapterFactory.DEFAULT_COMPILER);
     }
 
     /**
      * Sets the location to store the compiled files; required
      * @param base the location to store the compiled files
      */
     public void setBase(File base) {
         this.baseDir = base;
     }
 
     /**
      * Sets the base directory to output the generated files.
      * @param destdir the base directory to output the generated files.
      * @since Ant 1.8.0
      */
     public void setDestdir(File destdir) {
         this.destDir = destdir;
     }
 
     /**
      * Gets the base directory to output the generated files.
      * @return the base directory to output the generated files.
      * @since Ant 1.8.0
      */
     public File getDestdir() {
         return this.destDir;
     }
 
     /**
      * Gets the base directory to output the generated files,
      * favoring destdir if set, otherwise defaulting to basedir.
      * @return the actual directory to output to (either destdir or basedir)
      * @since Ant 1.8.0
      */
     public File getOutputDir() {
         if (getDestdir() != null) {
             return getDestdir();
         }
         return getBase();
     }
 
     /**
      * Gets the base directory to output generated class.
      * @return the location of the compiled files
      */
     public File getBase() {
         return this.baseDir;
     }
 
     /**
      * Sets the class to run <code>rmic</code> against;
      * optional
      * @param classname the name of the class for rmic to create code for
      */
     public void setClassname(String classname) {
         this.classname = classname;
     }
 
     /**
      * Gets the class name to compile.
      * @return the name of the class to compile
      */
     public String getClassname() {
         return classname;
     }
 
     /**
      * optional directory to save generated source files to.
      * @param sourceBase the directory to save source files to.
      */
     public void setSourceBase(File sourceBase) {
         this.sourceBase = sourceBase;
     }
 
     /**
      * Gets the source dirs to find the source java files.
      * @return sourceBase the directory containing the source files.
      */
     public File getSourceBase() {
         return sourceBase;
     }
 
     /**
      * Specify the JDK version for the generated stub code.
      * Specify &quot;1.1&quot; to pass the &quot;-v1.1&quot; option to rmic.
      * @param stubVersion the JDK version
      */
     public void setStubVersion(String stubVersion) {
         this.stubVersion = stubVersion;
     }
 
     /**
      * Gets the JDK version for the generated stub code.
      * @return stubVersion
      */
     public String getStubVersion() {
         return stubVersion;
     }
 
     /**
      * Sets token filtering [optional], default=false
      * @param filter turn on token filtering
      */
     public void setFiltering(boolean filter) {
         this.filtering = filter;
     }
 
     /**
      * Gets whether token filtering is set
      * @return filtering
      */
     public boolean getFiltering() {
         return filtering;
     }
 
     /**
      * Generate debug info (passes -g to rmic);
      * optional, defaults to false
      * @param debug turn on debug info
      */
     public void setDebug(boolean debug) {
         this.debug = debug;
     }
 
     /**
      * Gets the debug flag.
      * @return debug
      */
     public boolean getDebug() {
         return debug;
     }
 
     /**
      * Set the classpath to be used for this compilation.
      * @param classpath the classpath used for this compilation
      */
     public synchronized void setClasspath(Path classpath) {
         if (compileClasspath == null) {
             compileClasspath = classpath;
         } else {
             compileClasspath.append(classpath);
         }
     }
 
     /**
      * Creates a nested classpath element.
      * @return classpath
      */
     public synchronized Path createClasspath() {
         if (compileClasspath == null) {
             compileClasspath = new Path(getProject());
         }
         return compileClasspath.createPath();
     }
 
     /**
      * Adds to the classpath a reference to
      * a &lt;path&gt; defined elsewhere.
      * @param pathRef the reference to add to the classpath
      */
     public void setClasspathRef(Reference pathRef) {
         createClasspath().setRefid(pathRef);
     }
 
     /**
      * Gets the classpath.
      * @return the classpath
      */
     public Path getClasspath() {
         return compileClasspath;
     }
 
     /**
      * Flag to enable verification so that the classes
      * found by the directory match are
      * checked to see if they implement java.rmi.Remote.
      * optional; This defaults to false if not set.
      * @param verify turn on verification for classes
      */
     public void setVerify(boolean verify) {
         this.verify = verify;
     }
 
     /**
      * Get verify flag.
      * @return verify
      */
     public boolean getVerify() {
         return verify;
     }
 
     /**
      * Indicates that IIOP compatible stubs should
      * be generated; optional, defaults to false
      * if not set.
      * @param iiop generate IIOP compatible stubs
      */
     public void setIiop(boolean iiop) {
         this.iiop = iiop;
     }
 
     /**
      * Gets iiop flags.
      * @return iiop
      */
     public boolean getIiop() {
         return iiop;
     }
 
     /**
      * Set additional arguments for iiop
      * @param iiopOpts additional arguments for iiop
      */
     public void setIiopopts(String iiopOpts) {
         this.iiopOpts = iiopOpts;
     }
 
     /**
      * Gets additional arguments for iiop.
      * @return iiopOpts
      */
     public String getIiopopts() {
         return iiopOpts;
     }
 
     /**
      * Indicates that IDL output should be
      * generated.  This defaults to false
      * if not set.
      * @param idl generate IDL output
      */
     public void setIdl(boolean idl) {
         this.idl = idl;
     }
 
     /**
      * Gets IDL flags.
      * @return the idl flag
      */
     public boolean getIdl() {
         return idl;
     }
 
     /**
      * pass additional arguments for IDL compile
      * @param idlOpts additional IDL arguments
      */
     public void setIdlopts(String idlOpts) {
         this.idlOpts = idlOpts;
     }
 
     /**
      * Gets additional arguments for idl compile.
      * @return the idl options
      */
     public String getIdlopts() {
         return idlOpts;
     }
 
     /**
      * Gets file list to compile.
      * @return the list of files to compile.
      */
     public Vector getFileList() {
         return compileList;
     }
 
     /**
      * Sets whether or not to include ant's own classpath in this task's
      * classpath.
      * Optional; default is <code>true</code>.
      * @param include if true include ant's classpath
      */
     public void setIncludeantruntime(boolean include) {
         includeAntRuntime = include;
     }
 
     /**
      * Gets whether or not the ant classpath is to be included in the
      * task's classpath.
      * @return true if ant's classpath is to be included
      */
     public boolean getIncludeantruntime() {
         return includeAntRuntime;
     }
 
     /**
      * task's classpath.
      * Enables or disables including the default run-time
      * libraries from the executing VM; optional,
      * defaults to false
      * @param include if true include default run-time libraries
      */
     public void setIncludejavaruntime(boolean include) {
         includeJavaRuntime = include;
     }
 
     /**
      * Gets whether or not the java runtime should be included in this
      * task's classpath.
      * @return true if default run-time libraries are included
      */
     public boolean getIncludejavaruntime() {
         return includeJavaRuntime;
     }
 
     /**
      * Sets the extension directories that will be used during the
      * compilation; optional.
      * @param extDirs the extension directories to be used
      */
     public synchronized void setExtdirs(Path extDirs) {
         if (this.extDirs == null) {
             this.extDirs = extDirs;
         } else {
             this.extDirs.append(extDirs);
         }
     }
 
     /**
      * Maybe creates a nested extdirs element.
      * @return path object to be configured with the extension directories
      */
     public synchronized Path createExtdirs() {
         if (extDirs == null) {
             extDirs = new Path(getProject());
         }
         return extDirs.createPath();
     }
 
     /**
      * Gets the extension directories that will be used during the
      * compilation.
      * @return the extension directories to be used
      */
     public Path getExtdirs() {
         return extDirs;
     }
 
     /**
      * @return the compile list.
      */
     public Vector getCompileList() {
         return compileList;
     }
 
     /**
      * Sets the compiler implementation to use; optional,
      * defaults to the value of the <code>build.rmic</code> property,
      * or failing that, default compiler for the current VM
-     * @param compiler the compiler implemention to use
+     * @param compiler the compiler implementation to use
      * @since Ant 1.5
      */
     public void setCompiler(String compiler) {
         if (compiler.length() > 0) {
             facade.setImplementation(compiler);
         }
     }
 
     /**
      * get the name of the current compiler
      * @return the name of the compiler
      * @since Ant 1.5
      */
     public String getCompiler() {
         facade.setMagicValue(getProject().getProperty("build.rmic"));
         return facade.getImplementation();
     }
 
     /**
      * Adds an implementation specific command line argument.
      * @return an object to be configured with a command line argument
      * @since Ant 1.5
      */
     public ImplementationSpecificArgument createCompilerArg() {
         ImplementationSpecificArgument arg = new ImplementationSpecificArgument();
         facade.addImplementationArgument(arg);
         return arg;
     }
 
     /**
      * Get the additional implementation specific command line arguments.
      * @return array of command line arguments, guaranteed to be non-null.
      * @since Ant 1.5
      */
     public String[] getCurrentCompilerArgs() {
         getCompiler();
         return facade.getArgs();
     }
 
     /**
      * Name of the executable to use when forking.
      *
      * @since Ant 1.8.0
      */
     public void setExecutable(String ex) {
         executable = ex;
     }
 
     /**
      * Explicitly specified name of the executable to use when forking
      * - if any.
      *
      * @since Ant 1.8.0
      */
     public String getExecutable() {
         return executable;
     }
 
     /**
      * The classpath to use when loading the compiler implementation
      * if it is not a built-in one.
      *
      * @since Ant 1.8.0
      */
     public Path createCompilerClasspath() {
         return facade.getImplementationClasspath(getProject());
     }
 
     /**
      * If true, list the source files being handed off to the compiler.
      * @param list if true list the source files
      * @since Ant 1.8.0
      */
     public void setListfiles(boolean list) {
         listFiles = list;
     }
 
     /**
      * Set the compiler adapter explicitly.
      * @since Ant 1.8.0
      */
     public void add(RmicAdapter adapter) {
         if (nestedAdapter != null) {
             throw new BuildException("Can't have more than one rmic adapter");
         }
         nestedAdapter = adapter;
     }
 
     /**
      * execute by creating an instance of an implementation
      * class and getting to do the work
      * @throws org.apache.tools.ant.BuildException
      * if there's a problem with baseDir or RMIC
      */
     public void execute() throws BuildException {
         try {
             compileList.clear();
 
             File outputDir = getOutputDir();
             if (outputDir == null) {
                 throw new BuildException(ERROR_BASE_NOT_SET, getLocation());
             }
             if (!outputDir.exists()) {
                 throw new BuildException(ERROR_NO_BASE_EXISTS + outputDir,
                                          getLocation());
             }
             if (!outputDir.isDirectory()) {
                 throw new BuildException(ERROR_NOT_A_DIR + outputDir, getLocation());
             }
             if (verify) {
                 log("Verify has been turned on.", Project.MSG_VERBOSE);
             }
             RmicAdapter adapter =
                 nestedAdapter != null ? nestedAdapter :
                 RmicAdapterFactory.getRmic(getCompiler(), this,
                                            createCompilerClasspath());
 
             // now we need to populate the compiler adapter
             adapter.setRmic(this);
 
             Path classpath = adapter.getClasspath();
             loader = getProject().createClassLoader(classpath);
 
             // scan base dirs to build up compile lists only if a
             // specific classname is not given
             if (classname == null) {
                 DirectoryScanner ds = this.getDirectoryScanner(baseDir);
                 String[] files = ds.getIncludedFiles();
                 scanDir(baseDir, files, adapter.getMapper());
             } else {
                 // otherwise perform a timestamp comparison - at least
                 String path = classname.replace('.', File.separatorChar)
                     + ".class";
                 File f = new File(baseDir, path);
                 if (f.isFile()) {
                     scanDir(baseDir, new String[] {path}, adapter.getMapper());
                 } else {
                     // Does not exist, so checking whether it is up to
                     // date makes no sense.  Compilation will fail
                     // later anyway, but tests expect a certain
                     // output.
                     compileList.add(classname);
                 }
             }
             int fileCount = compileList.size();
             if (fileCount > 0) {
                 log("RMI Compiling " + fileCount + " class"
                     + (fileCount > 1 ? "es" : "") + " to "
                     + outputDir, Project.MSG_INFO);
 
                 if (listFiles) {
                     for (int i = 0; i < fileCount; i++) {
                         log(compileList.get(i).toString());
                     }
                 }
 
                 // finally, lets execute the compiler!!
                 if (!adapter.execute()) {
                     throw new BuildException(ERROR_RMIC_FAILED, getLocation());
                 }
             }
             /*
              * Move the generated source file to the base directory.  If
              * base directory and sourcebase are the same, the generated
              * sources are already in place.
              */
             if (null != sourceBase && !outputDir.equals(sourceBase)
                 && fileCount > 0) {
                 if (idl) {
                     log("Cannot determine sourcefiles in idl mode, ",
                         Project.MSG_WARN);
                     log("sourcebase attribute will be ignored.",
                         Project.MSG_WARN);
                 } else {
                     for (int j = 0; j < fileCount; j++) {
                         moveGeneratedFile(outputDir, sourceBase,
                                           (String) compileList.elementAt(j),
                                           adapter);
                     }
                 }
             }
         } finally {
             cleanup();
         }
     }
 
     /**
      * Cleans up resources.
      *
      * @since Ant 1.8.0
      */
     protected void cleanup() {
         if (loader != null) {
             loader.cleanup();
             loader = null;
         }
     }
 
     /**
      * Move the generated source file(s) to the base directory
      *
      * @throws org.apache.tools.ant.BuildException When error
      * copying/removing files.
      */
     private void moveGeneratedFile(File baseDir, File sourceBaseFile, String classname,
                                    RmicAdapter adapter) throws BuildException {
         String classFileName = classname.replace('.', File.separatorChar)
             + ".class";
         String[] generatedFiles = adapter.getMapper().mapFileName(classFileName);
 
         for (int i = 0; i < generatedFiles.length; i++) {
             final String generatedFile = generatedFiles[i];
             if (!generatedFile.endsWith(".class")) {
                 // don't know how to handle that - a IDL file doesn't
                 // have a corresponding Java source for example.
                 continue;
             }
             String sourceFileName = StringUtils.removeSuffix(generatedFile,
                                                              ".class")
                 + ".java";
 
             File oldFile = new File(baseDir, sourceFileName);
             if (!oldFile.exists()) {
                 // no source file generated, nothing to move
                 continue;
             }
 
             File newFile = new File(sourceBaseFile, sourceFileName);
             try {
                 if (filtering) {
                     FILE_UTILS.copyFile(oldFile, newFile,
                                         new FilterSetCollection(getProject()
                                                                 .getGlobalFilterSet()));
                 } else {
                     FILE_UTILS.copyFile(oldFile, newFile);
                 }
                 oldFile.delete();
             } catch (IOException ioe) {
                 String msg = "Failed to copy " + oldFile + " to " + newFile
                     + " due to "
                     + ioe.getMessage();
                 throw new BuildException(msg, ioe, getLocation());
             }
         }
     }
 
     /**
      * Scans the directory looking for class files to be compiled.
      * The result is returned in the class variable compileList.
      * @param baseDir the base direction
      * @param files   the list of files to scan
      * @param mapper  the mapper of files to target files
      */
     protected void scanDir(File baseDir, String[] files, FileNameMapper mapper) {
         String[] newFiles = files;
         if (idl) {
             log("will leave uptodate test to rmic implementation in idl mode.",
                 Project.MSG_VERBOSE);
         } else if (iiop && iiopOpts != null && iiopOpts.indexOf("-always") > -1) {
             log("no uptodate test as -always option has been specified",
                 Project.MSG_VERBOSE);
         } else {
             SourceFileScanner sfs = new SourceFileScanner(this);
             newFiles = sfs.restrict(files, baseDir, getOutputDir(), mapper);
         }
         for (int i = 0; i < newFiles.length; i++) {
             String name = newFiles[i].replace(File.separatorChar, '.');
             name = name.substring(0, name.lastIndexOf(".class"));
             compileList.addElement(name);
         }
     }
 
     /**
      * Load named class and test whether it can be rmic'ed
      * @param classname the name of the class to be tested
      * @return true if the class can be rmic'ed
      */
     public boolean isValidRmiRemote(String classname) {
         try {
             Class testClass = loader.loadClass(classname);
             // One cannot RMIC an interface for "classic" RMI (JRMP)
             if (testClass.isInterface() && !iiop && !idl) {
                 return false;
             }
             return isValidRmiRemote(testClass);
         } catch (ClassNotFoundException e) {
             log(ERROR_UNABLE_TO_VERIFY_CLASS + classname + ERROR_NOT_FOUND,
                 Project.MSG_WARN);
         } catch (NoClassDefFoundError e) {
             log(ERROR_UNABLE_TO_VERIFY_CLASS + classname + ERROR_NOT_DEFINED,
                 Project.MSG_WARN);
         } catch (Throwable t) {
             log(ERROR_UNABLE_TO_VERIFY_CLASS + classname
                 + ERROR_LOADING_CAUSED_EXCEPTION + t.getMessage(),
                 Project.MSG_WARN);
         }
         // we only get here if an exception has been thrown
         return false;
     }
 
     /**
      * Returns the topmost interface that extends Remote for a given
      * class - if one exists.
      * @param testClass the class to be tested
      * @return the topmost interface that extends Remote, or null if there
      *         is none.
      */
     public Class getRemoteInterface(Class testClass) {
         if (Remote.class.isAssignableFrom(testClass)) {
             Class [] interfaces = testClass.getInterfaces();
             if (interfaces != null) {
                 for (int i = 0; i < interfaces.length; i++) {
                     if (Remote.class.isAssignableFrom(interfaces[i])) {
                         return interfaces[i];
                     }
                 }
             }
         }
         return null;
     }
 
     /**
      * Check to see if the class or (super)interfaces implement
      * java.rmi.Remote.
      */
     private boolean isValidRmiRemote (Class testClass) {
         return getRemoteInterface(testClass) != null;
     }
 
     /**
      * Classloader for the user-specified classpath.
      * @return the classloader
      */
     public ClassLoader getLoader() {
         return loader;
     }
 
     /**
      * Adds an "compiler" attribute to Commandline$Attribute used to
      * filter command line attributes based on the current
      * implementation.
      */
     public class ImplementationSpecificArgument extends
                                                     org.apache.tools.ant.util.facade.ImplementationSpecificArgument {
         /**
          * Only pass the specified argument if the
          * chosen compiler implementation matches the
          * value of this attribute. Legal values are
          * the same as those in the above list of
          * valid compilers.)
          * @param impl the compiler to be used.
          */
         public void setCompiler(String impl) {
             super.setImplementation(impl);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/SQLExec.java b/src/main/org/apache/tools/ant/taskdefs/SQLExec.java
index 4515f501b..576ececc7 100644
--- a/src/main/org/apache/tools/ant/taskdefs/SQLExec.java
+++ b/src/main/org/apache/tools/ant/taskdefs/SQLExec.java
@@ -1,1138 +1,1138 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.KeepAliveOutputStream;
 import org.apache.tools.ant.util.StringUtils;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.resources.Appendable;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.Union;
 
 import java.io.File;
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.io.BufferedOutputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.Reader;
 import java.io.BufferedReader;
 import java.io.StringReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.StringTokenizer;
 import java.util.Vector;
 
 import java.sql.Blob;
 import java.sql.Connection;
 import java.sql.Statement;
 import java.sql.SQLException;
 import java.sql.SQLWarning;
 import java.sql.ResultSet;
 import java.sql.ResultSetMetaData;
 import java.sql.Types;
 
 /**
  * Executes a series of SQL statements on a database using JDBC.
  *
  * <p>Statements can
  * either be read in from a text file using the <i>src</i> attribute or from
  * between the enclosing SQL tags.</p>
  *
  * <p>Multiple statements can be provided, separated by semicolons (or the
  * defined <i>delimiter</i>). Individual lines within the statements can be
  * commented using either --, // or REM at the start of the line.</p>
  *
  * <p>The <i>autocommit</i> attribute specifies whether auto-commit should be
  * turned on or off whilst executing the statements. If auto-commit is turned
  * on each statement will be executed and committed. If it is turned off the
  * statements will all be executed as one transaction.</p>
  *
  * <p>The <i>onerror</i> attribute specifies how to proceed when an error occurs
  * during the execution of one of the statements.
  * The possible values are: <b>continue</b> execution, only show the error;
  * <b>stop</b> execution and commit transaction;
  * and <b>abort</b> execution and transaction and fail task.</p>
  *
  * @since Ant 1.2
  *
  * @ant.task name="sql" category="database"
  */
 public class SQLExec extends JDBCTask {
 
     /**
      * delimiters we support, "normal" and "row"
      */
     public static class DelimiterType extends EnumeratedAttribute {
         /** The enumerated strings */
         public static final String NORMAL = "normal", ROW = "row";
         /** @return the enumerated strings */
         public String[] getValues() {
             return new String[] {NORMAL, ROW};
         }
     }
 
     private int goodSql = 0;
 
     private int totalSql = 0;
 
     /**
      * Database connection
      */
     private Connection conn = null;
 
     /**
      * files to load
      */
     private Union resources;
 
     /**
      * SQL statement
      */
     private Statement statement = null;
 
     /**
      * SQL input file
      */
     private File srcFile = null;
 
     /**
      * SQL input command
      */
     private String sqlCommand = "";
 
     /**
      * SQL transactions to perform
      */
     private Vector transactions = new Vector();
 
     /**
      * SQL Statement delimiter
      */
     private String delimiter = ";";
 
     /**
      * The delimiter type indicating whether the delimiter will
      * only be recognized on a line by itself
      */
     private String delimiterType = DelimiterType.NORMAL;
 
     /**
      * Print SQL results.
      */
     private boolean print = false;
 
     /**
      * Print header columns.
      */
     private boolean showheaders = true;
 
     /**
      * Print SQL stats (rows affected)
      */
     private boolean showtrailers = true;
 
     /**
      * Results Output Resource.
      */
     private Resource output = null;
 
     /**
      * Action to perform if an error is found
      */
     private String onError = "abort";
 
     /**
      * Encoding to use when reading SQL statements from a file
      */
     private String encoding = null;
 
     /**
      * Append to an existing file or overwrite it?
      */
     private boolean append = false;
 
     /**
      * Keep the format of a sql block?
      */
     private boolean keepformat = false;
 
     /**
      * Argument to Statement.setEscapeProcessing
      *
      * @since Ant 1.6
      */
     private boolean escapeProcessing = true;
 
     /**
      * should properties be expanded in text?
      * false for backwards compatibility
      *
      * @since Ant 1.7
      */
     private boolean expandProperties = true;
 
     /**
      * should we print raw BLOB data?
      * @since Ant 1.7.1
      */
     private boolean rawBlobs;
 
     /**
-     * delimers must match in case and whitespace is significant.
+     * delimiters must match in case and whitespace is significant.
      * @since Ant 1.8.0
      */
     private boolean strictDelimiterMatching = true;
 
     /**
      * whether to show SQLWarnings as WARN messages.
      * @since Ant 1.8.0
      */
     private boolean showWarnings = false;
 
     /**
      * The column separator used when printing the results.
      *
      * <p>Defaults to ","</p>
      *
      * @since Ant 1.8.0
      */
     private String csvColumnSep = ",";
 
     /**
      * The character used to quote column values.
      *
      * <p>If set, columns that contain either the column separator or
      * the quote character itself will be surrounded by the quote
      * character.  The quote character itself will be doubled if it
      * appears inside of the column's value.</p>
      *
      * <p>If this value is not set (the default), no column values
      * will be quoted, not even if they contain the column
      * separator.</p>
      *
      * <p><b>Note:<b> BLOB values will never be quoted.</p>
      *
      * <p>Defaults to "not set"</p>
      *
      * @since Ant 1.8.0
      */
     private String csvQuoteChar = null;
 
     /**
-     * Whether a warning is an error - in which case onError aplies.
+     * Whether a warning is an error - in which case onError applies.
      * @since Ant 1.8.0
      */
     private boolean treatWarningsAsErrors = false;
 
     /**
      * The name of the property to set in the event of an error
      * @since Ant 1.8.0
      */
     private String errorProperty = null;
 
     /**
      * The name of the property to set in the event of a warning
      * @since Ant 1.8.0
      */
     private String warningProperty = null;
 
     /**
      * The name of the property that receives the number of rows
      * returned
      * @since Ant 1.8.0
      */
     private String rowCountProperty = null;
 
     /**
      * Set the name of the SQL file to be run.
      * Required unless statements are enclosed in the build file
      * @param srcFile the file containing the SQL command.
      */
     public void setSrc(File srcFile) {
         this.srcFile = srcFile;
     }
 
     /**
      * Enable property expansion inside nested text
      *
      * @param expandProperties if true expand properties.
      * @since Ant 1.7
      */
     public void setExpandProperties(boolean expandProperties) {
         this.expandProperties = expandProperties;
     }
 
     /**
      * is property expansion inside inline text enabled?
      *
      * @return true if properties are to be expanded.
      * @since Ant 1.7
      */
     public boolean getExpandProperties() {
         return expandProperties;
     }
 
     /**
      * Set an inline SQL command to execute.
      * NB: Properties are not expanded in this text unless {@link #expandProperties}
      * is set.
      * @param sql an inline string containing the SQL command.
      */
     public void addText(String sql) {
         //there is no need to expand properties here as that happens when Transaction.addText is
         //called; to do so here would be an error.
         this.sqlCommand += sql;
     }
 
     /**
      * Adds a set of files (nested fileset attribute).
      * @param set a set of files contains SQL commands, each File is run in
      *            a separate transaction.
      */
     public void addFileset(FileSet set) {
         add(set);
     }
 
     /**
      * Adds a collection of resources (nested element).
      * @param rc a collection of resources containing SQL commands,
      * each resource is run in a separate transaction.
      * @since Ant 1.7
      */
     public void add(ResourceCollection rc) {
         if (rc == null) {
             throw new BuildException("Cannot add null ResourceCollection");
         }
         synchronized (this) {
             if (resources == null) {
                 resources = new Union();
             }
         }
         resources.add(rc);
     }
 
     /**
      * Add a SQL transaction to execute
      * @return a Transaction to be configured.
      */
     public Transaction createTransaction() {
         Transaction t = new Transaction();
         transactions.addElement(t);
         return t;
     }
 
     /**
      * Set the file encoding to use on the SQL files read in
      *
      * @param encoding the encoding to use on the files
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * Set the delimiter that separates SQL statements. Defaults to &quot;;&quot;;
      * optional
      *
      * <p>For example, set this to "go" and delimitertype to "ROW" for
      * Sybase ASE or MS SQL Server.</p>
      * @param delimiter the separator.
      */
     public void setDelimiter(String delimiter) {
         this.delimiter = delimiter;
     }
 
     /**
      * Set the delimiter type: "normal" or "row" (default "normal").
      *
      * <p>The delimiter type takes two values - normal and row. Normal
      * means that any occurrence of the delimiter terminate the SQL
      * command whereas with row, only a line containing just the
      * delimiter is recognized as the end of the command.</p>
      * @param delimiterType the type of delimiter - "normal" or "row".
      */
     public void setDelimiterType(DelimiterType delimiterType) {
         this.delimiterType = delimiterType.getValue();
     }
 
     /**
      * Print result sets from the statements;
      * optional, default false
      * @param print if true print result sets.
      */
     public void setPrint(boolean print) {
         this.print = print;
     }
 
     /**
      * Print headers for result sets from the
      * statements; optional, default true.
      * @param showheaders if true print headers of result sets.
      */
     public void setShowheaders(boolean showheaders) {
         this.showheaders = showheaders;
     }
 
     /**
      * Print trailing info (rows affected) for the SQL
      * Addresses Bug/Request #27446
      * @param showtrailers if true prints the SQL rows affected
      * @since Ant 1.7
      */
     public void setShowtrailers(boolean showtrailers) {
         this.showtrailers = showtrailers;
     }
 
     /**
      * Set the output file;
      * optional, defaults to the Ant log.
      * @param output the output file to use for logging messages.
      */
     public void setOutput(File output) {
         setOutput(new FileResource(getProject(), output));
     }
 
     /**
      * Set the output Resource;
      * optional, defaults to the Ant log.
      * @param output the output Resource to store results.
      * @since Ant 1.8
      */
     public void setOutput(Resource output) {
         this.output = output;
     }
 
     /**
      * whether output should be appended to or overwrite
      * an existing file.  Defaults to false.
      *
      * @since Ant 1.5
      * @param append if true append to an existing file.
      */
     public void setAppend(boolean append) {
         this.append = append;
     }
 
 
     /**
      * Action to perform when statement fails: continue, stop, or abort
      * optional; default &quot;abort&quot;
      * @param action the action to perform on statement failure.
      */
     public void setOnerror(OnError action) {
         this.onError = action.getValue();
     }
 
     /**
      * whether or not format should be preserved.
      * Defaults to false.
      *
      * @param keepformat The keepformat to set
      */
     public void setKeepformat(boolean keepformat) {
         this.keepformat = keepformat;
     }
 
     /**
      * Set escape processing for statements.
      * @param enable if true enable escape processing, default is true.
      * @since Ant 1.6
      */
     public void setEscapeProcessing(boolean enable) {
         escapeProcessing = enable;
     }
 
     /**
      * Set whether to print raw BLOBs rather than their string (hex) representations.
      * @param rawBlobs whether to print raw BLOBs.
      * @since Ant 1.7.1
      */
     public void setRawBlobs(boolean rawBlobs) {
         this.rawBlobs = rawBlobs;
     }
 
     /**
-     * If false, delimiters will be searched for in a case-insesitive
-     * manner (i.e. delimer="go" matches "GO") and surrounding
-     * whitespace will be ignored (delimter="go" matches "GO ").
+     * If false, delimiters will be searched for in a case-insensitive
+     * manner (i.e. delimiter="go" matches "GO") and surrounding
+     * whitespace will be ignored (delimiter="go" matches "GO ").
      * @since Ant 1.8.0
      */
     public void setStrictDelimiterMatching(boolean b) {
         strictDelimiterMatching = b;
     }
 
     /**
      * whether to show SQLWarnings as WARN messages.
      * @since Ant 1.8.0
      */
     public void setShowWarnings(boolean b) {
         showWarnings = b;
     }
 
     /**
-     * Whether a warning is an error - in which case onError aplies.
+     * Whether a warning is an error - in which case onError applies.
      * @since Ant 1.8.0
      */
     public void setTreatWarningsAsErrors(boolean b) {
         treatWarningsAsErrors =  b;
     }
 
     /**
      * The column separator used when printing the results.
      *
      * <p>Defaults to ","</p>
      *
      * @since Ant 1.8.0
      */
     public void setCsvColumnSeparator(String s) {
         csvColumnSep = s;
     }
 
     /**
      * The character used to quote column values.
      *
      * <p>If set, columns that contain either the column separator or
      * the quote character itself will be surrounded by the quote
      * character.  The quote character itself will be doubled if it
      * appears inside of the column's value.</p>
      *
      * <p>If this value is not set (the default), no column values
      * will be quoted, not even if they contain the column
      * separator.</p>
      *
      * <p><b>Note:<b> BLOB values will never be quoted.</p>
      *
      * <p>Defaults to "not set"</p>
      *
      * @since Ant 1.8.0
      */
     public void setCsvQuoteCharacter(String s) {
         if (s != null && s.length() > 1) {
             throw new BuildException("The quote character must be a single"
                                      + " character.");
         }
         csvQuoteChar = s;
     }
 
     /**
      * Property to set to "true" if a statement throws an error.
      *
      * @param errorProperty the name of the property to set in the
      * event of an error.
      * @since Ant 1.8.0
      */
     public void setErrorProperty(String errorProperty) {
         this.errorProperty = errorProperty;
     }
 
     /**
      * Property to set to "true" if a statement produces a warning.
      *
      * @param warningProperty the name of the property to set in the
      * event of a warning.
      * @since Ant 1.8.0
      */
     public void setWarningProperty(String warningProperty) {
         this.warningProperty = warningProperty;
     }
 
     /**
      * Sets a given property to the number of rows in the first
      * statement that returned a row count.
      * @since Ant 1.8.0
      */
     public void setRowCountProperty(String rowCountProperty) {
         this.rowCountProperty = rowCountProperty;
     }
 
     /**
      * Load the sql file and then execute it
      * @throws BuildException on error.
      */
     public void execute() throws BuildException {
         Vector savedTransaction = (Vector) transactions.clone();
         String savedSqlCommand = sqlCommand;
 
         sqlCommand = sqlCommand.trim();
 
         try {
             if (srcFile == null && sqlCommand.length() == 0 && resources == null) {
                 if (transactions.size() == 0) {
                     throw new BuildException("Source file or resource collection, "
                                              + "transactions or sql statement "
                                              + "must be set!", getLocation());
                 }
             }
 
             if (srcFile != null && !srcFile.isFile()) {
                 throw new BuildException("Source file " + srcFile
                         + " is not a file!", getLocation());
             }
 
             if (resources != null) {
                 // deal with the resources
                 for (Resource r : resources) {
                     // Make a transaction for each resource
                     Transaction t = createTransaction();
                     t.setSrcResource(r);
                 }
             }
 
             // Make a transaction group for the outer command
             Transaction t = createTransaction();
             t.setSrc(srcFile);
             t.addText(sqlCommand);
 
             if (getConnection() == null) {
                 // not a valid rdbms
                 return;
             }
 
             try {
                 PrintStream out = KeepAliveOutputStream.wrapSystemOut();
                 try {
                     if (output != null) {
                         log("Opening PrintStream to output Resource " + output, Project.MSG_VERBOSE);
                         OutputStream os = null;
                         FileProvider fp =
                             output.as(FileProvider.class);
                         if (fp != null) {
                             os = new FileOutputStream(fp.getFile(), append);
                         } else {
                             if (append) {
                                 Appendable a =
                                     output.as(Appendable.class);
                                 if (a != null) {
                                     os = a.getAppendOutputStream();
                                 }
                             }
                             if (os == null) {
                                 os = output.getOutputStream();
                                 if (append) {
                                     log("Ignoring append=true for non-appendable"
                                         + " resource " + output,
                                         Project.MSG_WARN);
                                 }
                             }
                         }
                         out = new PrintStream(new BufferedOutputStream(os));
                     }
 
                     // Process all transactions
                     for (Enumeration e = transactions.elements();
                          e.hasMoreElements();) {
 
                         ((Transaction) e.nextElement()).runTransaction(out);
                         if (!isAutocommit()) {
                             log("Committing transaction", Project.MSG_VERBOSE);
                             getConnection().commit();
                         }
                     }
                 } finally {
                     FileUtils.close(out);
                 }
             } catch (IOException e) {
                 closeQuietly();
                 setErrorProperty();
                 if (onError.equals("abort")) {
                     throw new BuildException(e, getLocation());
                 }
             } catch (SQLException e) {
                 closeQuietly();
                 setErrorProperty();
                 if (onError.equals("abort")) {
                     throw new BuildException(e, getLocation());
                 }
             } finally {
                 try {
                     if (getStatement() != null) {
                         getStatement().close();
                     }
                 } catch (SQLException ex) {
                     // ignore
                 }
                 try {
                     if (getConnection() != null) {
                         getConnection().close();
                     }
                 } catch (SQLException ex) {
                     // ignore
                 }
             }
 
             log(goodSql + " of " + totalSql + " SQL statements executed successfully");
         } finally {
             transactions = savedTransaction;
             sqlCommand = savedSqlCommand;
         }
     }
 
     /**
      * read in lines and execute them
      * @param reader the reader contains sql lines.
      * @param out the place to output results.
      * @throws SQLException on sql problems
      * @throws IOException on io problems
      */
     protected void runStatements(Reader reader, PrintStream out)
         throws SQLException, IOException {
         StringBuffer sql = new StringBuffer();
         String line;
 
         BufferedReader in = new BufferedReader(reader);
 
         while ((line = in.readLine()) != null) {
             if (!keepformat) {
                 line = line.trim();
             }
             if (expandProperties) {
                 line = getProject().replaceProperties(line);
             }
             if (!keepformat) {
                 if (line.startsWith("//")) {
                     continue;
                 }
                 if (line.startsWith("--")) {
                     continue;
                 }
                 StringTokenizer st = new StringTokenizer(line);
                 if (st.hasMoreTokens()) {
                     String token = st.nextToken();
                     if ("REM".equalsIgnoreCase(token)) {
                         continue;
                     }
                 }
             }
 
             sql.append(keepformat ? "\n" : " ").append(line);
 
             // SQL defines "--" as a comment to EOL
             // and in Oracle it may contain a hint
             // so we cannot just remove it, instead we must end it
             if (!keepformat && line.indexOf("--") >= 0) {
                 sql.append("\n");
             }
             int lastDelimPos = lastDelimiterPosition(sql, line);
             if (lastDelimPos > -1) {
                 execSQL(sql.substring(0, lastDelimPos), out);
                 sql.replace(0, sql.length(), "");
             }
         }
         // Catch any statements not followed by ;
         if (sql.length() > 0) {
             execSQL(sql.toString(), out);
         }
     }
 
     /**
      * Exec the sql statement.
      * @param sql the SQL statement to execute
      * @param out the place to put output
      * @throws SQLException on SQL problems
      */
     protected void execSQL(String sql, PrintStream out) throws SQLException {
         // Check and ignore empty statements
         if ("".equals(sql.trim())) {
             return;
         }
 
         ResultSet resultSet = null;
         try {
             totalSql++;
             log("SQL: " + sql, Project.MSG_VERBOSE);
 
             boolean ret;
             int updateCount = 0, updateCountTotal = 0;
 
             ret = getStatement().execute(sql);
             updateCount = getStatement().getUpdateCount();
             do {
                 if (updateCount != -1) {
                     updateCountTotal += updateCount;
                 }
                 if (ret) {
                     resultSet = getStatement().getResultSet();
                     printWarnings(resultSet.getWarnings(), false);
                     resultSet.clearWarnings();
                     if (print) {
                         printResults(resultSet, out);
                     }
                 }
                 ret = getStatement().getMoreResults();
                 updateCount = getStatement().getUpdateCount();
             } while (ret || updateCount != -1);
 
             printWarnings(getStatement().getWarnings(), false);
             getStatement().clearWarnings();
 
             log(updateCountTotal + " rows affected", Project.MSG_VERBOSE);
             if (updateCountTotal != -1) {
                 setRowCountProperty(updateCountTotal);
             }
 
             if (print && showtrailers) {
                 out.println(updateCountTotal + " rows affected");
             }
             SQLWarning warning = getConnection().getWarnings();
             printWarnings(warning, true);
             getConnection().clearWarnings();
             goodSql++;
         } catch (SQLException e) {
             log("Failed to execute: " + sql, Project.MSG_ERR);
             setErrorProperty();
             if (!onError.equals("abort")) {
                 log(e.toString(), Project.MSG_ERR);
             }
             if (!onError.equals("continue")) {
                 throw e;
             }
         } finally {
             if (resultSet != null) {
                 try {
                     resultSet.close();
                 } catch (SQLException e) {
                     //ignore
                 }
             }
         }
     }
 
     /**
      * print any results in the statement
      * @deprecated since 1.6.x.
      *             Use {@link #printResults(java.sql.ResultSet, java.io.PrintStream)
      *             the two arg version} instead.
      * @param out the place to print results
      * @throws SQLException on SQL problems.
      */
     protected void printResults(PrintStream out) throws SQLException {
         ResultSet rs = getStatement().getResultSet();
         try {
             printResults(rs, out);
         } finally {
             if (rs != null) {
                 rs.close();
             }
         }
     }
 
     /**
      * print any results in the result set.
      * @param rs the resultset to print information about
      * @param out the place to print results
      * @throws SQLException on SQL problems.
      * @since Ant 1.6.3
      */
     protected void printResults(ResultSet rs, PrintStream out) throws SQLException {
         if (rs != null) {
             log("Processing new result set.", Project.MSG_VERBOSE);
             ResultSetMetaData md = rs.getMetaData();
             int columnCount = md.getColumnCount();
             if (columnCount > 0) {
                 if (showheaders) {
                     out.print(md.getColumnName(1));
                     for (int col = 2; col <= columnCount; col++) {
                          out.print(csvColumnSep);
                          out.print(maybeQuote(md.getColumnName(col)));
                     }
                     out.println();
                 }
                 while (rs.next()) {
                     printValue(rs, 1, out);
                     for (int col = 2; col <= columnCount; col++) {
                         out.print(csvColumnSep);
                         printValue(rs, col, out);
                     }
                     out.println();
                     printWarnings(rs.getWarnings(), false);
                 }
             }
         }
         out.println();
     }
 
     private void printValue(ResultSet rs, int col, PrintStream out)
             throws SQLException {
         if (rawBlobs && rs.getMetaData().getColumnType(col) == Types.BLOB) {
             Blob blob = rs.getBlob(col);
             if (blob != null) {
                 new StreamPumper(rs.getBlob(col).getBinaryStream(), out).run();
             }
         } else {
             out.print(maybeQuote(rs.getString(col)));
         }
     }
 
     private String maybeQuote(String s) {
         if (csvQuoteChar == null || s == null
             || (s.indexOf(csvColumnSep) == -1 && s.indexOf(csvQuoteChar) == -1)
             ) {
             return s;
         }
         StringBuffer sb = new StringBuffer(csvQuoteChar);
         int len = s.length();
         char q = csvQuoteChar.charAt(0);
         for (int i = 0; i < len; i++) {
             char c = s.charAt(i);
             if (c == q) {
                 sb.append(q);
             }
             sb.append(c);
         }
         return sb.append(csvQuoteChar).toString();
     }
 
     /*
      * Closes an unused connection after an error and doesn't rethrow
      * a possible SQLException
      * @since Ant 1.7
      */
     private void closeQuietly() {
         if (!isAutocommit() && getConnection() != null && onError.equals("abort")) {
             try {
                 getConnection().rollback();
             } catch (SQLException ex) {
                 // ignore
             }
         }
     }
 
 
     /**
      * Caches the connection returned by the base class's getConnection method.
      *
      * <p>Subclasses that need to provide a different connection than
      * the base class would, should override this method but keep in
      * mind that this class expects to get the same connection
      * instance on consecutive calls.</p>
      *
      * <p>returns null if the connection does not connect to the
      * expected RDBMS.</p>
      */
     protected Connection getConnection() {
         if (conn == null) {
             conn = super.getConnection();
             if (!isValidRdbms(conn)) {
                 conn = null;
             }
         }
         return conn;
     }
 
     /**
      * Creates and configures a Statement instance which is then
      * cached for subsequent calls.
      *
      * <p>Subclasses that want to provide different Statement
      * instances, should override this method but keep in mind that
      * this class expects to get the same connection instance on
      * consecutive calls.</p>
      */
     protected Statement getStatement() throws SQLException {
         if (statement == null) {
             statement = getConnection().createStatement();
             statement.setEscapeProcessing(escapeProcessing);
         }
 
         return statement;
     }
         
     /**
      * The action a task should perform on an error,
      * one of "continue", "stop" and "abort"
      */
     public static class OnError extends EnumeratedAttribute {
         /** @return the enumerated values */
         public String[] getValues() {
             return new String[] {"continue", "stop", "abort"};
         }
     }
 
     /**
      * Contains the definition of a new transaction element.
      * Transactions allow several files or blocks of statements
      * to be executed using the same JDBC connection and commit
      * operation in between.
      */
     public class Transaction {
         private Resource tSrcResource = null;
         private String tSqlCommand = "";
 
         /**
          * Set the source file attribute.
          * @param src the source file
          */
         public void setSrc(File src) {
             //there are places (in this file, and perhaps elsewhere, where it is assumed
             //that null is an acceptable parameter.
             if (src != null) {
                 setSrcResource(new FileResource(src));
             }
         }
 
         /**
          * Set the source resource attribute.
          * @param src the source file
          * @since Ant 1.7
          */
         public void setSrcResource(Resource src) {
             if (tSrcResource != null) {
                 throw new BuildException("only one resource per transaction");
             }
             tSrcResource = src;
         }
 
         /**
          * Set inline text
          * @param sql the inline text
          */
         public void addText(String sql) {
             if (sql != null) {
                 this.tSqlCommand += sql;
             }
         }
 
         /**
          * Set the source resource.
          * @param a the source resource collection.
          * @since Ant 1.7
          */
         public void addConfigured(ResourceCollection a) {
             if (a.size() != 1) {
                 throw new BuildException("only single argument resource "
                                          + "collections are supported.");
             }
             setSrcResource(a.iterator().next());
         }
 
         /**
          *
          */
         private void runTransaction(PrintStream out)
             throws IOException, SQLException {
             if (tSqlCommand.length() != 0) {
                 log("Executing commands", Project.MSG_INFO);
                 runStatements(new StringReader(tSqlCommand), out);
             }
 
             if (tSrcResource != null) {
                 log("Executing resource: " + tSrcResource.toString(),
                     Project.MSG_INFO);
                 InputStream is = null;
                 Reader reader = null;
                 try {
                     is = tSrcResource.getInputStream();
                     reader = (encoding == null) ? new InputStreamReader(is)
                         : new InputStreamReader(is, encoding);
                     runStatements(reader, out);
                 } finally {
                     FileUtils.close(is);
                     FileUtils.close(reader);
                 }
             }
         }
     }
 
     public int lastDelimiterPosition(StringBuffer buf, String currentLine) {
         if (strictDelimiterMatching) {
             if ((delimiterType.equals(DelimiterType.NORMAL)
                  && StringUtils.endsWith(buf, delimiter)) ||
                 (delimiterType.equals(DelimiterType.ROW)
                  && currentLine.equals(delimiter))) {
                 return buf.length() - delimiter.length();
             }
             // no match
             return -1;
         } else {
             String d = delimiter.trim().toLowerCase(Locale.ENGLISH);
             if (delimiterType.equals(DelimiterType.NORMAL)) {
                 // still trying to avoid wasteful copying, see
                 // StringUtils.endsWith
                 int endIndex = delimiter.length() - 1;
                 int bufferIndex = buf.length() - 1;
                 while (bufferIndex >= 0
                        && Character.isWhitespace(buf.charAt(bufferIndex))) {
                     --bufferIndex;
                 }
                 if (bufferIndex < endIndex) {
                     return -1;
                 }
                 while (endIndex >= 0) {
                     if (buf.substring(bufferIndex, bufferIndex + 1)
                         .toLowerCase(Locale.ENGLISH).charAt(0)
                         != d.charAt(endIndex)) {
                         return -1;
                     }
                     bufferIndex--;
                     endIndex--;
                 }
                 return bufferIndex + 1;
             } else {
                 return currentLine.trim().toLowerCase(Locale.ENGLISH).equals(d)
                     ? buf.length() - currentLine.length() : -1;
             }
         }
     }
 
     private void printWarnings(SQLWarning warning, boolean force)
         throws SQLException {
         SQLWarning initialWarning = warning;
         if (showWarnings || force) {
             while (warning != null) {
                 log(warning + " sql warning",
                     showWarnings ? Project.MSG_WARN : Project.MSG_VERBOSE);
                 warning = warning.getNextWarning();
             }
         }
         if (initialWarning != null) {
             setWarningProperty();
         }
         if (treatWarningsAsErrors && initialWarning != null) {
             throw initialWarning;
         }
     }
 
     protected final void setErrorProperty() {
         setProperty(errorProperty, "true");
     }
 
     protected final void setWarningProperty() {
         setProperty(warningProperty, "true");
     }
 
     protected final void setRowCountProperty(int rowCount) {
         setProperty(rowCountProperty, Integer.toString(rowCount));
     }
 
     private void setProperty(String name, String value) {
         if (name != null) {
             getProject().setNewProperty(name, value);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/SubAnt.java b/src/main/org/apache/tools/ant/taskdefs/SubAnt.java
index b8c5b1660..1cf79323e 100644
--- a/src/main/org/apache/tools/ant/taskdefs/SubAnt.java
+++ b/src/main/org/apache/tools/ant/taskdefs/SubAnt.java
@@ -1,635 +1,635 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 
 import java.util.Vector;
 import java.util.Enumeration;
 
 import org.apache.tools.ant.Main;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.BuildException;
 
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.DirSet;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.FileList;
 import org.apache.tools.ant.types.PropertySet;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.types.ResourceCollection;
 
 import org.apache.tools.ant.taskdefs.Ant.TargetElement;
 
 
 /**
  * Calls a given target for all defined sub-builds. This is an extension
  * of ant for bulk project execution.
  * <p>
  * <h2> Use with directories </h2>
  * <p>
  * subant can be used with directory sets to execute a build from different directories.
  * 2 different options are offered
  * </p>
  * <ul>
  * <li>
  * run the same build file /somepath/otherpath/mybuild.xml
  * with different base directories use the genericantfile attribute
  * </li>
  * <li>if you want to run directory1/build.xml, directory2/build.xml, ....
  * use the antfile attribute. The base directory does not get set by the subant task in this case,
  * because you can specify it in each build file.
  * </li>
  * </ul>
  * @since Ant1.6
  * @ant.task name="subant" category="control"
  */
 public class SubAnt extends Task {
 
     private Path buildpath;
 
     private Ant ant = null;
     private String subTarget = null;
     private String antfile = getDefaultBuildFile();
     private File genericantfile = null;
     private boolean verbose = false;
     private boolean inheritAll = false;
     private boolean inheritRefs = false;
     private boolean failOnError = true;
     private String output  = null;
 
     private Vector properties = new Vector();
     private Vector references = new Vector();
     private Vector propertySets = new Vector();
 
     /** the targets to call on the new project */
     private Vector/*<TargetElement>*/ targets = new Vector();
 
     /**
      * Get the default build file name to use when launching the task.
      * <p>
      * This function may be overrided by providers of custom ProjectHelper so they can implement easily their sub
      * launcher.
      * 
      * @return the name of the default file
      * @since Ant 1.8.0
      */
     protected String getDefaultBuildFile() {
         return Main.DEFAULT_BUILD_FILENAME;
     }
 
     /**
      * Pass output sent to System.out to the new project.
      *
      * @param output a line of output
      * @since Ant 1.6.2
      */
     public void handleOutput(String output) {
         if (ant != null) {
             ant.handleOutput(output);
         } else {
             super.handleOutput(output);
         }
     }
 
     /**
      * Process input into the ant task
      *
      * @param buffer the buffer into which data is to be read.
      * @param offset the offset into the buffer at which data is stored.
      * @param length the amount of data to read
      *
      * @return the number of bytes read
      *
      * @exception IOException if the data cannot be read
      *
      * @see Task#handleInput(byte[], int, int)
      *
      * @since Ant 1.6.2
      */
     public int handleInput(byte[] buffer, int offset, int length)
         throws IOException {
         if (ant != null) {
             return ant.handleInput(buffer, offset, length);
         } else {
             return super.handleInput(buffer, offset, length);
         }
     }
 
     /**
      * Pass output sent to System.out to the new project.
      *
      * @param output The output to log. Should not be <code>null</code>.
      *
      * @since Ant 1.6.2
      */
     public void handleFlush(String output) {
         if (ant != null) {
             ant.handleFlush(output);
         } else {
             super.handleFlush(output);
         }
     }
 
     /**
      * Pass output sent to System.err to the new project.
      *
      * @param output The error output to log. Should not be <code>null</code>.
      *
      * @since Ant 1.6.2
      */
     public void handleErrorOutput(String output) {
         if (ant != null) {
             ant.handleErrorOutput(output);
         } else {
             super.handleErrorOutput(output);
         }
     }
 
     /**
      * Pass output sent to System.err to the new project.
      *
      * @param output The error output to log. Should not be <code>null</code>.
      *
      * @since Ant 1.6.2
      */
     public void handleErrorFlush(String output) {
         if (ant != null) {
             ant.handleErrorFlush(output);
         } else {
             super.handleErrorFlush(output);
         }
     }
 
     /**
      * Runs the various sub-builds.
      */
     public void execute() {
         if (buildpath == null) {
             throw new BuildException("No buildpath specified");
         }
 
         final String[] filenames = buildpath.list();
         final int count = filenames.length;
         if (count < 1) {
             log("No sub-builds to iterate on", Project.MSG_WARN);
             return;
         }
 /*
     //REVISIT: there must be cleaner way of doing this, if it is merited at all
         if (subTarget == null) {
             subTarget = getOwningTarget().getName();
         }
 */
         BuildException buildException = null;
         for (int i = 0; i < count; ++i) {
             File file = null;
             String subdirPath = null;
             Throwable thrownException = null;
             try {
                 File directory = null;
                 file = new File(filenames[i]);
                 if (file.isDirectory()) {
                     if (verbose) {
                         subdirPath = file.getPath();
                         log("Entering directory: " + subdirPath + "\n", Project.MSG_INFO);
                     }
                     if (genericantfile != null) {
                         directory = file;
                         file = genericantfile;
                     } else {
                         file = new File(file, antfile);
                     }
                 }
                 execute(file, directory);
                 if (verbose && subdirPath != null) {
                     log("Leaving directory: " + subdirPath + "\n", Project.MSG_INFO);
                 }
             } catch (RuntimeException ex) {
                 if (!(getProject().isKeepGoingMode())) {
                     if (verbose && subdirPath != null) {
                         log("Leaving directory: " + subdirPath + "\n", Project.MSG_INFO);
                     }
                     throw ex; // throw further
                 }
                 thrownException = ex;
             } catch (Throwable ex) {
                 if (!(getProject().isKeepGoingMode())) {
                     if (verbose && subdirPath != null) {
                         log("Leaving directory: " + subdirPath + "\n", Project.MSG_INFO);
                     }
                     throw new BuildException(ex);
                 }
                 thrownException = ex;
             }
             if (thrownException != null) {
                 if (thrownException instanceof BuildException) {
                     log("File '" + file
                         + "' failed with message '"
                         + thrownException.getMessage() + "'.", Project.MSG_ERR);
                     // only the first build exception is reported
                     if (buildException == null) {
                         buildException = (BuildException) thrownException;
                     }
                 } else {
                     log("Target '" + file
                         + "' failed with message '"
                         + thrownException.getMessage() + "'.", Project.MSG_ERR);
                     thrownException.printStackTrace(System.err);
                     if (buildException == null) {
                         buildException =
                             new BuildException(thrownException);
                     }
                 }
                 if (verbose && subdirPath != null) {
                     log("Leaving directory: " + subdirPath + "\n", Project.MSG_INFO);
                 }
             }
         }
         // check if one of the builds failed in keep going mode
         if (buildException != null) {
             throw buildException;
         }
     }
 
     /**
      * Runs the given target on the provided build file.
      *
      * @param  file the build file to execute
      * @param  directory the directory of the current iteration
      * @throws BuildException is the file cannot be found, read, is
      *         a directory, or the target called failed, but only if
      *         <code>failOnError</code> is <code>true</code>. Otherwise,
      *         a warning log message is simply output.
      */
     private void execute(File file, File directory)
                 throws BuildException {
         if (!file.exists() || file.isDirectory() || !file.canRead()) {
             String msg = "Invalid file: " + file;
             if (failOnError) {
                 throw new BuildException(msg);
             }
             log(msg, Project.MSG_WARN);
             return;
         }
 
         ant = createAntTask(directory);
         String antfilename = file.getAbsolutePath();
         ant.setAntfile(antfilename);
         final int size = targets.size();
         for (int i = 0; i < size; i++) {
             TargetElement targetElement = (TargetElement) targets.get(i);
             ant.addConfiguredTarget(targetElement);
         }
 
         try {
             ant.execute();
         } catch (BuildException e) {
             if (failOnError || isHardError(e)) {
                 throw e;
             }
             log("Failure for target '" + subTarget
                + "' of: " +  antfilename + "\n"
                + e.getMessage(), Project.MSG_WARN);
         } catch (Throwable e) {
             if (failOnError || isHardError(e)) {
                 throw new BuildException(e);
             }
             log("Failure for target '" + subTarget
                 + "' of: " + antfilename + "\n"
                 + e.toString(),
                 Project.MSG_WARN);
         } finally {
             ant = null;
         }
     }
     /** whether we should even try to continue after this error */
     private boolean isHardError(Throwable t) {
         if (t instanceof BuildException) {
             return isHardError(t.getCause());
         } else if (t instanceof OutOfMemoryError) {
             return true;
         } else if (t instanceof ThreadDeath) {
             return true;
         } else { // incl. t == null
             return false;
         }
     }
 
     /**
      * This method builds the file name to use in conjunction with directories.
      *
      * <p>Defaults to "build.xml".
      * If <code>genericantfile</code> is set, this attribute is ignored.</p>
      *
      * @param  antfile the short build file name. Defaults to "build.xml".
      */
     public void setAntfile(String antfile) {
         this.antfile = antfile;
     }
 
     /**
      * This method builds a file path to use in conjunction with directories.
      *
      * <p>Use <code>genericantfile</code>, in order to run the same build file
      * with different basedirs.</p>
      * If this attribute is set, <code>antfile</code> is ignored.
      *
      * @param afile (path of the generic ant file, absolute or relative to
      *               project base directory)
      * */
     public void setGenericAntfile(File afile) {
         this.genericantfile = afile;
     }
 
     /**
      * Sets whether to fail with a build exception on error, or go on.
      *
      * @param  failOnError the new value for this boolean flag.
      */
     public void setFailonerror(boolean failOnError) {
         this.failOnError = failOnError;
     }
 
     /**
      * The target to call on the different sub-builds. Set to "" to execute
      * the default target.
      * @param target the target
      * <p>
      */
     //     REVISIT: Defaults to the target name that contains this task if not specified.
     public void setTarget(String target) {
         this.subTarget = target;
     }
 
     /**
      * Add a target to this Ant invocation.
      * @param t the <code>TargetElement</code> to add.
      * @since Ant 1.7
      */
     public void addConfiguredTarget(TargetElement t) {
         String name = t.getName();
         if ("".equals(name)) {
             throw new BuildException("target name must not be empty");
         }
         targets.add(t);
     }
 
     /**
      * Enable/ disable verbose log messages showing when each sub-build path is entered/ exited.
      * The default value is "false".
      * @param on true to enable verbose mode, false otherwise (default).
      */
     public void setVerbose(boolean on) {
         this.verbose = on;
     }
 
     /**
      * Corresponds to <code>&lt;ant&gt;</code>'s
      * <code>output</code> attribute.
      *
      * @param  s the filename to write the output to.
      */
     public void setOutput(String s) {
         this.output = s;
     }
 
     /**
      * Corresponds to <code>&lt;ant&gt;</code>'s
      * <code>inheritall</code> attribute.
      *
      * @param  b the new value for this boolean flag.
      */
     public void setInheritall(boolean b) {
         this.inheritAll = b;
     }
 
     /**
      * Corresponds to <code>&lt;ant&gt;</code>'s
      * <code>inheritrefs</code> attribute.
      *
      * @param  b the new value for this boolean flag.
      */
     public void setInheritrefs(boolean b) {
         this.inheritRefs = b;
     }
 
     /**
      * Corresponds to <code>&lt;ant&gt;</code>'s
      * nested <code>&lt;property&gt;</code> element.
      *
      * @param  p the property to pass on explicitly to the sub-build.
      */
     public void addProperty(Property p) {
         properties.addElement(p);
     }
 
     /**
      * Corresponds to <code>&lt;ant&gt;</code>'s
      * nested <code>&lt;reference&gt;</code> element.
      *
      * @param  r the reference to pass on explicitly to the sub-build.
      */
     public void addReference(Ant.Reference r) {
         references.addElement(r);
     }
 
     /**
      * Corresponds to <code>&lt;ant&gt;</code>'s
      * nested <code>&lt;propertyset&gt;</code> element.
-     * @param ps the propertset
+     * @param ps the propertyset
      */
     public void addPropertyset(PropertySet ps) {
         propertySets.addElement(ps);
     }
 
     /**
      * Adds a directory set to the implicit build path.
      * <p>
      * <em>Note that the directories will be added to the build path
      * in no particular order, so if order is significant, one should
      * use a file list instead!</em>
      *
      * @param  set the directory set to add.
      */
     public void addDirset(DirSet set) {
         add(set);
     }
 
     /**
      * Adds a file set to the implicit build path.
      * <p>
      * <em>Note that the directories will be added to the build path
      * in no particular order, so if order is significant, one should
      * use a file list instead!</em>
      *
      * @param  set the file set to add.
      */
     public void addFileset(FileSet set) {
         add(set);
     }
 
     /**
      * Adds an ordered file list to the implicit build path.
      * <p>
      * <em>Note that contrary to file and directory sets, file lists
      * can reference non-existent files or directories!</em>
      *
      * @param  list the file list to add.
      */
     public void addFilelist(FileList list) {
         add(list);
     }
 
     /**
      * Adds a resource collection to the implicit build path.
      *
      * @param  rc the resource collection to add.
      * @since Ant 1.7
      */
     public void add(ResourceCollection rc) {
         getBuildpath().add(rc);
     }
 
     /**
      * Set the buildpath to be used to find sub-projects.
      *
      * @param  s an Ant Path object containing the buildpath.
      */
     public void setBuildpath(Path s) {
         getBuildpath().append(s);
     }
 
     /**
      * Creates a nested build path, and add it to the implicit build path.
      *
      * @return the newly created nested build path.
      */
     public Path createBuildpath() {
         return getBuildpath().createPath();
     }
 
     /**
      * Creates a nested <code>&lt;buildpathelement&gt;</code>,
      * and add it to the implicit build path.
      *
      * @return the newly created nested build path element.
      */
     public Path.PathElement createBuildpathElement() {
         return getBuildpath().createPathElement();
     }
 
     /**
      * Gets the implicit build path, creating it if <code>null</code>.
      *
      * @return the implicit build path.
      */
     private Path getBuildpath() {
         if (buildpath == null) {
             buildpath = new Path(getProject());
         }
         return buildpath;
     }
 
     /**
      * Buildpath to use, by reference.
      *
      * @param  r a reference to an Ant Path object containing the buildpath.
      */
     public void setBuildpathRef(Reference r) {
         createBuildpath().setRefid(r);
     }
 
     /**
      * Creates the &lt;ant&gt; task configured to run a specific target.
      *
      * @param directory : if not null the directory where the build should run
      *
      * @return the ant task, configured with the explicit properties and
      *         references necessary to run the sub-build.
      */
     private Ant createAntTask(File directory) {
         Ant antTask = new Ant(this);
         antTask.init();
         if (subTarget != null && subTarget.length() > 0) {
             antTask.setTarget(subTarget);
         }
 
 
         if (output != null) {
             antTask.setOutput(output);
         }
 
         if (directory != null) {
             antTask.setDir(directory);
         } else {
             antTask.setUseNativeBasedir(true);
         }
 
         antTask.setInheritAll(inheritAll);
         for (Enumeration i = properties.elements(); i.hasMoreElements();) {
             copyProperty(antTask.createProperty(), (Property) i.nextElement());
         }
 
         for (Enumeration i = propertySets.elements(); i.hasMoreElements();) {
             antTask.addPropertyset((PropertySet) i.nextElement());
         }
 
         antTask.setInheritRefs(inheritRefs);
         for (Enumeration i = references.elements(); i.hasMoreElements();) {
             antTask.addReference((Ant.Reference) i.nextElement());
         }
 
         return antTask;
     }
 
     /**
      * Assigns an Ant property to another.
      *
      * @param  to the destination property whose content is modified.
      * @param  from the source property whose content is copied.
      */
     private static void copyProperty(Property to, Property from) {
         to.setName(from.getName());
 
         if (from.getValue() != null) {
             to.setValue(from.getValue());
         }
         if (from.getFile() != null) {
             to.setFile(from.getFile());
         }
         if (from.getResource() != null) {
             to.setResource(from.getResource());
         }
         if (from.getPrefix() != null) {
             to.setPrefix(from.getPrefix());
         }
         if (from.getRefid() != null) {
             to.setRefid(from.getRefid());
         }
         if (from.getEnvironment() != null) {
             to.setEnvironment(from.getEnvironment());
         }
         if (from.getClasspath() != null) {
             to.setClasspath(from.getClasspath());
         }
     }
 
 } // END class SubAnt
diff --git a/src/main/org/apache/tools/ant/taskdefs/WaitFor.java b/src/main/org/apache/tools/ant/taskdefs/WaitFor.java
index a5818a7c7..ef64f6786 100644
--- a/src/main/org/apache/tools/ant/taskdefs/WaitFor.java
+++ b/src/main/org/apache/tools/ant/taskdefs/WaitFor.java
@@ -1,276 +1,276 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.condition.Condition;
 import org.apache.tools.ant.taskdefs.condition.ConditionBase;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 
 /**
  * Wait for an external event to occur.
  *
  * Wait for an external process to start or to complete some
  * task. This is useful with the <code>parallel</code> task to
  * synchronize the execution of tests with server startup.
  *
  * The following attributes can be specified on a waitfor task:
  * <ul>
  * <li>maxwait - maximum length of time to wait before giving up</li>
  * <li>maxwaitunit - The unit to be used to interpret maxwait attribute</li>
  * <li>checkevery - amount of time to sleep between each check</li>
  * <li>checkeveryunit - The unit to be used to interpret checkevery attribute</li>
  * <li>timeoutproperty - name of a property to set if maxwait has been exceeded.</li>
  * </ul>
  *
  * The maxwaitunit and checkeveryunit are allowed to have the following values:
  * millisecond, second, minute, hour, day and week. The default is millisecond.
  *
- * For programmatic use/subclassing, there are two methods that may be overrridden,
+ * For programmatic use/subclassing, there are two methods that may be overridden,
  * <code>processSuccess</code> and <code>processTimeout</code>
  * @since Ant 1.5
  *
  * @ant.task category="control"
  */
 public class WaitFor extends ConditionBase {
     /** a millisecond */
     public static final long ONE_MILLISECOND = 1L;
     /** a second in milliseconds */
     public static final long ONE_SECOND = 1000L;
     /** a minute in milliseconds */
     public static final long ONE_MINUTE = ONE_SECOND * 60L;
     /** an hour in milliseconds */
     public static final long ONE_HOUR   = ONE_MINUTE * 60L;
     /** a day in milliseconds */
     public static final long ONE_DAY    = ONE_HOUR * 24L;
     /** a week in milliseconds */
     public static final long ONE_WEEK   = ONE_DAY * 7L;
 
     /** default wait time */
     public static final long DEFAULT_MAX_WAIT_MILLIS = ONE_MINUTE * 3L;
     /** default check time */
     public static final long DEFAULT_CHECK_MILLIS = 500L;
 
     /** default max wait time in the current unit*/
     private long maxWait = DEFAULT_MAX_WAIT_MILLIS;
     private long maxWaitMultiplier = ONE_MILLISECOND;
     /**
      * check time in the current unit
      */
     private long checkEvery = DEFAULT_CHECK_MILLIS;
     private long checkEveryMultiplier = ONE_MILLISECOND;
     private String timeoutProperty;
 
     /**
      * Constructor, names this task "waitfor".
      */
     public WaitFor() {
         super("waitfor");
     }
 
 
     /**
      * Constructor that takes the name of the task in the task name.
      *
      * @param taskName the name of the task.
      * @since Ant 1.8
      */
     public WaitFor(String taskName) {
         super(taskName);
     }
 
     /**
      * Set the maximum length of time to wait.
      * @param time a <code>long</code> value
      */
     public void setMaxWait(long time) {
         maxWait = time;
     }
 
 
     /**
      * Set the max wait time unit
      * @param unit an enumerated <code>Unit</code> value
      */
     public void setMaxWaitUnit(Unit unit) {
         maxWaitMultiplier = unit.getMultiplier();
     }
 
 
 
     /**
      * Set the time between each check
      * @param time a <code>long</code> value
      */
     public void setCheckEvery(long time) {
         checkEvery = time;
     }
 
     /**
      * Set the check every time unit
      * @param unit an enumerated <code>Unit</code> value
      */
     public void setCheckEveryUnit(Unit unit) {
         checkEveryMultiplier = unit.getMultiplier();
     }
 
     /**
      * Name the property to set after a timeout.
      * @param p the property name
      */
     public void setTimeoutProperty(String p) {
         timeoutProperty = p;
     }
 
     /**
      * Check repeatedly for the specified conditions until they become
      * true or the timeout expires.
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
         if (countConditions() > 1) {
             throw new BuildException("You must not nest more than one "
                                      + "condition into "
                                      + getTaskName());
         }
         if (countConditions() < 1) {
             throw new BuildException("You must nest a condition into "
                                      + getTaskName());
         }
         Condition c = (Condition) getConditions().nextElement();
         try {
             long maxWaitMillis = calculateMaxWaitMillis();
             long checkEveryMillis = calculateCheckEveryMillis();
             long start = System.currentTimeMillis();
             long end = start + maxWaitMillis;
 
             while (System.currentTimeMillis() < end) {
                 if (c.eval()) {
                     processSuccess();
                     return;
                 }
                 Thread.sleep(checkEveryMillis);
             }
         } catch (InterruptedException e) {
             log("Task " + getTaskName()
                     + " interrupted, treating as timed out.");
         }
         processTimeout();
     }
 
     /**
      * Get the check wait time, in milliseconds.
      * @since Ant 1.8
      * @return how long to wait between checks
      */
     public long calculateCheckEveryMillis() {
         return checkEvery * checkEveryMultiplier;
     }
 
     /**
-     * Get the maxiumum wait time, in milliseconds.
+     * Get the maximum wait time, in milliseconds.
      * @since Ant 1.8
      * @return how long to wait before timing out
      */
     public long calculateMaxWaitMillis() {
         return maxWait * maxWaitMultiplier;
     }
 
     /**
      * Actions to be taken on a successful waitfor.
      * This is an override point. The base implementation does nothing.
      * @since Ant1.7
      */
     protected void processSuccess() {
         log(getTaskName() + ": condition was met", Project.MSG_VERBOSE);
     }
 
     /**
      * Actions to be taken on an unsuccessful wait.
      * This is an override point. It is where the timeout processing takes place.
      * The base implementation sets the timeoutproperty if there was a timeout
      * and the property was defined.
      * @since Ant1.7
      */
     protected void processTimeout() {
         log(getTaskName() + ": timeout", Project.MSG_VERBOSE);
         if (timeoutProperty != null) {
             getProject().setNewProperty(timeoutProperty, "true");
         }
     }
 
     /**
      * The enumeration of units:
      * millisecond, second, minute, hour, day, week
      * @todo we use timestamps in many places, why not factor this out
      */
     public static class Unit extends EnumeratedAttribute {
 
         /** millisecond string */
         public static final String MILLISECOND = "millisecond";
         /** second string */
         public static final String SECOND = "second";
         /** minute string */
         public static final String MINUTE = "minute";
         /** hour string */
         public static final String HOUR = "hour";
         /** day string */
         public static final String DAY = "day";
         /** week string */
         public static final String WEEK = "week";
 
         private static final String[] UNITS = {
             MILLISECOND, SECOND, MINUTE, HOUR, DAY, WEEK
         };
 
         private Map timeTable = new HashMap();
 
         /** Constructor the Unit enumerated type. */
         public Unit() {
             timeTable.put(MILLISECOND, new Long(1L));
             timeTable.put(SECOND,      new Long(ONE_SECOND));
             timeTable.put(MINUTE,      new Long(ONE_MINUTE));
             timeTable.put(HOUR,        new Long(ONE_HOUR));
             timeTable.put(DAY,         new Long(ONE_DAY));
             timeTable.put(WEEK,        new Long(ONE_WEEK));
         }
 
         /**
          * Convert the value to a multipler (millisecond to unit).
          * @return a multipler (a long value)
          */
         public long getMultiplier() {
             String key = getValue().toLowerCase(Locale.ENGLISH);
             Long l = (Long) timeTable.get(key);
             return l.longValue();
         }
 
         /**
          * @see EnumeratedAttribute#getValues()
          */
         /** {@inheritDoc} */
         public String[] getValues() {
             return UNITS;
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/XSLTLiaison2.java b/src/main/org/apache/tools/ant/taskdefs/XSLTLiaison2.java
index 831aff5f9..f41f91511 100644
--- a/src/main/org/apache/tools/ant/taskdefs/XSLTLiaison2.java
+++ b/src/main/org/apache/tools/ant/taskdefs/XSLTLiaison2.java
@@ -1,33 +1,33 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 /**
  * Extended Proxy interface for XSLT processors.
  *
  * @see XSLTProcess
  * @since Ant 1.6
  */
 public interface XSLTLiaison2 extends XSLTLiaison {
     /**
-     * Configure the liasion from the XSLTProcess task
+     * Configure the liaision from the XSLTProcess task
      * @param xsltTask the XSLTProcess task
      */
     void configure(XSLTProcess xsltTask);
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java b/src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java
index 28167b5c1..bde1c55dc 100644
--- a/src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java
+++ b/src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java
@@ -1,1514 +1,1514 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.util.Enumeration;
 import java.util.Vector;
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.DynamicConfigurator;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.PropertyHelper;
 import org.apache.tools.ant.types.CommandlineJava;
 import org.apache.tools.ant.types.Environment;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.PropertySet;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.XMLCatalog;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.Resources;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.ResourceUtils;
 
 /**
  * Processes a set of XML documents via XSLT. This is
  * useful for building views of XML based documentation.
  *
  *
  * @since Ant 1.1
  *
  * @ant.task name="xslt" category="xml"
  */
 
 public class XSLTProcess extends MatchingTask implements XSLTLogger {
     /** destination directory */
     private File destDir = null;
 
     /** where to find the source XML file, default is the project's basedir */
     private File baseDir = null;
 
     /** XSL stylesheet as a filename */
     private String xslFile = null;
 
     /** XSL stylesheet as a {@link org.apache.tools.ant.types.Resource} */
     private Resource xslResource = null;
 
     /** extension of the files produced by XSL processing */
     private String targetExtension = ".html";
 
     /** name for XSL parameter containing the filename */
     private String fileNameParameter = null;
 
     /** name for XSL parameter containing the file directory */
     private String fileDirParameter = null;
 
     /** additional parameters to be passed to the stylesheets */
     private Vector params = new Vector();
 
     /** Input XML document to be used */
     private File inFile = null;
 
     /** Output file */
     private File outFile = null;
 
     /** The name of the XSL processor to use */
     private String processor;
 
     /** Classpath to use when trying to load the XSL processor */
     private Path classpath = null;
 
-    /** The Liason implementation to use to communicate with the XSL
+    /** The Liaison implementation to use to communicate with the XSL
      *  processor */
     private XSLTLiaison liaison;
 
     /** Flag which indicates if the stylesheet has been loaded into
      *  the processor */
     private boolean stylesheetLoaded = false;
 
     /** force output of target files even if they already exist */
     private boolean force = false;
 
     /** XSL output properties to be used */
     private Vector outputProperties = new Vector();
 
     /** for resolving entities such as dtds */
     private XMLCatalog xmlCatalog = new XMLCatalog();
 
     /** Utilities used for file operations */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Whether to style all files in the included directories as well.
      *
      * @since Ant 1.5
      */
     private boolean performDirectoryScan = true;
 
     /**
      * factory element for TraX processors only
      * @since Ant 1.6
      */
     private Factory factory = null;
 
     /**
      * whether to reuse Transformer if transforming multiple files.
      * @since 1.5.2
      */
     private boolean reuseLoadedStylesheet = true;
 
     /**
      * AntClassLoader for the nested &lt;classpath&gt; - if set.
      *
      * <p>We keep this here in order to reset the context classloader
      * in execute.  We can't use liaison.getClass().getClassLoader()
      * since the actual liaison class may have been loaded by a loader
      * higher up (system classloader, for example).</p>
      *
      * @since Ant 1.6.2
      */
     private AntClassLoader loader = null;
 
     /**
      * Mapper to use when a set of files gets processed.
      *
      * @since Ant 1.6.2
      */
     private Mapper mapperElement = null;
 
     /**
      * Additional resource collections to process.
      *
      * @since Ant 1.7
      */
     private Union resources = new Union();
 
     /**
      * Whether to use the implicit fileset.
      *
      * @since Ant 1.7
      */
     private boolean useImplicitFileset = true;
 
     /**
      * The default processor is trax
      * @since Ant 1.7
      */
     public static final String PROCESSOR_TRAX = "trax";
 
     /**
      * whether to suppress warnings.
      *
      * @since Ant 1.8.0
      */
     private boolean suppressWarnings = false;
 
     /**
      * whether to fail the build if an error occurs during transformation.
      *
      * @since Ant 1.8.0
      */
     private boolean failOnTransformationError = true;
 
     /**
      * whether to fail the build if an error occurs.
      *
      * @since Ant 1.8.0
      */
     private boolean failOnError = true;
 
     /**
      * Whether the build should fail if the nested resource collection
      * is empty.
      *
      * @since Ant 1.8.0
      */
     private boolean failOnNoResources = true;
 
     /**
      * System properties to set during transformation.
      *
      * @since Ant 1.8.0
      */
     private CommandlineJava.SysProperties sysProperties =
         new CommandlineJava.SysProperties();
 
     /**
      * Trace configuration for Xalan2.
      *
      * @since Ant 1.8.0
      */
     private TraceConfiguration traceConfiguration;
 
     /**
      * Creates a new XSLTProcess Task.
      */
     public XSLTProcess() {
     } //-- XSLTProcess
 
     /**
      * Whether to style all files in the included directories as well;
      * optional, default is true.
      *
      * @param b true if files in included directories are processed.
      * @since Ant 1.5
      */
     public void setScanIncludedDirectories(boolean b) {
         performDirectoryScan = b;
     }
 
     /**
      * Controls whether the stylesheet is reloaded for every transform.
      *
      * <p>Setting this to true may get around a bug in certain
      * Xalan-J versions, default is false.</p>
      * @param b a <code>boolean</code> value
      * @since Ant 1.5.2
      */
     public void setReloadStylesheet(boolean b) {
         reuseLoadedStylesheet = !b;
     }
 
     /**
      * Defines the mapper to map source to destination files.
      * @param mapper the mapper to use
      * @exception BuildException if more than one mapper is defined
      * @since Ant 1.6.2
      */
     public void addMapper(Mapper mapper) {
         if (mapperElement != null) {
             handleError("Cannot define more than one mapper");
         } else {
             mapperElement = mapper;
         }
     }
 
     /**
      * Adds a collection of resources to style in addition to the
      * given file or the implicit fileset.
      *
      * @param rc the collection of resources to style
      * @since Ant 1.7
      */
     public void add(ResourceCollection rc) {
         resources.add(rc);
     }
 
     /**
      * Add a nested &lt;style&gt; element.
      * @param rc the configured Resources object represented as &lt;style&gt;.
      * @since Ant 1.7
      */
     public void addConfiguredStyle(Resources rc) {
         if (rc.size() != 1) {
             handleError("The style element must be specified with exactly one"
                         + " nested resource.");
         } else {
             setXslResource(rc.iterator().next());
         }
     }
 
     /**
      * API method to set the XSL Resource.
      * @param xslResource Resource to set as the stylesheet.
      * @since Ant 1.7
      */
     public void setXslResource(Resource xslResource) {
         this.xslResource = xslResource;
     }
 
     /**
      * Adds a nested filenamemapper.
      * @param fileNameMapper the mapper to add
      * @exception BuildException if more than one mapper is defined
      * @since Ant 1.7.0
      */
     public void add(FileNameMapper fileNameMapper) throws BuildException {
        Mapper mapper = new Mapper(getProject());
        mapper.add(fileNameMapper);
        addMapper(mapper);
     }
 
     /**
      * Executes the task.
      *
      * @exception BuildException if there is an execution problem.
      * @todo validate that if either in or our is defined, then both are
      */
     public void execute() throws BuildException {
         if ("style".equals(getTaskType())) {
             log("Warning: the task name <style> is deprecated. Use <xslt> instead.",
                     Project.MSG_WARN);
         }
         File savedBaseDir = baseDir;
 
         DirectoryScanner scanner;
         String[]         list;
         String[]         dirs;
 
         String baseMessage =
             "specify the stylesheet either as a filename in style attribute "
             + "or as a nested resource";
 
         if (xslResource == null && xslFile == null) {
             handleError(baseMessage);
             return;
         }
         if (xslResource != null && xslFile != null) {
             handleError(baseMessage + " but not as both");
             return;
         }
         if (inFile != null && !inFile.exists()) {
             handleError("input file " + inFile + " does not exist");
             return;
         }
         try {
             setupLoader();
 
             if (sysProperties.size() > 0) {
                 sysProperties.setSystem();
             }
 
             Resource styleResource;
             if (baseDir == null) {
                 baseDir = getProject().getBaseDir();
             }
             liaison = getLiaison();
 
             // check if liaison wants to log errors using us as logger
             if (liaison instanceof XSLTLoggerAware) {
                 ((XSLTLoggerAware) liaison).setLogger(this);
             }
             log("Using " + liaison.getClass().toString(), Project.MSG_VERBOSE);
 
             if (xslFile != null) {
                 // If we enter here, it means that the stylesheet is supplied
                 // via style attribute
                 File stylesheet = getProject().resolveFile(xslFile);
                 if (!stylesheet.exists()) {
                     File alternative = FILE_UTILS.resolveFile(baseDir, xslFile);
                     /*
                      * shouldn't throw out deprecation warnings before we know,
                      * the wrong version has been used.
                      */
                     if (alternative.exists()) {
                         log("DEPRECATED - the 'style' attribute should be "
                             + "relative to the project's");
                         log("             basedir, not the tasks's basedir.");
                         stylesheet = alternative;
                     }
                 }
                 FileResource fr = new FileResource();
                 fr.setProject(getProject());
                 fr.setFile(stylesheet);
                 styleResource = fr;
             } else {
                 styleResource = xslResource;
             }
 
             if (!styleResource.isExists()) {
                 handleError("stylesheet " + styleResource + " doesn't exist.");
                 return;
             }
 
             // if we have an in file and out then process them
             if (inFile != null && outFile != null) {
                 process(inFile, outFile, styleResource);
                 return;
             }
             /*
              * if we get here, in and out have not been specified, we are
              * in batch processing mode.
              */
 
             //-- make sure destination directory exists...
             checkDest();
 
             if (useImplicitFileset) {
                 scanner = getDirectoryScanner(baseDir);
                 log("Transforming into " + destDir, Project.MSG_INFO);
 
                 // Process all the files marked for styling
                 list = scanner.getIncludedFiles();
                 for (int i = 0; i < list.length; ++i) {
                     process(baseDir, list[i], destDir, styleResource);
                 }
                 if (performDirectoryScan) {
                     // Process all the directories marked for styling
                     dirs = scanner.getIncludedDirectories();
                     for (int j = 0; j < dirs.length; ++j) {
                         list = new File(baseDir, dirs[j]).list();
                         for (int i = 0; i < list.length; ++i) {
                             process(baseDir, dirs[j] + File.separator + list[i], destDir,
                                     styleResource);
                         }
                     }
                 }
             } else { // only resource collections, there better be some
                 if (resources.size() == 0) {
                     if (failOnNoResources) {
                         handleError("no resources specified");
                     }
                     return;
                 }
             }
             processResources(styleResource);
         } finally {
             if (loader != null) {
                 loader.resetThreadContextLoader();
                 loader.cleanup();
                 loader = null;
             }
             if (sysProperties.size() > 0) {
                 sysProperties.restoreSystem();
             }
             liaison = null;
             stylesheetLoaded = false;
             baseDir = savedBaseDir;
         }
     }
 
     /**
      * Set whether to check dependencies, or always generate;
      * optional, default is false.
      *
      * @param force true if always generate.
      */
     public void setForce(boolean force) {
         this.force = force;
     }
 
     /**
      * Set the base directory;
      * optional, default is the project's basedir.
      *
      * @param dir the base directory
      **/
     public void setBasedir(File dir) {
         baseDir = dir;
     }
 
     /**
      * Set the destination directory into which the XSL result
      * files should be copied to;
      * required, unless <tt>in</tt> and <tt>out</tt> are
      * specified.
      * @param dir the name of the destination directory
      **/
     public void setDestdir(File dir) {
         destDir = dir;
     }
 
     /**
      * Set the desired file extension to be used for the target;
      * optional, default is html.
      * @param name the extension to use
      **/
     public void setExtension(String name) {
         targetExtension = name;
     }
 
     /**
      * Name of the stylesheet to use - given either relative
      * to the project's basedir or as an absolute path; required.
      *
      * @param xslFile the stylesheet to use
      */
     public void setStyle(String xslFile) {
         this.xslFile = xslFile;
     }
 
     /**
      * Set the optional classpath to the XSL processor
      *
      * @param classpath the classpath to use when loading the XSL processor
      */
     public void setClasspath(Path classpath) {
         createClasspath().append(classpath);
     }
 
     /**
      * Set the optional classpath to the XSL processor
      *
      * @return a path instance to be configured by the Ant core.
      */
     public Path createClasspath() {
         if (classpath == null) {
             classpath = new Path(getProject());
         }
         return classpath.createPath();
     }
 
     /**
      * Set the reference to an optional classpath to the XSL processor
      *
      * @param r the id of the Ant path instance to act as the classpath
      *          for loading the XSL processor
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * Set the name of the XSL processor to use; optional, default trax.
      *
      * @param processor the name of the XSL processor
      */
     public void setProcessor(String processor) {
         this.processor = processor;
     }
 
     /**
      * Whether to use the implicit fileset.
      *
      * <p>Set this to false if you want explicit control with nested
      * resource collections.</p>
      * @param useimplicitfileset set to true if you want to use implicit fileset
      * @since Ant 1.7
      */
     public void setUseImplicitFileset(boolean useimplicitfileset) {
         useImplicitFileset = useimplicitfileset;
     }
 
     /**
      * Add the catalog to our internal catalog
      *
      * @param xmlCatalog the XMLCatalog instance to use to look up DTDs
      */
     public void addConfiguredXMLCatalog(XMLCatalog xmlCatalog) {
         this.xmlCatalog.addConfiguredXMLCatalog(xmlCatalog);
     }
 
     /**
      * Pass the filename of the current processed file as a xsl parameter
      * to the transformation. This value sets the name of that xsl parameter.
      *
      * @param fileNameParameter name of the xsl parameter retrieving the
      *                          current file name
      */
     public void setFileNameParameter(String fileNameParameter) {
         this.fileNameParameter = fileNameParameter;
     }
 
     /**
      * Pass the directory name of the current processed file as a xsl parameter
      * to the transformation. This value sets the name of that xsl parameter.
      *
      * @param fileDirParameter name of the xsl parameter retrieving the
      *                         current file directory
      */
     public void setFileDirParameter(String fileDirParameter) {
         this.fileDirParameter = fileDirParameter;
     }
 
     /**
      * Whether to suppress warning messages of the processor.
      *
      * @since Ant 1.8.0
      */
     public void setSuppressWarnings(boolean b) {
         suppressWarnings = b;
     }
 
     /**
      * Whether to suppress warning messages of the processor.
      *
      * @since Ant 1.8.0
      */
     public boolean getSuppressWarnings() {
         return suppressWarnings;
     }    
 
     /**
      * Whether transformation errors should make the build fail.
      *
      * @since Ant 1.8.0
      */
     public void setFailOnTransformationError(boolean b) {
         failOnTransformationError = b;
     }
 
     /**
      * Whether any errors should make the build fail.
      *
      * @since Ant 1.8.0
      */
     public void setFailOnError(boolean b) {
         failOnError = b;
     }
 
     /**
      * Whether the build should fail if the nested resource collection is empty.
      *
      * @since Ant 1.8.0
      */
     public void setFailOnNoResources(boolean b) {
         failOnNoResources = b;
     }
 
     /**
      * A system property to set during transformation.
      *
      * @since Ant 1.8.0
      */
     public void addSysproperty(Environment.Variable sysp) {
         sysProperties.addVariable(sysp);
     }
 
     /**
      * A set of system properties to set during transformation.
      *
      * @since Ant 1.8.0
      */
     public void addSyspropertyset(PropertySet sysp) {
         sysProperties.addSyspropertyset(sysp);
     }
 
     /**
      * Enables Xalan2 traces and uses the given configuration.
      *
      * <p>Note that this element doesn't have any effect with a
      * processor other than trax or if the Transformer is not Xalan2's
      * transformer implementation.</p>
      *
      * @since Ant 1.8.0
      */
     public TraceConfiguration createTrace() {
         if (traceConfiguration != null) {
             throw new BuildException("can't have more than one trace"
                                      + " configuration");
         }
         traceConfiguration = new TraceConfiguration();
         return traceConfiguration;
     }
 
     /**
      * Configuration for Xalan2 traces.
      *
      * @since Ant 1.8.0
      */
     public TraceConfiguration getTraceConfiguration() {
         return traceConfiguration;
     }
 
     /**
      * Load processor here instead of in setProcessor - this will be
      * called from within execute, so we have access to the latest
      * classpath.
      *
      * @param proc the name of the processor to load.
      * @exception Exception if the processor cannot be loaded.
      */
     private void resolveProcessor(String proc) throws Exception {
         if (proc.equals(PROCESSOR_TRAX)) {
             liaison = new org.apache.tools.ant.taskdefs.optional.TraXLiaison();
         } else {
             //anything else is a classname
             Class clazz = loadClass(proc);
             liaison = (XSLTLiaison) clazz.newInstance();
         }
     }
 
     /**
      * Load named class either via the system classloader or a given
      * custom classloader.
      *
      * As a side effect, the loader is set as the thread context classloader
      * @param classname the name of the class to load.
      * @return the requested class.
      * @exception Exception if the class could not be loaded.
      */
     private Class loadClass(String classname) throws Exception {
         setupLoader();
         if (loader == null) {
             return Class.forName(classname);
         }
         return Class.forName(classname, true, loader);
     }
 
     /**
      * If a custom classpath has been defined but no loader created
      * yet, create the classloader and set it as the context
      * classloader.
      */
     private void setupLoader() {
         if (classpath != null && loader == null) {
             loader = getProject().createClassLoader(classpath);
             loader.setThreadContextLoader();
         }
     }
 
     /**
      * Specifies the output name for the styled result from the
      * <tt>in</tt> attribute; required if <tt>in</tt> is set
      *
      * @param outFile the output File instance.
      */
     public void setOut(File outFile) {
         this.outFile = outFile;
     }
 
     /**
      * specifies a single XML document to be styled. Should be used
      * with the <tt>out</tt> attribute; ; required if <tt>out</tt> is set
      *
      * @param inFile the input file
      */
     public void setIn(File inFile) {
         this.inFile = inFile;
     }
 
     /**
      * Throws a BuildException if the destination directory hasn't
      * been specified.
      * @since Ant 1.7
      */
     private void checkDest() {
         if (destDir == null) {
             handleError("destdir attributes must be set!");
         }
     }
 
     /**
      * Styles all existing resources.
      *
      * @param stylesheet style sheet to use
      * @since Ant 1.7
      */
     private void processResources(Resource stylesheet) {
         for (Resource r : resources) {
             if (!r.isExists()) {
                 continue;
             }
             File base = baseDir;
             String name = r.getName();
             FileProvider fp = r.as(FileProvider.class);
             if (fp != null) {
                 FileResource f = ResourceUtils.asFileResource(fp);
                 base = f.getBaseDir();
                 if (base == null) {
                     name = f.getFile().getAbsolutePath();
                 }
             }
             process(base, name, destDir, stylesheet);
         }
     }
 
     /**
      * Processes the given input XML file and stores the result
      * in the given resultFile.
      *
      * @param baseDir the base directory for resolving files.
      * @param xmlFile the input file
      * @param destDir the destination directory
      * @param stylesheet the stylesheet to use.
      * @exception BuildException if the processing fails.
      */
     private void process(File baseDir, String xmlFile, File destDir, Resource stylesheet)
             throws BuildException {
 
         File   outF = null;
         File   inF = null;
 
         try {
             long styleSheetLastModified = stylesheet.getLastModified();
             inF = new File(baseDir, xmlFile);
 
             if (inF.isDirectory()) {
                 log("Skipping " + inF + " it is a directory.", Project.MSG_VERBOSE);
                 return;
             }
             FileNameMapper mapper = null;
             if (mapperElement != null) {
                 mapper = mapperElement.getImplementation();
             } else {
                 mapper = new StyleMapper();
             }
 
             String[] outFileName = mapper.mapFileName(xmlFile);
             if (outFileName == null || outFileName.length == 0) {
                 log("Skipping " + inFile + " it cannot get mapped to output.", Project.MSG_VERBOSE);
                 return;
             } else if (outFileName == null || outFileName.length > 1) {
                 log("Skipping " + inFile + " its mapping is ambiguos.", Project.MSG_VERBOSE);
                 return;
             }
             outF = new File(destDir, outFileName[0]);
 
             if (force || inF.lastModified() > outF.lastModified()
                     || styleSheetLastModified > outF.lastModified()) {
                 ensureDirectoryFor(outF);
                 log("Processing " + inF + " to " + outF);
                 configureLiaison(stylesheet);
                 setLiaisonDynamicFileParameters(liaison, inF);
                 liaison.transform(inF, outF);
             }
         } catch (Exception ex) {
             // If failed to process document, must delete target document,
             // or it will not attempt to process it the second time
             log("Failed to process " + inFile, Project.MSG_INFO);
             if (outF != null) {
                 outF.delete();
             }
             handleTransformationError(ex);
         }
 
     } //-- processXML
 
     /**
      * Process the input file to the output file with the given stylesheet.
      *
      * @param inFile the input file to process.
      * @param outFile the destination file.
      * @param stylesheet the stylesheet to use.
      * @exception BuildException if the processing fails.
      */
     private void process(File inFile, File outFile, Resource stylesheet) throws BuildException {
         try {
             long styleSheetLastModified = stylesheet.getLastModified();
             log("In file " + inFile + " time: " + inFile.lastModified(), Project.MSG_DEBUG);
             log("Out file " + outFile + " time: " + outFile.lastModified(), Project.MSG_DEBUG);
             log("Style file " + xslFile + " time: " + styleSheetLastModified, Project.MSG_DEBUG);
             if (force || inFile.lastModified() >= outFile.lastModified()
                     || styleSheetLastModified >= outFile.lastModified()) {
                 ensureDirectoryFor(outFile);
                 log("Processing " + inFile + " to " + outFile, Project.MSG_INFO);
                 configureLiaison(stylesheet);
                 setLiaisonDynamicFileParameters(liaison, inFile);
                 liaison.transform(inFile, outFile);
             } else {
                 log("Skipping input file " + inFile + " because it is older than output file "
                         + outFile + " and so is the stylesheet " + stylesheet, Project.MSG_DEBUG);
             }
         } catch (Exception ex) {
             log("Failed to process " + inFile, Project.MSG_INFO);
             if (outFile != null) {
                 outFile.delete();
             }
             handleTransformationError(ex);
         }
     }
 
     /**
      * Ensure the directory exists for a given file
      *
      * @param targetFile the file for which the directories are required.
      * @exception BuildException if the directories cannot be created.
      */
     private void ensureDirectoryFor(File targetFile) throws BuildException {
         File directory = targetFile.getParentFile();
         if (!directory.exists()) {
             if (!directory.mkdirs()) {
                 handleError("Unable to create directory: "
                             + directory.getAbsolutePath());
             }
         }
     }
 
     /**
      * Get the factory instance configured for this processor
      *
      * @return the factory instance in use
      */
     public Factory getFactory() {
         return factory;
     }
 
     /**
      * Get the XML catalog containing entity definitions
      *
      * @return the XML catalog for the task.
      */
     public XMLCatalog getXMLCatalog() {
         xmlCatalog.setProject(getProject());
         return xmlCatalog;
     }
 
     /**
      * Get an enumeration on the outputproperties.
      * @return the outputproperties
      */
     public Enumeration getOutputProperties() {
         return outputProperties.elements();
     }
 
     /**
-     * Get the Liason implementation to use in processing.
+     * Get the Liaison implementation to use in processing.
      *
-     * @return an instance of the XSLTLiason interface.
+     * @return an instance of the XSLTLiaison interface.
      */
     protected XSLTLiaison getLiaison() {
         // if processor wasn't specified, use TraX.
         if (liaison == null) {
             if (processor != null) {
                 try {
                     resolveProcessor(processor);
                 } catch (Exception e) {
                     handleError(e);
                 }
             } else {
                 try {
                     resolveProcessor(PROCESSOR_TRAX);
                 } catch (Throwable e1) {
                     e1.printStackTrace();
                     handleError(e1);
                 }
             }
         }
         return liaison;
     }
 
     /**
      * Create an instance of an XSL parameter for configuration by Ant.
      *
      * @return an instance of the Param class to be configured.
      */
     public Param createParam() {
         Param p = new Param();
         params.addElement(p);
         return p;
     }
 
     /**
      * The Param inner class used to store XSL parameters
      */
     public static class Param {
         /** The parameter name */
         private String name = null;
 
         /** The parameter's value */
         private String expression = null;
 
         private Object ifCond;
         private Object unlessCond;
         private Project project;
 
         /**
          * Set the current project
          *
          * @param project the current project
          */
         public void setProject(Project project) {
             this.project = project;
         }
 
         /**
          * Set the parameter name.
          *
          * @param name the name of the parameter.
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * The parameter value
          * NOTE : was intended to be an XSL expression.
          * @param expression the parameter's value.
          */
         public void setExpression(String expression) {
             this.expression = expression;
         }
 
         /**
          * Get the parameter name
          *
          * @return the parameter name
          * @exception BuildException if the name is not set.
          */
         public String getName() throws BuildException {
             if (name == null) {
                 throw new BuildException("Name attribute is missing.");
             }
             return name;
         }
 
         /**
          * Get the parameter's value
          *
          * @return the parameter value
          * @exception BuildException if the value is not set.
          */
         public String getExpression() throws BuildException {
             if (expression == null) {
                 throw new BuildException("Expression attribute is missing.");
             }
             return expression;
         }
 
         /**
          * Set whether this param should be used.  It will be used if
-         * the expression evalutes to true or the name of a property
+         * the expression evaluates to true or the name of a property
          * which has been set, otherwise it won't.
          * @param ifCond evaluated expression
          * @since Ant 1.8.0
          */
         public void setIf(Object ifCond) {
             this.ifCond = ifCond;
         }
 
         /**
          * Set whether this param should be used.  It will be used if
-         * the expression evalutes to true or the name of a property
+         * the expression evaluates to true or the name of a property
          * which has been set, otherwise it won't.
          * @param ifProperty evaluated expression
          */
         public void setIf(String ifProperty) {
             setIf((Object) ifProperty);
         }
 
         /**
          * Set whether this param should NOT be used. It will not be
          * used if the expression evaluates to true or the name of a
          * property which has been set, otherwise it will be used.
          * @param unlessCond evaluated expression
          * @since Ant 1.8.0
          */
         public void setUnless(Object unlessCond) {
             this.unlessCond = unlessCond;
         }
 
         /**
          * Set whether this param should NOT be used. It will not be
          * used if the expression evaluates to true or the name of a
          * property which has been set, otherwise it will be used.
          * @param unlessProperty evaluated expression
          */
         public void setUnless(String unlessProperty) {
             setUnless((Object) unlessProperty);
         }
 
         /**
          * Ensures that the param passes the conditions placed
          * on it with <code>if</code> and <code>unless</code> properties.
          * @return true if the task passes the "if" and "unless" parameters
          */
         public boolean shouldUse() {
             PropertyHelper ph = PropertyHelper.getPropertyHelper(project);
             return ph.testIfCondition(ifCond)
                 && ph.testUnlessCondition(unlessCond);
         }
     } // Param
 
     /**
      * Create an instance of an output property to be configured.
      * @return the newly created output property.
      * @since Ant 1.5
      */
     public OutputProperty createOutputProperty() {
         OutputProperty p = new OutputProperty();
         outputProperties.addElement(p);
         return p;
     }
 
     /**
      * Specify how the result tree should be output as specified
      * in the <a href="http://www.w3.org/TR/xslt#output">
      * specification</a>.
      * @since Ant 1.5
      */
     public static class OutputProperty {
         /** output property name */
         private String name;
 
         /** output property value */
         private String value;
 
         /**
          * @return the output property name.
          */
         public String getName() {
             return name;
         }
 
         /**
          * set the name for this property
          * @param name A non-null String that specifies an
          * output property name, which may be namespace qualified.
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * @return the output property value.
          */
         public String getValue() {
             return value;
         }
 
         /**
          * set the value for this property
          * @param value The non-null string value of the output property.
          */
         public void setValue(String value) {
             this.value = value;
         }
     }
 
     /**
      * Initialize internal instance of XMLCatalog
      * @throws BuildException on error
      */
     public void init() throws BuildException {
         super.init();
         xmlCatalog.setProject(getProject());
     }
 
     /**
      * Loads the stylesheet and set xsl:param parameters.
      *
      * @param stylesheet the file from which to load the stylesheet.
      * @exception BuildException if the stylesheet cannot be loaded.
      * @deprecated since Ant 1.7
      */
     protected void configureLiaison(File stylesheet) throws BuildException {
         FileResource fr = new FileResource();
         fr.setProject(getProject());
         fr.setFile(stylesheet);
         configureLiaison(fr);
     }
 
     /**
      * Loads the stylesheet and set xsl:param parameters.
      *
      * @param stylesheet the resource from which to load the stylesheet.
      * @exception BuildException if the stylesheet cannot be loaded.
      * @since Ant 1.7
      */
     protected void configureLiaison(Resource stylesheet) throws BuildException {
         if (stylesheetLoaded && reuseLoadedStylesheet) {
             return;
         }
         stylesheetLoaded = true;
 
         try {
             log("Loading stylesheet " + stylesheet, Project.MSG_INFO);
-            // We call liason.configure() and then liaison.setStylesheet()
+            // We call liaison.configure() and then liaison.setStylesheet()
             // so that the internal variables of liaison can be set up
             if (liaison instanceof XSLTLiaison2) {
                 ((XSLTLiaison2) liaison).configure(this);
             }
             if (liaison instanceof XSLTLiaison3) {
                 // If we are here we can set the stylesheet as a
                 // resource
                 ((XSLTLiaison3) liaison).setStylesheet(stylesheet);
             } else {
                 // If we are here we cannot set the stylesheet as
                 // a resource, but we can set it as a file. So,
                 // we make an attempt to get it as a file
                 FileProvider fp =
                     stylesheet.as(FileProvider.class);
                 if (fp != null) {
                     liaison.setStylesheet(fp.getFile());
                 } else {
                     handleError(liaison.getClass().toString()
                                 + " accepts the stylesheet only as a file");
                     return;
                 }
             }
             for (Enumeration e = params.elements(); e.hasMoreElements();) {
                 Param p = (Param) e.nextElement();
                 if (p.shouldUse()) {
                     liaison.addParam(p.getName(), p.getExpression());
                 }
             }
         } catch (Exception ex) {
             log("Failed to transform using stylesheet " + stylesheet, Project.MSG_INFO);
             handleTransformationError(ex);
         }
     }
 
     /**
      * Sets file parameter(s) for directory and filename if the attribute
      * 'filenameparameter' or 'filedirparameter' are set in the task.
      *
      * @param  liaison    to change parameters for
      * @param  inFile     to get the additional file information from
      * @throws Exception  if an exception occurs on filename lookup
      *
      * @since Ant 1.7
      */
     private void setLiaisonDynamicFileParameters(
         XSLTLiaison liaison, File inFile) throws Exception {
         if (fileNameParameter != null) {
             liaison.addParam(fileNameParameter, inFile.getName());
         }
         if (fileDirParameter != null) {
             String fileName = FileUtils.getRelativePath(baseDir, inFile);
             File file = new File(fileName);
             // Give always a slash as file separator, so the stylesheet could be sure about that
             // Use '.' so a dir+"/"+name would not result in an absolute path
             liaison.addParam(fileDirParameter, file.getParent() != null ? file.getParent().replace(
                     '\\', '/') : ".");
         }
     }
 
     /**
      * Create the factory element to configure a trax liaison.
      * @return the newly created factory element.
      * @throws BuildException if the element is created more than one time.
      */
     public Factory createFactory() throws BuildException {
         if (factory != null) {
             handleError("'factory' element must be unique");
         } else {
             factory = new Factory();
         }
         return factory;
     }
 
     /**
      * Throws an exception with the given message if failOnError is
      * true, otherwise logs the message using the WARN level.
      *
      * @since Ant 1.8.0
      */
     protected void handleError(String msg) {
         if (failOnError) {
             throw new BuildException(msg, getLocation());
         }
         log(msg, Project.MSG_WARN);
     }
 
 
     /**
      * Throws an exception with the given nested exception if
      * failOnError is true, otherwise logs the message using the WARN
      * level.
      *
      * @since Ant 1.8.0
      */
     protected void handleError(Throwable ex) {
         if (failOnError) {
             throw new BuildException(ex);
         } else {
             log("Caught an exception: " + ex, Project.MSG_WARN);
         }
     }
 
     /**
      * Throws an exception with the given nested exception if
      * failOnError and failOnTransformationError are true, otherwise
      * logs the message using the WARN level.
      *
      * @since Ant 1.8.0
      */
     protected void handleTransformationError(Exception ex) {
         if (failOnError && failOnTransformationError) {
             throw new BuildException(ex);
         } else {
             log("Caught an error during transformation: " + ex,
                 Project.MSG_WARN);
         }
     }
 
     /**
      * The factory element to configure a transformer factory
      * @since Ant 1.6
      */
     public static class Factory {
 
         /** the factory class name to use for TraXLiaison */
         private String name;
 
         /**
          * the list of factory attributes to use for TraXLiaison
          */
         private Vector attributes = new Vector();
 
         /**
          * @return the name of the factory.
          */
         public String getName() {
             return name;
         }
 
         /**
          * Set the name of the factory
          * @param name the name of the factory.
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * Create an instance of a factory attribute.
          * @param attr the newly created factory attribute
          */
         public void addAttribute(Attribute attr) {
             attributes.addElement(attr);
         }
 
         /**
          * return the attribute elements.
          * @return the enumeration of attributes
          */
         public Enumeration getAttributes() {
             return attributes.elements();
         }
 
         /**
          * A JAXP factory attribute. This is mostly processor specific, for
          * example for Xalan 2.3+, the following attributes could be set:
          * <ul>
          *  <li>http://xml.apache.org/xalan/features/optimize (true|false) </li>
          *  <li>http://xml.apache.org/xalan/features/incremental (true|false) </li>
          * </ul>
          */
         public static class Attribute implements DynamicConfigurator {
 
             /** attribute name, mostly processor specific */
             private String name;
 
             /** attribute value, often a boolean string */
             private Object value;
 
             /**
              * @return the attribute name.
              */
             public String getName() {
                 return name;
             }
 
             /**
              * @return the output property value.
              */
             public Object getValue() {
                 return value;
             }
 
             /**
              * Not used.
              * @param name not used
              * @return null
              * @throws BuildException never
              */
             public Object createDynamicElement(String name) throws BuildException {
                 return null;
             }
 
             /**
              * Set an attribute.
              * Only "name" and "value" are supported as names.
              * @param name the name of the attribute
              * @param value the value of the attribute
              * @throws BuildException on error
              */
             public void setDynamicAttribute(String name, String value) throws BuildException {
                 // only 'name' and 'value' exist.
                 if ("name".equalsIgnoreCase(name)) {
                     this.name = value;
                 } else if ("value".equalsIgnoreCase(name)) {
                     // a value must be of a given type
                     // say boolean|integer|string that are mostly used.
                     if ("true".equalsIgnoreCase(value)) {
                         this.value = Boolean.TRUE;
                     } else if ("false".equalsIgnoreCase(value)) {
                         this.value = Boolean.FALSE;
                     } else {
                         try {
                             this.value = new Integer(value);
                         } catch (NumberFormatException e) {
                             this.value = value;
                         }
                     }
                 } else {
                     throw new BuildException("Unsupported attribute: " + name);
                 }
             }
         } // -- class Attribute
     } // -- class Factory
 
     /**
      * Mapper implementation of the "traditional" way &lt;xslt&gt;
      * mapped filenames.
      *
      * <p>If the file has an extension, chop it off.  Append whatever
      * the user has specified as extension or ".html".</p>
      *
      * @since Ant 1.6.2
      */
     private class StyleMapper implements FileNameMapper {
         public void setFrom(String from) {
         }
         public void setTo(String to) {
         }
         public String[] mapFileName(String xmlFile) {
             int dotPos = xmlFile.lastIndexOf('.');
             if (dotPos > 0) {
                 xmlFile = xmlFile.substring(0, dotPos);
             }
             return new String[] {xmlFile + targetExtension};
         }
     }
 
     /**
      * Configuration for Xalan2 traces.
      *
      * @since Ant 1.8.0
      */
     public final class TraceConfiguration {
         private boolean elements, extension, generation, selection, templates;
 
         /**
          * Set to true if the listener is to print events that occur
          * as each node is 'executed' in the stylesheet.
          */
         public void setElements(boolean b) {
             elements = b;
         }
 
         /**
          * True if the listener is to print events that occur as each
          * node is 'executed' in the stylesheet.
          */
         public boolean getElements() {
             return elements;
         }
 
         /**
          * Set to true if the listener is to print information after
          * each extension event.
          */
         public void setExtension(boolean b) {
             extension = b;
         }
 
         /**
          * True if the listener is to print information after each
          * extension event.
          */
         public boolean getExtension() {
             return extension;
         }
 
         /**
          * Set to true if the listener is to print information after
          * each result-tree generation event.
          */
         public void setGeneration(boolean b) {
             generation = b;
         }
 
         /**
          * True if the listener is to print information after each
          * result-tree generation event.
          */
         public boolean getGeneration() {
             return generation;
         }
 
         /**
          * Set to true if the listener is to print information after
          * each selection event.
          */
         public void setSelection(boolean b) {
             selection = b;
         }
 
         /**
          * True if the listener is to print information after each
          * selection event.
          */
         public boolean getSelection() {
             return selection;
         }
 
         /**
          * Set to true if the listener is to print an event whenever a
          * template is invoked.
          */
         public void setTemplates(boolean b) {
             templates = b;
         }
 
         /**
          * True if the listener is to print an event whenever a
          * template is invoked.
          */
         public boolean getTemplates() {
             return templates;
         }
 
         /**
          * The stream to write traces to.
          */
         public java.io.OutputStream getOutputStream() {
             return new LogOutputStream(XSLTProcess.this);
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/XmlProperty.java b/src/main/org/apache/tools/ant/taskdefs/XmlProperty.java
index 4e37a31aa..d85f86e10 100644
--- a/src/main/org/apache/tools/ant/taskdefs/XmlProperty.java
+++ b/src/main/org/apache/tools/ant/taskdefs/XmlProperty.java
@@ -1,778 +1,778 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.Hashtable;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.ParserConfigurationException;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.XMLCatalog;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.util.FileUtils;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 import org.xml.sax.SAXException;
 import org.xml.sax.EntityResolver;
 
 /**
  * Loads property values from a valid XML file, generating the
  * property names from the file's element and attribute names.
  *
  * <p>Example:</p>
  * <pre>
  *   &lt;root-tag myattr="true"&gt;
  *     &lt;inner-tag someattr="val"&gt;Text&lt;/inner-tag&gt;
  *     &lt;a2&gt;&lt;a3&gt;&lt;a4&gt;false&lt;/a4&gt;&lt;/a3&gt;&lt;/a2&gt;
  *     &lt;x&gt;x1&lt;/x&gt;
  *     &lt;x&gt;x2&lt;/x&gt;
  *   &lt;/root-tag&gt;
  *</pre>
  *
  * <p>this generates the following properties:</p>
  *
  * <pre>
  *  root-tag(myattr)=true
  *  root-tag.inner-tag=Text
  *  root-tag.inner-tag(someattr)=val
  *  root-tag.a2.a3.a4=false
  *  root-tag.x=x1,x2
  * </pre>
  *
  * <p>The <i>collapseAttributes</i> property of this task can be set
  * to true (the default is false) which will instead result in the
  * following properties (note the difference in names of properties
  * corresponding to XML attributes):</p>
  *
  * <pre>
  *  root-tag.myattr=true
  *  root-tag.inner-tag=Text
  *  root-tag.inner-tag.someattr=val
  *  root-tag.a2.a3.a4=false
  *  root-tag.x=x1,x2
  * </pre>
  *
  * <p>Optionally, to more closely mirror the abilities of the Property
  * task, a selected set of attributes can be treated specially.  To
  * enable this behavior, the "semanticAttributes" property of this task
  * must be set to true (it defaults to false).  If this attribute is
  * specified, the following attributes take on special meaning
  * (setting this to true implicitly sets collapseAttributes to true as
  * well):</p>
  *
  * <ul>
  *  <li><b>value</b>: Identifies a text value for a property.</li>
  *  <li><b>location</b>: Identifies a file location for a property.</li>
  *  <li><b>id</b>: Sets an id for a property</li>
  *  <li><b>refid</b>: Sets a property to the value of another property
  *       based upon the provided id</li>
  *  <li><b>pathid</b>: Defines a path rather than a property with
  *       the given id.</li>
  * </ul>
  *
  * <p>For example, with keepRoot = false, the following properties file:</p>
  *
  * <pre>
  * &lt;root-tag&gt;
  *   &lt;build&gt;
  *   &lt;build folder="build"&gt;
  *     &lt;classes id="build.classes" location="${build.folder}/classes"/&gt;
  *     &lt;reference refid="build.classes"/&gt;
  *   &lt;/build&gt;
  *   &lt;compile&gt;
  *     &lt;classpath pathid="compile.classpath"&gt;
  *       &lt;pathelement location="${build.classes}"/&gt;
  *     &lt;/classpath&gt;
  *   &lt;/compile&gt;
  *   &lt;run-time&gt;
  *     &lt;jars&gt;*.jar&lt;/jars&gt;
  *     &lt;classpath pathid="run-time.classpath"&gt;
  *       &lt;path refid="compile.classpath"/&gt;
  *       &lt;pathelement path="${run-time.jars}"/&gt;
  *     &lt;/classpath&gt;
  *   &lt;/run-time&gt;
  * &lt;/root-tag&gt;
  * </pre>
  *
  * <p>is equivalent to the following entries in a build file:</p>
  *
  * <pre>
  * &lt;property name="build" location="build"/&gt;
  * &lt;property name="build.classes" location="${build.location}/classes"/&gt;
  * &lt;property name="build.reference" refid="build.classes"/&gt;
  *
  * &lt;property name="run-time.jars" value="*.jar/&gt;
  *
  * &lt;classpath id="compile.classpath"&gt;
  *   &lt;pathelement location="${build.classes}"/&gt;
  * &lt;/classpath&gt;
  *
  * &lt;classpath id="run-time.classpath"&gt;
  *   &lt;path refid="compile.classpath"/&gt;
  *   &lt;pathelement path="${run-time.jars}"/&gt;
  * &lt;/classpath&gt;
  * </pre>
  *
  * <p> This task <i>requires</i> the following attributes:</p>
  *
  * <ul>
  * <li><b>file</b>: The name of the file to load.</li>
  * </ul>
  *
  * <p>This task supports the following attributes:</p>
  *
  * <ul>
  * <li><b>prefix</b>: Optionally specify a prefix applied to
  *     all properties loaded.  Defaults to an empty string.</li>
  * <li><b>keepRoot</b>: Indicate whether the root xml element
  *     is kept as part of property name.  Defaults to true.</li>
  * <li><b>validate</b>: Indicate whether the xml file is validated.
  *     Defaults to false.</li>
  * <li><b>collapseAttributes</b>: Indicate whether attributes are
  *     stored in property names with parens or with period
  *     delimiters.  Defaults to false, meaning properties
  *     are stored with parens (i.e., foo(attr)).</li>
  * <li><b>semanticAttributes</b>: Indicate whether attributes
  *     named "location", "value", "refid" and "path"
  *     are interpreted as ant properties.  Defaults
  *     to false.</li>
  * <li><b>rootDirectory</b>: Indicate the directory to use
  *     as the root directory for resolving location
  *     properties.  Defaults to the directory
  *     of the project using the task.</li>
  * <li><b>includeSemanticAttribute</b>: Indicate whether to include
  *     the semantic attribute ("location" or "value") as
  *     part of the property name.  Defaults to false.</li>
  * </ul>
  *
  * @ant.task name="xmlproperty" category="xml"
  */
 public class XmlProperty extends org.apache.tools.ant.Task {
 
     private Resource src;
     private String prefix = "";
     private boolean keepRoot = true;
     private boolean validate = false;
     private boolean collapseAttributes = false;
     private boolean semanticAttributes = false;
     private boolean includeSemanticAttribute = false;
     private File rootDirectory = null;
     private Hashtable addedAttributes = new Hashtable();
     private XMLCatalog xmlCatalog = new XMLCatalog();
     private String delimiter = ",";
 
     private static final String ID = "id";
     private static final String REF_ID = "refid";
     private static final String LOCATION = "location";
     private static final String VALUE = "value";
     private static final String PATH = "path";
     private static final String PATHID = "pathid";
     private static final String[] ATTRIBUTES = new String[] {
             ID, REF_ID, LOCATION, VALUE, PATH, PATHID
     };
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Constructor.
      */
     public XmlProperty() {
         super();
     }
 
     /**
      * Initializes the task.
      */
 
     public void init() {
         super.init();
         xmlCatalog.setProject(getProject());
     }
 
     /**
      * @return the xmlCatalog as the entityresolver.
      */
     protected EntityResolver getEntityResolver() {
         return xmlCatalog;
     }
 
     /**
      * Run the task.
      * @throws BuildException The exception raised during task execution.
      * @todo validate the source file is valid before opening, print a better error message
      * @todo add a verbose level log message listing the name of the file being loaded
      */
     public void execute() throws BuildException {
         Resource r = getResource();
 
         if (r == null) {
             throw new BuildException("XmlProperty task requires a source resource");
         }
         try {
             log("Loading " + src, Project.MSG_VERBOSE);
 
             if (r.isExists()) {
 
               DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
               factory.setValidating(validate);
               factory.setNamespaceAware(false);
               DocumentBuilder builder = factory.newDocumentBuilder();
               builder.setEntityResolver(getEntityResolver());
               Document document = null;
               FileProvider fp = src.as(FileProvider.class);
               if (fp != null) {
                   document = builder.parse(fp.getFile());
               } else {
                   document = builder.parse(src.getInputStream());
               }
               Element topElement = document.getDocumentElement();
 
               // Keep a hashtable of attributes added by this task.
               // This task is allow to override its own properties
               // but not other properties.  So we need to keep track
               // of which properties we've added.
               addedAttributes = new Hashtable();
 
               if (keepRoot) {
                   addNodeRecursively(topElement, prefix, null);
               } else {
                   NodeList topChildren = topElement.getChildNodes();
                   int numChildren = topChildren.getLength();
                   for (int i = 0; i < numChildren; i++) {
                     addNodeRecursively(topChildren.item(i), prefix, null);
                   }
               }
             } else {
                 log("Unable to find property resource: " + r, Project.MSG_VERBOSE);
             }
 
         } catch (SAXException sxe) {
             // Error generated during parsing
             Exception x = sxe;
             if (sxe.getException() != null) {
                 x = sxe.getException();
             }
             throw new BuildException("Failed to load " + src, x);
         } catch (ParserConfigurationException pce) {
             // Parser with specified options can't be built
             throw new BuildException(pce);
         } catch (IOException ioe) {
             // I/O error
             throw new BuildException("Failed to load " + src, ioe);
         }
     }
 
     /** Iterate through all nodes in the tree. */
     private void addNodeRecursively(Node node, String prefix, Object container) {
         // Set the prefix for this node to include its tag name.
         String nodePrefix = prefix;
         if (node.getNodeType() != Node.TEXT_NODE) {
             if (prefix.trim().length() > 0) {
                 nodePrefix += ".";
             }
             nodePrefix += node.getNodeName();
         }
         // Pass the container to the processing of this node,
         Object nodeObject = processNode(node, nodePrefix, container);
 
         // now, iterate through children.
         if (node.hasChildNodes()) {
             NodeList nodeChildren = node.getChildNodes();
             int numChildren = nodeChildren.getLength();
 
             for (int i = 0; i < numChildren; i++) {
                 // For each child, pass the object added by
                 // processNode to its children -- in other word, each
                 // object can pass information along to its children.
                 addNodeRecursively(nodeChildren.item(i), nodePrefix, nodeObject);
             }
         }
     }
 
     void addNodeRecursively(org.w3c.dom.Node node, String prefix) {
         addNodeRecursively(node, prefix, null);
     }
 
     /**
      * Process the given node, adding any required attributes from
      * this child node alone -- but <em>not</em> processing any
      * children.
      *
      * @param node the XML Node to parse
      * @param prefix A string to prepend to any properties that get
      * added by this node.
      * @param container Optionally, an object that a parent node
      * generated that this node might belong to.  For example, this
      * node could be within a node that generated a Path.
      * @return the Object created by this node.  Generally, this is
      * either a String if this node resulted in setting an attribute,
      * or a Path.
      */
     public Object processNode (Node node, String prefix, Object container) {
 
         // Parse the attribute(s) and text of this node, adding
         // properties for each.
         // if the "path" attribute is specified, then return the created path
         // which will be passed to the children of this node.
         Object addedPath = null;
 
         // The value of an id attribute of this node.
         String id = null;
 
         if (node.hasAttributes()) {
 
             NamedNodeMap nodeAttributes = node.getAttributes();
 
             // Is there an id attribute?
             Node idNode = nodeAttributes.getNamedItem(ID);
             id = semanticAttributes && idNode != null ? idNode.getNodeValue() : null;
 
             // Now, iterate through the attributes adding them.
             for (int i = 0; i < nodeAttributes.getLength(); i++) {
 
                 Node attributeNode = nodeAttributes.item(i);
 
                 if (!semanticAttributes) {
                     String attributeName = getAttributeName(attributeNode);
                     String attributeValue = getAttributeValue(attributeNode);
                     addProperty(prefix + attributeName, attributeValue, null);
                 } else {
                     String nodeName = attributeNode.getNodeName();
                     String attributeValue = getAttributeValue(attributeNode);
 
                     Path containingPath =
                         ((container != null) && (container instanceof Path))
                         ? (Path) container
                         : null;
                     /*
                      * The main conditional logic -- if the attribute
                      * is somehow "special" (i.e., it has known
                      * semantic meaning) then deal with it
                      * appropriately.
                      */
                     if (nodeName.equals(ID)) {
                         // ID has already been found above.
                         continue;
                     }
                     if (containingPath != null && nodeName.equals(PATH)) {
                         // A "path" attribute for a node within a Path object.
                         containingPath.setPath(attributeValue);
                     } else if (container instanceof Path && nodeName.equals(REF_ID)) {
                         // A "refid" attribute for a node within a Path object.
                         containingPath.setPath(attributeValue);
                     } else if (container instanceof Path && nodeName.equals(LOCATION)) {
                         // A "location" attribute for a node within a
                         // Path object.
                         containingPath.setLocation(resolveFile(attributeValue));
                     } else if (nodeName.equals(PATHID)) {
                         // A node identifying a new path
                         if (container != null) {
                             throw new BuildException("XmlProperty does not support nested paths");
                         }
                         addedPath = new Path(getProject());
                         getProject().addReference(attributeValue, addedPath);
                     } else {
                         // An arbitrary attribute.
                         String attributeName = getAttributeName(attributeNode);
                         addProperty(prefix + attributeName, attributeValue, id);
                     }
                 }
             }
         }
         String nodeText = null;
         boolean emptyNode = false;
         boolean semanticEmptyOverride = false;
         if (node.getNodeType() == Node.ELEMENT_NODE
                 && semanticAttributes
                 && node.hasAttributes()
                 && (node.getAttributes().getNamedItem(VALUE) != null
                         || node.getAttributes().getNamedItem(LOCATION) != null
                         || node.getAttributes().getNamedItem(REF_ID) != null
                         || node.getAttributes().getNamedItem(PATH) != null || node.getAttributes()
                         .getNamedItem(PATHID) != null)) {
             semanticEmptyOverride = true;
         }
         if (node.getNodeType() == Node.TEXT_NODE) {
             // For the text node, add a property.
             nodeText = getAttributeValue(node);
         } else if (node.getNodeType() == Node.ELEMENT_NODE
                 && node.getChildNodes().getLength() == 1
                 && node.getFirstChild().getNodeType() == Node.CDATA_SECTION_NODE) {
 
             nodeText = node.getFirstChild().getNodeValue();
             if ("".equals(nodeText) && !semanticEmptyOverride) {
                 emptyNode = true;
             }
         } else if (node.getNodeType() == Node.ELEMENT_NODE
                && node.getChildNodes().getLength() == 0
                && !semanticEmptyOverride) {
             nodeText = "";
             emptyNode = true;
         } else if (node.getNodeType() == Node.ELEMENT_NODE
                && node.getChildNodes().getLength() == 1
                && node.getFirstChild().getNodeType() == Node.TEXT_NODE
                && "".equals(node.getFirstChild().getNodeValue())
                && !semanticEmptyOverride) {
             nodeText = "";
             emptyNode = true;
         }
         if (nodeText != null) {
             // If the containing object was a String, then use it as the ID.
             if (semanticAttributes && id == null && container instanceof String) {
                 id = (String) container;
             }
             if (nodeText.trim().length() != 0 || emptyNode) {
                 addProperty(prefix, nodeText, id);
             }
         }
         // Return the Path we added or the ID of this node for
         // children to reference if needed.  Path objects are
         // definitely used by child path elements, and ID may be used
         // for a child text node.
         return (addedPath != null ? addedPath : id);
     }
 
     /**
      * Actually add the given property/value to the project
      * after writing a log message.
      */
     private void addProperty (String name, String value, String id) {
         String msg = name + ":" + value;
         if (id != null) {
             msg += ("(id=" + id + ")");
         }
         log(msg, Project.MSG_DEBUG);
 
         if (addedAttributes.containsKey(name)) {
             // If this attribute was added by this task, then
             // we append this value to the existing value.
             // We use the setProperty method which will
             // forcibly override the property if it already exists.
             // We need to put these properties into the project
             // when we read them, though (instead of keeping them
             // outside of the project and batch adding them at the end)
             // to allow other properties to reference them.
             value = (String) addedAttributes.get(name) + getDelimiter() + value;
             getProject().setProperty(name, value);
             addedAttributes.put(name, value);
         } else if (getProject().getProperty(name) == null) {
             getProject().setNewProperty(name, value);
             addedAttributes.put(name, value);
         } else {
             log("Override ignored for property " + name, Project.MSG_VERBOSE);
         }
         if (id != null) {
             getProject().addReference(id, value);
         }
     }
 
     /**
      * Return a reasonable attribute name for the given node.
      * If we are using semantic attributes or collapsing
      * attributes, the returned name is ".nodename".
      * Otherwise, we return "(nodename)".  This is long-standing
      * (and default) &lt;xmlproperty&gt; behavior.
      */
     private String getAttributeName (Node attributeNode) {
         String attributeName = attributeNode.getNodeName();
 
         if (semanticAttributes) {
             // Never include the "refid" attribute as part of the
             // attribute name.
             if (attributeName.equals(REF_ID)) {
                 return "";
             }
             // Otherwise, return it appended unless property to hide it is set.
             if (!isSemanticAttribute(attributeName) || includeSemanticAttribute) {
                 return "." + attributeName;
             }
             return "";
         }
         return collapseAttributes ? "." + attributeName : "(" + attributeName + ")";
     }
 
     /**
      * Return whether the provided attribute name is recognized or not.
      */
     private static boolean isSemanticAttribute (String attributeName) {
         for (int i = 0; i < ATTRIBUTES.length; i++) {
             if (attributeName.equals(ATTRIBUTES[i])) {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * Return the value for the given attribute.
      * If we are not using semantic attributes, its just the
      * literal string value of the attribute.
      *
      * <p>If we <em>are</em> using semantic attributes, then first
      * dependent properties are resolved (i.e., ${foo} is resolved
      * based on the foo property value), and then an appropriate data
      * type is used.  In particular, location-based properties are
      * resolved to absolute file names.  Also for refid values, look
      * up the referenced object from the project.</p>
      */
     private String getAttributeValue (Node attributeNode) {
         String nodeValue = attributeNode.getNodeValue().trim();
         if (semanticAttributes) {
             String attributeName = attributeNode.getNodeName();
             nodeValue = getProject().replaceProperties(nodeValue);
             if (attributeName.equals(LOCATION)) {
                 File f = resolveFile(nodeValue);
                 return f.getPath();
             }
             if (attributeName.equals(REF_ID)) {
                 Object ref = getProject().getReference(nodeValue);
                 if (ref != null) {
                     return ref.toString();
                 }
             }
         }
         return nodeValue;
     }
 
     /**
      * The XML file to parse; required.
      * @param src the file to parse
      */
     public void setFile(File src) {
         setSrcResource(new FileResource(src));
     }
 
     /**
      * The resource to pack; required.
      * @param src resource to expand
      */
     public void setSrcResource(Resource src) {
         if (src.isDirectory()) {
             throw new BuildException("the source can't be a directory");
         }
         if (src.as(FileProvider.class) != null || supportsNonFileResources()) {
             this.src = src;
         } else {
             throw new BuildException("Only FileSystem resources are supported.");
         }
     }
 
     /**
      * Set the source resource.
      * @param a the resource to pack as a single element Resource collection.
      */
     public void addConfigured(ResourceCollection a) {
         if (a.size() != 1) {
             throw new BuildException(
                     "only single argument resource collections are supported as archives");
         }
         setSrcResource(a.iterator().next());
     }
 
     /**
      * the prefix to prepend to each property
      * @param prefix the prefix to prepend to each property
      */
     public void setPrefix(String prefix) {
         this.prefix = prefix.trim();
     }
 
     /**
      * flag to include the xml root tag as a
      * first value in the property name; optional,
      * default is true
      * @param keepRoot if true (default), include the xml root tag
      */
     public void setKeeproot(boolean keepRoot) {
         this.keepRoot = keepRoot;
     }
 
     /**
      * flag to validate the XML file; optional, default false
      * @param validate if true validate the XML file, default false
      */
     public void setValidate(boolean validate) {
         this.validate = validate;
     }
 
     /**
      * flag to treat attributes as nested elements;
      * optional, default false
      * @param collapseAttributes if true treat attributes as nested elements
      */
     public void setCollapseAttributes(boolean collapseAttributes) {
         this.collapseAttributes = collapseAttributes;
     }
 
     /**
      * Attribute to enable special handling of attributes - see ant manual.
      * @param semanticAttributes if true enable the special handling.
      */
     public void setSemanticAttributes(boolean semanticAttributes) {
         this.semanticAttributes = semanticAttributes;
     }
 
     /**
      * The directory to use for resolving file references.
      * Ignored if semanticAttributes is not set to true.
      * @param rootDirectory the directory.
      */
     public void setRootDirectory(File rootDirectory) {
         this.rootDirectory = rootDirectory;
     }
 
     /**
      * Include the semantic attribute name as part of the property name.
      * Ignored if semanticAttributes is not set to true.
-     * @param includeSemanticAttribute if true include the sematic attribute
+     * @param includeSemanticAttribute if true include the semantic attribute
      *                                 name.
      */
     public void setIncludeSemanticAttribute(boolean includeSemanticAttribute) {
         this.includeSemanticAttribute = includeSemanticAttribute;
     }
 
     /**
      * add an XMLCatalog as a nested element; optional.
      * @param catalog the XMLCatalog to use
      */
     public void addConfiguredXMLCatalog(XMLCatalog catalog) {
         xmlCatalog.addConfiguredXMLCatalog(catalog);
     }
 
     /* Expose members for extensibility */
 
     /**
      * @return the file attribute.
      */
     protected File getFile () {
         FileProvider fp = src.as(FileProvider.class);
         return fp != null ? fp.getFile() : null;
     }
 
     /**
      * @return the resource.
      */
     protected Resource getResource() {
         // delegate this way around to support subclasses that
         // overwrite getFile
         File f = getFile();
         FileProvider fp = src.as(FileProvider.class);
         return f == null ? src : fp != null
                 && fp.getFile().equals(f) ? src : new FileResource(f);
     }
 
     /**
      * @return the prefix attribute.
      */
     protected String getPrefix () {
         return this.prefix;
     }
 
     /**
      * @return the keeproot attribute.
      */
     protected boolean getKeeproot () {
         return this.keepRoot;
     }
 
     /**
      * @return the validate attribute.
      */
     protected boolean getValidate () {
         return this.validate;
     }
 
     /**
      * @return the collapse attributes attribute.
      */
     protected boolean getCollapseAttributes () {
         return this.collapseAttributes;
     }
 
     /**
      * @return the semantic attributes attribute.
      */
     protected boolean getSemanticAttributes () {
         return this.semanticAttributes;
     }
 
     /**
      * @return the root directory attribute.
      */
     protected File getRootDirectory () {
         return this.rootDirectory;
     }
 
     /**
      * @return the include semantic attribute.
      */
     protected boolean getIncludeSementicAttribute () {
         return this.includeSemanticAttribute;
     }
 
     /**
      * Let project resolve the file - or do it ourselves if
      * rootDirectory has been set.
      */
     private File resolveFile(String fileName) {
         return FILE_UTILS.resolveFile(rootDirectory == null ? getProject().getBaseDir()
                 : rootDirectory, fileName);
     }
 
     /**
      * Whether this task can deal with non-file resources.
      *
      * <p>This implementation returns true only if this task is
      * &lt;xmlproperty&gt;.  Any subclass of this class that also wants to
      * support non-file resources needs to override this method.  We
      * need to do so for backwards compatibility reasons since we
      * can't expect subclasses to support resources.</p>
      * @return true for this task.
      * @since Ant 1.7
      */
     protected boolean supportsNonFileResources() {
         return getClass().equals(XmlProperty.class);
     }
 
     /**
      * Get the current delimiter.
      * @return delimiter
      */
     public String getDelimiter() {
         return delimiter;
     }
 
     /**
      * Sets a new delimiter.
      * @param delimiter new value
      * @since Ant 1.7.1
      */
     public void setDelimiter(String delimiter) {
         this.delimiter = delimiter;
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Zip.java b/src/main/org/apache/tools/ant/taskdefs/Zip.java
index 2b0d66db5..f5cdde0bb 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Zip.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Zip.java
@@ -1,2182 +1,2182 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Stack;
 import java.util.Vector;
 import java.util.zip.CRC32;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.FileScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.ArchiveFileSet;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.PatternSet;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.ZipFileSet;
 import org.apache.tools.ant.types.ZipScanner;
 import org.apache.tools.ant.types.resources.ArchiveResource;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.types.resources.ZipResource;
 import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.GlobPatternMapper;
 import org.apache.tools.ant.util.IdentityMapper;
 import org.apache.tools.ant.util.MergingMapper;
 import org.apache.tools.ant.util.ResourceUtils;
 import org.apache.tools.zip.UnixStat;
 import org.apache.tools.zip.ZipEntry;
 import org.apache.tools.zip.ZipExtraField;
 import org.apache.tools.zip.ZipFile;
 import org.apache.tools.zip.ZipOutputStream;
 
 /**
  * Create a Zip file.
  *
  * @since Ant 1.1
  *
  * @ant.task category="packaging"
  */
 public class Zip extends MatchingTask {
     private static final int BUFFER_SIZE = 8 * 1024;
     private static final int ROUNDUP_MILLIS = 1999; // 2 seconds - 1
     // CheckStyle:VisibilityModifier OFF - bc
 
     protected File zipFile;
     // use to scan own archive
     private ZipScanner zs;
     private File baseDir;
     protected Hashtable entries = new Hashtable();
     private Vector groupfilesets = new Vector();
     private Vector filesetsFromGroupfilesets = new Vector();
     protected String duplicate = "add";
     private boolean doCompress = true;
     private boolean doUpdate = false;
     // shadow of the above if the value is altered in execute
     private boolean savedDoUpdate = false;
     private boolean doFilesonly = false;
     protected String archiveType = "zip";
 
     // For directories:
     private static final long EMPTY_CRC = new CRC32 ().getValue ();
     protected String emptyBehavior = "skip";
     private Vector resources = new Vector();
     protected Hashtable addedDirs = new Hashtable();
     private Vector addedFiles = new Vector();
 
     private static final ResourceSelector MISSING_SELECTOR =
         new ResourceSelector() {
             public boolean isSelected(Resource target) {
                 return !target.isExists();
             }
         };
 
     private static final ResourceUtils.ResourceSelectorProvider
         MISSING_DIR_PROVIDER = new ResourceUtils.ResourceSelectorProvider() {
                 public ResourceSelector
                     getTargetSelectorForSource(Resource sr) {
                     return MISSING_SELECTOR;
                 }
             };
 
     /**
      * If this flag is true, execute() will run most operations twice,
      * the first time with {@link #skipWriting skipWriting} set to
      * true and the second time with setting it to false.
      *
      * <p>The only situation in Ant's current code base where this is
      * ever going to be true is if the jar task has been configured
      * with a filesetmanifest other than "skip".</p>
      */
     protected boolean doubleFilePass = false;
     /**
      * whether the methods should just perform some sort of dry-run.
      *
      * <p>Will only ever be true in the first pass if the task
      * performs two passes because {@link #doubleFilePass
      * doubleFilePass} is true.</p>
      */
     protected boolean skipWriting = false;
 
     /**
      * Whether this is the first time the archive building methods are invoked.
      *
      * @return true if either {@link #doubleFilePass doubleFilePass}
      * is false or {@link #skipWriting skipWriting} is true.
      *
      * @since Ant 1.8.0
      */
     protected final boolean isFirstPass() {
         return !doubleFilePass || skipWriting;
     }
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     // CheckStyle:VisibilityModifier ON
 
     // This boolean is set if the task detects that the
     // target is outofdate and has written to the target file.
     private boolean updatedFile = false;
 
     /**
      * true when we are adding new files into the Zip file, as opposed
      * to adding back the unchanged files
      */
     private boolean addingNewFiles = false;
 
     /**
      * Encoding to use for filenames, defaults to the platform's
      * default encoding.
      */
     private String encoding;
 
     /**
      * Whether the original compression of entries coming from a ZIP
      * archive should be kept (for example when updating an archive).
      *
      * @since Ant 1.6
      */
     private boolean keepCompression = false;
 
     /**
      * Whether the file modification times will be rounded up to the
      * next even number of seconds.
      *
      * @since Ant 1.6.2
      */
     private boolean roundUp = true;
 
     /**
      * Comment for the archive.
      * @since Ant 1.6.3
      */
     private String comment = "";
 
     private int level = ZipOutputStream.DEFAULT_COMPRESSION;
 
     /**
      * Assume 0 Unix mode is intentional.
      * @since Ant 1.8.0
      */
     private boolean preserve0Permissions = false;
 
     /**
      * Whether to set the language encoding flag when creating the archive.
      *
      * @since Ant 1.8.0
      */
     private boolean useLanguageEncodingFlag = true;
 
     /**
      * Whether to add unicode extra fields.
      *
      * @since Ant 1.8.0
      */
     private UnicodeExtraField createUnicodeExtraFields =
         UnicodeExtraField.NEVER;
 
     /**
-     * Whether to fall back to UTF-8 if a name cannot be enoded using
+     * Whether to fall back to UTF-8 if a name cannot be encoded using
      * the specified encoding.
      *
      * @since Ant 1.8.0
      */
     private boolean fallBackToUTF8 = false;
 
     /**
      * This is the name/location of where to
      * create the .zip file.
      * @param zipFile the path of the zipFile
      * @deprecated since 1.5.x.
      *             Use setDestFile(File) instead.
      * @ant.attribute ignore="true"
      */
     public void setZipfile(File zipFile) {
         setDestFile(zipFile);
     }
 
     /**
      * This is the name/location of where to
      * create the file.
      * @param file the path of the zipFile
      * @since Ant 1.5
      * @deprecated since 1.5.x.
      *             Use setDestFile(File) instead.
      * @ant.attribute ignore="true"
      */
     public void setFile(File file) {
         setDestFile(file);
     }
 
 
     /**
      * The file to create; required.
      * @since Ant 1.5
      * @param destFile The new destination File
      */
     public void setDestFile(File destFile) {
        this.zipFile = destFile;
     }
 
     /**
      * The file to create.
      * @return the destination file
      * @since Ant 1.5.2
      */
     public File getDestFile() {
         return zipFile;
     }
 
 
     /**
      * Directory from which to archive files; optional.
      * @param baseDir the base directory
      */
     public void setBasedir(File baseDir) {
         this.baseDir = baseDir;
     }
 
     /**
      * Whether we want to compress the files or only store them;
      * optional, default=true;
      * @param c if true, compress the files
      */
     public void setCompress(boolean c) {
         doCompress = c;
     }
 
     /**
      * Whether we want to compress the files or only store them;
      * @return true if the files are to be compressed
      * @since Ant 1.5.2
      */
     public boolean isCompress() {
         return doCompress;
     }
 
     /**
      * If true, emulate Sun's jar utility by not adding parent directories;
      * optional, defaults to false.
      * @param f if true, emulate sun's jar by not adding parent directories
      */
     public void setFilesonly(boolean f) {
         doFilesonly = f;
     }
 
     /**
      * If true, updates an existing file, otherwise overwrite
      * any existing one; optional defaults to false.
      * @param c if true, updates an existing zip file
      */
     public void setUpdate(boolean c) {
         doUpdate = c;
         savedDoUpdate = c;
     }
 
     /**
      * Are we updating an existing archive?
      * @return true if updating an existing archive
      */
     public boolean isInUpdateMode() {
         return doUpdate;
     }
 
     /**
      * Adds a set of files.
      * @param set the fileset to add
      */
     public void addFileset(FileSet set) {
         add(set);
     }
 
     /**
      * Adds a set of files that can be
      * read from an archive and be given a prefix/fullpath.
      * @param set the zipfileset to add
      */
     public void addZipfileset(ZipFileSet set) {
         add(set);
     }
 
     /**
      * Add a collection of resources to be archived.
      * @param a the resources to archive
      * @since Ant 1.7
      */
     public void add(ResourceCollection a) {
         resources.add(a);
     }
 
     /**
      * Adds a group of zip files.
      * @param set the group (a fileset) to add
      */
     public void addZipGroupFileset(FileSet set) {
         groupfilesets.addElement(set);
     }
 
     /**
      * Sets behavior for when a duplicate file is about to be added -
      * one of <code>add</code>, <code>preserve</code> or <code>fail</code>.
      * Possible values are: <code>add</code> (keep both
      * of the files); <code>preserve</code> (keep the first version
      * of the file found); <code>fail</code> halt a problem
      * Default for zip tasks is <code>add</code>
      * @param df a <code>Duplicate</code> enumerated value
      */
     public void setDuplicate(Duplicate df) {
         duplicate = df.getValue();
     }
 
     /**
      * Possible behaviors when there are no matching files for the task:
      * "fail", "skip", or "create".
      */
     public static class WhenEmpty extends EnumeratedAttribute {
         /**
          * The string values for the enumerated value
          * @return the values
          */
         public String[] getValues() {
             return new String[] {"fail", "skip", "create"};
         }
     }
 
     /**
      * Sets behavior of the task when no files match.
      * Possible values are: <code>fail</code> (throw an exception
      * and halt the build); <code>skip</code> (do not create
      * any archive, but issue a warning); <code>create</code>
      * (make an archive with no entries).
      * Default for zip tasks is <code>skip</code>;
      * for jar tasks, <code>create</code>.
      * @param we a <code>WhenEmpty</code> enumerated value
      */
     public void setWhenempty(WhenEmpty we) {
         emptyBehavior = we.getValue();
     }
 
     /**
      * Encoding to use for filenames, defaults to the platform's
      * default encoding.
      *
      * <p>For a list of possible values see <a
      * href="http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.</p>
      * @param encoding the encoding name
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * Encoding to use for filenames.
      * @return the name of the encoding to use
      * @since Ant 1.5.2
      */
     public String getEncoding() {
         return encoding;
     }
 
     /**
      * Whether the original compression of entries coming from a ZIP
      * archive should be kept (for example when updating an archive).
      * Default is false.
      * @param keep if true, keep the original compression
      * @since Ant 1.6
      */
     public void setKeepCompression(boolean keep) {
         keepCompression = keep;
     }
 
     /**
      * Comment to use for archive.
      *
      * @param comment The content of the comment.
      * @since Ant 1.6.3
      */
     public void setComment(String comment) {
         this.comment = comment;
     }
 
     /**
      * Comment of the archive
      *
      * @return Comment of the archive.
      * @since Ant 1.6.3
      */
     public String getComment() {
         return comment;
     }
 
     /**
      * Set the compression level to use.  Default is
      * ZipOutputStream.DEFAULT_COMPRESSION.
      * @param level compression level.
      * @since Ant 1.7
      */
     public void setLevel(int level) {
         this.level = level;
     }
 
     /**
      * Get the compression level.
      * @return compression level.
      * @since Ant 1.7
      */
     public int getLevel() {
         return level;
     }
 
     /**
      * Whether the file modification times will be rounded up to the
      * next even number of seconds.
      *
      * <p>Zip archives store file modification times with a
      * granularity of two seconds, so the times will either be rounded
      * up or down.  If you round down, the archive will always seem
      * out-of-date when you rerun the task, so the default is to round
      * up.  Rounding up may lead to a different type of problems like
      * JSPs inside a web archive that seem to be slightly more recent
      * than precompiled pages, rendering precompilation useless.</p>
      * @param r a <code>boolean</code> value
      * @since Ant 1.6.2
      */
     public void setRoundUp(boolean r) {
         roundUp = r;
     }
 
     /**
      * Assume 0 Unix mode is intentional.
      * @since Ant 1.8.0
      */
     public void setPreserve0Permissions(boolean b) {
         preserve0Permissions = b;
     }
 
     /**
      * Assume 0 Unix mode is intentional.
      * @since Ant 1.8.0
      */
     public boolean getPreserve0Permissions() {
         return preserve0Permissions;
     }
 
     /**
      * Whether to set the language encoding flag.
      * @since Ant 1.8.0
      */
     public void setUseLanguageEncodingFlag(boolean b) {
         useLanguageEncodingFlag = b;
     }
 
     /**
      * Whether the language encoding flag will be used.
      * @since Ant 1.8.0
      */
     public boolean getUseLanguageEnodingFlag() {
         return useLanguageEncodingFlag;
     }
 
     /**
      * Whether Unicode extra fields will be created.
      * @since Ant 1.8.0
      */
     public void setCreateUnicodeExtraFields(UnicodeExtraField b) {
         createUnicodeExtraFields = b;
     }
 
     /**
      * Whether Unicode extra fields will be created.
      * @since Ant 1.8.0
      */
     public UnicodeExtraField getCreateUnicodeExtraFields() {
         return createUnicodeExtraFields;
     }
 
     /**
-     * Whether to fall back to UTF-8 if a name cannot be enoded using
+     * Whether to fall back to UTF-8 if a name cannot be encoded using
      * the specified encoding.
      *
      * <p>Defaults to false.</p>
      *
      * @since Ant 1.8.0
      */
     public void setFallBackToUTF8(boolean b) {
         fallBackToUTF8 = b;
     }
 
     /**
-     * Whether to fall back to UTF-8 if a name cannot be enoded using
+     * Whether to fall back to UTF-8 if a name cannot be encoded using
      * the specified encoding.
      *
      * @since Ant 1.8.0
      */
     public boolean getFallBackToUTF8() {
         return fallBackToUTF8;
     }
 
     /**
      * validate and build
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
 
         if (doubleFilePass) {
             skipWriting = true;
             executeMain();
             skipWriting = false;
             executeMain();
         } else {
             executeMain();
         }
     }
 
     /**
      * Get the value of the updatedFile attribute.
      * This should only be called after executeMain has been
      * called.
      * @return true if executeMain has written to the zip file.
      */
     protected boolean hasUpdatedFile() {
         return updatedFile;
     }
 
     /**
      * Build the zip file.
      * This is called twice if doubleFilePass is true.
      * @throws BuildException on error
      */
     public void executeMain() throws BuildException {
 
         checkAttributesAndElements();
 
         // Renamed version of original file, if it exists
         File renamedFile = null;
         addingNewFiles = true;
 
         processDoUpdate();
         processGroupFilesets();
 
         // collect filesets to pass them to getResourcesToAdd
         Vector vfss = new Vector();
         if (baseDir != null) {
             FileSet fs = (FileSet) getImplicitFileSet().clone();
             fs.setDir(baseDir);
             vfss.addElement(fs);
         }
         final int size = resources.size();
         for (int i = 0; i < size; i++) {
             ResourceCollection rc = (ResourceCollection) resources.elementAt(i);
             vfss.addElement(rc);
         }
 
         ResourceCollection[] fss = new ResourceCollection[vfss.size()];
         vfss.copyInto(fss);
         boolean success = false;
         try {
             // can also handle empty archives
             ArchiveState state = getResourcesToAdd(fss, zipFile, false);
 
             // quick exit if the target is up to date
             if (!state.isOutOfDate()) {
                 return;
             }
 
             File parent = zipFile.getParentFile();
             if (parent != null && !parent.isDirectory() && !parent.mkdirs()) {
                 throw new BuildException("Failed to create missing parent"
                                          + " directory for " + zipFile);
             }
 
             updatedFile = true;
             if (!zipFile.exists() && state.isWithoutAnyResources()) {
                 createEmptyZip(zipFile);
                 return;
             }
             Resource[][] addThem = state.getResourcesToAdd();
 
             if (doUpdate) {
                 renamedFile = renameFile();
             }
 
             String action = doUpdate ? "Updating " : "Building ";
 
             if (!skipWriting) {
                 log(action + archiveType + ": " + zipFile.getAbsolutePath());
             }
 
             ZipOutputStream zOut = null;
             try {
                 if (!skipWriting) {
                     zOut = new ZipOutputStream(zipFile);
 
                     zOut.setEncoding(encoding);
                     zOut.setUseLanguageEncodingFlag(useLanguageEncodingFlag);
                     zOut.setCreateUnicodeExtraFields(createUnicodeExtraFields.
                                                      getPolicy());
                     zOut.setFallbackToUTF8(fallBackToUTF8);
                     zOut.setMethod(doCompress
                         ? ZipOutputStream.DEFLATED : ZipOutputStream.STORED);
                     zOut.setLevel(level);
                 }
                 initZipOutputStream(zOut);
 
                 // Add the explicit resource collections to the archive.
                 for (int i = 0; i < fss.length; i++) {
                     if (addThem[i].length != 0) {
                         addResources(fss[i], addThem[i], zOut);
                     }
                 }
 
                 if (doUpdate) {
                     addingNewFiles = false;
                     ZipFileSet oldFiles = new ZipFileSet();
                     oldFiles.setProject(getProject());
                     oldFiles.setSrc(renamedFile);
                     oldFiles.setDefaultexcludes(false);
 
                     final int addSize = addedFiles.size();
                     for (int i = 0; i < addSize; i++) {
                         PatternSet.NameEntry ne = oldFiles.createExclude();
                         ne.setName((String) addedFiles.elementAt(i));
                     }
                     DirectoryScanner ds =
                         oldFiles.getDirectoryScanner(getProject());
                     ((ZipScanner) ds).setEncoding(encoding);
 
                     String[] f = ds.getIncludedFiles();
                     Resource[] r = new Resource[f.length];
                     for (int i = 0; i < f.length; i++) {
                         r[i] = ds.getResource(f[i]);
                     }
 
                     if (!doFilesonly) {
                         String[] d = ds.getIncludedDirectories();
                         Resource[] dr = new Resource[d.length];
                         for (int i = 0; i < d.length; i++) {
                             dr[i] = ds.getResource(d[i]);
                         }
                         Resource[] tmp = r;
                         r = new Resource[tmp.length + dr.length];
                         System.arraycopy(dr, 0, r, 0, dr.length);
                         System.arraycopy(tmp, 0, r, dr.length, tmp.length);
                     }
                     addResources(oldFiles, r, zOut);
                 }
                 if (zOut != null) {
                     zOut.setComment(comment);
                 }
                 finalizeZipOutputStream(zOut);
 
                 // If we've been successful on an update, delete the
                 // temporary file
                 if (doUpdate) {
                     if (!renamedFile.delete()) {
                         log ("Warning: unable to delete temporary file "
                             + renamedFile.getName(), Project.MSG_WARN);
                     }
                 }
                 success = true;
             } finally {
                 // Close the output stream.
                 closeZout(zOut, success);
             }
         } catch (IOException ioe) {
             String msg = "Problem creating " + archiveType + ": "
                 + ioe.getMessage();
 
             // delete a bogus ZIP file (but only if it's not the original one)
             if ((!doUpdate || renamedFile != null) && !zipFile.delete()) {
                 msg += " (and the archive is probably corrupt but I could not "
                     + "delete it)";
             }
 
             if (doUpdate && renamedFile != null) {
                 try {
                     FILE_UTILS.rename(renamedFile, zipFile);
                 } catch (IOException e) {
                     msg += " (and I couldn't rename the temporary file "
                             + renamedFile.getName() + " back)";
                 }
             }
 
             throw new BuildException(msg, ioe, getLocation());
         } finally {
             cleanUp();
         }
     }
 
     /** rename the zip file. */
     private File renameFile() {
         File renamedFile = FILE_UTILS.createTempFile(
             "zip", ".tmp", zipFile.getParentFile(), true, false);
         try {
             FILE_UTILS.rename(zipFile, renamedFile);
         } catch (SecurityException e) {
             throw new BuildException(
                 "Not allowed to rename old file ("
                 + zipFile.getAbsolutePath()
                 + ") to temporary file");
         } catch (IOException e) {
             throw new BuildException(
                 "Unable to rename old file ("
                 + zipFile.getAbsolutePath()
                 + ") to temporary file");
         }
         return renamedFile;
     }
 
     /** Close zout */
     private void closeZout(ZipOutputStream zOut, boolean success)
         throws IOException {
         if (zOut == null) {
             return;
         }
         try {
             zOut.close();
         } catch (IOException ex) {
             // If we're in this finally clause because of an
             // exception, we don't really care if there's an
             // exception when closing the stream. E.g. if it
             // throws "ZIP file must have at least one entry",
             // because an exception happened before we added
             // any files, then we must swallow this
             // exception. Otherwise, the error that's reported
             // will be the close() error, which is not the
             // real cause of the problem.
             if (success) {
                 throw ex;
             }
         }
     }
 
     /** Check the attributes and elements */
     private void checkAttributesAndElements() {
         if (baseDir == null && resources.size() == 0
             && groupfilesets.size() == 0 && "zip".equals(archiveType)) {
             throw new BuildException("basedir attribute must be set, "
                                      + "or at least one "
                                      + "resource collection must be given!");
         }
 
         if (zipFile == null) {
             throw new BuildException("You must specify the "
                                      + archiveType + " file to create!");
         }
 
         if (zipFile.exists() && !zipFile.isFile()) {
             throw new BuildException(zipFile + " is not a file.");
         }
 
         if (zipFile.exists() && !zipFile.canWrite()) {
             throw new BuildException(zipFile + " is read-only.");
         }
     }
 
     /** Process doupdate */
     private void processDoUpdate() {
         // Whether or not an actual update is required -
         // we don't need to update if the original file doesn't exist
         if (doUpdate && !zipFile.exists()) {
             doUpdate = false;
             logWhenWriting("ignoring update attribute as " + archiveType
                            + " doesn't exist.", Project.MSG_DEBUG);
         }
     }
 
     /** Process groupfilesets */
     private void processGroupFilesets() {
         // Add the files found in groupfileset to fileset
         final int size = groupfilesets.size();
         for (int i = 0; i < size; i++) {
 
             logWhenWriting("Processing groupfileset ", Project.MSG_VERBOSE);
             FileSet fs = (FileSet) groupfilesets.elementAt(i);
             FileScanner scanner = fs.getDirectoryScanner(getProject());
             String[] files = scanner.getIncludedFiles();
             File basedir = scanner.getBasedir();
             for (int j = 0; j < files.length; j++) {
 
                 logWhenWriting("Adding file " + files[j] + " to fileset",
                                Project.MSG_VERBOSE);
                 ZipFileSet zf = new ZipFileSet();
                 zf.setProject(getProject());
                 zf.setSrc(new File(basedir, files[j]));
                 add(zf);
                 filesetsFromGroupfilesets.addElement(zf);
             }
         }
     }
 
     /**
      * Indicates if the task is adding new files into the archive as opposed to
      * copying back unchanged files from the backup copy
      * @return true if adding new files
      */
     protected final boolean isAddingNewFiles() {
         return addingNewFiles;
     }
 
     /**
      * Add the given resources.
      *
      * @param fileset may give additional information like fullpath or
      * permissions.
      * @param resources the resources to add
      * @param zOut the stream to write to
      * @throws IOException on error
      *
      * @since Ant 1.5.2
      */
     protected final void addResources(FileSet fileset, Resource[] resources,
                                       ZipOutputStream zOut)
         throws IOException {
 
         String prefix = "";
         String fullpath = "";
         int dirMode = ArchiveFileSet.DEFAULT_DIR_MODE;
         int fileMode = ArchiveFileSet.DEFAULT_FILE_MODE;
 
         ArchiveFileSet zfs = null;
         if (fileset instanceof ArchiveFileSet) {
             zfs = (ArchiveFileSet) fileset;
             prefix = zfs.getPrefix(getProject());
             fullpath = zfs.getFullpath(getProject());
             dirMode = zfs.getDirMode(getProject());
             fileMode = zfs.getFileMode(getProject());
         }
 
         if (prefix.length() > 0 && fullpath.length() > 0) {
             throw new BuildException("Both prefix and fullpath attributes must"
                                      + " not be set on the same fileset.");
         }
 
         if (resources.length != 1 && fullpath.length() > 0) {
             throw new BuildException("fullpath attribute may only be specified"
                                      + " for filesets that specify a single"
                                      + " file.");
         }
 
         if (prefix.length() > 0) {
             if (!prefix.endsWith("/") && !prefix.endsWith("\\")) {
                 prefix += "/";
             }
             addParentDirs(null, prefix, zOut, "", dirMode);
         }
 
         ZipFile zf = null;
         try {
             boolean dealingWithFiles = false;
             File base = null;
 
             if (zfs == null || zfs.getSrc(getProject()) == null) {
                 dealingWithFiles = true;
                 base = fileset.getDir(getProject());
             } else if (zfs instanceof ZipFileSet) {
                 zf = new ZipFile(zfs.getSrc(getProject()), encoding);
             }
 
             for (int i = 0; i < resources.length; i++) {
                 String name = null;
                 if (fullpath.length() > 0) {
                     name = fullpath;
                 } else {
                     name = resources[i].getName();
                 }
                 name = name.replace(File.separatorChar, '/');
 
                 if ("".equals(name)) {
                     continue;
                 }
 
                 if (resources[i].isDirectory()) {
                     if (doFilesonly) {
                         continue;
                     }
                     int thisDirMode = zfs != null && zfs.hasDirModeBeenSet()
                         ? dirMode : getUnixMode(resources[i], zf, dirMode);
                     addDirectoryResource(resources[i], name, prefix,
                                          base, zOut,
                                          dirMode, thisDirMode);
 
                 } else { // !isDirectory
 
                     addParentDirs(base, name, zOut, prefix, dirMode);
 
                     if (dealingWithFiles) {
                         File f = FILE_UTILS.resolveFile(base,
                                                         resources[i].getName());
                         zipFile(f, zOut, prefix + name, fileMode);
                     } else {
                         int thisFileMode =
                             zfs != null && zfs.hasFileModeBeenSet()
                             ? fileMode : getUnixMode(resources[i], zf,
                                                      fileMode);
                         addResource(resources[i], name, prefix,
                                     zOut, thisFileMode, zf,
                                     zfs == null
                                     ? null : zfs.getSrc(getProject()));
                     }
                 }
             }
         } finally {
             if (zf != null) {
                 zf.close();
             }
         }
     }
 
     /**
      * Add a directory entry to the archive using a specified
      * Unix-mode and the default mode for its parent directories (if
      * necessary).
      */
     private void addDirectoryResource(Resource r, String name, String prefix,
                                       File base, ZipOutputStream zOut,
                                       int defaultDirMode, int thisDirMode)
         throws IOException {
 
         if (!name.endsWith("/")) {
             name = name + "/";
         }
 
         int nextToLastSlash = name.lastIndexOf("/", name.length() - 2);
         if (nextToLastSlash != -1) {
             addParentDirs(base, name.substring(0, nextToLastSlash + 1),
                           zOut, prefix, defaultDirMode);
         }
         zipDir(r, zOut, prefix + name, thisDirMode,
                r instanceof ZipResource
                ? ((ZipResource) r).getExtraFields() : null);
     }
 
     /**
      * Determine a Resource's Unix mode or return the given default
      * value if not available.
      */
     private int getUnixMode(Resource r, ZipFile zf, int defaultMode)
         throws IOException {
 
         int unixMode = defaultMode;
         if (zf != null) {
             ZipEntry ze = zf.getEntry(r.getName());
             unixMode = ze.getUnixMode();
             if ((unixMode == 0 || unixMode == UnixStat.DIR_FLAG)
                 && !preserve0Permissions) {
                 unixMode = defaultMode;
             }
         } else if (r instanceof ArchiveResource) {
             unixMode = ((ArchiveResource) r).getMode();
         }
         return unixMode;
     }
 
     /**
      * Add a file entry.
      */
     private void addResource(Resource r, String name, String prefix,
                              ZipOutputStream zOut, int mode,
                              ZipFile zf, File fromArchive)
         throws IOException {
 
         if (zf != null) {
             ZipEntry ze = zf.getEntry(r.getName());
 
             if (ze != null) {
                 boolean oldCompress = doCompress;
                 if (keepCompression) {
                     doCompress = (ze.getMethod() == ZipEntry.DEFLATED);
                 }
                 InputStream is = null;
                 try {
                     is = zf.getInputStream(ze);
                     zipFile(is, zOut, prefix + name, ze.getTime(),
                             fromArchive, mode, ze.getExtraFields(true));
                 } finally {
                     doCompress = oldCompress;
                     FileUtils.close(is);
                 }
             }
         } else {
             InputStream is = null;
             try {
                 is = r.getInputStream();
                 zipFile(is, zOut, prefix + name, r.getLastModified(),
                         fromArchive, mode, r instanceof ZipResource
                         ? ((ZipResource) r).getExtraFields() : null);
             } finally {
                 FileUtils.close(is);
             }
         }
     }
 
     /**
      * Add the given resources.
      *
      * @param rc may give additional information like fullpath or
      * permissions.
      * @param resources the resources to add
      * @param zOut the stream to write to
      * @throws IOException on error
      *
      * @since Ant 1.7
      */
     protected final void addResources(ResourceCollection rc,
                                       Resource[] resources,
                                       ZipOutputStream zOut)
         throws IOException {
         if (rc instanceof FileSet) {
             addResources((FileSet) rc, resources, zOut);
             return;
         }
         for (int i = 0; i < resources.length; i++) {
             String name = resources[i].getName().replace(File.separatorChar,
                                                          '/');
             if ("".equals(name)) {
                 continue;
             }
             if (resources[i].isDirectory() && doFilesonly) {
                 continue;
             }
             File base = null;
             FileProvider fp = resources[i].as(FileProvider.class);
             if (fp != null) {
                 base = ResourceUtils.asFileResource(fp).getBaseDir();
             }
 
             if (resources[i].isDirectory()) {
                 addDirectoryResource(resources[i], name, "", base, zOut,
                                      ArchiveFileSet.DEFAULT_DIR_MODE,
                                      ArchiveFileSet.DEFAULT_DIR_MODE);
 
             } else {
                 addParentDirs(base, name, zOut, "",
                               ArchiveFileSet.DEFAULT_DIR_MODE);
 
                 if (fp != null) {
                     File f = (fp).getFile();
                     zipFile(f, zOut, name, ArchiveFileSet.DEFAULT_FILE_MODE);
                 } else {
                     addResource(resources[i], name, "", zOut,
                                 ArchiveFileSet.DEFAULT_FILE_MODE,
                                 null, null);
                 }
             }
         }
     }
 
     /**
      * method for subclasses to override
      * @param zOut the zip output stream
      * @throws IOException on output error
      * @throws BuildException on other errors
      */
     protected void initZipOutputStream(ZipOutputStream zOut)
         throws IOException, BuildException {
     }
 
     /**
      * method for subclasses to override
      * @param zOut the zip output stream
      * @throws IOException on output error
      * @throws BuildException on other errors
      */
     protected void finalizeZipOutputStream(ZipOutputStream zOut)
         throws IOException, BuildException {
     }
 
     /**
      * Create an empty zip file
      * @param zipFile the zip file
      * @return true for historic reasons
      * @throws BuildException on error
      */
     protected boolean createEmptyZip(File zipFile) throws BuildException {
         // In this case using java.util.zip will not work
         // because it does not permit a zero-entry archive.
         // Must create it manually.
         if (!skipWriting) {
             log("Note: creating empty " + archiveType + " archive " + zipFile,
                 Project.MSG_INFO);
         }
         OutputStream os = null;
         try {
             os = new FileOutputStream(zipFile);
             // CheckStyle:MagicNumber OFF
             // Cf. PKZIP specification.
             byte[] empty = new byte[22];
             empty[0] = 80; // P
             empty[1] = 75; // K
             empty[2] = 5;
             empty[3] = 6;
             // remainder zeros
             // CheckStyle:MagicNumber ON
             os.write(empty);
         } catch (IOException ioe) {
             throw new BuildException("Could not create empty ZIP archive "
                                      + "(" + ioe.getMessage() + ")", ioe,
                                      getLocation());
         } finally {
             FileUtils.close(os);
         }
         return true;
     }
 
     /**
      * @since Ant 1.5.2
      */
     private synchronized ZipScanner getZipScanner() {
         if (zs == null) {
             zs = new ZipScanner();
             zs.setEncoding(encoding);
             zs.setSrc(zipFile);
         }
         return zs;
     }
 
     /**
      * Collect the resources that are newer than the corresponding
      * entries (or missing) in the original archive.
      *
      * <p>If we are going to recreate the archive instead of updating
      * it, all resources should be considered as new, if a single one
      * is.  Because of this, subclasses overriding this method must
      * call <code>super.getResourcesToAdd</code> and indicate with the
      * third arg if they already know that the archive is
      * out-of-date.</p>
      *
-     * <p>This method first delegates to getNonFileSetResourceToAdd
+     * <p>This method first delegates to getNonFileSetResourcesToAdd
      * and then invokes the FileSet-arg version.  All this to keep
      * backwards compatibility for subclasses that don't know how to
      * deal with non-FileSet ResourceCollections.</p>
      *
      * @param rcs The resource collections to grab resources from
      * @param zipFile intended archive file (may or may not exist)
      * @param needsUpdate whether we already know that the archive is
      * out-of-date.  Subclasses overriding this method are supposed to
      * set this value correctly in their call to
      * <code>super.getResourcesToAdd</code>.
      * @return an array of resources to add for each fileset passed in as well
      *         as a flag that indicates whether the archive is uptodate.
      *
      * @exception BuildException if it likes
      * @since Ant 1.7
      */
     protected ArchiveState getResourcesToAdd(ResourceCollection[] rcs,
                                              File zipFile,
                                              boolean needsUpdate)
         throws BuildException {
         ArrayList filesets = new ArrayList();
         ArrayList rest = new ArrayList();
         for (int i = 0; i < rcs.length; i++) {
             if (rcs[i] instanceof FileSet) {
                 filesets.add(rcs[i]);
             } else {
                 rest.add(rcs[i]);
             }
         }
         ResourceCollection[] rc = (ResourceCollection[])
             rest.toArray(new ResourceCollection[rest.size()]);
         ArchiveState as = getNonFileSetResourcesToAdd(rc, zipFile,
                                                       needsUpdate);
 
         FileSet[] fs = (FileSet[]) filesets.toArray(new FileSet[filesets
                                                                 .size()]);
         ArchiveState as2 = getResourcesToAdd(fs, zipFile, as.isOutOfDate());
         if (!as.isOutOfDate() && as2.isOutOfDate()) {
             /*
              * Bad luck.
              *
              * There are resources in the filesets that make the
              * archive out of date, but not in the non-fileset
              * resources. We need to rescan the non-FileSets to grab
              * all of them now.
              */
             as = getNonFileSetResourcesToAdd(rc, zipFile, true);
         }
 
         Resource[][] toAdd = new Resource[rcs.length][];
         int fsIndex = 0;
         int restIndex = 0;
         for (int i = 0; i < rcs.length; i++) {
             if (rcs[i] instanceof FileSet) {
                 toAdd[i] = as2.getResourcesToAdd()[fsIndex++];
             } else {
                 toAdd[i] = as.getResourcesToAdd()[restIndex++];
             }
         }
         return new ArchiveState(as2.isOutOfDate(), toAdd);
     }
 
     /*
      * This is yet another hacky construct to extend the FileSet[]
      * getResourcesToAdd method so we can pass the information whether
      * non-fileset resources have been available to it without having
      * to move the withEmpty behavior checks (since either would break
      * subclasses in several ways).
      */
     private static ThreadLocal haveNonFileSetResourcesToAdd = new ThreadLocal() {
             protected Object initialValue() {
                 return Boolean.FALSE;
             }
         };
 
     /**
      * Collect the resources that are newer than the corresponding
      * entries (or missing) in the original archive.
      *
      * <p>If we are going to recreate the archive instead of updating
      * it, all resources should be considered as new, if a single one
      * is.  Because of this, subclasses overriding this method must
      * call <code>super.getResourcesToAdd</code> and indicate with the
      * third arg if they already know that the archive is
      * out-of-date.</p>
      *
      * @param filesets The filesets to grab resources from
      * @param zipFile intended archive file (may or may not exist)
      * @param needsUpdate whether we already know that the archive is
      * out-of-date.  Subclasses overriding this method are supposed to
      * set this value correctly in their call to
      * <code>super.getResourcesToAdd</code>.
      * @return an array of resources to add for each fileset passed in as well
      *         as a flag that indicates whether the archive is uptodate.
      *
      * @exception BuildException if it likes
      */
     protected ArchiveState getResourcesToAdd(FileSet[] filesets,
                                              File zipFile,
                                              boolean needsUpdate)
         throws BuildException {
 
         Resource[][] initialResources = grabResources(filesets);
         if (isEmpty(initialResources)) {
             if (Boolean.FALSE.equals(haveNonFileSetResourcesToAdd.get())) {
                 if (needsUpdate && doUpdate) {
                     /*
                      * This is a rather hairy case.
                      *
                      * One of our subclasses knows that we need to
                      * update the archive, but at the same time, there
                      * are no resources known to us that would need to
                      * be added.  Only the subclass seems to know
                      * what's going on.
                      *
                      * This happens if <jar> detects that the manifest
                      * has changed, for example.  The manifest is not
                      * part of any resources because of our support
                      * for inline <manifest>s.
                      *
                      * If we invoke createEmptyZip like Ant 1.5.2 did,
                      * we'll loose all stuff that has been in the
                      * original archive (bugzilla report 17780).
                      */
                     return new ArchiveState(true, initialResources);
                 }
 
                 if (emptyBehavior.equals("skip")) {
                     if (doUpdate) {
                         logWhenWriting(archiveType + " archive " + zipFile
                                        + " not updated because no new files were"
                                        + " included.", Project.MSG_VERBOSE);
                     } else {
                         logWhenWriting("Warning: skipping " + archiveType
                                        + " archive " + zipFile
                                        + " because no files were included.",
                                        Project.MSG_WARN);
                     }
                 } else if (emptyBehavior.equals("fail")) {
                     throw new BuildException("Cannot create " + archiveType
                                              + " archive " + zipFile
                                              + ": no files were included.",
                                              getLocation());
                 } else {
                     // Create.
                     if (!zipFile.exists())  {
                         needsUpdate = true;
                     }
                 }
             }
 
             // either there are non-fileset resources or we
             // (re-)create the archive anyway
             return new ArchiveState(needsUpdate, initialResources);
         }
 
         // initialResources is not empty
 
         if (!zipFile.exists()) {
             return new ArchiveState(true, initialResources);
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         Resource[][] newerResources = new Resource[filesets.length][];
 
         for (int i = 0; i < filesets.length; i++) {
             if (!(fileset instanceof ZipFileSet)
                 || ((ZipFileSet) fileset).getSrc(getProject()) == null) {
                 File base = filesets[i].getDir(getProject());
 
                 for (int j = 0; j < initialResources[i].length; j++) {
                     File resourceAsFile =
                         FILE_UTILS.resolveFile(base,
                                               initialResources[i][j].getName());
                     if (resourceAsFile.equals(zipFile)) {
                         throw new BuildException("A zip file cannot include "
                                                  + "itself", getLocation());
                     }
                 }
             }
         }
 
         for (int i = 0; i < filesets.length; i++) {
             if (initialResources[i].length == 0) {
                 newerResources[i] = new Resource[] {};
                 continue;
             }
 
             FileNameMapper myMapper = new IdentityMapper();
             if (filesets[i] instanceof ZipFileSet) {
                 ZipFileSet zfs = (ZipFileSet) filesets[i];
                 if (zfs.getFullpath(getProject()) != null
                     && !zfs.getFullpath(getProject()).equals("")) {
                     // in this case all files from origin map to
                     // the fullPath attribute of the zipfileset at
                     // destination
                     MergingMapper fm = new MergingMapper();
                     fm.setTo(zfs.getFullpath(getProject()));
                     myMapper = fm;
 
                 } else if (zfs.getPrefix(getProject()) != null
                            && !zfs.getPrefix(getProject()).equals("")) {
                     GlobPatternMapper gm = new GlobPatternMapper();
                     gm.setFrom("*");
                     String prefix = zfs.getPrefix(getProject());
                     if (!prefix.endsWith("/") && !prefix.endsWith("\\")) {
                         prefix += "/";
                     }
                     gm.setTo(prefix + "*");
                     myMapper = gm;
                 }
             }
 
             newerResources[i] = selectOutOfDateResources(initialResources[i],
                                                          myMapper);
             needsUpdate = needsUpdate || (newerResources[i].length > 0);
 
             if (needsUpdate && !doUpdate) {
                 // we will return initialResources anyway, no reason
                 // to scan further.
                 break;
             }
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         return new ArchiveState(needsUpdate, newerResources);
     }
 
     /**
      * Collect the resources that are newer than the corresponding
      * entries (or missing) in the original archive.
      *
      * <p>If we are going to recreate the archive instead of updating
      * it, all resources should be considered as new, if a single one
      * is.  Because of this, subclasses overriding this method must
      * call <code>super.getResourcesToAdd</code> and indicate with the
      * third arg if they already know that the archive is
      * out-of-date.</p>
      *
      * @param rcs The filesets to grab resources from
      * @param zipFile intended archive file (may or may not exist)
      * @param needsUpdate whether we already know that the archive is
      * out-of-date.  Subclasses overriding this method are supposed to
      * set this value correctly in their call to
      * <code>super.getResourcesToAdd</code>.
      * @return an array of resources to add for each fileset passed in as well
      *         as a flag that indicates whether the archive is uptodate.
      *
      * @exception BuildException if it likes
      */
     protected ArchiveState getNonFileSetResourcesToAdd(ResourceCollection[] rcs,
                                                        File zipFile,
                                                        boolean needsUpdate)
         throws BuildException {
         /*
          * Backwards compatibility forces us to repeat the logic of
          * getResourcesToAdd(FileSet[], ...) here once again.
          */
 
         Resource[][] initialResources = grabNonFileSetResources(rcs);
         boolean empty = isEmpty(initialResources);
         haveNonFileSetResourcesToAdd.set(Boolean.valueOf(!empty));
         if (empty) {
             // no emptyBehavior handling since the FileSet version
             // will take care of it.
             return new ArchiveState(needsUpdate, initialResources);
         }
 
         // initialResources is not empty
 
         if (!zipFile.exists()) {
             return new ArchiveState(true, initialResources);
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         Resource[][] newerResources = new Resource[rcs.length][];
 
         for (int i = 0; i < rcs.length; i++) {
             if (initialResources[i].length == 0) {
                 newerResources[i] = new Resource[] {};
                 continue;
             }
 
             for (int j = 0; j < initialResources[i].length; j++) {
                 FileProvider fp =
                     initialResources[i][j].as(FileProvider.class);
                 if (fp != null && zipFile.equals(fp.getFile())) {
                     throw new BuildException("A zip file cannot include "
                                              + "itself", getLocation());
                 }
             }
 
             newerResources[i] = selectOutOfDateResources(initialResources[i],
                                                          new IdentityMapper());
             needsUpdate = needsUpdate || (newerResources[i].length > 0);
 
             if (needsUpdate && !doUpdate) {
                 // we will return initialResources anyway, no reason
                 // to scan further.
                 break;
             }
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         return new ArchiveState(needsUpdate, newerResources);
     }
 
     private Resource[] selectOutOfDateResources(Resource[] initial,
                                                 FileNameMapper mapper) {
         Resource[] rs = selectFileResources(initial);
         Resource[] result =
             ResourceUtils.selectOutOfDateSources(this, rs, mapper,
                                                  getZipScanner());
         if (!doFilesonly) {
             Union u = new Union();
             u.addAll(Arrays.asList(selectDirectoryResources(initial)));
             ResourceCollection rc =
                 ResourceUtils.selectSources(this, u, mapper,
                                             getZipScanner(),
                                             MISSING_DIR_PROVIDER);
             if (rc.size() > 0) {
                 ArrayList newer = new ArrayList();
                 newer.addAll(Arrays.asList(((Union) rc).listResources()));
                 newer.addAll(Arrays.asList(result));
                 result = (Resource[]) newer.toArray(result);
             }
         }
         return result;
     }
 
     /**
      * Fetch all included and not excluded resources from the sets.
      *
      * <p>Included directories will precede included files.</p>
      * @param filesets an array of filesets
      * @return the resources included
      * @since Ant 1.5.2
      */
     protected Resource[][] grabResources(FileSet[] filesets) {
         Resource[][] result = new Resource[filesets.length][];
         for (int i = 0; i < filesets.length; i++) {
             boolean skipEmptyNames = true;
             if (filesets[i] instanceof ZipFileSet) {
                 ZipFileSet zfs = (ZipFileSet) filesets[i];
                 skipEmptyNames = zfs.getPrefix(getProject()).equals("")
                     && zfs.getFullpath(getProject()).equals("");
             }
             DirectoryScanner rs =
                 filesets[i].getDirectoryScanner(getProject());
             if (rs instanceof ZipScanner) {
                 ((ZipScanner) rs).setEncoding(encoding);
             }
             Vector resources = new Vector();
             if (!doFilesonly) {
                 String[] directories = rs.getIncludedDirectories();
                 for (int j = 0; j < directories.length; j++) {
                     if (!"".equals(directories[j]) || !skipEmptyNames) {
                         resources.addElement(rs.getResource(directories[j]));
                     }
                 }
             }
             String[] files = rs.getIncludedFiles();
             for (int j = 0; j < files.length; j++) {
                 if (!"".equals(files[j]) || !skipEmptyNames) {
                     resources.addElement(rs.getResource(files[j]));
                 }
             }
 
             result[i] = new Resource[resources.size()];
             resources.copyInto(result[i]);
         }
         return result;
     }
 
     /**
      * Fetch all included and not excluded resources from the collections.
      *
      * <p>Included directories will precede included files.</p>
      * @param rcs an array of resource collections
      * @return the resources included
      * @since Ant 1.7
      */
     protected Resource[][] grabNonFileSetResources(ResourceCollection[] rcs) {
         Resource[][] result = new Resource[rcs.length][];
         for (int i = 0; i < rcs.length; i++) {
             ArrayList dirs = new ArrayList();
             ArrayList files = new ArrayList();
             for (Resource r : rcs[i]) {
                 if (r.isExists()) {
                     if (r.isDirectory()) {
                         dirs.add(r);
                     } else {
                         files.add(r);
                     }
                 }
             }
             // make sure directories are in alpha-order - this also
             // ensures parents come before their children
             Collections.sort(dirs, new Comparator() {
                     public int compare(Object o1, Object o2) {
                         Resource r1 = (Resource) o1;
                         Resource r2 = (Resource) o2;
                         return r1.getName().compareTo(r2.getName());
                     }
                 });
             ArrayList rs = new ArrayList(dirs);
             rs.addAll(files);
             result[i] = (Resource[]) rs.toArray(new Resource[rs.size()]);
         }
         return result;
     }
 
     /**
      * Add a directory to the zip stream.
      * @param dir  the directort to add to the archive
      * @param zOut the stream to write to
      * @param vPath the name this entry shall have in the archive
      * @param mode the Unix permissions to set.
      * @throws IOException on error
      * @since Ant 1.5.2
      */
     protected void zipDir(File dir, ZipOutputStream zOut, String vPath,
                           int mode)
         throws IOException {
         zipDir(dir, zOut, vPath, mode, null);
     }
 
     /**
      * Add a directory to the zip stream.
      * @param dir  the directory to add to the archive
      * @param zOut the stream to write to
      * @param vPath the name this entry shall have in the archive
      * @param mode the Unix permissions to set.
      * @param extra ZipExtraFields to add
      * @throws IOException on error
      * @since Ant 1.6.3
      */
     protected void zipDir(File dir, ZipOutputStream zOut, String vPath,
                           int mode, ZipExtraField[] extra)
         throws IOException {
         zipDir(dir == null ? (Resource) null : new FileResource(dir),
                zOut, vPath, mode, extra);
     }
 
     /**
      * Add a directory to the zip stream.
      * @param dir  the directory to add to the archive
      * @param zOut the stream to write to
      * @param vPath the name this entry shall have in the archive
      * @param mode the Unix permissions to set.
      * @param extra ZipExtraFields to add
      * @throws IOException on error
      * @since Ant 1.8.0
      */
     protected void zipDir(Resource dir, ZipOutputStream zOut, String vPath,
                           int mode, ZipExtraField[] extra)
         throws IOException {
         if (doFilesonly) {
             logWhenWriting("skipping directory " + vPath
                            + " for file-only archive",
                            Project.MSG_VERBOSE);
             return;
         }
         if (addedDirs.get(vPath) != null) {
             // don't add directories we've already added.
             // no warning if we try, it is harmless in and of itself
             return;
         }
 
         logWhenWriting("adding directory " + vPath, Project.MSG_VERBOSE);
         addedDirs.put(vPath, vPath);
 
         if (!skipWriting) {
             ZipEntry ze = new ZipEntry (vPath);
 
             // ZIPs store time with a granularity of 2 seconds, round up
             int millisToAdd = roundUp ? ROUNDUP_MILLIS : 0;
 
             if (dir != null && dir.isExists()) {
                 ze.setTime(dir.getLastModified() + millisToAdd);
             } else {
                 ze.setTime(System.currentTimeMillis() + millisToAdd);
             }
             ze.setSize (0);
             ze.setMethod (ZipEntry.STORED);
             // This is faintly ridiculous:
             ze.setCrc (EMPTY_CRC);
             ze.setUnixMode(mode);
 
             if (extra != null) {
                 ze.setExtraFields(extra);
             }
 
             zOut.putNextEntry(ze);
         }
     }
 
     /*
      * This is a hacky construct to extend the zipFile method to
      * support a new parameter (extra fields to preserve) without
      * breaking subclasses that override the old method signature.
      */
     private static ThreadLocal currentZipExtra = new ThreadLocal() {
             protected Object initialValue() {
                 return null;
             }
         };
 
     /**
      * Provides the extra fields for the zip entry currently being
      * added to the archive - if any.
      * @since Ant 1.8.0
      */
     protected final ZipExtraField[] getCurrentExtraFields() {
         return (ZipExtraField[]) currentZipExtra.get();
     }
 
     /**
      * Sets the extra fields for the zip entry currently being
      * added to the archive - if any.
      * @since Ant 1.8.0
      */
     protected final void setCurrentExtraFields(ZipExtraField[] extra) {
         currentZipExtra.set(extra);
     }
 
     /**
      * Adds a new entry to the archive, takes care of duplicates as well.
      *
      * @param in the stream to read data for the entry from.  The
      * caller of the method is responsible for closing the stream.
      * @param zOut the stream to write to.
      * @param vPath the name this entry shall have in the archive.
      * @param lastModified last modification time for the entry.
      * @param fromArchive the original archive we are copying this
      * entry from, will be null if we are not copying from an archive.
      * @param mode the Unix permissions to set.
      *
      * @since Ant 1.5.2
      * @throws IOException on error
      */
     protected void zipFile(InputStream in, ZipOutputStream zOut, String vPath,
                            long lastModified, File fromArchive, int mode)
         throws IOException {
         // fromArchive is used in subclasses overriding this method
 
         if (entries.containsKey(vPath)) {
 
             if (duplicate.equals("preserve")) {
                 logWhenWriting(vPath + " already added, skipping",
                                Project.MSG_INFO);
                 return;
             } else if (duplicate.equals("fail")) {
                 throw new BuildException("Duplicate file " + vPath
                                          + " was found and the duplicate "
                                          + "attribute is 'fail'.");
             } else {
                 // duplicate equal to add, so we continue
                 logWhenWriting("duplicate file " + vPath
                                + " found, adding.", Project.MSG_VERBOSE);
             }
         } else {
             logWhenWriting("adding entry " + vPath, Project.MSG_VERBOSE);
         }
 
         entries.put(vPath, vPath);
 
         if (!skipWriting) {
             ZipEntry ze = new ZipEntry(vPath);
             ze.setTime(lastModified);
             ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);
 
             /*
              * ZipOutputStream.putNextEntry expects the ZipEntry to
              * know its size and the CRC sum before you start writing
              * the data when using STORED mode - unless it is seekable.
              *
              * This forces us to process the data twice.
              */
             if (!zOut.isSeekable() && !doCompress) {
                 long size = 0;
                 CRC32 cal = new CRC32();
                 if (!in.markSupported()) {
                     // Store data into a byte[]
                     ByteArrayOutputStream bos = new ByteArrayOutputStream();
 
                     byte[] buffer = new byte[BUFFER_SIZE];
                     int count = 0;
                     do {
                         size += count;
                         cal.update(buffer, 0, count);
                         bos.write(buffer, 0, count);
                         count = in.read(buffer, 0, buffer.length);
                     } while (count != -1);
                     in = new ByteArrayInputStream(bos.toByteArray());
 
                 } else {
                     in.mark(Integer.MAX_VALUE);
                     byte[] buffer = new byte[BUFFER_SIZE];
                     int count = 0;
                     do {
                         size += count;
                         cal.update(buffer, 0, count);
                         count = in.read(buffer, 0, buffer.length);
                     } while (count != -1);
                     in.reset();
                 }
                 ze.setSize(size);
                 ze.setCrc(cal.getValue());
             }
 
             ze.setUnixMode(mode);
             ZipExtraField[] extra = getCurrentExtraFields();
             if (extra != null) {
                 ze.setExtraFields(extra);
             }
 
             zOut.putNextEntry(ze);
 
             byte[] buffer = new byte[BUFFER_SIZE];
             int count = 0;
             do {
                 if (count != 0) {
                     zOut.write(buffer, 0, count);
                 }
                 count = in.read(buffer, 0, buffer.length);
             } while (count != -1);
         }
         addedFiles.addElement(vPath);
     }
 
     /**
      * Adds a new entry to the archive, takes care of duplicates as well.
      *
      * @param in the stream to read data for the entry from.  The
      * caller of the method is responsible for closing the stream.
      * @param zOut the stream to write to.
      * @param vPath the name this entry shall have in the archive.
      * @param lastModified last modification time for the entry.
      * @param fromArchive the original archive we are copying this
      * entry from, will be null if we are not copying from an archive.
      * @param mode the Unix permissions to set.
      * @param extra ZipExtraFields to add
      *
      * @since Ant 1.8.0
      * @throws IOException on error
      */
     protected final void zipFile(InputStream in, ZipOutputStream zOut,
                                  String vPath, long lastModified,
                                  File fromArchive, int mode,
                                  ZipExtraField[] extra)
         throws IOException {
         try {
             setCurrentExtraFields(extra);
             zipFile(in, zOut, vPath, lastModified, fromArchive, mode);
         } finally {
             setCurrentExtraFields(null);
         }
     }
 
     /**
      * Method that gets called when adding from <code>java.io.File</code> instances.
      *
      * <p>This implementation delegates to the six-arg version.</p>
      *
      * @param file the file to add to the archive
      * @param zOut the stream to write to
      * @param vPath the name this entry shall have in the archive
      * @param mode the Unix permissions to set.
      * @throws IOException on error
      *
      * @since Ant 1.5.2
      */
     protected void zipFile(File file, ZipOutputStream zOut, String vPath,
                            int mode)
         throws IOException {
         if (file.equals(zipFile)) {
             throw new BuildException("A zip file cannot include itself",
                                      getLocation());
         }
 
         FileInputStream fIn = new FileInputStream(file);
         try {
             // ZIPs store time with a granularity of 2 seconds, round up
             zipFile(fIn, zOut, vPath,
                     file.lastModified() + (roundUp ? ROUNDUP_MILLIS : 0),
                     null, mode);
         } finally {
             fIn.close();
         }
     }
 
     /**
      * Ensure all parent dirs of a given entry have been added.
      * @param baseDir the base directory to use (may be null)
      * @param entry   the entry name to create directories from
      * @param zOut    the stream to write to
      * @param prefix  a prefix to place on the created entries
      * @param dirMode the directory mode
      * @throws IOException on error
      * @since Ant 1.5.2
      */
     protected final void addParentDirs(File baseDir, String entry,
                                        ZipOutputStream zOut, String prefix,
                                        int dirMode)
         throws IOException {
         if (!doFilesonly) {
             Stack directories = new Stack();
             int slashPos = entry.length();
 
             while ((slashPos = entry.lastIndexOf('/', slashPos - 1)) != -1) {
                 String dir = entry.substring(0, slashPos + 1);
                 if (addedDirs.get(prefix + dir) != null) {
                     break;
                 }
                 directories.push(dir);
             }
 
             while (!directories.isEmpty()) {
                 String dir = (String) directories.pop();
                 File f = null;
                 if (baseDir != null) {
                     f = new File(baseDir, dir);
                 } else {
                     f = new File(dir);
                 }
                 zipDir(f, zOut, prefix + dir, dirMode);
             }
         }
     }
 
     /**
      * Do any clean up necessary to allow this instance to be used again.
      *
      * <p>When we get here, the Zip file has been closed and all we
      * need to do is to reset some globals.</p>
      *
      * <p>This method will only reset globals that have been changed
      * during execute(), it will not alter the attributes or nested
      * child elements.  If you want to reset the instance so that you
      * can later zip a completely different set of files, you must use
      * the reset method.</p>
      *
      * @see #reset
      */
     protected void cleanUp() {
         addedDirs.clear();
         addedFiles.removeAllElements();
         entries.clear();
         addingNewFiles = false;
         doUpdate = savedDoUpdate;
         Enumeration e = filesetsFromGroupfilesets.elements();
         while (e.hasMoreElements()) {
             ZipFileSet zf = (ZipFileSet) e.nextElement();
             resources.removeElement(zf);
         }
         filesetsFromGroupfilesets.removeAllElements();
         haveNonFileSetResourcesToAdd.set(Boolean.FALSE);
     }
 
     /**
      * Makes this instance reset all attributes to their default
      * values and forget all children.
      *
      * @since Ant 1.5
      *
      * @see #cleanUp
      */
     public void reset() {
         resources.removeAllElements();
         zipFile = null;
         baseDir = null;
         groupfilesets.removeAllElements();
         duplicate = "add";
         archiveType = "zip";
         doCompress = true;
         emptyBehavior = "skip";
         doUpdate = false;
         doFilesonly = false;
         encoding = null;
     }
 
     /**
      * Check is the resource arrays are empty.
      * @param r the arrays to check
      * @return true if all individual arrays are empty
      *
      * @since Ant 1.5.2
      */
     protected static final boolean isEmpty(Resource[][] r) {
         for (int i = 0; i < r.length; i++) {
             if (r[i].length > 0) {
                 return false;
             }
         }
         return true;
     }
 
     /**
      * Drops all non-file resources from the given array.
      * @param orig the resources to filter
      * @return the filters resources
      * @since Ant 1.6
      */
     protected Resource[] selectFileResources(Resource[] orig) {
         return selectResources(orig,
                                new ResourceSelector() {
                                    public boolean isSelected(Resource r) {
                                        if (!r.isDirectory()) {
                                            return true;
                                        } else if (doFilesonly) {
                                            logWhenWriting("Ignoring directory "
                                                           + r.getName()
                                                           + " as only files will"
                                                           + " be added.",
                                                           Project.MSG_VERBOSE);
                                        }
                                        return false;
                                    }
                                });
     }
 
     /**
      * Drops all non-directory resources from the given array.
      * @param orig the resources to filter
      * @return the filters resources
      * @since Ant 1.8.0
      */
     protected Resource[] selectDirectoryResources(Resource[] orig) {
         return selectResources(orig,
                                new ResourceSelector() {
                                    public boolean isSelected(Resource r) {
                                        return r.isDirectory();
                                    }
                                });
     }
 
     /**
      * Drops all resources from the given array that are not selected
      * @param orig the resources to filter
      * @return the filters resources
      * @since Ant 1.8.0
      */
     protected Resource[] selectResources(Resource[] orig,
                                          ResourceSelector selector) {
         if (orig.length == 0) {
             return orig;
         }
 
         ArrayList v = new ArrayList(orig.length);
         for (int i = 0; i < orig.length; i++) {
             if (selector.isSelected(orig[i])) {
                 v.add(orig[i]);
             }
         }
 
         if (v.size() != orig.length) {
             Resource[] r = new Resource[v.size()];
             return (Resource[]) v.toArray(r);
         }
         return orig;
     }
 
     /**
      * Logs a message at the given output level, but only if this is
      * the pass that will actually create the archive.
      *
      * @since Ant 1.8.0
      */
     protected void logWhenWriting(String msg, int level) {
         if (!skipWriting) {
             log(msg, level);
         }
     }
 
     /**
      * Possible behaviors when a duplicate file is added:
      * "add", "preserve" or "fail"
      */
     public static class Duplicate extends EnumeratedAttribute {
         /**
          * @see EnumeratedAttribute#getValues()
          */
         /** {@inheritDoc} */
         public String[] getValues() {
             return new String[] {"add", "preserve", "fail"};
         }
     }
 
     /**
      * Holds the up-to-date status and the out-of-date resources of
      * the original archive.
      *
      * @since Ant 1.5.3
      */
     public static class ArchiveState {
         private boolean outOfDate;
         private Resource[][] resourcesToAdd;
 
         ArchiveState(boolean state, Resource[][] r) {
             outOfDate = state;
             resourcesToAdd = r;
         }
 
         /**
          * Return the outofdate status.
          * @return the outofdate status
          */
         public boolean isOutOfDate() {
             return outOfDate;
         }
 
         /**
          * Get the resources to add.
          * @return the resources to add
          */
         public Resource[][] getResourcesToAdd() {
             return resourcesToAdd;
         }
         /**
          * find out if there are absolutely no resources to add
          * @since Ant 1.6.3
          * @return true if there are no resources to add
          */
         public boolean isWithoutAnyResources() {
             if (resourcesToAdd == null)  {
                 return true;
             }
             for (int counter = 0; counter < resourcesToAdd.length; counter++) {
                 if (resourcesToAdd[counter] != null) {
                     if (resourcesToAdd[counter].length > 0) {
                         return false;
                     }
                 }
             }
             return true;
         }
     }
 
     /**
      * Policiy for creation of Unicode extra fields: never, always or
      * not-encodeable.
      *
      * @since Ant 1.8.0
      */
     public static final class UnicodeExtraField extends EnumeratedAttribute {
         private static final Map POLICIES = new HashMap();
         private static final String NEVER_KEY = "never";
         private static final String ALWAYS_KEY = "always";
         private static final String N_E_KEY = "not-encodeable";
         static {
             POLICIES.put(NEVER_KEY,
                          ZipOutputStream.UnicodeExtraFieldPolicy.NEVER);
             POLICIES.put(ALWAYS_KEY,
                          ZipOutputStream.UnicodeExtraFieldPolicy.ALWAYS);
             POLICIES.put(N_E_KEY,
                          ZipOutputStream.UnicodeExtraFieldPolicy
                          .NOT_ENCODEABLE);
         }
 
         public String[] getValues() {
             return new String[] {NEVER_KEY, ALWAYS_KEY, N_E_KEY};
         }
 
         public static final UnicodeExtraField NEVER =
             new UnicodeExtraField(NEVER_KEY);
 
         private UnicodeExtraField(String name) {
             setValue(name);
         }
 
         public UnicodeExtraField() {
         }
 
         public ZipOutputStream.UnicodeExtraFieldPolicy getPolicy() {
             return (ZipOutputStream.UnicodeExtraFieldPolicy)
                 POLICIES.get(getValue());
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/condition/AntVersion.java b/src/main/org/apache/tools/ant/taskdefs/condition/AntVersion.java
index b220d94a3..aadf5a7e5 100644
--- a/src/main/org/apache/tools/ant/taskdefs/condition/AntVersion.java
+++ b/src/main/org/apache/tools/ant/taskdefs/condition/AntVersion.java
@@ -1,171 +1,171 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.condition;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.util.DeweyDecimal;
 
 /**
  * An Ant version condition.
  * @since Ant 1.7
  */
 public class AntVersion extends Task implements Condition {
 
     private String atLeast = null;
     private String exactly = null;
     private String propertyname = null;
 
     /**
      * Run as a task.
      * @throws BuildException if an error occurs.
      */
     public void execute() throws BuildException {
         if (propertyname == null) {
             throw new BuildException("'property' must be set.");
         }
         if (atLeast != null || exactly != null) {
             // If condition values are set, evaluate the condition
             if (eval()) {
                 getProject().setNewProperty(propertyname, getVersion().toString());
             }
         } else {
             // Raw task
             getProject().setNewProperty(propertyname, getVersion().toString());
         }
     }
 
     /**
-     * Evalute the condition.
+     * Evaluate the condition.
      * @return true if the condition is true.
      * @throws BuildException if an error occurs.
      */
     public boolean eval() throws BuildException {
         validate();
         DeweyDecimal actual = getVersion();
         if (null != atLeast) {
             return actual.isGreaterThanOrEqual(new DeweyDecimal(atLeast));
         }
         if (null != exactly) {
             return actual.isEqual(new DeweyDecimal(exactly));
         }
         //default
         return false;
     }
 
     private void validate() throws BuildException {
         if (atLeast != null && exactly != null) {
             throw new BuildException("Only one of atleast or exactly may be set.");
         }
         if (null == atLeast && null == exactly) {
             throw new BuildException("One of atleast or exactly must be set.");
         }
         if (atLeast != null) {
             try {
                 new DeweyDecimal(atLeast);
             } catch (NumberFormatException e) {
                 throw new BuildException(
                     "The 'atleast' attribute is not a Dewey Decimal eg 1.1.0 : "
                     + atLeast);
             }
         } else {
             try {
                 new DeweyDecimal(exactly);
             } catch (NumberFormatException e) {
                 throw new BuildException(
                     "The 'exactly' attribute is not a Dewey Decimal eg 1.1.0 : "
                     + exactly);
             }
         }
     }
 
     private DeweyDecimal getVersion() {
         Project p = new Project();
         p.init();
         char[] versionString = p.getProperty("ant.version").toCharArray();
         StringBuffer sb = new StringBuffer();
         boolean foundFirstDigit = false;
         for (int i = 0; i < versionString.length; i++) {
             if (Character.isDigit(versionString[i])) {
                 sb.append(versionString[i]);
                 foundFirstDigit = true;
             }
             if (versionString[i] == '.' && foundFirstDigit) {
                 sb.append(versionString[i]);
             }
             if (Character.isLetter(versionString[i]) && foundFirstDigit) {
                 break;
             }
         }
         return new DeweyDecimal(sb.toString());
     }
 
     /**
      * Get the atleast attribute.
      * @return the atleast attribute.
      */
     public String getAtLeast() {
         return atLeast;
     }
 
     /**
      * Set the atleast attribute.
      * This is of the form major.minor.point.
      * For example 1.7.0.
      * @param atLeast the version to check against.
      */
     public void setAtLeast(String atLeast) {
         this.atLeast = atLeast;
     }
 
     /**
      * Get the exactly attribute.
      * @return the exactly attribute.
      */
     public String getExactly() {
         return exactly;
     }
 
     /**
      * Set the exactly attribute.
      * This is of the form major.minor.point.
      * For example 1.7.0.
      * @param exactly the version to check against.
      */
     public void setExactly(String exactly) {
         this.exactly = exactly;
     }
 
     /**
      * Get the name of the property to hold the ant version.
      * @return the name of the property.
      */
     public String getProperty() {
         return propertyname;
     }
 
     /**
      * Set the name of the property to hold the ant version.
      * @param propertyname the name of the property.
      */
     public void setProperty(String propertyname) {
         this.propertyname = propertyname;
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/condition/Matches.java b/src/main/org/apache/tools/ant/taskdefs/condition/Matches.java
index 7b4725130..ac37f8fed 100644
--- a/src/main/org/apache/tools/ant/taskdefs/condition/Matches.java
+++ b/src/main/org/apache/tools/ant/taskdefs/condition/Matches.java
@@ -1,119 +1,119 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.condition;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.ProjectComponent;
 import org.apache.tools.ant.types.RegularExpression;
 import org.apache.tools.ant.util.regexp.Regexp;
 import org.apache.tools.ant.util.regexp.RegexpUtil;
 
 /**
  * Simple regular expression condition.
  *
  * @since Ant 1.7
  */
 public class Matches extends ProjectComponent implements Condition {
 
     private String  string;
     private boolean caseSensitive = true;
     private boolean multiLine = false;
     private boolean singleLine = false;
     private RegularExpression regularExpression;
 
     /**
      * Set the string
      *
      * @param string the string to match
      */
     public void setString(String string) {
         this.string = string;
     }
 
     /**
      * Set the regular expression to match against
      *
      * @param pattern the regular expression pattern
      */
     public void setPattern(String pattern) {
         if (regularExpression != null) {
             throw new BuildException(
                 "Only one regular expression is allowed.");
         }
         regularExpression = new RegularExpression();
         regularExpression.setPattern(pattern);
     }
 
     /**
      * A regular expression.
      * You can use this element to refer to a previously
      * defined regular expression datatype instance
      * @param regularExpression the regular expression object
      *                          to be configured as an element
      */
     public void addRegexp(RegularExpression regularExpression) {
         if (this.regularExpression != null) {
             throw new BuildException(
                 "Only one regular expression is allowed.");
         }
         this.regularExpression = regularExpression;
     }
 
     /**
      * Whether to ignore case or not.
      * @param b if false, ignore case.
      * @since Ant 1.7
      */
     public void setCasesensitive(boolean b) {
         caseSensitive = b;
     }
 
     /**
      * Whether to match should be multiline.
      * @param b the value to set.
      */
     public void setMultiline(boolean b) {
         multiLine = b;
     }
 
     /**
      * Whether to treat input as singleline ('.' matches newline).
-     * Corresponsds to java.util.regex.Pattern.DOTALL.
+     * Corresponds to java.util.regex.Pattern.DOTALL.
      * @param b the value to set.
      */
     public void setSingleLine(boolean b) {
         singleLine = b;
     }
 
     /**
      * @return true if the string matches the regular expression pattern
      * @exception BuildException if the attributes are not set correctly
      */
     public boolean eval() throws BuildException {
         if (string == null) {
             throw new BuildException(
                 "Parameter string is required in matches.");
         }
         if (regularExpression == null) {
             throw new BuildException("Missing pattern in matches.");
         }
         int options = RegexpUtil.asOptions(caseSensitive, multiLine, singleLine);
         Regexp regexp = regularExpression.getRegexp(getProject());
         return regexp.matches(string, options);
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/Javah.java b/src/main/org/apache/tools/ant/taskdefs/optional/Javah.java
index 1908682c6..06e1d110d 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/Javah.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/Javah.java
@@ -1,513 +1,513 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.StringTokenizer;
 import java.util.Vector;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.optional.javah.JavahAdapter;
 import org.apache.tools.ant.taskdefs.optional.javah.JavahAdapterFactory;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.util.StringUtils;
 import org.apache.tools.ant.util.facade.FacadeTaskHelper;
 import org.apache.tools.ant.util.facade.ImplementationSpecificArgument;
 
 /**
  * Generates JNI header files using javah.
  *
  * This task can take the following arguments:
  * <ul>
  * <li>classname - the fully-qualified name of a class</li>
  * <li>outputFile - Concatenates the resulting header or source files for all
  *     the classes listed into this file</li>
  * <li>destdir - Sets the directory where javah saves the header files or the
  *     stub files</li>
  * <li>classpath</li>
  * <li>bootclasspath</li>
  * <li>force - Specifies that output files should always be written
        (JDK1.2 only)</li>
  * <li>old - Specifies that old JDK1.0-style header files should be generated
  *     (otherwise output file contain JNI-style native method
  *      function prototypes) (JDK1.2 only)</li>
  * <li>stubs - generate C declarations from the Java object file (used with old)</li>
  * <li>verbose - causes javah to print a message to stdout concerning the status
  *     of the generated files</li>
  * <li>extdirs - Override location of installed extensions</li>
  * </ul>
  * Of these arguments, either <b>outputFile</b> or <b>destdir</b> is required,
  * but not both. More than one classname may be specified, using a comma-separated
  * list or by using <code>&lt;class name="xxx"&gt;</code> elements within the task.
  * <p>
  * When this task executes, it will generate C header and source files that
  * are needed to implement native methods.
  *
  */
 
 public class Javah extends Task {
 
     private Vector classes = new Vector(2);
     private String cls;
     private File destDir;
     private Path classpath = null;
     private File outputFile = null;
     private boolean verbose = false;
     private boolean force   = false;
     private boolean old     = false;
     private boolean stubs   = false;
     private Path bootclasspath;
     //private Path extdirs;
     private FacadeTaskHelper facade = null;
     private Vector files = new Vector();
     private JavahAdapter nestedAdapter = null;
 
     /**
      * No arg constructor.
      */
     public Javah() {
         facade = new FacadeTaskHelper(JavahAdapterFactory.getDefault());
     }
 
     /**
      * the fully-qualified name of the class (or classes, separated by commas).
      * @param cls the classname (or classnames).
      */
     public void setClass(String cls) {
         this.cls = cls;
     }
 
     /**
      * Adds class to process.
      * @return a <code>ClassArgument</code> to be configured.
      */
     public ClassArgument createClass() {
         ClassArgument ga = new ClassArgument();
         classes.addElement(ga);
         return ga;
     }
 
     /**
      * A class corresponding the the nested "class" element.
      * It contains a "name" attribute.
      */
     public class ClassArgument {
         private String name;
 
         /** Constructor for ClassArgument. */
         public ClassArgument() {
         }
 
         /**
          * Set the name attribute.
          * @param name the name attribute.
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * Get the name attribute.
          * @return the name attribute.
          */
         public String getName() {
             return name;
         }
     }
 
     /**
      * Add a fileset.
      * @param fs the fileset to add.
      */
     public void addFileSet(FileSet fs) {
         files.add(fs);
     }
 
     /**
      * Names of the classes to process.
      * @return the array of classes.
      * @since Ant 1.6.3
      */
     public String[] getClasses() {
         ArrayList al = new ArrayList();
         if (cls != null) {
             StringTokenizer tok = new StringTokenizer(cls, ",", false);
             while (tok.hasMoreTokens()) {
                 al.add(tok.nextToken().trim());
             }
         }
 
         if (files.size() > 0) {
             for (Enumeration e = files.elements(); e.hasMoreElements();) {
                 FileSet fs = (FileSet) e.nextElement();
                 String[] includedClasses = fs.getDirectoryScanner(
                     getProject()).getIncludedFiles();
                 for (int i = 0; i < includedClasses.length; i++) {
                     String className =
                         includedClasses[i].replace('\\', '.').replace('/', '.')
                         .substring(0, includedClasses[i].length() - 6);
                     al.add(className);
                 }
             }
         }
         Enumeration e = classes.elements();
         while (e.hasMoreElements()) {
             ClassArgument arg = (ClassArgument) e.nextElement();
             al.add(arg.getName());
         }
         return (String[]) al.toArray(new String[al.size()]);
     }
 
     /**
      * Set the destination directory into which the Java source
      * files should be compiled.
      * @param destDir the destination directory.
      */
     public void setDestdir(File destDir) {
         this.destDir = destDir;
     }
 
     /**
      * The destination directory, if any.
      * @return the destination directory.
      * @since Ant 1.6.3
      */
     public File getDestdir() {
         return destDir;
     }
 
     /**
      * the classpath to use.
      * @param src the classpath.
      */
     public void setClasspath(Path src) {
         if (classpath == null) {
             classpath = src;
         } else {
             classpath.append(src);
         }
     }
 
     /**
      * Path to use for classpath.
      * @return a path to be configured.
      */
     public Path createClasspath() {
         if (classpath == null) {
             classpath = new Path(getProject());
         }
         return classpath.createPath();
     }
 
     /**
      * Adds a reference to a classpath defined elsewhere.
      * @param r a reference to a classpath.
      * @todo this needs to be documented in the HTML docs.
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * The classpath to use.
      * @return the classpath.
      * @since Ant 1.6.3
      */
     public Path getClasspath() {
         return classpath;
     }
 
     /**
      * location of bootstrap class files.
      * @param src the bootstrap classpath.
      */
     public void setBootclasspath(Path src) {
         if (bootclasspath == null) {
             bootclasspath = src;
         } else {
             bootclasspath.append(src);
         }
     }
 
     /**
      * Adds path to bootstrap class files.
      * @return a path to be configured.
      */
     public Path createBootclasspath() {
         if (bootclasspath == null) {
             bootclasspath = new Path(getProject());
         }
         return bootclasspath.createPath();
     }
 
     /**
      * To the bootstrap path, this adds a reference to a classpath defined elsewhere.
      * @param r a reference to a classpath
      * @todo this needs to be documented in the HTML.
      */
     public void setBootClasspathRef(Reference r) {
         createBootclasspath().setRefid(r);
     }
 
     /**
      * The bootclasspath to use.
      * @return the bootclass path.
      * @since Ant 1.6.3
      */
     public Path getBootclasspath() {
         return bootclasspath;
     }
 
     /**
      * Concatenates the resulting header or source files for all
      * the classes listed into this file.
      * @param outputFile the output file.
      */
     public void setOutputFile(File outputFile) {
         this.outputFile = outputFile;
     }
 
     /**
      * The destination file, if any.
      * @return the destination file.
      * @since Ant 1.6.3
      */
     public File getOutputfile() {
         return outputFile;
     }
 
     /**
      * If true, output files should always be written (JDK1.2 only).
      * @param force the value to use.
      */
     public void setForce(boolean force) {
         this.force = force;
     }
 
     /**
      * Whether output files should always be written.
      * @return the force attribute.
      * @since Ant 1.6.3
      */
     public boolean getForce() {
         return force;
     }
 
     /**
      * If true, specifies that old JDK1.0-style header files should be
      * generated.
      * (otherwise output file contain JNI-style native method function
      *  prototypes) (JDK1.2 only).
      * @param old if true use old 1.0 style header files.
      */
     public void setOld(boolean old) {
         this.old = old;
     }
 
     /**
      * Whether old JDK1.0-style header files should be generated.
      * @return the old attribute.
      * @since Ant 1.6.3
      */
     public boolean getOld() {
         return old;
     }
 
     /**
      * If true, generate C declarations from the Java object file (used with old).
      * @param stubs if true, generated C declarations.
      */
     public void setStubs(boolean stubs) {
         this.stubs = stubs;
     }
 
     /**
      * Whether C declarations from the Java object file should be generated.
      * @return the stubs attribute.
      * @since Ant 1.6.3
      */
     public boolean getStubs() {
         return stubs;
     }
 
     /**
      * If true, causes Javah to print a message concerning
      * the status of the generated files.
      * @param verbose if true, do verbose printing.
      */
     public void setVerbose(boolean verbose) {
         this.verbose = verbose;
     }
 
     /**
      * Whether verbose output should get generated.
      * @return the verbose attribute.
      * @since Ant 1.6.3
      */
     public boolean getVerbose() {
         return verbose;
     }
 
     /**
      * Choose the implementation for this particular task.
-     * @param impl the name of the implemenation.
+     * @param impl the name of the implementation.
      * @since Ant 1.6.3
      */
     public void setImplementation(String impl) {
         if ("default".equals(impl)) {
             facade.setImplementation(JavahAdapterFactory.getDefault());
         } else {
             facade.setImplementation(impl);
         }
     }
 
     /**
      * Adds an implementation specific command-line argument.
      * @return a ImplementationSpecificArgument to be configured.
      *
      * @since Ant 1.6.3
      */
     public ImplementationSpecificArgument createArg() {
         ImplementationSpecificArgument arg =
             new ImplementationSpecificArgument();
         facade.addImplementationArgument(arg);
         return arg;
     }
 
     /**
      * Returns the (implementation specific) settings given as nested
      * arg elements.
      * @return the arguments.
      * @since Ant 1.6.3
      */
     public String[] getCurrentArgs() {
         return facade.getArgs();
     }
 
     /**
      * The classpath to use when loading the javah implementation
      * if it is not a built-in one.
      *
      * @since Ant 1.8.0
      */
     public Path createImplementationClasspath() {
         return facade.getImplementationClasspath(getProject());
     }
 
     /**
      * Set the adapter explicitly.
      * @since Ant 1.8.0
      */
     public void add(JavahAdapter adapter) {
         if (nestedAdapter != null) {
             throw new BuildException("Can't have more than one javah"
                                      + " adapter");
         }
         nestedAdapter = adapter;
     }
 
     /**
      * Execute the task
      *
      * @throws BuildException is there is a problem in the task execution.
      */
     public void execute() throws BuildException {
         // first off, make sure that we've got a srcdir
 
         if ((cls == null) && (classes.size() == 0) && (files.size() == 0)) {
             throw new BuildException("class attribute must be set!",
                 getLocation());
         }
 
         if ((cls != null) && (classes.size() > 0) && (files.size() > 0)) {
             throw new BuildException("set class attribute OR class element OR fileset, "
                 + "not 2 or more of them.", getLocation());
         }
 
         if (destDir != null) {
             if (!destDir.isDirectory()) {
                 throw new BuildException("destination directory \"" + destDir
                     + "\" does not exist or is not a directory", getLocation());
             }
             if (outputFile != null) {
                 throw new BuildException("destdir and outputFile are mutually "
                     + "exclusive", getLocation());
             }
         }
 
         if (classpath == null) {
             classpath = (new Path(getProject())).concatSystemClasspath("last");
         } else {
             classpath = classpath.concatSystemClasspath("ignore");
         }
 
         JavahAdapter ad =
             nestedAdapter != null ? nestedAdapter :
             JavahAdapterFactory.getAdapter(facade.getImplementation(),
                                            this,
                                            createImplementationClasspath());
         if (!ad.compile(this)) {
             throw new BuildException("compilation failed");
         }
     }
 
     /**
      * Logs the compilation parameters, adds the files to compile and logs the
      * &quot;niceSourceList&quot;
      * @param cmd the command line.
      */
     public void logAndAddFiles(Commandline cmd) {
         logAndAddFilesToCompile(cmd);
     }
 
     /**
      * Logs the compilation parameters, adds the files to compile and logs the
      * &quot;niceSourceList&quot;
      * @param cmd the command line to add parameters to.
      */
     protected void logAndAddFilesToCompile(Commandline cmd) {
         log("Compilation " + cmd.describeArguments(),
             Project.MSG_VERBOSE);
 
         StringBuffer niceClassList = new StringBuffer();
         String[] c = getClasses();
         for (int i = 0; i < c.length; i++) {
             cmd.createArgument().setValue(c[i]);
             niceClassList.append("    ");
             niceClassList.append(c[i]);
             niceClassList.append(StringUtils.LINE_SEP);
         }
 
         StringBuffer prefix = new StringBuffer("Class");
         if (c.length > 1) {
             prefix.append("es");
         }
         prefix.append(" to be compiled:");
         prefix.append(StringUtils.LINE_SEP);
 
         log(prefix.toString() + niceClassList.toString(), Project.MSG_VERBOSE);
     }
 }
\ No newline at end of file
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/Native2Ascii.java b/src/main/org/apache/tools/ant/taskdefs/optional/Native2Ascii.java
index a40e6a331..291d444d7 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/Native2Ascii.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/Native2Ascii.java
@@ -1,326 +1,326 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.File;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.taskdefs.optional.native2ascii.Native2AsciiAdapter;
 import org.apache.tools.ant.taskdefs.optional.native2ascii.Native2AsciiAdapterFactory;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.IdentityMapper;
 import org.apache.tools.ant.util.SourceFileScanner;
 import org.apache.tools.ant.util.facade.FacadeTaskHelper;
 import org.apache.tools.ant.util.facade.ImplementationSpecificArgument;
 
 /**
  * Converts files from native encodings to ASCII.
  *
  * @since Ant 1.2
  */
 public class Native2Ascii extends MatchingTask {
 
     private boolean reverse = false;  // convert from ascii back to native
     private String encoding = null;   // encoding to convert to/from
     private File srcDir = null;       // Where to find input files
     private File destDir = null;      // Where to put output files
     private String extension = null;  // Extension of output files if different
 
     private Mapper mapper;
     private FacadeTaskHelper facade = null;
     private Native2AsciiAdapter nestedAdapter = null;
 
     /** No args constructor */
     public Native2Ascii() {
         facade = new FacadeTaskHelper(Native2AsciiAdapterFactory.getDefault());
     }
 
     /**
      * Flag the conversion to run in the reverse sense,
      * that is Ascii to Native encoding.
      *
      * @param reverse True if the conversion is to be reversed,
      *                otherwise false;
      */
     public void setReverse(boolean reverse) {
         this.reverse = reverse;
     }
 
     /**
      * The value of the reverse attribute.
      * @return the reverse attribute.
      * @since Ant 1.6.3
      */
     public boolean getReverse() {
         return reverse;
     }
 
     /**
      * Set the encoding to translate to/from.
      * If unset, the default encoding for the JVM is used.
      *
      * @param encoding String containing the name of the Native
      *                 encoding to convert from or to.
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * The value of the encoding attribute.
      * @return the encoding attribute.
      * @since Ant 1.6.3
      */
     public String getEncoding() {
         return encoding;
     }
 
     /**
      * Set the source directory in which to find files to convert.
      *
      * @param srcDir directory to find input file in.
      */
     public void setSrc(File srcDir) {
         this.srcDir = srcDir;
     }
 
 
     /**
      * Set the destination directory to place converted files into.
      *
      * @param destDir directory to place output file into.
      */
     public void setDest(File destDir) {
         this.destDir = destDir;
     }
 
     /**
      * Set the extension which converted files should have.
      * If unset, files will not be renamed.
      *
      * @param ext File extension to use for converted files.
      */
     public void setExt(String ext) {
         this.extension = ext;
     }
 
     /**
      * Choose the implementation for this particular task.
-     * @param impl the name of the implemenation
+     * @param impl the name of the implementation
      * @since Ant 1.6.3
      */
     public void setImplementation(String impl) {
         if ("default".equals(impl)) {
             facade.setImplementation(Native2AsciiAdapterFactory.getDefault());
         } else {
             facade.setImplementation(impl);
         }
     }
 
     /**
      * Defines the FileNameMapper to use (nested mapper element).
      *
      * @return the mapper to use for file name translations.
      *
      * @throws BuildException if more than one mapper is defined.
      */
     public Mapper createMapper() throws BuildException {
         if (mapper != null) {
             throw new BuildException("Cannot define more than one mapper",
                                      getLocation());
         }
         mapper = new Mapper(getProject());
         return mapper;
     }
 
     /**
      * A nested filenamemapper
      * @param fileNameMapper the mapper to add
      * @since Ant 1.6.3
      */
     public void add(FileNameMapper fileNameMapper) {
         createMapper().add(fileNameMapper);
     }
 
     /**
      * Adds an implementation specific command-line argument.
      * @return a ImplementationSpecificArgument to be configured
      *
      * @since Ant 1.6.3
      */
     public ImplementationSpecificArgument createArg() {
         ImplementationSpecificArgument arg =
             new ImplementationSpecificArgument();
         facade.addImplementationArgument(arg);
         return arg;
     }
 
     /**
      * The classpath to use when loading the native2ascii
      * implementation if it is not a built-in one.
      *
      * @since Ant 1.8.0
      */
     public Path createImplementationClasspath() {
         return facade.getImplementationClasspath(getProject());
     }
 
     /**
      * Set the adapter explicitly.
      * @since Ant 1.8.0
      */
     public void add(Native2AsciiAdapter adapter) {
         if (nestedAdapter != null) {
             throw new BuildException("Can't have more than one native2ascii"
                                      + " adapter");
         }
         nestedAdapter = adapter;
     }
 
     /**
      * Execute the task
      *
      * @throws BuildException is there is a problem in the task execution.
      */
     public void execute() throws BuildException {
 
         DirectoryScanner scanner = null; // Scanner to find our inputs
         String[] files;                  // list of files to process
 
         // default srcDir to basedir
         if (srcDir == null) {
             srcDir = getProject().resolveFile(".");
         }
 
         // Require destDir
         if (destDir == null) {
             throw new BuildException("The dest attribute must be set.");
         }
 
         // if src and dest dirs are the same, require the extension
         // to be set, so we don't stomp every file.  One could still
         // include a file with the same extension, but ....
         if (srcDir.equals(destDir) && extension == null && mapper == null) {
             throw new BuildException("The ext attribute or a mapper must be set if"
                                      + " src and dest dirs are the same.");
         }
 
         FileNameMapper m = null;
         if (mapper == null) {
             if (extension == null) {
                 m = new IdentityMapper();
             } else {
                 m = new ExtMapper();
             }
         } else {
             m = mapper.getImplementation();
         }
 
         scanner = getDirectoryScanner(srcDir);
         files = scanner.getIncludedFiles();
         SourceFileScanner sfs = new SourceFileScanner(this);
         files = sfs.restrict(files, srcDir, destDir, m);
         int count = files.length;
         if (count == 0) {
             return;
         }
         String message = "Converting " + count + " file"
             + (count != 1 ? "s" : "") + " from ";
         log(message + srcDir + " to " + destDir);
         for (int i = 0; i < files.length; i++) {
             convert(files[i], m.mapFileName(files[i])[0]);
         }
     }
 
     /**
      * Convert a single file.
      *
      * @param srcName name of the input file.
      * @param destName name of the input file.
      */
     private void convert(String srcName, String destName)
         throws BuildException {
         File srcFile;                         // File to convert
         File destFile;                        // where to put the results
 
         // Build the full file names
         srcFile = new File(srcDir, srcName);
         destFile = new File(destDir, destName);
 
         // Make sure we're not about to clobber something
         if (srcFile.equals(destFile)) {
             throw new BuildException("file " + srcFile
                                      + " would overwrite its self");
         }
 
         // Make intermediate directories if needed
         // XXX JDK 1.1 doesn't have File.getParentFile,
         String parentName = destFile.getParent();
         if (parentName != null) {
             File parentFile = new File(parentName);
 
             if ((!parentFile.exists()) && (!parentFile.mkdirs())) {
                 throw new BuildException("cannot create parent directory "
                                          + parentName);
             }
         }
 
         log("converting " + srcName, Project.MSG_VERBOSE);
         Native2AsciiAdapter ad =
             nestedAdapter != null ? nestedAdapter :
             Native2AsciiAdapterFactory.getAdapter(facade.getImplementation(),
                                                   this,
                                                   createImplementationClasspath());
         if (!ad.convert(this, srcFile, destFile)) {
             throw new BuildException("conversion failed");
         }
     }
 
     /**
      * Returns the (implementation specific) settings given as nested
      * arg elements.
      * @return the arguments.
      * @since Ant 1.6.3
      */
     public String[] getCurrentArgs() {
         return facade.getArgs();
     }
 
     private class ExtMapper implements FileNameMapper {
 
         public void setFrom(String s) {
         }
         public void setTo(String s) {
         }
 
         public String[] mapFileName(String fileName) {
             int lastDot = fileName.lastIndexOf('.');
             if (lastDot >= 0) {
                 return new String[] {fileName.substring(0, lastDot)
                                          + extension};
             } else {
                 return new String[] {fileName + extension};
             }
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/NetRexxC.java b/src/main/org/apache/tools/ant/taskdefs/optional/NetRexxC.java
index 5bd74870c..83ae93001 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/NetRexxC.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/NetRexxC.java
@@ -1,1041 +1,1041 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Properties;
 import java.util.StringTokenizer;
 import java.util.Vector;
 import netrexx.lang.Rexx;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.util.FileUtils;
 
 // CheckStyle:InnerAssignmentCheck OFF - used too much in the file to be removed
 /**
  * Compiles NetRexx source files.
  * This task can take the following
  * arguments:
  * <ul>
  * <li>binary</li>
  * <li>classpath</li>
  * <li>comments</li>
  * <li>compile</li>
  * <li>console</li>
  * <li>crossref</li>
  * <li>decimal</li>
  * <li>destdir</li>
  * <li>diag</li>
  * <li>explicit</li>
  * <li>format</li>
  * <li>keep</li>
  * <li>logo</li>
  * <li>replace</li>
  * <li>savelog</li>
  * <li>srcdir</li>
  * <li>sourcedir</li>
  * <li>strictargs</li>
  * <li>strictassign</li>
  * <li>strictcase</li>
  * <li>strictimport</li>
  * <li>symbols</li>
  * <li>time</li>
  * <li>trace</li>
  * <li>utf8</li>
  * <li>verbose</li>
  * <li>suppressMethodArgumentNotUsed</li>
  * <li>suppressPrivatePropertyNotUsed</li>
  * <li>suppressVariableNotUsed</li>
  * <li>suppressExceptionNotSignalled</li>
  * <li>suppressDeprecation</li>
  * <li>removeKeepExtension</li>
  * </ul>
  * Of these arguments, the <b>srcdir</b> argument is required.
  *
  * <p>When this task executes, it will recursively scan the srcdir
  * looking for NetRexx source files to compile. This task makes its
  * compile decision based on timestamp.
  * <p>Before files are compiled they and any other file in the
  * srcdir will be copied to the destdir allowing support files to be
  * located properly in the classpath. The reason for copying the source files
  * before the compile is that NetRexxC has only two destinations for classfiles:
  * <ol>
  * <li>The current directory, and,</li>
  * <li>The directory the source is in (see sourcedir option)
  * </ol>
  *
  */
 public class NetRexxC extends MatchingTask {
 
     // variables to hold arguments
     private boolean binary;
     private String classpath;
     private boolean comments;
     private boolean compact = true; // should be the default, as it integrates better in ant.
     private boolean compile = true;
     private boolean console;
     private boolean crossref;
     private boolean decimal = true;
     private File destDir;
     private boolean diag;
     private boolean explicit;
     private boolean format;
     private boolean keep;
     private boolean logo = true;
     private boolean replace;
     private boolean savelog;
     private File srcDir;
     private boolean sourcedir = true; // ?? Should this be the default for ant?
     private boolean strictargs;
     private boolean strictassign;
     private boolean strictcase;
     private boolean strictimport;
     private boolean strictprops;
     private boolean strictsignal;
     private boolean symbols;
     private boolean time;
     private String trace = "trace2";
     private boolean utf8;
     private String verbose = "verbose3";
     private boolean suppressMethodArgumentNotUsed = false;
     private boolean suppressPrivatePropertyNotUsed = false;
     private boolean suppressVariableNotUsed = false;
     private boolean suppressExceptionNotSignalled = false;
     private boolean suppressDeprecation = false;
     private boolean removeKeepExtension = false;
 
     // constants for the messages to suppress by flags and their corresponding properties
     static final String MSG_METHOD_ARGUMENT_NOT_USED
         = "Warning: Method argument is not used";
     static final String MSG_PRIVATE_PROPERTY_NOT_USED
         = "Warning: Private property is defined but not used";
     static final String MSG_VARIABLE_NOT_USED
         = "Warning: Variable is set but not used";
     static final String MSG_EXCEPTION_NOT_SIGNALLED
         = "is in SIGNALS list but is not signalled within the method";
     static final String MSG_DEPRECATION = "has been deprecated";
 
     // other implementation variables
     private Vector compileList = new Vector();
     private Hashtable filecopyList = new Hashtable();
 
     /**
      * Set whether literals are treated as binary, rather than NetRexx types.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default is false.
      * @param binary a <code>boolean</code> value.
      */
     public void setBinary(boolean binary) {
         this.binary = binary;
     }
 
 
     /**
      * Set the classpath used for NetRexx compilation.
      * @param classpath the classpath to use.
      */
     public void setClasspath(String classpath) {
         this.classpath = classpath;
     }
 
 
     /**
      * Set whether comments are passed through to the generated java source.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param comments a <code>boolean</code> value.
      */
     public void setComments(boolean comments) {
         this.comments = comments;
     }
 
 
     /**
      * Set whether error messages come out in compact or verbose format.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is true.
      * @param compact a <code>boolean</code> value.
      */
     public void setCompact(boolean compact) {
         this.compact = compact;
     }
 
 
     /**
      * Set whether the NetRexx compiler should compile the generated java code.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is true.
      * Setting this flag to false, will automatically set the keep flag to true.
      * @param compile a <code>boolean</code> value.
      */
     public void setCompile(boolean compile) {
         this.compile = compile;
         if (!this.compile && !this.keep) {
             this.keep = true;
         }
     }
 
 
     /**
      * Set whether or not compiler messages should be displayed on the 'console'.
      * Note that this task will rely on the default value for filtering compile messages.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param console a <code>boolean</code> value.
      */
     public void setConsole(boolean console) {
         this.console = console;
     }
 
 
     /**
      * Whether variable cross references are generated.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param crossref a <code>boolean</code> value.
      */
     public void setCrossref(boolean crossref) {
         this.crossref = crossref;
     }
 
 
     /**
      * Set whether decimal arithmetic should be used for the netrexx code.
      * Setting this to off will report decimal arithmetic as an error, for
      * performance critical applications.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is true.
      * @param decimal a <code>boolean</code> value.
      */
     public void setDecimal(boolean decimal) {
         this.decimal = decimal;
     }
 
 
     /**
      * Set the destination directory into which the NetRexx source files
      * should be copied and then compiled.
      * @param destDirName the destination directory.
      */
     public void setDestDir(File destDirName) {
         destDir = destDirName;
     }
 
 
     /**
      * Whether diagnostic information about the compile is generated
      * @param diag a <code>boolean</code> value.
      */
     public void setDiag(boolean diag) {
         this.diag = diag;
     }
 
 
     /**
      * Sets whether variables must be declared explicitly before use.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param explicit a <code>boolean</code> value.
      */
     public void setExplicit(boolean explicit) {
         this.explicit = explicit;
     }
 
 
     /**
      * Whether the generated java code is formatted nicely or left to match
      * NetRexx line numbers for call stack debugging.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value false.
      * @param format a <code>boolean</code> value.
      */
     public void setFormat(boolean format) {
         this.format = format;
     }
 
 
     /**
      * Whether the generated java code is produced.
      * This is not implemented yet.
      * @param java a <code>boolean</code> value.
      */
     public void setJava(boolean java) {
         log("The attribute java is currently unused.", Project.MSG_WARN);
     }
 
 
     /**
      * Sets whether the generated java source file should be kept after
      * compilation. The generated files will have an extension of .java.keep,
      * <b>not</b> .java. See setRemoveKeepExtension
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param keep a <code>boolean</code> value.
      * @see #setRemoveKeepExtension(boolean)
      */
     public void setKeep(boolean keep) {
         this.keep = keep;
     }
 
 
     /**
      * Whether the compiler text logo is displayed when compiling.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param logo a <code>boolean</code> value.
      */
     public void setLogo(boolean logo) {
         this.logo = logo;
     }
 
 
     /**
      * Whether the generated .java file should be replaced when compiling.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param replace a <code>boolean</code> value.
      */
     public void setReplace(boolean replace) {
         this.replace = replace;
     }
 
 
     /**
      * Sets whether the compiler messages will be written to NetRexxC.log as
      * well as to the console.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param savelog a <code>boolean</code> value.
      */
     public void setSavelog(boolean savelog) {
         this.savelog = savelog;
     }
 
 
     /**
      * Tells the NetRexx compiler to store the class files in the same
      * directory as the source files. The alternative is the working directory.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is true.
      * @param sourcedir a <code>boolean</code> value.
      */
     public void setSourcedir(boolean sourcedir) {
         this.sourcedir = sourcedir;
     }
 
 
     /**
      * Set the source dir to find the source Java files.
      * @param srcDirName the source directory.
      */
     public void setSrcDir(File srcDirName) {
         srcDir = srcDirName;
     }
 
 
     /**
      * Tells the NetRexx compiler that method calls always need parentheses,
      * even if no arguments are needed, e.g. <code>aStringVar.getBytes</code>
      * vs. <code>aStringVar.getBytes()</code>.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param strictargs a <code>boolean</code> value.
      */
     public void setStrictargs(boolean strictargs) {
         this.strictargs = strictargs;
     }
 
 
     /**
      * Tells the NetRexx compile that assignments must match exactly on type.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param strictassign a <code>boolean</code> value.
      */
     public void setStrictassign(boolean strictassign) {
         this.strictassign = strictassign;
     }
 
 
     /**
      * Specifies whether the NetRexx compiler should be case sensitive or not.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param strictcase a <code>boolean</code> value.
      */
     public void setStrictcase(boolean strictcase) {
         this.strictcase = strictcase;
     }
 
 
     /**
      * Sets whether classes need to be imported explicitly using an <code>import</code>
      * statement. By default the NetRexx compiler will import certain packages
      * automatically.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param strictimport a <code>boolean</code> value.
      */
     public void setStrictimport(boolean strictimport) {
         this.strictimport = strictimport;
     }
 
 
     /**
      * Sets whether local properties need to be qualified explicitly using
      * <code>this</code>.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param strictprops a <code>boolean</code> value.
      */
     public void setStrictprops(boolean strictprops) {
         this.strictprops = strictprops;
     }
 
 
     /**
      * Whether the compiler should force catching of exceptions by explicitly
      * named types.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false
      * @param strictsignal a <code>boolean</code> value.
      */
     public void setStrictsignal(boolean strictsignal) {
         this.strictsignal = strictsignal;
     }
 
 
     /**
      * Sets whether debug symbols should be generated into the class file.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param symbols a <code>boolean</code> value.
      */
     public void setSymbols(boolean symbols) {
         this.symbols = symbols;
     }
 
 
     /**
      * Asks the NetRexx compiler to print compilation times to the console
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param time a <code>boolean</code> value.
      */
     public void setTime(boolean time) {
         this.time = time;
     }
 
     /**
      * Turns on or off tracing and directs the resultant trace output Valid
      * values are: "trace", "trace1", "trace2" and "notrace". "trace" and
      * "trace2".
      * @param trace the value to set.
      */
     public void setTrace(TraceAttr trace) {
         this.trace = trace.getValue();
     }
 
     /**
      * Turns on or off tracing and directs the resultant trace output Valid
      * values are: "trace", "trace1", "trace2" and "notrace". "trace" and
      * "trace2".
      * @param trace the value to set.
      */
     public void setTrace(String trace) {
         TraceAttr t = new TraceAttr();
 
         t.setValue(trace);
         setTrace(t);
     }
 
 
     /**
      * Tells the NetRexx compiler that the source is in UTF8.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param utf8 a <code>boolean</code> value.
      */
     public void setUtf8(boolean utf8) {
         this.utf8 = utf8;
     }
 
 
     /**
      * Whether lots of warnings and error messages should be generated
      * @param verbose the value to set - verbose&lt;level&gt; or noverbose.
      */
     public void setVerbose(VerboseAttr verbose) {
         this.verbose = verbose.getValue();
     }
 
 
     /**
      * Whether lots of warnings and error messages should be generated
      * @param verbose the value to set - verbose&lt;level&gt; or noverbose.
      */
     public void setVerbose(String verbose) {
         VerboseAttr v = new VerboseAttr();
 
         v.setValue(verbose);
         setVerbose(v);
     }
 
     /**
      * Whether the task should suppress the "Method argument is not used" in
      * strictargs-Mode, which can not be suppressed by the compiler itself.
      * The warning is logged as verbose message, though.
      * @param suppressMethodArgumentNotUsed a <code>boolean</code> value.
      */
     public void setSuppressMethodArgumentNotUsed(boolean suppressMethodArgumentNotUsed) {
         this.suppressMethodArgumentNotUsed = suppressMethodArgumentNotUsed;
     }
 
 
     /**
      * Whether the task should suppress the "Private property is defined but
      * not used" in strictargs-Mode, which can be quite annoying while
      * developing. The warning is logged as verbose message, though.
      * @param suppressPrivatePropertyNotUsed a <code>boolean</code> value.
      */
     public void setSuppressPrivatePropertyNotUsed(boolean suppressPrivatePropertyNotUsed) {
         this.suppressPrivatePropertyNotUsed = suppressPrivatePropertyNotUsed;
     }
 
 
     /**
      * Whether the task should suppress the "Variable is set but not used" in
      * strictargs-Mode. Be careful with this one! The warning is logged as
      * verbose message, though.
      * @param suppressVariableNotUsed a <code>boolean</code> value.
      */
     public void setSuppressVariableNotUsed(boolean suppressVariableNotUsed) {
         this.suppressVariableNotUsed = suppressVariableNotUsed;
     }
 
 
     /**
      * Whether the task should suppress the "FooException is in SIGNALS list
      * but is not signalled within the method", which is sometimes rather
      * useless. The warning is logged as verbose message, though.
      * @param suppressExceptionNotSignalled a <code>boolean</code> value.
      */
     public void setSuppressExceptionNotSignalled(boolean suppressExceptionNotSignalled) {
         this.suppressExceptionNotSignalled = suppressExceptionNotSignalled;
     }
 
 
     /**
      * Tells whether we should filter out any deprecation-messages
      * of the compiler out.
      * @param suppressDeprecation a <code>boolean</code> value.
      */
     public void setSuppressDeprecation(boolean suppressDeprecation) {
         this.suppressDeprecation = suppressDeprecation;
     }
 
 
     /**
-     * Tells wether the trailing .keep in nocompile-mode should be removed
+     * Tells whether the trailing .keep in nocompile-mode should be removed
      * so that the resulting java source really ends on .java.
      * This facilitates the use of the javadoc tool lateron.
      */
     public void setRemoveKeepExtension(boolean removeKeepExtension) {
         this.removeKeepExtension = removeKeepExtension;
     }
 
 
     /**
      * init-Method sets defaults from Properties. That way, when ant is called
      * with arguments like -Dant.netrexxc.verbose=verbose5 one can easily take
      * control of all netrexxc-tasks.
      */
     public void init() {
         String p;
 
         if ((p = getProject().getProperty("ant.netrexxc.binary")) != null) {
             this.binary = Project.toBoolean(p);
         }
         // classpath makes no sense
         if ((p = getProject().getProperty("ant.netrexxc.comments")) != null) {
             this.comments = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.compact")) != null) {
             this.compact = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.compile")) != null) {
             this.compile = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.console")) != null) {
             this.console = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.crossref")) != null) {
             this.crossref = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.decimal")) != null) {
             this.decimal = Project.toBoolean(p);
             // destDir
         }
         if ((p = getProject().getProperty("ant.netrexxc.diag")) != null) {
             this.diag = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.explicit")) != null) {
             this.explicit = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.format")) != null) {
             this.format = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.keep")) != null) {
             this.keep = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.logo")) != null) {
             this.logo = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.replace")) != null) {
             this.replace = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.savelog")) != null) {
             this.savelog = Project.toBoolean(p);
             // srcDir
         }
         if ((p = getProject().getProperty("ant.netrexxc.sourcedir")) != null) {
             this.sourcedir = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.strictargs")) != null) {
             this.strictargs = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.strictassign")) != null) {
             this.strictassign = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.strictcase")) != null) {
             this.strictcase = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.strictimport")) != null) {
             this.strictimport = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.strictprops")) != null) {
             this.strictprops = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.strictsignal")) != null) {
             this.strictsignal = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.symbols")) != null) {
             this.symbols = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.time")) != null) {
             this.time = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.trace")) != null) {
             setTrace(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.utf8")) != null) {
             this.utf8 = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.verbose")) != null) {
             setVerbose(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.suppressMethodArgumentNotUsed")) != null) {
             this.suppressMethodArgumentNotUsed = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.suppressPrivatePropertyNotUsed")) != null) {
             this.suppressPrivatePropertyNotUsed = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.suppressVariableNotUsed")) != null) {
             this.suppressVariableNotUsed = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.suppressExceptionNotSignalled")) != null) {
             this.suppressExceptionNotSignalled = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.suppressDeprecation")) != null) {
             this.suppressDeprecation = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.removeKeepExtension")) != null) {
             this.removeKeepExtension = Project.toBoolean(p);
         }
     }
 
 
     /**
      * Executes the task - performs the actual compiler call.
      * @throws BuildException on error.
      */
     public void execute() throws BuildException {
 
         // first off, make sure that we've got a srcdir and destdir
         if (srcDir == null || destDir == null) {
             throw new BuildException("srcDir and destDir attributes must be set!");
         }
 
         // scan source and dest dirs to build up both copy lists and
         // compile lists
         //        scanDir(srcDir, destDir);
         DirectoryScanner ds = getDirectoryScanner(srcDir);
 
         String[] files = ds.getIncludedFiles();
 
         scanDir(srcDir, destDir, files);
 
         // copy the source and support files
         copyFilesToDestination();
 
         // compile the source files
         if (compileList.size() > 0) {
             log("Compiling " + compileList.size() + " source file"
                  + (compileList.size() == 1 ? "" : "s")
                  + " to " + destDir);
             doNetRexxCompile();
             if (removeKeepExtension && (!compile || keep)) {
                 removeKeepExtensions();
             }
         }
     }
 
 
     /**
      * Scans the directory looking for source files to be compiled and support
      * files to be copied.
      */
     private void scanDir(File srcDir, File destDir, String[] files) {
         for (int i = 0; i < files.length; i++) {
             File srcFile = new File(srcDir, files[i]);
             File destFile = new File(destDir, files[i]);
             String filename = files[i];
             // if it's a non source file, copy it if a later date than the
             // dest
             // if it's a source file, see if the destination class file
             // needs to be recreated via compilation
             if (filename.toLowerCase().endsWith(".nrx")) {
                 File classFile =
                     new File(destDir,
                     filename.substring(0, filename.lastIndexOf('.')) + ".class");
                 File javaFile =
                     new File(destDir,
                     filename.substring(0, filename.lastIndexOf('.'))
                     + (removeKeepExtension ? ".java" : ".java.keep"));
 
                 // nocompile case tests against .java[.keep] file
                 if (!compile && srcFile.lastModified() > javaFile.lastModified()) {
                     filecopyList.put(srcFile.getAbsolutePath(), destFile.getAbsolutePath());
                     compileList.addElement(destFile.getAbsolutePath());
                 }
                 // compile case tests against .class file
                 else if (compile && srcFile.lastModified() > classFile.lastModified()) {
                     filecopyList.put(srcFile.getAbsolutePath(), destFile.getAbsolutePath());
                     compileList.addElement(destFile.getAbsolutePath());
                 }
             } else {
                 if (srcFile.lastModified() > destFile.lastModified()) {
                     filecopyList.put(srcFile.getAbsolutePath(), destFile.getAbsolutePath());
                 }
             }
         }
     }
 
 
     /** Copy eligible files from the srcDir to destDir  */
     private void copyFilesToDestination() {
         if (filecopyList.size() > 0) {
             log("Copying " + filecopyList.size() + " file"
                  + (filecopyList.size() == 1 ? "" : "s")
                  + " to " + destDir.getAbsolutePath());
 
             Enumeration e = filecopyList.keys();
 
             while (e.hasMoreElements()) {
                 String fromFile = (String) e.nextElement();
                 String toFile = (String) filecopyList.get(fromFile);
 
                 try {
                     FileUtils.getFileUtils().copyFile(fromFile, toFile);
                 } catch (IOException ioe) {
                     String msg = "Failed to copy " + fromFile + " to " + toFile
                          + " due to " + ioe.getMessage();
 
                     throw new BuildException(msg, ioe);
                 }
             }
         }
     }
 
 
     /**
      * Rename .java.keep files (back) to .java. The netrexxc renames all
      * .java files to .java.keep if either -keep or -nocompile option is set.
      */
     private void removeKeepExtensions() {
         if (compileList.size() > 0) {
             log("Removing .keep extension on " + compileList.size() + " file"
                  + (compileList.size() == 1 ? "" : "s"));
             Enumeration e = compileList.elements();
             while (e.hasMoreElements()) {
                 String nrxName = (String) e.nextElement();
                 String baseName = nrxName.substring(0, nrxName.lastIndexOf('.'));
                 File fromFile = new File(baseName + ".java.keep");
                 File toFile = new File(baseName + ".java");
                 if (fromFile.renameTo(toFile)) {
                     log("Successfully renamed " + fromFile + " to " + toFile, Project.MSG_VERBOSE);
                 } else {
                     log("Failed to rename " + fromFile + " to " + toFile);
                 }
             }
         }
     }
 
 
     /** Performs a compile using the NetRexx 1.1.x compiler  */
     private void doNetRexxCompile() throws BuildException {
         log("Using NetRexx compiler", Project.MSG_VERBOSE);
 
         String classpath = getCompileClasspath();
         StringBuffer compileOptions = new StringBuffer();
 
         // create an array of strings for input to the compiler: one array
         // comes from the compile options, the other from the compileList
         String[] compileOptionsArray = getCompileOptionsAsArray();
         String[] fileListArray = new String[compileList.size()];
         Enumeration e = compileList.elements();
         int j = 0;
 
         while (e.hasMoreElements()) {
             fileListArray[j] = (String) e.nextElement();
             j++;
         }
         // create a single array of arguments for the compiler
         String[] compileArgs = new String[compileOptionsArray.length + fileListArray.length];
 
         for (int i = 0; i < compileOptionsArray.length; i++) {
             compileArgs[i] = compileOptionsArray[i];
         }
         for (int i = 0; i < fileListArray.length; i++) {
             compileArgs[i + compileOptionsArray.length] = fileListArray[i];
         }
 
         // print nice output about what we are doing for the log
         compileOptions.append("Compilation args: ");
         for (int i = 0; i < compileOptionsArray.length; i++) {
             compileOptions.append(compileOptionsArray[i]);
             compileOptions.append(" ");
         }
         log(compileOptions.toString(), Project.MSG_VERBOSE);
 
         String eol = System.getProperty("line.separator");
         StringBuffer niceSourceList = new StringBuffer("Files to be compiled:" + eol);
 
         final int size = compileList.size();
         for (int i = 0; i < size; i++) {
             niceSourceList.append("    ");
             niceSourceList.append(compileList.elementAt(i).toString());
             niceSourceList.append(eol);
         }
 
         log(niceSourceList.toString(), Project.MSG_VERBOSE);
 
         // need to set java.class.path property and restore it later
         // since the NetRexx compiler has no option for the classpath
         String currentClassPath = System.getProperty("java.class.path");
         Properties currentProperties = System.getProperties();
 
         currentProperties.put("java.class.path", classpath);
 
         try {
             StringWriter out = new StringWriter();
             PrintWriter w = null;
             int rc =
                 COM.ibm.netrexx.process.NetRexxC.main(new Rexx(compileArgs),
                                                       w = new PrintWriter(out));
             String sdir = srcDir.getAbsolutePath();
             String ddir = destDir.getAbsolutePath();
             boolean doReplace = !(sdir.equals(ddir));
             int dlen = ddir.length();
             String l;
             BufferedReader in = new BufferedReader(new StringReader(out.toString()));
 
             log("replacing destdir '" + ddir + "' through sourcedir '"
                 + sdir + "'", Project.MSG_VERBOSE);
             while ((l = in.readLine()) != null) {
                 int idx;
 
                 while (doReplace && ((idx = l.indexOf(ddir)) != -1)) {
                     // path is mentioned in the message
                     l = (new StringBuffer(l)).replace(idx, idx + dlen, sdir).toString();
                 }
                 // verbose level logging for suppressed messages
                 if (suppressMethodArgumentNotUsed
                     && l.indexOf(MSG_METHOD_ARGUMENT_NOT_USED) != -1) {
                     log(l, Project.MSG_VERBOSE);
                 } else if (suppressPrivatePropertyNotUsed
                     && l.indexOf(MSG_PRIVATE_PROPERTY_NOT_USED) != -1) {
                     log(l, Project.MSG_VERBOSE);
                 } else if (suppressVariableNotUsed
                     && l.indexOf(MSG_VARIABLE_NOT_USED) != -1) {
                     log(l, Project.MSG_VERBOSE);
                 } else if (suppressExceptionNotSignalled
                     && l.indexOf(MSG_EXCEPTION_NOT_SIGNALLED) != -1) {
                     log(l, Project.MSG_VERBOSE);
                 } else if (suppressDeprecation
                     && l.indexOf(MSG_DEPRECATION) != -1) {
                     log(l, Project.MSG_VERBOSE);
                 } else if (l.indexOf("Error:") != -1) {
                     // error level logging for compiler errors
                     log(l, Project.MSG_ERR);
                 } else if (l.indexOf("Warning:") != -1) {
                     // warning for all warning messages
                     log(l, Project.MSG_WARN);
                 } else {
                     log(l, Project.MSG_INFO); // info level for the rest.
                 }
             }
             if (rc > 1) {
                 throw new BuildException("Compile failed, messages should "
                     + "have been provided.");
             }
             if (w.checkError()) {
                 throw new IOException("Encountered an error");
             }
         } catch (IOException ioe) {
             throw new BuildException("Unexpected IOException while "
                 + "playing with Strings", ioe);
         } finally {
             // need to reset java.class.path property
             // since the NetRexx compiler has no option for the classpath
             currentProperties = System.getProperties();
             currentProperties.put("java.class.path", currentClassPath);
         }
 
     }
 
 
     /** Builds the compilation classpath.  */
     private String getCompileClasspath() {
         StringBuffer classpath = new StringBuffer();
 
         // add dest dir to classpath so that previously compiled and
         // untouched classes are on classpath
         classpath.append(destDir.getAbsolutePath());
 
         // add our classpath to the mix
         if (this.classpath != null) {
             addExistingToClasspath(classpath, this.classpath);
         }
 
         // add the system classpath
         // addExistingToClasspath(classpath,System.getProperty("java.class.path"));
         return classpath.toString();
     }
 
 
     /** This  */
     private String[] getCompileOptionsAsArray() {
         Vector options = new Vector();
 
         options.addElement(binary ? "-binary" : "-nobinary");
         options.addElement(comments ? "-comments" : "-nocomments");
         options.addElement(compile ? "-compile" : "-nocompile");
         options.addElement(compact ? "-compact" : "-nocompact");
         options.addElement(console ? "-console" : "-noconsole");
         options.addElement(crossref ? "-crossref" : "-nocrossref");
         options.addElement(decimal ? "-decimal" : "-nodecimal");
         options.addElement(diag ? "-diag" : "-nodiag");
         options.addElement(explicit ? "-explicit" : "-noexplicit");
         options.addElement(format ? "-format" : "-noformat");
         options.addElement(keep ? "-keep" : "-nokeep");
         options.addElement(logo ? "-logo" : "-nologo");
         options.addElement(replace ? "-replace" : "-noreplace");
         options.addElement(savelog ? "-savelog" : "-nosavelog");
         options.addElement(sourcedir ? "-sourcedir" : "-nosourcedir");
         options.addElement(strictargs ? "-strictargs" : "-nostrictargs");
         options.addElement(strictassign ? "-strictassign" : "-nostrictassign");
         options.addElement(strictcase ? "-strictcase" : "-nostrictcase");
         options.addElement(strictimport ? "-strictimport" : "-nostrictimport");
         options.addElement(strictprops ? "-strictprops" : "-nostrictprops");
         options.addElement(strictsignal ? "-strictsignal" : "-nostrictsignal");
         options.addElement(symbols ? "-symbols" : "-nosymbols");
         options.addElement(time ? "-time" : "-notime");
         options.addElement("-" + trace);
         options.addElement(utf8 ? "-utf8" : "-noutf8");
         options.addElement("-" + verbose);
 
         String[] results = new String[options.size()];
 
         options.copyInto(results);
         return results;
     }
 
 
     /**
      * Takes a classpath-like string, and adds each element of this string to
      * a new classpath, if the components exist. Components that don't exist,
      * aren't added. We do this, because jikes issues warnings for
      * non-existant files/dirs in his classpath, and these warnings are pretty
      * annoying.
      *
      * @param target - target classpath
      * @param source - source classpath to get file objects.
      */
     private void addExistingToClasspath(StringBuffer target, String source) {
         StringTokenizer tok = new StringTokenizer(source,
             System.getProperty("path.separator"), false);
 
         while (tok.hasMoreTokens()) {
             File f = getProject().resolveFile(tok.nextToken());
 
             if (f.exists()) {
                 target.append(File.pathSeparator);
                 target.append(f.getAbsolutePath());
             } else {
                 log("Dropping from classpath: "
                     + f.getAbsolutePath(), Project.MSG_VERBOSE);
             }
         }
 
     }
 
 
     /**
      * Enumerated class corresponding to the trace attribute.
      */
     public static class TraceAttr extends EnumeratedAttribute {
         /** {@inheritDoc}. */
         public String[] getValues() {
             return new String[]{"trace", "trace1", "trace2", "notrace"};
         }
     }
 
     /**
      * Enumerated class corresponding to the verbose attribute.
      */
     public static class VerboseAttr extends EnumeratedAttribute {
         /** {@inheritDoc}. */
         public String[] getValues() {
             return new String[]{"verbose", "verbose0", "verbose1",
                 "verbose2", "verbose3", "verbose4",
                 "verbose5", "noverbose"};
         }
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ReplaceRegExp.java b/src/main/org/apache/tools/ant/taskdefs/optional/ReplaceRegExp.java
index b31d1d87a..0751ec541 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ReplaceRegExp.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ReplaceRegExp.java
@@ -1,546 +1,546 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.InputStreamReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Reader;
 import java.io.Writer;
 import java.util.Iterator;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.RegularExpression;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.Substitution;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.regexp.Regexp;
 import org.apache.tools.ant.util.regexp.RegexpUtil;
 
 /**
  * Performs regular expression string replacements in a text
  * file.  The input file(s) must be able to be properly processed by
  * a Reader instance.  That is, they must be text only, no binary.
  *
  * The syntax of the regular expression depends on the implementation that
  * you choose to use. The system property <code>ant.regexp.regexpimpl</code>
  * will be the classname of the implementation that will be used (the default
  * is <code>org.apache.tools.ant.util.regexp.JakartaOroRegexp</code> and
  * requires the Jakarta Oro Package).
  *
  * <pre>
  * Available implementations:
  *
  *   org.apache.tools.ant.util.regexp.Jdk14RegexpRegexp (default)
  *        Uses Java's built-in regular expression package
  *
  *   org.apache.tools.ant.util.regexp.JakartaOroRegexp
  *        Requires  the jakarta-oro package
  *
  *   org.apache.tools.ant.util.regexp.JakartaRegexpRegexp
  *        Requires the jakarta-regexp package
  *
  * Usage:
  *
  *   Call Syntax:
  *
  *     &lt;replaceregexp file="file"
  *                    match="pattern"
  *                    replace="pattern"
  *                    flags="options"?
  *                    byline="true|false"? &gt;
  *       regexp?
  *       substitution?
  *       fileset*
  *     &lt;/replaceregexp&gt;
  *
  *    NOTE: You must have either the file attribute specified, or at least one fileset subelement
  *    to operation on.  You may not have the file attribute specified if you nest fileset elements
  *    inside this task.  Also, you cannot specify both match and a regular expression subelement at
  *    the same time, nor can you specify the replace attribute and the substitution subelement at
  *    the same time.
  *
  *   Attributes:
  *
  *     file    --&gt; A single file to operation on (mutually exclusive
  *                    with the fileset subelements)
  *     match   --&gt; The Regular expression to match
  *     replace --&gt; The Expression replacement string
  *     flags   --&gt; The options to give to the replacement
  *                 g = Substitute all occurrences. default is to replace only the first one
  *                 i = Case insensitive match
  *
  *     byline  --&gt; Should this file be processed a single line at a time (default is false)
  *                 "true" indicates to perform replacement on a line by line basis
  *                 "false" indicates to perform replacement on the whole file at once.
  *
  *  Example:
  *
  *     The following call could be used to replace an old property name in a ".properties"
  *     file with a new name.  In the replace attribute, you can refer to any part of the
  *     match expression in parenthesis using backslash followed by a number like '\1'.
  *
  *     &lt;replaceregexp file="test.properties"
  *                    match="MyProperty=(.*)"
  *                    replace="NewProperty=\1"
  *                    byline="true" /&gt;
  *
  * </pre>
  *
  */
 public class ReplaceRegExp extends Task {
 
     private File file;
     private String flags;
     private boolean byline;
     private Union resources;
     private RegularExpression regex;
     private Substitution subs;
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     private boolean preserveLastModified = false;
 
     /**
      * Encoding to assume for the files
      */
     private String encoding = null;
 
     /** Default Constructor  */
     public ReplaceRegExp() {
         super();
         this.file = null;
         this.flags = "";
         this.byline = false;
 
         this.regex = null;
         this.subs = null;
     }
 
 
     /**
      * file for which the regular expression should be replaced;
      * required unless a nested fileset is supplied.
      * @param file The file for which the reg exp should be replaced.
      */
     public void setFile(File file) {
         this.file = file;
     }
 
 
     /**
      * the regular expression pattern to match in the file(s);
      * required if no nested &lt;regexp&gt; is used
      * @param match the match attribute.
      */
     public void setMatch(String match) {
         if (regex != null) {
             throw new BuildException("Only one regular expression is allowed");
         }
 
         regex = new RegularExpression();
         regex.setPattern(match);
     }
 
 
     /**
      * The substitution pattern to place in the file(s) in place
      * of the regular expression.
      * Required if no nested &lt;substitution&gt; is used
      * @param replace the replace attribute
      */
 
     public void setReplace(String replace) {
         if (subs != null) {
             throw new BuildException("Only one substitution expression is "
                                      + "allowed");
         }
 
         subs = new Substitution();
         subs.setExpression(replace);
     }
 
     /**
      * The flags to use when matching the regular expression.  For more
      * information, consult the Perl5 syntax.
      * <ul>
      *  <li>g : Global replacement.  Replace all occurrences found
      *  <li>i : Case Insensitive.  Do not consider case in the match
      *  <li>m : Multiline.  Treat the string as multiple lines of input,
      *         using "^" and "$" as the start or end of any line, respectively,
      *         rather than start or end of string.
      *  <li> s : Singleline.  Treat the string as a single line of input, using
      *        "." to match any character, including a newline, which normally,
      *        it would not match.
      *</ul>
      * @param flags the flags attribute
      */
     public void setFlags(String flags) {
         this.flags = flags;
     }
 
 
     /**
      * Process the file(s) one line at a time, executing the replacement
      * on one line at a time.  This is useful if you
      * want to only replace the first occurrence of a regular expression on
      * each line, which is not easy to do when processing the file as a whole.
      * Defaults to <i>false</i>.</td>
      * @param byline the byline attribute as a string
      * @deprecated since 1.6.x.
      *             Use setByLine(boolean).
      */
     public void setByLine(String byline) {
         Boolean res = Boolean.valueOf(byline);
 
         if (res == null) {
             res = Boolean.FALSE;
         }
         this.byline = res.booleanValue();
     }
 
     /**
      * Process the file(s) one line at a time, executing the replacement
      * on one line at a time.  This is useful if you
      * want to only replace the first occurrence of a regular expression on
      * each line, which is not easy to do when processing the file as a whole.
      * Defaults to <i>false</i>.</td>
      * @param byline the byline attribute
      */
     public void setByLine(boolean byline) {
         this.byline = byline;
     }
 
 
     /**
      * Specifies the encoding Ant expects the files to be in -
      * defaults to the platforms default encoding.
      * @param encoding the encoding attribute
      *
      * @since Ant 1.6
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * list files to apply the replacement to
      * @param set the fileset element
      */
     public void addFileset(FileSet set) {
         addConfigured(set);
     }
 
     /**
      * Support arbitrary file system based resource collections.
      *
      * @since Ant 1.8.0
      */
     public void addConfigured(ResourceCollection rc) {
         if (!rc.isFilesystemOnly()) {
             throw new BuildException("only filesystem resources are supported");
         }
         if (resources == null) {
             resources = new Union();
         }
         resources.add(rc);
     }
 
     /**
      * A regular expression.
      * You can use this element to refer to a previously
      * defined regular expression datatype instance
      * @return the regular expression object to be configured as an element
      */
     public RegularExpression createRegexp() {
         if (regex != null) {
             throw new BuildException("Only one regular expression is allowed.");
         }
 
         regex = new RegularExpression();
         return regex;
     }
 
 
     /**
      * A substitution pattern.  You can use this element to refer to a previously
      * defined substitution pattern datatype instance.
      * @return the substitution pattern object to be configured as an element
      */
     public Substitution createSubstitution() {
         if (subs != null) {
             throw new BuildException("Only one substitution expression is "
                                      + "allowed");
         }
 
         subs = new Substitution();
         return subs;
     }
 
     /**
      * Whether the file timestamp shall be preserved even if the file
      * is modified.
      *
      * @since Ant 1.8.0
      */
     public void setPreserveLastModified(boolean b) {
         preserveLastModified = b;
     }
 
     /**
      * Invoke a regular expression (r) on a string (input) using
      * substitutions (s) for a matching regex.
      *
      * @param r a regular expression
      * @param s a Substitution
      * @param input the string to do the replacement on
      * @param options The options for the regular expression
      * @return the replacement result
      */
     protected String doReplace(RegularExpression r,
                                Substitution s,
                                String input,
                                int options) {
         String res = input;
         Regexp regexp = r.getRegexp(getProject());
 
         if (regexp.matches(input, options)) {
             log("Found match; substituting", Project.MSG_DEBUG);
             res = regexp.substitute(input, s.getExpression(getProject()),
                                     options);
         }
 
         return res;
     }
 
 
     /**
      *  Perform the replacement on a file
      *
-     * @param f the file to perform the relacement on
+     * @param f the file to perform the replacement on
      * @param options the regular expressions options
      * @exception IOException if an error occurs
      */
     protected void doReplace(File f, int options)
          throws IOException {
         File temp = FILE_UTILS.createTempFile("replace", ".txt", null, true, true);
         try {
             boolean changes = false;
 
             InputStream is = new FileInputStream(f);
             try {
                 Reader r = encoding != null ? new InputStreamReader(is, encoding) : new InputStreamReader(is);
                 OutputStream os = new FileOutputStream(temp);
                 try {
                     Writer w = encoding != null ? new OutputStreamWriter(os, encoding) : new OutputStreamWriter(os);
 
                     BufferedReader br = new BufferedReader(r);
                     BufferedWriter bw = new BufferedWriter(w);
 
             log("Replacing pattern '" + regex.getPattern(getProject())
                 + "' with '" + subs.getExpression(getProject())
                 + "' in '" + f.getPath() + "'" + (byline ? " by line" : "")
                 + (flags.length() > 0 ? " with flags: '" + flags + "'" : "")
                 + ".", Project.MSG_VERBOSE);
 
             if (byline) {
                 StringBuffer linebuf = new StringBuffer();
                 String line = null;
                 String res = null;
                 int c;
                 boolean hasCR = false;
 
                 do {
                     c = br.read();
 
                     if (c == '\r') {
                         if (hasCR) {
                             // second CR -> EOL + possibly empty line
                             line = linebuf.toString();
                             res  = doReplace(regex, subs, line, options);
 
                             if (!res.equals(line)) {
                                 changes = true;
                             }
 
                             bw.write(res);
                             bw.write('\r');
 
                             linebuf = new StringBuffer();
                             // hasCR is still true (for the second one)
                         } else {
                             // first CR in this line
                             hasCR = true;
                         }
                     } else if (c == '\n') {
                         // LF -> EOL
                         line = linebuf.toString();
                         res  = doReplace(regex, subs, line, options);
 
                         if (!res.equals(line)) {
                             changes = true;
                         }
 
                         bw.write(res);
                         if (hasCR) {
                             bw.write('\r');
                             hasCR = false;
                         }
                         bw.write('\n');
 
                         linebuf = new StringBuffer();
                     } else { // any other char
                         if ((hasCR) || (c < 0)) {
                             // Mac-style linebreak or EOF (or both)
                             line = linebuf.toString();
                             res  = doReplace(regex, subs, line, options);
 
                             if (!res.equals(line)) {
                                 changes = true;
                             }
 
                             bw.write(res);
                             if (hasCR) {
                                 bw.write('\r');
                                 hasCR = false;
                             }
 
                             linebuf = new StringBuffer();
                         }
 
                         if (c >= 0) {
                             linebuf.append((char) c);
                         }
                     }
                 } while (c >= 0);
 
             } else {
                 String buf = FileUtils.safeReadFully(br);
 
                 String res = doReplace(regex, subs, buf, options);
 
                 if (!res.equals(buf)) {
                     changes = true;
                 }
 
                 bw.write(res);
             }
 
             bw.flush();
 
                 } finally {
                     os.close();
                 }
             } finally {
                 is.close();
             }
             if (changes) {
                 log("File has changed; saving the updated file", Project.MSG_VERBOSE);
                 try {
                     long origLastModified = f.lastModified();
                     FILE_UTILS.rename(temp, f);
                     if (preserveLastModified) {
                         FILE_UTILS.setFileLastModified(f, origLastModified);
                     }
                     temp = null;
                 } catch (IOException e) {
                     throw new BuildException("Couldn't rename temporary file "
                                              + temp, e, getLocation());
                 }
             } else {
                 log("No change made", Project.MSG_DEBUG);
             }
         } finally {
             if (temp != null) {
                 temp.delete();
             }
         }
     }
 
 
     /**
      * Execute the task
      *
      * @throws BuildException is there is a problem in the task execution.
      */
     public void execute() throws BuildException {
         if (regex == null) {
             throw new BuildException("No expression to match.");
         }
         if (subs == null) {
             throw new BuildException("Nothing to replace expression with.");
         }
 
         if (file != null && resources != null) {
             throw new BuildException("You cannot supply the 'file' attribute "
                                      + "and resource collections at the same "
                                      + "time.");
         }
 
         int options = RegexpUtil.asOptions(flags);
 
         if (file != null && file.exists()) {
             try {
                 doReplace(file, options);
             } catch (IOException e) {
                 log("An error occurred processing file: '"
                     + file.getAbsolutePath() + "': " + e.toString(),
                     Project.MSG_ERR);
             }
         } else if (file != null) {
             log("The following file is missing: '"
                 + file.getAbsolutePath() + "'", Project.MSG_ERR);
         }
 
         if (resources != null) {
             for (Resource r : resources) {
                 FileProvider fp =
                     r.as(FileProvider.class);
                 File f = fp.getFile();
 
                 if (f.exists()) {
                     try {
                         doReplace(f, options);
                     } catch (Exception e) {
                         log("An error occurred processing file: '"
                             + f.getAbsolutePath() + "': " + e.toString(),
                             Project.MSG_ERR);
                     }
                 } else {
                     log("The following file is missing: '"
                         + f.getAbsolutePath() + "'", Project.MSG_ERR);
                 }
             }
         }
     }
 
 }
 
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/SchemaValidate.java b/src/main/org/apache/tools/ant/taskdefs/optional/SchemaValidate.java
index 91b1700f5..2e08ff5bb 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/SchemaValidate.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/SchemaValidate.java
@@ -1,528 +1,528 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.XmlConstants;
 import org.xml.sax.XMLReader;
 import org.xml.sax.SAXNotRecognizedException;
 import org.xml.sax.SAXNotSupportedException;
 import org.xml.sax.SAXException;
 
 import javax.xml.parsers.SAXParserFactory;
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.ParserConfigurationException;
 import java.util.Iterator;
 import java.util.HashMap;
 import java.io.File;
 import java.net.MalformedURLException;
 
 /**
  * Validate XML Schema documents.
  * This task validates XML schema documents. It requires an XML parser
- * that handles the relevant SAx, Xerces or JAXP options.
+ * that handles the relevant SAX, Xerces or JAXP options.
  *
  * To resolve remote referencies, Ant may need its proxy set up, using the
  * setproxy task.
  *
  * Hands off most of the work to its parent, {@link XMLValidateTask}
  * @since Ant1.7
  */
 
 public class SchemaValidate extends XMLValidateTask {
 
     /** map of all declared schemas; we catch and complain about redefinitions */
     private HashMap schemaLocations = new HashMap();
 
     /** full checking of a schema */
     private boolean fullChecking = true;
 
     /**
      * flag to disable DTD support. Best left enabled.
      */
     private boolean disableDTD = false;
 
     /**
      * default URL for nonamespace schemas
      */
     private SchemaLocation anonymousSchema;
 
     // Error strings
     /** SAX1 not supported */
     public static final String ERROR_SAX_1 = "SAX1 parsers are not supported";
 
     /** schema features not supported */
     public static final String ERROR_NO_XSD_SUPPORT
         = "Parser does not support Xerces or JAXP schema features";
 
     /** too many default schemas */
     public static final String ERROR_TOO_MANY_DEFAULT_SCHEMAS
         = "Only one of defaultSchemaFile and defaultSchemaURL allowed";
 
     /** unable to create parser */
     public static final String ERROR_PARSER_CREATION_FAILURE
         = "Could not create parser";
 
     /** adding schema */
     public static final String MESSAGE_ADDING_SCHEMA = "Adding schema ";
 
     /** Duplicate declaration of schema  */
     public static final String ERROR_DUPLICATE_SCHEMA
         = "Duplicate declaration of schema ";
 
     /**
      * Called by the project to let the task initialize properly. The default
      * implementation is a no-op.
      *
      * @throws BuildException if something goes wrong with the build
      */
     public void init() throws BuildException {
         super.init();
         //validating
         setLenient(false);
     }
 
     /**
      * Turn on XSD support in Xerces.
      * @return true on success, false on failure
      */
     public boolean enableXercesSchemaValidation() {
         try {
             setFeature(XmlConstants.FEATURE_XSD, true);
             //set the schema source for the doc
             setNoNamespaceSchemaProperty(XmlConstants.PROPERTY_NO_NAMESPACE_SCHEMA_LOCATION);
         } catch (BuildException e) {
             log(e.toString(), Project.MSG_VERBOSE);
             return false;
         }
         return true;
     }
 
     /**
      * set nonamespace handling up for xerces or other parsers
      * @param property name of the property to set
      */
     private void setNoNamespaceSchemaProperty(String property) {
         String anonSchema = getNoNamespaceSchemaURL();
         if (anonSchema != null) {
             setProperty(property, anonSchema);
         }
     }
 
     /**
      * Set schema attributes in a JAXP 1.2 engine.
      * @see <A href="http://java.sun.com/xml/jaxp/change-requests-11.html">
      * JAXP 1.2 Approved CHANGES</A>
      * @return true on success, false on failure
      */
     public boolean enableJAXP12SchemaValidation() {
         try {
             //enable XSD
             setProperty(XmlConstants.FEATURE_JAXP12_SCHEMA_LANGUAGE, XmlConstants.URI_XSD);
             //set the schema source for the doc
             setNoNamespaceSchemaProperty(XmlConstants.FEATURE_JAXP12_SCHEMA_SOURCE);
         } catch (BuildException e) {
             log(e.toString(), Project.MSG_VERBOSE);
             return false;
         }
         return true;
     }
 
     /**
      * add the schema
      * @param location the schema location.
      * @throws BuildException if there is no namespace, or if there already
      * is a declaration of this schema with a different value
      */
     public void addConfiguredSchema(SchemaLocation location) {
         log("adding schema " + location, Project.MSG_DEBUG);
         location.validateNamespace();
         SchemaLocation old = (SchemaLocation) schemaLocations.get(location.getNamespace());
         if (old != null && !old.equals(location)) {
             throw new BuildException(ERROR_DUPLICATE_SCHEMA + location);
         }
         schemaLocations.put(location.getNamespace(), location);
     }
 
     /**
      * enable full schema checking. Slower but better.
      * @param fullChecking a <code>boolean</code> value.
      */
     public void setFullChecking(boolean fullChecking) {
         this.fullChecking = fullChecking;
     }
 
     /**
      * create a schema location to hold the anonymous
      * schema
      */
     protected void createAnonymousSchema() {
         if (anonymousSchema == null) {
             anonymousSchema = new SchemaLocation();
         }
         anonymousSchema.setNamespace("(no namespace)");
     }
 
     /**
      * identify the URL of the default schema
      * @param defaultSchemaURL the URL of the default schema.
      */
     public void setNoNamespaceURL(String defaultSchemaURL) {
         createAnonymousSchema();
         this.anonymousSchema.setUrl(defaultSchemaURL);
     }
 
     /**
      * identify a file containing the default schema
      * @param defaultSchemaFile the location of the default schema.
      */
     public void setNoNamespaceFile(File defaultSchemaFile) {
         createAnonymousSchema();
         this.anonymousSchema.setFile(defaultSchemaFile);
     }
 
     /**
      * flag to disable DTD support.
      * @param disableDTD a <code>boolean</code> value.
      */
     public void setDisableDTD(boolean disableDTD) {
         this.disableDTD = disableDTD;
     }
 
     /**
      * init the parser : load the parser class, and set features if necessary It
      * is only after this that the reader is valid
      *
      * @throws BuildException if something went wrong
      */
     protected void initValidator() {
         super.initValidator();
         //validate the parser type
         if (isSax1Parser()) {
             throw new BuildException(ERROR_SAX_1);
         }
 
         //enable schema
         //setFeature(XmlConstants.FEATURE_VALIDATION, false);
         setFeature(XmlConstants.FEATURE_NAMESPACES, true);
         if (!enableXercesSchemaValidation() && !enableJAXP12SchemaValidation()) {
             //couldnt use the xerces or jaxp calls
             throw new BuildException(ERROR_NO_XSD_SUPPORT);
         }
 
         //enable schema checking
         setFeature(XmlConstants.FEATURE_XSD_FULL_VALIDATION, fullChecking);
 
         //turn off DTDs if desired
         setFeatureIfSupported(XmlConstants.FEATURE_DISALLOW_DTD, disableDTD);
 
         //schema declarations go in next
         addSchemaLocations();
     }
 
     /**
      * Create a reader if the use of the class did not specify another one.
      * The reason to not use {@link org.apache.tools.ant.util.JAXPUtils#getXMLReader()} was to
      * create our own factory with our own options.
      * @return a default XML parser
      */
     protected XMLReader createDefaultReader() {
         SAXParserFactory factory = SAXParserFactory.newInstance();
         factory.setValidating(true);
         factory.setNamespaceAware(true);
         XMLReader reader = null;
         try {
             SAXParser saxParser = factory.newSAXParser();
             reader = saxParser.getXMLReader();
         } catch (ParserConfigurationException e) {
             throw new BuildException(ERROR_PARSER_CREATION_FAILURE, e);
         } catch (SAXException e) {
             throw new BuildException(ERROR_PARSER_CREATION_FAILURE, e);
         }
         return reader;
     }
 
     /**
      * build a string list of all schema locations, then set the relevant
      * property.
      */
     protected void addSchemaLocations() {
         Iterator it = schemaLocations.values().iterator();
         StringBuffer buffer = new StringBuffer();
         int count = 0;
         while (it.hasNext()) {
             if (count > 0) {
                 buffer.append(' ');
             }
             SchemaLocation schemaLocation = (SchemaLocation) it.next();
             String tuple = schemaLocation.getURIandLocation();
             buffer.append(tuple);
             log("Adding schema " + tuple, Project.MSG_VERBOSE);
             count++;
         }
         if (count > 0) {
             setProperty(XmlConstants.PROPERTY_SCHEMA_LOCATION, buffer.toString());
         }
 
     }
 
     /**
      * get the URL of the no namespace schema
      * @return the schema URL
      */
     protected String getNoNamespaceSchemaURL() {
         if (anonymousSchema == null) {
             return null;
         } else {
             return anonymousSchema.getSchemaLocationURL();
         }
     }
 
     /**
      * set a feature if it is supported, log at verbose level if
      * not
      * @param feature the feature.
      * @param value a <code>boolean</code> value.
      */
     protected void setFeatureIfSupported(String feature, boolean value) {
         try {
             getXmlReader().setFeature(feature, value);
         } catch (SAXNotRecognizedException e) {
             log("Not recognizied: " + feature, Project.MSG_VERBOSE);
         } catch (SAXNotSupportedException e) {
             log("Not supported: " + feature, Project.MSG_VERBOSE);
         }
     }
 
     /**
      * handler called on successful file validation.
      *
      * @param fileProcessed number of files processed.
      */
     protected void onSuccessfulValidation(int fileProcessed) {
         log(fileProcessed + MESSAGE_FILES_VALIDATED, Project.MSG_VERBOSE);
     }
 
     /**
      * representation of a schema location. This is a URI plus either a file or
      * a url
      */
     public static class SchemaLocation {
         private String namespace;
 
         private File file;
 
         private String url;
 
         /** No namespace URI */
         public static final String ERROR_NO_URI = "No namespace URI";
 
         /** Both URL and File were given for schema */
         public static final String ERROR_TWO_LOCATIONS
             = "Both URL and File were given for schema ";
 
         /** File not found */
         public static final String ERROR_NO_FILE = "File not found: ";
 
         /** Cannot make URL */
         public static final String ERROR_NO_URL_REPRESENTATION
             = "Cannot make a URL of ";
 
         /** No location provided */
         public static final String ERROR_NO_LOCATION
             = "No file or URL supplied for the schema ";
 
         /** No arg constructor */
         public SchemaLocation() {
         }
 
         /**
          * Get the namespace.
          * @return the namespace.
          */
         public String getNamespace() {
             return namespace;
         }
 
         /**
          * set the namespace of this schema. Any URI
          * @param namespace the namespace to use.
          */
         public void setNamespace(String namespace) {
             this.namespace = namespace;
         }
 
         /**
          * Get the file.
          * @return the file containing the schema.
          */
         public File getFile() {
             return file;
         }
 
         /**
          * identify a file that contains this namespace's schema.
          * The file must exist.
          * @param file the file contains the schema.
          */
         public void setFile(File file) {
             this.file = file;
         }
 
         /**
          * The URL containing the schema.
          * @return the URL string.
          */
         public String getUrl() {
             return url;
         }
 
         /**
          * identify a URL that hosts the schema.
          * @param url the URL string.
          */
         public void setUrl(String url) {
             this.url = url;
         }
 
         /**
          * get the URL of the schema
          * @return a URL to the schema
          * @throws BuildException if not
          */
         public String getSchemaLocationURL() {
             boolean hasFile = file != null;
             boolean hasURL = isSet(url);
             //error if both are empty, or both are set
             if (!hasFile && !hasURL) {
                 throw new BuildException(ERROR_NO_LOCATION + namespace);
             }
             if (hasFile && hasURL) {
                 throw new BuildException(ERROR_TWO_LOCATIONS + namespace);
             }
             String schema = url;
             if (hasFile) {
                 if (!file.exists()) {
                     throw new BuildException(ERROR_NO_FILE + file);
                 }
 
                 try {
                     schema = FileUtils.getFileUtils().getFileURL(file).toString();
                 } catch (MalformedURLException e) {
                     //this is almost implausible, but required handling
                     throw new BuildException(ERROR_NO_URL_REPRESENTATION + file, e);
                 }
             }
             return schema;
         }
 
         /**
          * validate the fields then create a "uri location" string
          *
          * @return string of uri and location
          * @throws BuildException if there is an error.
          */
         public String getURIandLocation() throws BuildException {
             validateNamespace();
             StringBuffer buffer = new StringBuffer();
             buffer.append(namespace);
             buffer.append(' ');
             buffer.append(getSchemaLocationURL());
             return new String(buffer);
         }
 
         /**
          * assert that a namespace is valid
          * @throws BuildException if not
          */
         public void validateNamespace() {
             if (!isSet(getNamespace())) {
                 throw new BuildException(ERROR_NO_URI);
             }
         }
 
         /**
          * check that a property is set
          * @param property string to check
          * @return true if it is not null or empty
          */
         private boolean isSet(String property) {
             return property != null && property.length() != 0;
         }
 
         /**
          * equality test checks namespace, location and filename. All must match,
          * @param o object to compare against
          * @return true iff the objects are considered equal in value
          */
 
         public boolean equals(Object o) {
             if (this == o) {
                 return true;
             }
             if (!(o instanceof SchemaLocation)) {
                 return false;
             }
 
             final SchemaLocation schemaLocation = (SchemaLocation) o;
 
             if (file != null ? !file.equals(schemaLocation.file) : schemaLocation.file != null) {
                 return false;
             }
             if (namespace != null ? !namespace.equals(schemaLocation.namespace)
                     : schemaLocation.namespace != null) {
                 return false;
             }
             if (url != null ? !url.equals(schemaLocation.url) : schemaLocation.url != null) {
                 return false;
             }
 
             return true;
         }
 
         /**
          * Generate a hashcode depending on the namespace, url and file name.
          * @return the hashcode.
          */
         public int hashCode() {
             int result;
             // CheckStyle:MagicNumber OFF
             result = (namespace != null ? namespace.hashCode() : 0);
             result = 29 * result + (file != null ? file.hashCode() : 0);
             result = 29 * result + (url != null ? url.hashCode() : 0);
             // CheckStyle:MagicNumber OFF
             return result;
         }
 
         /**
          * Returns a string representation of the object for error messages
          * and the like
          * @return a string representation of the object.
          */
         public String toString() {
             StringBuffer buffer = new StringBuffer();
             buffer.append(namespace != null ? namespace : "(anonymous)");
             buffer.append(' ');
             buffer.append(url != null ? (url + " ") : "");
             buffer.append(file != null ? file.getAbsolutePath() : "");
             return buffer.toString();
         }
     } //SchemaLocation
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ejb/DescriptorHandler.java b/src/main/org/apache/tools/ant/taskdefs/optional/ejb/DescriptorHandler.java
index e8392605b..202b7718c 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ejb/DescriptorHandler.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ejb/DescriptorHandler.java
@@ -1,389 +1,389 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.ejb;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.Hashtable;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.xml.sax.AttributeList;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 
 /**
  * Inner class used by EjbJar to facilitate the parsing of deployment
  * descriptors and the capture of appropriate information. Extends
  * HandlerBase so it only implements the methods needed. During parsing
  * creates a hashtable consisting of entries mapping the name it should be
  * inserted into an EJB jar as to a File representing the file on disk. This
  * list can then be accessed through the getFiles() method.
  */
 public class DescriptorHandler extends org.xml.sax.HandlerBase {
     private static final int DEFAULT_HASH_TABLE_SIZE = 10;
     private static final int STATE_LOOKING_EJBJAR = 1;
     private static final int STATE_IN_EJBJAR = 2;
     private static final int STATE_IN_BEANS = 3;
     private static final int STATE_IN_SESSION = 4;
     private static final int STATE_IN_ENTITY = 5;
     private static final int STATE_IN_MESSAGE = 6;
 
     private Task owningTask;
 
     private String publicId = null;
 
     /**
      * Bunch of constants used for storing entries in a hashtable, and for
      * constructing the filenames of various parts of the ejb jar.
      */
     private static final String EJB_REF               = "ejb-ref";
     private static final String EJB_LOCAL_REF         = "ejb-local-ref";
     private static final String HOME_INTERFACE        = "home";
     private static final String REMOTE_INTERFACE      = "remote";
     private static final String LOCAL_HOME_INTERFACE  = "local-home";
     private static final String LOCAL_INTERFACE       = "local";
     private static final String BEAN_CLASS            = "ejb-class";
     private static final String PK_CLASS              = "prim-key-class";
     private static final String EJB_NAME              = "ejb-name";
     private static final String EJB_JAR               = "ejb-jar";
     private static final String ENTERPRISE_BEANS      = "enterprise-beans";
     private static final String ENTITY_BEAN           = "entity";
     private static final String SESSION_BEAN          = "session";
     private static final String MESSAGE_BEAN          = "message-driven";
 
     /**
      * The state of the parsing
      */
     private int parseState = STATE_LOOKING_EJBJAR;
 
     // CheckStyle:VisibilityModifier OFF - bc
     /**
      * Instance variable used to store the name of the current element being
      * processed by the SAX parser.  Accessed by the SAX parser call-back methods
      * startElement() and endElement().
      */
     protected String currentElement = null;
 
     /**
      * The text of the current element
      */
     protected String currentText = null;
 
     /**
      * Instance variable that stores the names of the files as they will be
      * put into the jar file, mapped to File objects  Accessed by the SAX
      * parser call-back method characters().
      */
     protected Hashtable ejbFiles = null;
 
     /**
      * Instance variable that stores the value found in the &lt;ejb-name&gt; element
      */
     protected String ejbName = null;
 
     private Hashtable fileDTDs = new Hashtable();
 
     private Hashtable resourceDTDs = new Hashtable();
 
     private boolean inEJBRef = false;
 
     private Hashtable urlDTDs = new Hashtable();
     // CheckStyle:VisibilityModifier OFF - bc
 
     /**
      * The directory containing the bean classes and interfaces. This is
      * used for performing dependency file lookups.
      */
     private File srcDir;
 
     /**
      * Constructor for DescriptorHandler.
-     * @param task the task that owns this desciptor
+     * @param task the task that owns this descriptor
      * @param srcDir the source directory
      */
     public DescriptorHandler(Task task, File srcDir) {
         this.owningTask = task;
         this.srcDir = srcDir;
     }
 
     /**
      * Register a dtd with a location.
      * The location is one of a filename, a resource name in the classpath, or
      * a URL.
      * @param publicId the public identity of the dtd
      * @param location the location of the dtd
      */
     public void registerDTD(String publicId, String location) {
         if (location == null) {
             return;
         }
 
         File fileDTD = new File(location);
         if (!fileDTD.exists()) {
             // resolve relative to project basedir
             fileDTD = owningTask.getProject().resolveFile(location);
         }
 
         if (fileDTD.exists()) {
             if (publicId != null) {
                 fileDTDs.put(publicId, fileDTD);
                 owningTask.log("Mapped publicId " + publicId + " to file "
                     + fileDTD, Project.MSG_VERBOSE);
             }
             return;
         }
 
         if (getClass().getResource(location) != null) {
             if (publicId != null) {
                 resourceDTDs.put(publicId, location);
                 owningTask.log("Mapped publicId " + publicId + " to resource "
                     + location, Project.MSG_VERBOSE);
             }
         }
 
         try {
             if (publicId != null) {
                 URL urldtd = new URL(location);
                 urlDTDs.put(publicId, urldtd);
             }
         } catch (java.net.MalformedURLException e) {
             //ignored
         }
 
     }
 
     /**
      * Resolve the entity.
      * @see org.xml.sax.EntityResolver#resolveEntity(String, String).
      * @param publicId The public identifier, or <code>null</code>
      *                 if none is available.
      * @param systemId The system identifier provided in the XML
      *                 document. Will not be <code>null</code>.
      * @return an inputsource for this identifier
      * @throws SAXException if there is a problem.
      */
     public InputSource resolveEntity(String publicId, String systemId)
         throws SAXException {
         this.publicId = publicId;
 
         File dtdFile = (File) fileDTDs.get(publicId);
         if (dtdFile != null) {
             try {
                 owningTask.log("Resolved " + publicId + " to local file "
                     + dtdFile, Project.MSG_VERBOSE);
                 return new InputSource(new FileInputStream(dtdFile));
             } catch (FileNotFoundException ex) {
                 // ignore
             }
         }
 
         String dtdResourceName = (String) resourceDTDs.get(publicId);
         if (dtdResourceName != null) {
             InputStream is = this.getClass().getResourceAsStream(dtdResourceName);
             if (is != null) {
                 owningTask.log("Resolved " + publicId + " to local resource "
                     + dtdResourceName, Project.MSG_VERBOSE);
                 return new InputSource(is);
             }
         }
 
         URL dtdUrl = (URL) urlDTDs.get(publicId);
         if (dtdUrl != null) {
             try {
                 InputStream is = dtdUrl.openStream();
                 owningTask.log("Resolved " + publicId + " to url "
                     + dtdUrl, Project.MSG_VERBOSE);
                 return new InputSource(is);
             } catch (IOException ioe) {
                 //ignore
             }
         }
 
         owningTask.log("Could not resolve ( publicId: " + publicId
             + ", systemId: " + systemId + ") to a local entity", Project.MSG_INFO);
 
         return null;
     }
 
     /**
      * Getter method that returns the set of files to include in the EJB jar.
      * @return the map of files
      */
     public Hashtable getFiles() {
         return (ejbFiles == null) ? new Hashtable() : ejbFiles;
     }
 
     /**
      * Get the publicId of the DTD
      * @return the public id
      */
     public String getPublicId() {
         return publicId;
     }
 
      /**
      * Getter method that returns the value of the &lt;ejb-name&gt; element.
      * @return the ejb name
      */
     public String getEjbName() {
         return ejbName;
     }
 
     /**
      * SAX parser call-back method that is used to initialize the values of some
      * instance variables to ensure safe operation.
      * @throws SAXException on error
      */
     public void startDocument() throws SAXException {
         this.ejbFiles = new Hashtable(DEFAULT_HASH_TABLE_SIZE, 1);
         this.currentElement = null;
         inEJBRef = false;
     }
 
 
     /**
      * SAX parser call-back method that is invoked when a new element is entered
      * into.  Used to store the context (attribute name) in the currentAttribute
      * instance variable.
      * @param name The name of the element being entered.
      * @param attrs Attributes associated to the element.
      * @throws SAXException on error
      */
     public void startElement(String name, AttributeList attrs)
         throws SAXException {
         this.currentElement = name;
         currentText = "";
         if (name.equals(EJB_REF) || name.equals(EJB_LOCAL_REF)) {
             inEJBRef = true;
         } else if (parseState == STATE_LOOKING_EJBJAR && name.equals(EJB_JAR)) {
             parseState = STATE_IN_EJBJAR;
         } else if (parseState == STATE_IN_EJBJAR && name.equals(ENTERPRISE_BEANS)) {
             parseState = STATE_IN_BEANS;
         } else if (parseState == STATE_IN_BEANS && name.equals(SESSION_BEAN)) {
             parseState = STATE_IN_SESSION;
         } else if (parseState == STATE_IN_BEANS && name.equals(ENTITY_BEAN)) {
             parseState = STATE_IN_ENTITY;
         } else if (parseState == STATE_IN_BEANS && name.equals(MESSAGE_BEAN)) {
             parseState = STATE_IN_MESSAGE;
         }
     }
 
 
     /**
      * SAX parser call-back method that is invoked when an element is exited.
      * Used to blank out (set to the empty string, not nullify) the name of
      * the currentAttribute.  A better method would be to use a stack as an
      * instance variable, however since we are only interested in leaf-node
      * data this is a simpler and workable solution.
      * @param name The name of the attribute being exited. Ignored
      *        in this implementation.
      * @throws SAXException on error
      */
     public void endElement(String name) throws SAXException {
         processElement();
         currentText = "";
         this.currentElement = "";
         if (name.equals(EJB_REF) || name.equals(EJB_LOCAL_REF)) {
             inEJBRef = false;
         } else if (parseState == STATE_IN_ENTITY && name.equals(ENTITY_BEAN)) {
             parseState = STATE_IN_BEANS;
         } else if (parseState == STATE_IN_SESSION && name.equals(SESSION_BEAN)) {
             parseState = STATE_IN_BEANS;
         } else if (parseState == STATE_IN_MESSAGE && name.equals(MESSAGE_BEAN)) {
             parseState = STATE_IN_BEANS;
         } else if (parseState == STATE_IN_BEANS && name.equals(ENTERPRISE_BEANS)) {
             parseState = STATE_IN_EJBJAR;
         } else if (parseState == STATE_IN_EJBJAR && name.equals(EJB_JAR)) {
             parseState = STATE_LOOKING_EJBJAR;
         }
     }
 
     /**
      * SAX parser call-back method invoked whenever characters are located within
      * an element.  currentAttribute (modified by startElement and endElement)
      * tells us whether we are in an interesting element (one of the up to four
      * classes of an EJB).  If so then converts the classname from the format
      * org.apache.tools.ant.Parser to the convention for storing such a class,
      * org/apache/tools/ant/Parser.class.  This is then resolved into a file
      * object under the srcdir which is stored in a Hashtable.
      * @param ch A character array containing all the characters in
      *        the element, and maybe others that should be ignored.
      * @param start An integer marking the position in the char
      *        array to start reading from.
      * @param length An integer representing an offset into the
      *        char array where the current data terminates.
      * @throws SAXException on error
      */
     public void characters(char[] ch, int start, int length)
         throws SAXException {
 
         currentText += new String(ch, start, length);
     }
 
 
     /**
      * Called when an endelement is seen.
      * This may be overridden in derived classes.
      * This updates the ejbfiles if the element is an interface or a bean class.
      * This updates the ejbname if the element is an ejb name.
      */
     protected void processElement() {
         if (inEJBRef
             || (parseState != STATE_IN_ENTITY
                 && parseState != STATE_IN_SESSION
                 && parseState != STATE_IN_MESSAGE)) {
             return;
         }
 
         if (currentElement.equals(HOME_INTERFACE)
             || currentElement.equals(REMOTE_INTERFACE)
             || currentElement.equals(LOCAL_INTERFACE)
             || currentElement.equals(LOCAL_HOME_INTERFACE)
             || currentElement.equals(BEAN_CLASS)
             || currentElement.equals(PK_CLASS)) {
 
             // Get the filename into a String object
             File classFile = null;
             String className = currentText.trim();
 
             // If it's a primitive wrapper then we shouldn't try and put
             // it into the jar, so ignore it.
             if (!className.startsWith("java.")
                 && !className.startsWith("javax.")) {
                 // Translate periods into path separators, add .class to the
                 // name, create the File object and add it to the Hashtable.
                 className = className.replace('.', File.separatorChar);
                 className += ".class";
                 classFile = new File(srcDir, className);
                 ejbFiles.put(className, classFile);
             }
         }
 
         // Get the value of the <ejb-name> tag.  Only the first occurrence.
         if (currentElement.equals(EJB_NAME)) {
             if (ejbName == null) {
                 ejbName = currentText.trim();
             }
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ejb/EjbJar.java b/src/main/org/apache/tools/ant/taskdefs/optional/ejb/EjbJar.java
index f161ca078..cac1db92a 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ejb/EjbJar.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ejb/EjbJar.java
@@ -1,628 +1,628 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.ejb;
 
 // Standard java imports
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Path;
 import org.xml.sax.SAXException;
 
 /**
  * Provides automated EJB JAR file creation.
  * <p>
  * Extends the
  * MatchingTask class provided in the default ant distribution to provide a
  * directory scanning EJB jarfile generator.
  * </p>
  *
  * <p>
  * The task works by taking the deployment descriptors one at a time and
  * parsing them to locate the names of the classes which should be placed in
  * the jar. The classnames are translated to java.io.Files by replacing
  * periods with File.separatorChar and resolving the generated filename as a
  * relative path under the srcDir attribute. All necessary files are then
  * assembled into a jarfile. One jarfile is constructed for each deployment
  * descriptor found.
  * </p>
  *
  * */
 public class EjbJar extends MatchingTask {
 
     /**
      * Inner class used to record information about the location of a local DTD
      */
     public static class DTDLocation
         extends org.apache.tools.ant.types.DTDLocation {
     }
 
     /**
      * A class which contains the configuration state of the ejbjar task.
      * This state is passed to the deployment tools for configuration
      */
     static class Config {
         // CheckStyle:VisibilityModifier OFF - bc
         /**
          * Stores a handle to the directory under which to search for class
          * files
          */
         public File srcDir;
 
         /**
          * Stores a handle to the directory under which to search for
          * deployment descriptors
          */
         public File descriptorDir;
 
         /** Instance variable that marks the end of the 'basename' */
         public String baseNameTerminator = "-";
 
         /** Stores a handle to the destination EJB Jar file */
         public String baseJarName;
 
         /**
          * Instance variable that determines whether to use a package structure
          * of a flat directory as the destination for the jar files.
          */
         public boolean flatDestDir = false;
 
         /**
          * The classpath to use when loading classes
          */
         public Path classpath;
 
         /**
          * A Fileset of support classes
          */
         public List supportFileSets = new ArrayList();
 
         /**
          * The list of configured DTD locations
          */
         public ArrayList dtdLocations = new ArrayList();
 
         /**
          * The naming scheme used to determine the generated jar name
          * from the descriptor information
          */
         public NamingScheme namingScheme;
 
         /**
          * The Manifest file
          */
         public File manifest;
 
         /**
          * The dependency analyzer to use to add additional classes to the jar
          */
         public String analyzer;
         // CheckStyle:VisibilityModifier ON
     }
 
     /**
      * An EnumeratedAttribute class for handling different EJB jar naming
      * schemes
      */
     public static class NamingScheme extends EnumeratedAttribute {
         /**
          * Naming scheme where generated jar is determined from the ejb-name in
-         * the deployment descripor
+         * the deployment descriptor
          */
         public static final String EJB_NAME = "ejb-name";
 
         /**
          * Naming scheme where the generated jar name is based on the
          * name of the directory containing the deployment descriptor
          */
         public static final String DIRECTORY = "directory";
 
         /**
          * Naming scheme where the generated jar name is based on the name of
          * the deployment descriptor file
          */
         public static final String DESCRIPTOR = "descriptor";
 
         /**
          * Naming scheme where the generated jar is named by the basejarname
          * attribute
          */
         public static final String BASEJARNAME = "basejarname";
 
         /**
          * Gets the values of the NamingScheme
          *
          * @return an array of the values of this attribute class.
          */
         public String[] getValues() {
             return new String[] {EJB_NAME, DIRECTORY, DESCRIPTOR, BASEJARNAME};
         }
     }
 
     /**
      * CMP versions supported
      * valid CMP versions are 1.0 and 2.0
      * @since ant 1.6
      */
     public static class CMPVersion extends EnumeratedAttribute {
         /** 1.0 value */
         public static final String CMP1_0 = "1.0";
         /** 2.0 value */
         public static final String CMP2_0 = "2.0";
         /** {@inheritDoc}. */
         public String[] getValues() {
             return new String[]{
                 CMP1_0,
                 CMP2_0,
             };
         }
     }
     /**
      * The config which is built by this task and used by the various deployment
      * tools to access the configuration of the ejbjar task
      */
     private Config config = new Config();
 
 
     /**
      * Stores a handle to the directory to put the Jar files in. This is
      * only used by the generic deployment descriptor tool which is created
      * if no other deployment descriptor tools are provided. Normally each
      * deployment tool will specify the desitination dir itself.
      */
     private File destDir;
 
     /** Instance variable that stores the suffix for the generated jarfile. */
     private String genericJarSuffix = "-generic.jar";
 
     /** Instance variable that stores the CMP version for the jboss jarfile. */
     private String cmpVersion = CMPVersion.CMP1_0;
 
     /** The list of deployment tools we are going to run. */
     private ArrayList deploymentTools = new ArrayList();
 
     /**
      * Add a deployment tool to the list of deployment tools that will be
      * processed
      *
      * @param deploymentTool a deployment tool instance to which descriptors
      *        will be passed for processing.
      */
     protected void addDeploymentTool(EJBDeploymentTool deploymentTool) {
         deploymentTool.setTask(this);
         deploymentTools.add(deploymentTool);
     }
 
     /**
      * Adds a deployment tool for Weblogic server.
      *
      * @return the deployment tool instance to be configured.
      */
     public WeblogicDeploymentTool createWeblogic() {
         WeblogicDeploymentTool tool = new WeblogicDeploymentTool();
         addDeploymentTool(tool);
         return tool;
     }
 
     /**
      * Adds a deployment tool for Websphere 4.0 server.
      *
      * @return the deployment tool instance to be configured.
      */
     public WebsphereDeploymentTool createWebsphere() {
         WebsphereDeploymentTool tool = new WebsphereDeploymentTool();
         addDeploymentTool(tool);
         return tool;
     }
 
     /**
      * Adds a deployment tool for Borland server.
      *
      * @return the deployment tool instance to be configured.
      */
     public BorlandDeploymentTool createBorland() {
         log("Borland deployment tools",  Project.MSG_VERBOSE);
 
         BorlandDeploymentTool tool = new BorlandDeploymentTool();
         tool.setTask(this);
         deploymentTools.add(tool);
         return tool;
     }
 
     /**
      * Adds a deployment tool for iPlanet Application Server.
      *
      * @return the deployment tool instance to be configured.
      */
     public IPlanetDeploymentTool createIplanet() {
         log("iPlanet Application Server deployment tools", Project.MSG_VERBOSE);
 
         IPlanetDeploymentTool tool = new IPlanetDeploymentTool();
         addDeploymentTool(tool);
         return tool;
     }
 
     /**
      * Adds a deployment tool for JBoss server.
      *
      * @return the deployment tool instance to be configured.
      */
     public JbossDeploymentTool createJboss() {
         JbossDeploymentTool tool = new JbossDeploymentTool();
         addDeploymentTool(tool);
         return tool;
     }
 
     /**
      * Adds a deployment tool for JOnAS server.
      *
      * @return the deployment tool instance to be configured.
      */
     public JonasDeploymentTool createJonas() {
         log("JOnAS deployment tools",  Project.MSG_VERBOSE);
 
         JonasDeploymentTool tool = new JonasDeploymentTool();
         addDeploymentTool(tool);
         return tool;
     }
 
     /**
      * Adds a deployment tool for Weblogic when using the Toplink
      * Object-Relational mapping.
      *
      * @return the deployment tool instance to be configured.
      */
     public WeblogicTOPLinkDeploymentTool createWeblogictoplink() {
         log("The <weblogictoplink> element is no longer required. Please use "
             + "the <weblogic> element and set newCMP=\"true\"",
             Project.MSG_INFO);
         WeblogicTOPLinkDeploymentTool tool
             = new WeblogicTOPLinkDeploymentTool();
         addDeploymentTool(tool);
         return tool;
     }
 
     /**
      * Adds to the classpath used to locate the super classes and
      * interfaces of the classes that will make up the EJB JAR.
      *
      * @return the path to be configured.
      */
     public Path createClasspath() {
         if (config.classpath == null) {
             config.classpath = new Path(getProject());
         }
         return config.classpath.createPath();
     }
 
     /**
      * Create a DTD location record. This stores the location of a DTD. The
      * DTD is identified by its public Id. The location may either be a file
      * location or a resource location.
      *
      * @return the DTD location object to be configured by Ant
      */
     public DTDLocation createDTD() {
         DTDLocation dtdLocation = new DTDLocation();
         config.dtdLocations.add(dtdLocation);
 
         return dtdLocation;
     }
 
     /**
      * Adds a fileset for support elements.
      *
      * @return a fileset which can be populated with support files.
      */
     public FileSet createSupport() {
         FileSet supportFileSet = new FileSet();
         config.supportFileSets.add(supportFileSet);
         return supportFileSet;
     }
 
 
     /**
      * Set the Manifest file to use when jarring. As of EJB 1.1, manifest
      * files are no longer used to configure the EJB. However, they still
      * have a vital importance if the EJB is intended to be packaged in an
      * EAR file. By adding "Class-Path" settings to a Manifest file, the EJB
      * can look for classes inside the EAR file itself, allowing for easier
      * deployment. This is outlined in the J2EE specification, and all J2EE
      * components are meant to support it.
      *
      * @param manifest the manifest to be used in the EJB jar
      */
      public void setManifest(File manifest) {
          config.manifest = manifest;
      }
 
     /**
      * Sets the source directory, which is the directory that
      * contains the classes that will be added to the EJB jar. Typically
      * this will include the home and remote interfaces and the bean class.
      *
      * @param inDir the source directory.
      */
     public void setSrcdir(File inDir) {
         config.srcDir = inDir;
     }
 
     /**
      * Set the descriptor directory. The descriptor directory contains the
      * EJB deployment descriptors. These are XML files that declare the
      * properties of a bean in a particular deployment scenario. Such
      * properties include, for example, the transactional nature of the bean
      * and the security access control to the bean's methods.
      *
      * @param inDir the directory containing the deployment descriptors.
      */
     public void setDescriptordir(File inDir) {
         config.descriptorDir = inDir;
     }
 
     /**
      * Set the analyzer to use when adding in dependencies to the JAR.
      *
      * @param analyzer the name of the dependency analyzer or a class.
      */
     public void setDependency(String analyzer) {
         config.analyzer = analyzer;
     }
 
     /**
      * Set the base name of the EJB JAR that is to be created if it is not
      * to be determined from the name of the deployment descriptor files.
      *
      * @param inValue the basename that will be used when writing the jar
      *      file containing the EJB
      */
     public void setBasejarname(String inValue) {
         config.baseJarName = inValue;
         if (config.namingScheme == null) {
             config.namingScheme = new NamingScheme();
             config.namingScheme.setValue(NamingScheme.BASEJARNAME);
         } else if (!config.namingScheme.getValue().equals(NamingScheme.BASEJARNAME)) {
             throw new BuildException("The basejarname attribute is not "
                 + "compatible with the "
                 + config.namingScheme.getValue() + " naming scheme");
         }
     }
 
     /**
      * Set the naming scheme used to determine the name of the generated jars
      * from the deployment descriptor
      *
      * @param namingScheme the naming scheme to be used
      */
     public void setNaming(NamingScheme namingScheme) {
         config.namingScheme = namingScheme;
         if (!config.namingScheme.getValue().equals(NamingScheme.BASEJARNAME)
             && config.baseJarName != null) {
             throw new BuildException("The basejarname attribute is not "
                 + "compatible with the "
                 + config.namingScheme.getValue() + " naming scheme");
         }
     }
 
     /**
      * Gets the destination directory.
      *
      * @return destination directory
      * @since ant 1.6
      */
     public File getDestdir() {
         return this.destDir;
     }
 
     /**
      * Set the destination directory. The EJB jar files will be written into
      * this directory. The jar files that exist in this directory are also
      * used when determining if the contents of the jar file have changed.
      * Note that this parameter is only used if no deployment tools are
      * specified. Typically each deployment tool will specify its own
      * destination directory.
      *
      * @param inDir the destination directory in which to generate jars
      */
     public void setDestdir(File inDir) {
         this.destDir = inDir;
     }
 
     /**
      * Gets the CMP version.
      *
      * @return CMP version
      * @since ant 1.6
      */
     public String getCmpversion() {
         return this.cmpVersion;
     }
 
     /**
      * Sets the CMP version.
      *
      * @param version CMP version.
      * Must be either <code>1.0</code> or <code>2.0</code>.<br/>
      * Default is <code>1.0</code>.<br/>
      * Initially, only the JBoss implementation does something specific for CMP 2.0.<br/>
      * @since ant 1.6
      */
     public void setCmpversion(CMPVersion version) {
         this.cmpVersion = version.getValue();
     }
 
     /**
      * Set the classpath to use when resolving classes for inclusion in the jar.
      *
      * @param classpath the classpath to use.
      */
     public void setClasspath(Path classpath) {
         config.classpath = classpath;
     }
 
     /**
      * Controls whether the
      * destination JARs are written out in the destination directory with
      * the same hierarchical structure from which the deployment descriptors
      * have been read. If this is set to true the generated EJB jars are
      * written into the root of the destination directory, otherwise they
      * are written out in the same relative position as the deployment
      * descriptors in the descriptor directory.
      *
      * @param inValue the new value of the flatdestdir flag.
      */
     public void setFlatdestdir(boolean inValue) {
         config.flatDestDir = inValue;
     }
 
     /**
      * Set the suffix for the generated jar file. When generic jars are
      * generated, they have a suffix which is appended to the the bean name
      * to create the name of the jar file. Note that this suffix includes
      * the extension fo te jar file and should therefore end with an
      * appropriate extension such as .jar or .ear
      *
      * @param inString the string to use as the suffix.
      */
     public void setGenericjarsuffix(String inString) {
         this.genericJarSuffix = inString;
     }
 
     /**
      * The string which terminates the bean name.
      * The convention used by this task is
      * that bean descriptors are named as the BeanName with some suffix. The
      * baseNameTerminator string separates the bean name and the suffix and
      * is used to determine the bean name.
      *
      * @param inValue a string which marks the end of the basename.
      */
     public void setBasenameterminator(String inValue) {
         config.baseNameTerminator = inValue;
     }
 
     /**
      * Validate the config that has been configured from the build file
      *
      * @throws BuildException if the config is not valid
      */
     private void validateConfig() throws BuildException {
         if (config.srcDir == null) {
             throw new BuildException("The srcDir attribute must be specified");
         }
 
         if (config.descriptorDir == null) {
             config.descriptorDir = config.srcDir;
         }
 
         if (config.namingScheme == null) {
             config.namingScheme = new NamingScheme();
             config.namingScheme.setValue(NamingScheme.DESCRIPTOR);
         } else if (config.namingScheme.getValue().equals(NamingScheme.BASEJARNAME)
                     && config.baseJarName == null) {
             throw new BuildException("The basejarname attribute must "
                 + "be specified with the basejarname naming scheme");
         }
     }
 
     /**
      * Invoked by Ant after the task is prepared, when it is ready to execute
      * this task.
      *
      * This will configure all of the nested deployment tools to allow them to
      * process the jar. If no deployment tools have been configured a generic
      * tool is created to handle the jar.
      *
      * A parser is configured and then each descriptor found is passed to all
      * the deployment tool elements for processing.
      *
      * @exception BuildException thrown whenever a problem is
      *            encountered that cannot be recovered from, to signal to ant
      *            that a major problem occurred within this task.
      */
     public void execute() throws BuildException {
         validateConfig();
 
         if (deploymentTools.size() == 0) {
             GenericDeploymentTool genericTool = new GenericDeploymentTool();
             genericTool.setTask(this);
             genericTool.setDestdir(destDir);
             genericTool.setGenericJarSuffix(genericJarSuffix);
             deploymentTools.add(genericTool);
         }
 
         for (Iterator i = deploymentTools.iterator(); i.hasNext();) {
             EJBDeploymentTool tool = (EJBDeploymentTool) i.next();
             tool.configure(config);
             tool.validateConfigured();
         }
 
         try {
             // Create the parser using whatever parser the system dictates
             SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
             saxParserFactory.setValidating(true);
             SAXParser saxParser = saxParserFactory.newSAXParser();
 
 
             DirectoryScanner ds = getDirectoryScanner(config.descriptorDir);
             ds.scan();
             String[] files = ds.getIncludedFiles();
 
             log(files.length + " deployment descriptors located.",
                 Project.MSG_VERBOSE);
 
             // Loop through the files. Each file represents one deployment
             // descriptor, and hence one bean in our model.
             for (int index = 0; index < files.length; ++index) {
                 // process the deployment descriptor in each tool
                 for (Iterator i = deploymentTools.iterator(); i.hasNext();) {
                     EJBDeploymentTool tool = (EJBDeploymentTool) i.next();
                     tool.processDescriptor(files[index], saxParser);
                 }
             }
         } catch (SAXException se) {
             String msg = "SAXException while creating parser."
                 + "  Details: "
                 + se.getMessage();
             throw new BuildException(msg, se);
         } catch (ParserConfigurationException pce) {
             String msg = "ParserConfigurationException while creating parser. "
                        + "Details: " + pce.getMessage();
             throw new BuildException(msg, pce);
         }
     } // end of execute()
 
 }
 
 
 
 
 
 
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java b/src/main/org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java
index 2cb67e36f..069bdfcf9 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java
@@ -1,953 +1,953 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.ejb;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.jar.JarOutputStream;
 import java.util.jar.Manifest;
 import java.util.zip.ZipEntry;
 
 import javax.xml.parsers.SAXParser;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Location;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.depend.DependencyAnalyzer;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 
 
 /**
  * A deployment tool which creates generic EJB jars. Generic jars contains
  * only those classes and META-INF entries specified in the EJB 1.1 standard
  *
  * This class is also used as a framework for the creation of vendor specific
  * deployment tools. A number of template methods are provided through which the
  * vendor specific tool can hook into the EJB creation process.
  *
  */
 public class GenericDeploymentTool implements EJBDeploymentTool {
     /** The default buffer byte size to use for IO */
     public static final int DEFAULT_BUFFER_SIZE = 1024;
     /** The level to use for compression */
     public static final int JAR_COMPRESS_LEVEL  = 9;
 
     /** The standard META-INF directory in jar files */
     protected static final String META_DIR  = "META-INF/";
 
     /** The standard MANIFEST file */
     protected static final String MANIFEST  = META_DIR + "MANIFEST.MF";
 
     /** Name for EJB Deployment descriptor within EJB jars */
     protected static final String EJB_DD    = "ejb-jar.xml";
 
     /** A dependency analyzer name to find ancestor classes */
     public static final String ANALYZER_SUPER = "super";
     /** A dependency analyzer name to find all related classes */
     public static final String ANALYZER_FULL = "full";
     /** A dependency analyzer name for no analyzer */
     public static final String ANALYZER_NONE = "none";
 
     /** The default analyzer */
     public static final String DEFAULT_ANALYZER = ANALYZER_SUPER;
 
     /** The analyzer class for the super analyzer */
     public static final String ANALYZER_CLASS_SUPER
         = "org.apache.tools.ant.util.depend.bcel.AncestorAnalyzer";
     /** The analyzer class for the super analyzer */
     public static final String ANALYZER_CLASS_FULL
         = "org.apache.tools.ant.util.depend.bcel.FullAnalyzer";
 
     /**
      * The configuration from the containing task. This config combined
      * with the settings of the individual attributes here constitues the
      * complete config for this deployment tool.
      */
     private EjbJar.Config config;
 
     /** Stores a handle to the directory to put the Jar files in */
     private File destDir;
 
     /** The classpath to use with this deployment tool. This is appended to
         any paths from the ejbjar task itself.*/
     private Path classpath;
 
     /** Instance variable that stores the suffix for the generated jarfile. */
     private String genericJarSuffix = "-generic.jar";
 
     /**
      * The task to which this tool belongs. This is used to access services
      * provided by the ant core, such as logging.
      */
     private Task task;
 
     /**
      * The classloader generated from the given classpath to load
      * the super classes and super interfaces.
      */
     private ClassLoader classpathLoader = null;
 
      /**
      * Set of files have been loaded into the EJB jar
      */
     private Set addedfiles;
 
     /**
      * Handler used to parse the EJB XML descriptor
      */
     private DescriptorHandler handler;
 
     /**
      * Dependency analyzer used to collect class dependencies
      */
     private DependencyAnalyzer dependencyAnalyzer;
 
     /** No arg constructor */
     public GenericDeploymentTool() {
     }
 
 
     /**
      * Set the destination directory; required.
      * @param inDir the destination directory.
      */
     public void setDestdir(File inDir) {
         this.destDir = inDir;
     }
 
     /**
      * Get the destination directory.
      *
      * @return the destination directory into which EJB jars are to be written
      */
     protected File getDestDir() {
         return destDir;
     }
 
 
     /**
      * Set the task which owns this tool
      *
      * @param task the Task to which this deployment tool is associated.
      */
     public void setTask(Task task) {
         this.task = task;
     }
 
     /**
      * Get the task for this tool.
      *
      * @return the Task instance this tool is associated with.
      */
     protected Task getTask() {
         return task;
     }
 
     /**
      * Get the basename terminator.
      *
      * @return an ejbjar task configuration
      */
     protected EjbJar.Config getConfig() {
         return config;
     }
 
     /**
      * Indicate if this build is using the base jar name.
      *
      * @return true if the name of the generated jar is coming from the
      *              basejarname attribute
      */
     protected boolean usingBaseJarName() {
         return config.baseJarName != null;
     }
 
     /**
      * Set the suffix for the generated jar file.
      * @param inString the string to use as the suffix.
      */
     public void setGenericJarSuffix(String inString) {
         this.genericJarSuffix = inString;
     }
 
     /**
      * Add the classpath for the user classes
      *
      * @return a Path instance to be configured by Ant.
      */
     public Path createClasspath() {
         if (classpath == null) {
             classpath = new Path(task.getProject());
         }
         return classpath.createPath();
     }
 
     /**
      * Set the classpath to be used for this compilation.
      *
      * @param classpath the classpath to be used for this build.
      */
     public void setClasspath(Path classpath) {
         this.classpath = classpath;
     }
 
     /**
      * Get the classpath by combining the one from the surrounding task, if any
      * and the one from this tool.
      *
      * @return the combined classpath
      */
     protected Path getCombinedClasspath() {
         Path combinedPath = classpath;
         if (config.classpath != null) {
             if (combinedPath == null) {
                 combinedPath = config.classpath;
             } else {
                 combinedPath.append(config.classpath);
             }
         }
 
         return combinedPath;
     }
 
     /**
      * Log a message to the Ant output.
      *
      * @param message the message to be logged.
      * @param level the severity of this message.
      */
     protected void log(String message, int level) {
         getTask().log(message, level);
     }
 
     /**
      * Get the build file location associated with this element's task.
      *
      * @return the task's location instance.
      */
     protected Location getLocation() {
         return getTask().getLocation();
     }
 
     private void createAnalyzer() {
         String analyzer = config.analyzer;
         if (analyzer == null) {
             analyzer = DEFAULT_ANALYZER;
         }
 
         if (analyzer.equals(ANALYZER_NONE)) {
             return;
         }
 
         String analyzerClassName = null;
         if (analyzer.equals(ANALYZER_SUPER)) {
             analyzerClassName = ANALYZER_CLASS_SUPER;
         } else if (analyzer.equals(ANALYZER_FULL)) {
             analyzerClassName = ANALYZER_CLASS_FULL;
         } else {
             analyzerClassName = analyzer;
         }
 
         try {
             Class analyzerClass = Class.forName(analyzerClassName);
             dependencyAnalyzer
                 = (DependencyAnalyzer) analyzerClass.newInstance();
             dependencyAnalyzer.addClassPath(new Path(task.getProject(),
                 config.srcDir.getPath()));
             dependencyAnalyzer.addClassPath(config.classpath);
         } catch (NoClassDefFoundError e) {
             dependencyAnalyzer = null;
             task.log("Unable to load dependency analyzer: " + analyzerClassName
                 + " - dependent class not found: " + e.getMessage(),
                 Project.MSG_WARN);
         } catch (Exception e) {
             dependencyAnalyzer = null;
             task.log("Unable to load dependency analyzer: " + analyzerClassName
                      + " - exception: " + e.getMessage(),
                 Project.MSG_WARN);
         }
     }
 
 
     /**
      * Configure this tool for use in the ejbjar task.
      *
      * @param config the configuration from the surrounding ejbjar task.
      */
     public void configure(EjbJar.Config config) {
         this.config = config;
 
         createAnalyzer();
         classpathLoader = null;
     }
 
     /**
      * Utility method that encapsulates the logic of adding a file entry to
      * a .jar file.  Used by execute() to add entries to the jar file as it is
      * constructed.
      * @param jStream A JarOutputStream into which to write the
      *        jar entry.
      * @param inputFile A File from which to read the
      *        contents the file being added.
      * @param logicalFilename A String representing the name, including
      *        all relevant path information, that should be stored for the entry
      *        being added.
      * @throws BuildException if there is a problem.
      */
     protected void addFileToJar(JarOutputStream jStream,
                                 File inputFile,
                                 String logicalFilename)
         throws BuildException {
         FileInputStream iStream = null;
         try {
             if (!addedfiles.contains(logicalFilename)) {
                 iStream = new FileInputStream(inputFile);
                 // Create the zip entry and add it to the jar file
                 ZipEntry zipEntry = new ZipEntry(logicalFilename.replace('\\', '/'));
                 jStream.putNextEntry(zipEntry);
 
                 // Create the file input stream, and buffer everything over
                 // to the jar output stream
                 byte[] byteBuffer = new byte[2 * DEFAULT_BUFFER_SIZE];
                 int count = 0;
                 do {
                     jStream.write(byteBuffer, 0, count);
                     count = iStream.read(byteBuffer, 0, byteBuffer.length);
                 } while (count != -1);
 
                 //add it to list of files in jar
                 addedfiles.add(logicalFilename);
            }
         } catch (IOException ioe) {
             log("WARNING: IOException while adding entry "
                 + logicalFilename + " to jarfile from "
                 + inputFile.getPath() + " "  + ioe.getClass().getName()
                 + "-" + ioe.getMessage(), Project.MSG_WARN);
         } finally {
             // Close up the file input stream for the class file
             if (iStream != null) {
                 try {
                     iStream.close();
                 } catch (IOException closeException) {
                     // ignore
                 }
             }
         }
     }
 
     /**
      * Get a descriptionHandler.
      * @param srcDir the source directory.
      * @return a handler.
      */
     protected DescriptorHandler getDescriptorHandler(File srcDir) {
         DescriptorHandler h = new DescriptorHandler(getTask(), srcDir);
 
         registerKnownDTDs(h);
 
         // register any DTDs supplied by the user
         for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
             EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
             h.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
         }
         return h;
     }
 
     /**
      * Register the locations of all known DTDs.
      *
      * vendor-specific subclasses should override this method to define
      * the vendor-specific locations of the EJB DTDs
      * @param handler no used in this class.
      */
     protected void registerKnownDTDs(DescriptorHandler handler) {
         // none to register for generic
     }
 
     /** {@inheritDoc}. */
     public void processDescriptor(String descriptorFileName, SAXParser saxParser) {
 
         checkConfiguration(descriptorFileName, saxParser);
 
         try {
             handler = getDescriptorHandler(config.srcDir);
 
             // Retrive the files to be added to JAR from EJB descriptor
             Hashtable ejbFiles = parseEjbFiles(descriptorFileName, saxParser);
 
             // Add any support classes specified in the build file
             addSupportClasses(ejbFiles);
 
             // Determine the JAR filename (without filename extension)
             String baseName = getJarBaseName(descriptorFileName);
 
             String ddPrefix = getVendorDDPrefix(baseName, descriptorFileName);
 
             File manifestFile = getManifestFile(ddPrefix);
             if (manifestFile != null) {
                 ejbFiles.put(MANIFEST, manifestFile);
             }
 
 
 
             // First the regular deployment descriptor
             ejbFiles.put(META_DIR + EJB_DD,
                          new File(config.descriptorDir, descriptorFileName));
 
             // now the vendor specific files, if any
             addVendorFiles(ejbFiles, ddPrefix);
 
             // add any dependent files
             checkAndAddDependants(ejbFiles);
 
             // Lastly create File object for the Jar files. If we are using
             // a flat destination dir, then we need to redefine baseName!
             if (config.flatDestDir && baseName.length() != 0) {
                 int startName = baseName.lastIndexOf(File.separator);
                 if (startName == -1) {
                     startName = 0;
                 }
 
                 int endName   = baseName.length();
                 baseName = baseName.substring(startName, endName);
             }
 
             File jarFile = getVendorOutputJarFile(baseName);
 
 
             // Check to see if we need a build and start doing the work!
             if (needToRebuild(ejbFiles, jarFile)) {
                 // Log that we are going to build...
                 log("building "
                               + jarFile.getName()
                               + " with "
                               + String.valueOf(ejbFiles.size())
                               + " files",
                               Project.MSG_INFO);
 
                 // Use helper method to write the jarfile
                 String publicId = getPublicId();
                 writeJar(baseName, jarFile, ejbFiles, publicId);
 
             } else {
                 // Log that the file is up to date...
                 log(jarFile.toString() + " is up to date.",
                               Project.MSG_VERBOSE);
             }
 
         } catch (SAXException se) {
             String msg = "SAXException while parsing '"
                 + descriptorFileName
                 + "'. This probably indicates badly-formed XML."
                 + "  Details: "
                 + se.getMessage();
             throw new BuildException(msg, se);
         } catch (IOException ioe) {
             String msg = "IOException while parsing'"
                 + descriptorFileName
                 + "'.  This probably indicates that the descriptor"
                 + " doesn't exist. Details: "
                 + ioe.getMessage();
             throw new BuildException(msg, ioe);
         }
     }
 
     /**
      * This method is called as the first step in the processDescriptor method
      * to allow vendor-specific subclasses to validate the task configuration
      * prior to processing the descriptor.  If the configuration is invalid,
      * a BuildException should be thrown.
      *
      * @param descriptorFileName String representing the file name of an EJB
      *                           descriptor to be processed
      * @param saxParser          SAXParser which may be used to parse the XML
      *                           descriptor
      * @throws BuildException if there is a problem.
      */
     protected void checkConfiguration(String descriptorFileName,
                                     SAXParser saxParser) throws BuildException {
 
         /*
          * For the GenericDeploymentTool, do nothing.  Vendor specific
          * subclasses should throw a BuildException if the configuration is
          * invalid for their server.
          */
     }
 
     /**
      * This method returns a list of EJB files found when the specified EJB
      * descriptor is parsed and processed.
      *
      * @param descriptorFileName String representing the file name of an EJB
      *                           descriptor to be processed
      * @param saxParser          SAXParser which may be used to parse the XML
      *                           descriptor
      * @return                   Hashtable of EJB class (and other) files to be
      *                           added to the completed JAR file
      * @throws SAXException      Any SAX exception, possibly wrapping another
      *                           exception
      * @throws IOException       An IOException from the parser, possibly from a
      *                           the byte stream or character stream
      */
     protected Hashtable parseEjbFiles(String descriptorFileName, SAXParser saxParser)
                             throws IOException, SAXException {
         FileInputStream descriptorStream = null;
         Hashtable ejbFiles = null;
 
         try {
 
             /* Parse the ejb deployment descriptor.  While it may not
              * look like much, we use a SAXParser and an inner class to
              * get hold of all the classfile names for the descriptor.
              */
             descriptorStream
                 = new FileInputStream(new File(config.descriptorDir, descriptorFileName));
             saxParser.parse(new InputSource(descriptorStream), handler);
 
             ejbFiles = handler.getFiles();
 
         } finally {
             if (descriptorStream != null) {
                 try {
                     descriptorStream.close();
                 } catch (IOException closeException) {
                     // ignore
                 }
             }
         }
 
         return ejbFiles;
     }
 
     /**
      * Adds any classes the user specifies using <i>support</i> nested elements
      * to the <code>ejbFiles</code> Hashtable.
      *
      * @param ejbFiles Hashtable of EJB classes (and other) files that will be
      *                 added to the completed JAR file
      */
     protected void addSupportClasses(Hashtable ejbFiles) {
         // add in support classes if any
         Project project = task.getProject();
         for (Iterator i = config.supportFileSets.iterator(); i.hasNext();) {
             FileSet supportFileSet = (FileSet) i.next();
             File supportBaseDir = supportFileSet.getDir(project);
             DirectoryScanner supportScanner = supportFileSet.getDirectoryScanner(project);
             supportScanner.scan();
             String[] supportFiles = supportScanner.getIncludedFiles();
             for (int j = 0; j < supportFiles.length; ++j) {
                 ejbFiles.put(supportFiles[j], new File(supportBaseDir, supportFiles[j]));
             }
         }
     }
 
 
     /**
      * Using the EJB descriptor file name passed from the <code>ejbjar</code>
      * task, this method returns the "basename" which will be used to name the
      * completed JAR file.
      *
      * @param descriptorFileName String representing the file name of an EJB
      *                           descriptor to be processed
      * @return                   The "basename" which will be used to name the
      *                           completed JAR file
      */
     protected String getJarBaseName(String descriptorFileName) {
 
         String baseName = "";
 
         // Work out what the base name is
         if (config.namingScheme.getValue().equals(EjbJar.NamingScheme.BASEJARNAME)) {
             String canonicalDescriptor = descriptorFileName.replace('\\', '/');
             int index = canonicalDescriptor.lastIndexOf('/');
             if (index != -1) {
                 baseName = descriptorFileName.substring(0, index + 1);
             }
             baseName += config.baseJarName;
         } else if (config.namingScheme.getValue().equals(EjbJar.NamingScheme.DESCRIPTOR)) {
             int lastSeparatorIndex = descriptorFileName.lastIndexOf(File.separator);
             int endBaseName = -1;
             if (lastSeparatorIndex != -1) {
                 endBaseName = descriptorFileName.indexOf(config.baseNameTerminator,
                                                             lastSeparatorIndex);
             } else {
                 endBaseName = descriptorFileName.indexOf(config.baseNameTerminator);
             }
 
             if (endBaseName != -1) {
                 baseName = descriptorFileName.substring(0, endBaseName);
             } else {
                 throw new BuildException("Unable to determine jar name "
                     + "from descriptor \"" + descriptorFileName + "\"");
             }
         } else if (config.namingScheme.getValue().equals(EjbJar.NamingScheme.DIRECTORY)) {
             File descriptorFile = new File(config.descriptorDir, descriptorFileName);
             String path = descriptorFile.getAbsolutePath();
             int lastSeparatorIndex
                 = path.lastIndexOf(File.separator);
             if (lastSeparatorIndex == -1) {
                 throw new BuildException("Unable to determine directory name holding descriptor");
             }
             String dirName = path.substring(0, lastSeparatorIndex);
             int dirSeparatorIndex = dirName.lastIndexOf(File.separator);
             if (dirSeparatorIndex != -1) {
                 dirName = dirName.substring(dirSeparatorIndex + 1);
             }
 
             baseName = dirName;
         } else if (config.namingScheme.getValue().equals(EjbJar.NamingScheme.EJB_NAME)) {
             baseName = handler.getEjbName();
         }
         return baseName;
     }
 
     /**
      * Get the prefix for vendor deployment descriptors.
      *
      * This will contain the path and the start of the descriptor name,
      * depending on the naming scheme
      * @param baseName the base name to use.
      * @param descriptorFileName the file name to use.
      * @return the prefix.
      */
     public String getVendorDDPrefix(String baseName, String descriptorFileName) {
         String ddPrefix = null;
 
         if (config.namingScheme.getValue().equals(EjbJar.NamingScheme.DESCRIPTOR)) {
             ddPrefix = baseName + config.baseNameTerminator;
         } else if (config.namingScheme.getValue().equals(EjbJar.NamingScheme.BASEJARNAME)
             || config.namingScheme.getValue().equals(EjbJar.NamingScheme.EJB_NAME)
             || config.namingScheme.getValue().equals(EjbJar.NamingScheme.DIRECTORY)) {
             String canonicalDescriptor = descriptorFileName.replace('\\', '/');
             int index = canonicalDescriptor.lastIndexOf('/');
             if (index == -1) {
                 ddPrefix = "";
             } else {
                 ddPrefix = descriptorFileName.substring(0, index + 1);
             }
         }
         return ddPrefix;
     }
 
     /**
      * Add any vendor specific files which should be included in the
      * EJB Jar.
      * @param ejbFiles a hashtable entryname -> file.
      * @param ddPrefix a prefix to use.
      */
     protected void addVendorFiles(Hashtable ejbFiles, String ddPrefix) {
         // nothing to add for generic tool.
     }
 
 
     /**
      * Get the vendor specific name of the Jar that will be output. The modification date
      * of this jar will be checked against the dependent bean classes.
      * @param baseName the basename to use.
      */
     File getVendorOutputJarFile(String baseName) {
         return new File(destDir, baseName + genericJarSuffix);
     }
 
     /**
      * This method checks the timestamp on each file listed in the <code>
      * ejbFiles</code> and compares them to the timestamp on the <code>jarFile
      * </code>.  If the <code>jarFile</code>'s timestamp is more recent than
      * each EJB file, <code>true</code> is returned.  Otherwise, <code>false
      * </code> is returned.
      * TODO: find a way to check the manifest-file, that is found by naming convention
      *
      * @param ejbFiles Hashtable of EJB classes (and other) files that will be
      *                 added to the completed JAR file
      * @param jarFile  JAR file which will contain all of the EJB classes (and
      *                 other) files
      * @return         boolean indicating whether or not the <code>jarFile</code>
      *                 is up to date
      */
     protected boolean needToRebuild(Hashtable ejbFiles, File jarFile) {
         if (jarFile.exists()) {
             long lastBuild = jarFile.lastModified();
 
             Iterator fileIter = ejbFiles.values().iterator();
 
             // Loop through the files seeing if any has been touched
             // more recently than the destination jar.
             while (fileIter.hasNext()) {
                 File currentFile = (File) fileIter.next();
                 if (lastBuild < currentFile.lastModified()) {
                     log("Build needed because " + currentFile.getPath() + " is out of date",
                         Project.MSG_VERBOSE);
                     return true;
                 }
             }
             return false;
         }
 
         return true;
     }
 
     /**
      * Returns the Public ID of the DTD specified in the EJB descriptor.  Not
      * every vendor-specific <code>DeploymentTool</code> will need to reference
      * this value or may want to determine this value in a vendor-specific way.
      *
      * @return Public ID of the DTD specified in the EJB descriptor.
      */
     protected String getPublicId() {
         return handler.getPublicId();
     }
 
     /**
-     * Get the manifets file to use for building the generic jar.
+     * Get the manifest file to use for building the generic jar.
      *
      * If the file does not exist the global manifest from the config is used
      * otherwise the default Ant manifest will be used.
      *
      * @param prefix the prefix where to llook for the manifest file based on
      *        the naming convention.
      *
      * @return the manifest file or null if the manifest file does not exist
      */
     protected File getManifestFile(String prefix) {
         File manifestFile
             = new File(getConfig().descriptorDir, prefix + "manifest.mf");
         if (manifestFile.exists()) {
             return manifestFile;
         }
 
         if (config.manifest != null) {
             return config.manifest;
         }
         return null;
     }
 
     /**
      * Method used to encapsulate the writing of the JAR file. Iterates over the
      * filenames/java.io.Files in the Hashtable stored on the instance variable
      * ejbFiles.
      * @param baseName the base name to use.
      * @param jarfile  the jar file to write to.
      * @param files    the files to write to the jar.
      * @param publicId the id to use.
      * @throws BuildException if there is a problem.
      */
     protected void writeJar(String baseName, File jarfile, Hashtable files,
                             String publicId) throws BuildException {
 
         JarOutputStream jarStream = null;
         try {
             // clean the addedfiles set
             if (addedfiles == null) {
                 addedfiles = new HashSet();
             } else {
                 addedfiles.clear();
             }
 
             /* If the jarfile already exists then whack it and recreate it.
              * Should probably think of a more elegant way to handle this
              * so that in case of errors we don't leave people worse off
              * than when we started =)
              */
             if (jarfile.exists()) {
                 jarfile.delete();
             }
             jarfile.getParentFile().mkdirs();
             jarfile.createNewFile();
 
             InputStream in = null;
             Manifest manifest = null;
             try {
                 File manifestFile = (File) files.get(MANIFEST);
                 if (manifestFile != null && manifestFile.exists()) {
                     in = new FileInputStream(manifestFile);
                 } else {
                     String defaultManifest = "/org/apache/tools/ant/defaultManifest.mf";
                     in = this.getClass().getResourceAsStream(defaultManifest);
                     if (in == null) {
                         throw new BuildException("Could not find "
                             + "default manifest: " + defaultManifest);
                     }
                 }
 
                 manifest = new Manifest(in);
             } catch (IOException e) {
                 throw new BuildException ("Unable to read manifest", e, getLocation());
             } finally {
                 if (in != null) {
                     in.close();
                 }
             }
 
             // Create the streams necessary to write the jarfile
 
             jarStream = new JarOutputStream(new FileOutputStream(jarfile), manifest);
             jarStream.setMethod(JarOutputStream.DEFLATED);
 
             // Loop through all the class files found and add them to the jar
             for (Iterator entryIterator = files.keySet().iterator(); entryIterator.hasNext();) {
                 String entryName = (String) entryIterator.next();
                 if (entryName.equals(MANIFEST)) {
                     continue;
                 }
 
                 File entryFile = (File) files.get(entryName);
 
                 log("adding file '" + entryName + "'",
                               Project.MSG_VERBOSE);
 
                 addFileToJar(jarStream, entryFile, entryName);
 
                 // See if there are any inner classes for this class and add them in if there are
                 InnerClassFilenameFilter flt = new InnerClassFilenameFilter(entryFile.getName());
                 File entryDir = entryFile.getParentFile();
                 String[] innerfiles = entryDir.list(flt);
                 if (innerfiles != null) {
                     for (int i = 0, n = innerfiles.length; i < n; i++) {
 
                         //get and clean up innerclass name
                         int entryIndex = entryName.lastIndexOf(entryFile.getName()) - 1;
                         if (entryIndex < 0) {
                             entryName = innerfiles[i];
                         } else {
                             entryName = entryName.substring(0, entryIndex)
                                 + File.separatorChar + innerfiles[i];
                         }
                         // link the file
                         entryFile = new File(config.srcDir, entryName);
 
                         log("adding innerclass file '" + entryName + "'",
                                 Project.MSG_VERBOSE);
 
                         addFileToJar(jarStream, entryFile, entryName);
 
                     }
                 }
             }
         } catch (IOException ioe) {
             String msg = "IOException while processing ejb-jar file '"
                 + jarfile.toString()
                 + "'. Details: "
                 + ioe.getMessage();
             throw new BuildException(msg, ioe);
         } finally {
             if (jarStream != null) {
                 try {
                     jarStream.close();
                 } catch (IOException closeException) {
                     // ignore
                 }
             }
         }
     } // end of writeJar
 
 
     /**
      * Add all available classes, that depend on Remote, Home, Bean, PK
      * @param checkEntries files, that are extracted from the deployment descriptor
      * @throws BuildException if there is a problem.
      */
     protected void checkAndAddDependants(Hashtable checkEntries)
         throws BuildException {
 
         if (dependencyAnalyzer == null) {
             return;
         }
 
         dependencyAnalyzer.reset();
 
         Iterator i = checkEntries.keySet().iterator();
         while (i.hasNext()) {
             String entryName = (String) i.next();
             if (entryName.endsWith(".class")) {
                 String className = entryName.substring(0,
                     entryName.length() - ".class".length());
                 className = className.replace(File.separatorChar, '/');
                 className = className.replace('/', '.');
 
                 dependencyAnalyzer.addRootClass(className);
             }
         }
 
         Enumeration e = dependencyAnalyzer.getClassDependencies();
 
         while (e.hasMoreElements()) {
             String classname = (String) e.nextElement();
             String location
                 = classname.replace('.', File.separatorChar) + ".class";
             File classFile = new File(config.srcDir, location);
             if (classFile.exists()) {
                 checkEntries.put(location, classFile);
                 log("dependent class: " + classname + " - " + classFile,
                     Project.MSG_VERBOSE);
             }
         }
     }
 
 
     /**
      * Returns a Classloader object which parses the passed in generic EjbJar classpath.
      * The loader is used to dynamically load classes from javax.ejb.* and the classes
      * being added to the jar.
      * @return a classloader.
      */
     protected ClassLoader getClassLoaderForBuild() {
         if (classpathLoader != null) {
             return classpathLoader;
         }
 
         Path combinedClasspath = getCombinedClasspath();
 
         // only generate a new ClassLoader if we have a classpath
         if (combinedClasspath == null) {
             classpathLoader = getClass().getClassLoader();
         } else {
             // Memory leak in line below
             classpathLoader
                 = getTask().getProject().createClassLoader(combinedClasspath);
         }
 
         return classpathLoader;
     }
 
     /**
      * Called to validate that the tool parameters have been configured.
      *
      * @throws BuildException If the Deployment Tool's configuration isn't
      *                        valid
      */
     public void validateConfigured() throws BuildException {
         if ((destDir == null) || (!destDir.isDirectory())) {
             String msg = "A valid destination directory must be specified "
                             + "using the \"destdir\" attribute.";
             throw new BuildException(msg, getLocation());
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java b/src/main/org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java
index ec721b556..23208810d 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java
@@ -1,896 +1,896 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.ejb;
 
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.JarOutputStream;
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.Java;
 import org.apache.tools.ant.types.Environment;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * Websphere deployment tool that augments the ejbjar task.
  * Searches for the websphere specific deployment descriptors and
  * adds them to the final ejb jar file. Websphere has two specific descriptors for session
  * beans:
  * <ul>
  *    <li>ibm-ejb-jar-bnd.xmi</li>
  *    <li>ibm-ejb-jar-ext.xmi</li>
  * </ul>
  * and another two for container managed entity beans:
  * <ul>
  *    <li>Map.mapxmi</li>
  *    <li>Schema.dbxmi</li>
  * </ul>
  * In terms of WebSphere, the generation of container code and stubs is
  * called <code>deployment</code>. This step can be performed by the websphere
  * element as part of the jar generation process. If the switch
  * <code>ejbdeploy</code> is on, the ejbdeploy tool from the websphere toolset
  * is called for every ejb-jar. Unfortunately, this step only works, if you
  * use the ibm jdk. Otherwise, the rmic (called by ejbdeploy) throws a
  * ClassFormatError. Be sure to switch ejbdeploy off, if run ant with
  * sun jdk.
  *
  */
 public class WebsphereDeploymentTool extends GenericDeploymentTool {
 
     /** ID for ejb 1.1 */
     public static final String PUBLICID_EJB11
          = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN";
     /** ID for ejb 2.0 */
     public static final String PUBLICID_EJB20
          = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN";
     /** Schema directory */
     protected static final String SCHEMA_DIR = "Schema/";
 
     protected static final String WAS_EXT = "ibm-ejb-jar-ext.xmi";
     protected static final String WAS_BND = "ibm-ejb-jar-bnd.xmi";
     protected static final String WAS_CMP_MAP = "Map.mapxmi";
     protected static final String WAS_CMP_SCHEMA = "Schema.dbxmi";
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /** Instance variable that stores the suffix for the websphere jarfile. */
     private String jarSuffix = ".jar";
 
     /** Instance variable that stores the location of the ejb 1.1 DTD file. */
     private String ejb11DTD;
 
     /** Instance variable that determines whether generic ejb jars are kept. */
 
     private boolean keepGeneric = false;
 
     private boolean alwaysRebuild = true;
 
     private boolean ejbdeploy = true;
 
     /** Indicates if the old CMP location convention is to be used. */
     private boolean newCMP = false;
 
     /** The classpath to the websphere classes. */
     private Path wasClasspath = null;
 
     /** The DB Vendor name, the EJB is persisted against */
     private String dbVendor;
 
     /** The name of the database to create. (For top-down mapping only) */
     private String dbName;
 
     /** The name of the schema to create. (For top-down mappings only) */
     private String dbSchema;
 
     /** true - Only generate the deployment code, do not run RMIC or Javac */
     private boolean codegen;
 
     /** true - Only output error messages, suppress informational messages */
     private boolean quiet = true;
 
     /** true - Disable the validation steps */
     private boolean novalidate;
 
     /** true - Disable warning and informational messages */
     private boolean nowarn;
 
     /** true - Disable informational messages */
     private boolean noinform;
 
     /** true - Enable internal tracing */
     private boolean trace;
 
     /** Additional options for RMIC */
     private String rmicOptions;
 
     /** true- Use the WebSphere 3.5 compatible mapping rules */
     private boolean use35MappingRules;
 
     /** the scratchdir for the ejbdeploy operation */
     private String tempdir = "_ejbdeploy_temp";
 
     /** the home directory for websphere */
     private File websphereHome;
 
     /**
      * Get the classpath to the websphere classpaths.
      * @return the websphere classpath.
      */
     public Path createWASClasspath() {
         if (wasClasspath == null) {
             wasClasspath = new Path(getTask().getProject());
         }
         return wasClasspath.createPath();
     }
 
 
     /**
      * Set the websphere classpath.
      * @param wasClasspath the websphere classpath.
      */
     public void setWASClasspath(Path wasClasspath) {
         this.wasClasspath = wasClasspath;
     }
 
 
     /** Sets the DB Vendor for the Entity Bean mapping ; optional.
      * <p>
      * Valid options can be obtained by running the following command:
      * <code>
      * &lt;WAS_HOME&gt;/bin/EJBDeploy.[sh/bat] -help
      * </code>
      * </p>
      * <p>
      * This is also used to determine the name of the Map.mapxmi and
      * Schema.dbxmi files, for example Account-DB2UDB_V81-Map.mapxmi
      * and Account-DB2UDB_V81-Schema.dbxmi.
      * </p>
      *
      * @param dbvendor database vendor type
      */
     public void setDbvendor(String dbvendor) {
         this.dbVendor = dbvendor;
     }
 
 
     /**
      * Sets the name of the Database to create; optional.
      *
      * @param dbName name of the database
      */
     public void setDbname(String dbName) {
         this.dbName = dbName;
     }
 
 
     /**
      * Sets the name of the schema to create; optional.
      *
      * @param dbSchema name of the schema
      */
     public void setDbschema(String dbSchema) {
         this.dbSchema = dbSchema;
     }
 
 
     /**
      * Flag, default false, to only generate the deployment
      * code, do not run RMIC or Javac
      *
      * @param codegen option
      */
     public void setCodegen(boolean codegen) {
         this.codegen = codegen;
     }
 
 
     /**
      * Flag, default true, to only output error messages.
      *
      * @param quiet option
      */
     public void setQuiet(boolean quiet) {
         this.quiet = quiet;
     }
 
 
     /**
      * Flag to disable the validation steps; optional, default false.
      *
      * @param novalidate option
      */
     public void setNovalidate(boolean novalidate) {
         this.novalidate = novalidate;
     }
 
 
     /**
      * Flag to disable warning and informational messages; optional, default false.
      *
      * @param nowarn option
      */
     public void setNowarn(boolean nowarn) {
         this.nowarn = nowarn;
     }
 
 
     /**
      * Flag to disable informational messages; optional, default false.
      *
      * @param noinform if true disables informational messages
      */
     public void setNoinform(boolean noinform) {
         this.noinform = noinform;
     }
 
 
     /**
      * Flag to enable internal tracing when set, optional, default false.
      *
-     * @param trace a <code>boolean</code> vaule.
+     * @param trace a <code>boolean</code> value.
      */
     public void setTrace(boolean trace) {
         this.trace = trace;
     }
 
     /**
      * Set the rmic options.
      *
      * @param options the options to use.
      */
     public void setRmicoptions(String options) {
         this.rmicOptions = options;
     }
 
     /**
      * Flag to use the WebSphere 3.5 compatible mapping rules ; optional, default false.
      *
      * @param attr a <code>boolean</code> value.
      */
     public void setUse35(boolean attr) {
         use35MappingRules = attr;
     }
 
 
     /**
      * Set the rebuild flag to false to only update changes in the jar rather
      * than rerunning ejbdeploy; optional, default true.
      * @param rebuild a <code>boolean</code> value.
      */
     public void setRebuild(boolean rebuild) {
         this.alwaysRebuild = rebuild;
     }
 
 
     /**
      * String value appended to the basename of the deployment
      * descriptor to create the filename of the WebLogic EJB
      * jar file. Optional, default '.jar'.
      * @param inString the string to use as the suffix.
      */
     public void setSuffix(String inString) {
         this.jarSuffix = inString;
     }
 
 
     /**
      * This controls whether the generic file used as input to
      * ejbdeploy is retained; optional, default false.
      * @param inValue either 'true' or 'false'.
      */
     public void setKeepgeneric(boolean inValue) {
         this.keepGeneric = inValue;
     }
 
 
     /**
-     * Decide, wether ejbdeploy should be called or not;
+     * Decide, whether ejbdeploy should be called or not;
      * optional, default true.
      *
      * @param ejbdeploy a <code>boolean</code> value.
      */
     public void setEjbdeploy(boolean ejbdeploy) {
         this.ejbdeploy = ejbdeploy;
     }
 
 
     /**
      * Setter used to store the location of the Sun's Generic EJB DTD. This
      * can be a file on the system or a resource on the classpath.
      *
      * @param inString the string to use as the DTD location.
      */
     public void setEJBdtd(String inString) {
         this.ejb11DTD = inString;
     }
 
 
     /**
      * Set the value of the oldCMP scheme. This is an antonym for newCMP
      * @ant.attribute ignore="true"
      * @param oldCMP a <code>boolean</code> value.
      */
     public void setOldCMP(boolean oldCMP) {
         this.newCMP = !oldCMP;
     }
 
 
     /**
      * Set the value of the newCMP scheme. The old CMP scheme locates the
      * websphere CMP descriptor based on the naming convention where the
      * websphere CMP file is expected to be named with the bean name as the
      * prefix. Under this scheme the name of the CMP descriptor does not match
      * the name actually used in the main websphere EJB descriptor. Also,
      * descriptors which contain multiple CMP references could not be used.
      * @param newCMP a <code>boolean</code> value.
      */
     public void setNewCMP(boolean newCMP) {
         this.newCMP = newCMP;
     }
 
 
     /**
      * The directory, where ejbdeploy will write temporary files;
      * optional, defaults to '_ejbdeploy_temp'.
      * @param tempdir the directory name to use.
      */
     public void setTempdir(String tempdir) {
         this.tempdir = tempdir;
     }
 
 
     /** {@inheritDoc}. */
     protected DescriptorHandler getDescriptorHandler(File srcDir) {
         DescriptorHandler handler = new DescriptorHandler(getTask(), srcDir);
         // register all the DTDs, both the ones that are known and
         // any supplied by the user
         handler.registerDTD(PUBLICID_EJB11, ejb11DTD);
 
         for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
             EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
 
             handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
         }
 
         return handler;
     }
 
 
     /**
      * Get a description handler.
      * @param srcDir the source directory.
      * @return the handler.
      */
     protected DescriptorHandler getWebsphereDescriptorHandler(final File srcDir) {
         DescriptorHandler handler =
             new DescriptorHandler(getTask(), srcDir) {
                 protected void processElement() {
                 }
             };
 
         for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
             EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
 
             handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
         }
         return handler;
     }
 
 
     /**
      * Add any vendor specific files which should be included in the EJB Jar.
      * @param ejbFiles a hashtable entryname -> file.
      * @param baseName a prefix to use.
      */
     protected void addVendorFiles(Hashtable ejbFiles, String baseName) {
 
         String ddPrefix = (usingBaseJarName() ? "" : baseName);
         String dbPrefix = (dbVendor == null) ? "" : dbVendor + "-";
 
         // Get the Extensions document
         File websphereEXT = new File(getConfig().descriptorDir, ddPrefix + WAS_EXT);
 
         if (websphereEXT.exists()) {
             ejbFiles.put(META_DIR + WAS_EXT,
                 websphereEXT);
         } else {
             log("Unable to locate websphere extensions. "
                 + "It was expected to be in "
                 + websphereEXT.getPath(), Project.MSG_VERBOSE);
         }
 
         File websphereBND = new File(getConfig().descriptorDir, ddPrefix + WAS_BND);
 
         if (websphereBND.exists()) {
             ejbFiles.put(META_DIR + WAS_BND,
                 websphereBND);
         } else {
             log("Unable to locate websphere bindings. "
                 + "It was expected to be in "
                 + websphereBND.getPath(), Project.MSG_VERBOSE);
         }
 
         if (!newCMP) {
             log("The old method for locating CMP files has been DEPRECATED.",
                 Project.MSG_VERBOSE);
             log("Please adjust your websphere descriptor and set "
                 + "newCMP=\"true\" to use the new CMP descriptor "
                 + "inclusion mechanism. ", Project.MSG_VERBOSE);
         } else {
             // We attempt to put in the MAP and Schema files of CMP beans
             try {
                 // Add the Map file
                 File websphereMAP = new File(getConfig().descriptorDir,
                     ddPrefix + dbPrefix + WAS_CMP_MAP);
 
                 if (websphereMAP.exists()) {
                     ejbFiles.put(META_DIR + WAS_CMP_MAP,
                         websphereMAP);
                 } else {
                     log("Unable to locate the websphere Map: "
                         + websphereMAP.getPath(), Project.MSG_VERBOSE);
                 }
 
                 File websphereSchema = new File(getConfig().descriptorDir,
                     ddPrefix + dbPrefix + WAS_CMP_SCHEMA);
 
                 if (websphereSchema.exists()) {
                     ejbFiles.put(META_DIR + SCHEMA_DIR + WAS_CMP_SCHEMA,
                         websphereSchema);
                 } else {
                     log("Unable to locate the websphere Schema: "
                         + websphereSchema.getPath(), Project.MSG_VERBOSE);
                 }
                 // Theres nothing else to see here...keep moving sonny
             } catch (Exception e) {
                 String msg = "Exception while adding Vendor specific files: "
                     + e.toString();
 
                 throw new BuildException(msg, e);
             }
         }
     }
 
 
     /**
      * Get the vendor specific name of the Jar that will be output. The
      * modification date of this jar will be checked against the dependent
      * bean classes.
      */
     File getVendorOutputJarFile(String baseName) {
         return new File(getDestDir(), baseName + jarSuffix);
     }
 
 
     /**
      * Gets the options for the EJB Deploy operation
      *
      * @return String
      */
     protected String getOptions() {
         // Set the options
         StringBuffer options = new StringBuffer();
 
         if (dbVendor != null) {
             options.append(" -dbvendor ").append(dbVendor);
         }
         if (dbName != null) {
             options.append(" -dbname \"").append(dbName).append("\"");
         }
 
         if (dbSchema != null) {
             options.append(" -dbschema \"").append(dbSchema).append("\"");
         }
 
         if (codegen) {
             options.append(" -codegen");
         }
 
         if (quiet) {
             options.append(" -quiet");
         }
 
         if (novalidate) {
             options.append(" -novalidate");
         }
 
         if (nowarn) {
             options.append(" -nowarn");
         }
 
         if (noinform) {
             options.append(" -noinform");
         }
 
         if (trace) {
             options.append(" -trace");
         }
 
         if (use35MappingRules) {
             options.append(" -35");
         }
 
         if (rmicOptions != null) {
             options.append(" -rmic \"").append(rmicOptions).append("\"");
         }
 
         return options.toString();
     }
 
 
     /**
      * Helper method invoked by execute() for each websphere jar to be built.
      * Encapsulates the logic of constructing a java task for calling
      * websphere.ejbdeploy and executing it.
      *
      * @param sourceJar java.io.File representing the source (EJB1.1) jarfile.
      * @param destJar java.io.File representing the destination, websphere
      *      jarfile.
      */
     private void buildWebsphereJar(File sourceJar, File destJar) {
         try {
             if (ejbdeploy) {
                 Java javaTask = new Java(getTask());
                 // Set the JvmArgs
                 javaTask.createJvmarg().setValue("-Xms64m");
                 javaTask.createJvmarg().setValue("-Xmx128m");
 
                 // Set the Environment variable
                 Environment.Variable var = new Environment.Variable();
 
                 var.setKey("websphere.lib.dir");
                 File libdir = new File(websphereHome, "lib");
                 var.setValue(libdir.getAbsolutePath());
                 javaTask.addSysproperty(var);
 
                 // Set the working directory
                 javaTask.setDir(websphereHome);
 
                 // Set the Java class name
                 javaTask.setTaskName("ejbdeploy");
                 javaTask.setClassname("com.ibm.etools.ejbdeploy.EJBDeploy");
 
                 javaTask.createArg().setValue(sourceJar.getPath());
                 javaTask.createArg().setValue(tempdir);
                 javaTask.createArg().setValue(destJar.getPath());
                 javaTask.createArg().setLine(getOptions());
                 if (getCombinedClasspath() != null
                     && getCombinedClasspath().toString().length() > 0) {
                     javaTask.createArg().setValue("-cp");
                     javaTask.createArg().setValue(getCombinedClasspath().toString());
                 }
 
                 Path classpath = wasClasspath;
 
                 if (classpath == null) {
                     classpath = getCombinedClasspath();
                 }
 
                 javaTask.setFork(true);
                 if (classpath != null) {
                     javaTask.setClasspath(classpath);
                 }
 
                 log("Calling websphere.ejbdeploy for " + sourceJar.toString(),
                     Project.MSG_VERBOSE);
 
                 javaTask.execute();
             }
         } catch (Exception e) {
             // Have to catch this because of the semantics of calling main()
             String msg = "Exception while calling ejbdeploy. Details: " + e.toString();
 
             throw new BuildException(msg, e);
         }
     }
 
     /** {@inheritDoc}. */
     protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId)
          throws BuildException {
         if (ejbdeploy) {
             // create the -generic.jar, if required
             File genericJarFile = super.getVendorOutputJarFile(baseName);
 
             super.writeJar(baseName, genericJarFile, files, publicId);
 
             // create the output .jar, if required
             if (alwaysRebuild || isRebuildRequired(genericJarFile, jarFile)) {
                 buildWebsphereJar(genericJarFile, jarFile);
             }
             if (!keepGeneric) {
                 log("deleting generic jar " + genericJarFile.toString(),
                     Project.MSG_VERBOSE);
                 genericJarFile.delete();
             }
         } else {
             // create the "undeployed" output .jar, if required
             super.writeJar(baseName, jarFile, files, publicId);
         }
     }
 
 
     /**
      * Called to validate that the tool parameters have been configured.
      * @throws BuildException if there is an error.
      */
     public void validateConfigured() throws BuildException {
         super.validateConfigured();
         if (ejbdeploy) {
             String home = getTask().getProject().getProperty("websphere.home");
             if (home == null) {
                 throw new BuildException("The 'websphere.home' property must "
                     + "be set when 'ejbdeploy=true'");
             }
             websphereHome = getTask().getProject().resolveFile(home);
         }
     }
 
 
     /**
      * Helper method to check to see if a websphere EBJ1.1 jar needs to be
      * rebuilt using ejbdeploy. Called from writeJar it sees if the "Bean"
      * classes are the only thing that needs to be updated and either updates
      * the Jar with the Bean classfile or returns true, saying that the whole
      * websphere jar needs to be regened with ejbdeploy. This allows faster
      * build times for working developers. <p>
      *
      * The way websphere ejbdeploy works is it creates wrappers for the
      * publicly defined methods as they are exposed in the remote interface.
      * If the actual bean changes without changing the the method signatures
      * then only the bean classfile needs to be updated and the rest of the
      * websphere jar file can remain the same. If the Interfaces, ie. the
      * method signatures change or if the xml deployment descriptors changed,
      * the whole jar needs to be rebuilt with ejbdeploy. This is not strictly
      * true for the xml files. If the JNDI name changes then the jar doesnt
      * have to be rebuild, but if the resources references change then it
      * does. At this point the websphere jar gets rebuilt if the xml files
      * change at all.
      *
      * @param genericJarFile java.io.File The generic jar file.
      * @param websphereJarFile java.io.File The websphere jar file to check to
      *      see if it needs to be rebuilt.
      * @return true if a rebuild is required.
      */
     // CheckStyle:MethodLength OFF - this will no be fixed
     protected boolean isRebuildRequired(File genericJarFile, File websphereJarFile) {
         boolean rebuild = false;
 
         JarFile genericJar = null;
         JarFile wasJar = null;
         File newwasJarFile = null;
         JarOutputStream newJarStream = null;
         ClassLoader genericLoader = null;
 
         try {
             log("Checking if websphere Jar needs to be rebuilt for jar "
                 + websphereJarFile.getName(), Project.MSG_VERBOSE);
             // Only go forward if the generic and the websphere file both exist
             if (genericJarFile.exists() && genericJarFile.isFile()
                  && websphereJarFile.exists() && websphereJarFile.isFile()) {
                 //open jar files
                 genericJar = new JarFile(genericJarFile);
                 wasJar = new JarFile(websphereJarFile);
 
                 Hashtable genericEntries = new Hashtable();
                 Hashtable wasEntries = new Hashtable();
                 Hashtable replaceEntries = new Hashtable();
 
                 //get the list of generic jar entries
                 for (Enumeration e = genericJar.entries(); e.hasMoreElements();) {
                     JarEntry je = (JarEntry) e.nextElement();
 
                     genericEntries.put(je.getName().replace('\\', '/'), je);
                 }
                 //get the list of websphere jar entries
                 for (Enumeration e = wasJar.entries(); e.hasMoreElements();) {
                     JarEntry je = (JarEntry) e.nextElement();
 
                     wasEntries.put(je.getName(), je);
                 }
 
                 //Cycle Through generic and make sure its in websphere
                 genericLoader = getClassLoaderFromJar(genericJarFile);
 
                 for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) {
                     String filepath = (String) e.nextElement();
 
                     if (wasEntries.containsKey(filepath)) {
                         // File name/path match
                         // Check files see if same
                         JarEntry genericEntry = (JarEntry) genericEntries.get(filepath);
                         JarEntry wasEntry = (JarEntry) wasEntries.get(filepath);
 
                         if ((genericEntry.getCrc() != wasEntry.getCrc())
                             || (genericEntry.getSize() != wasEntry.getSize())) {
 
                             if (genericEntry.getName().endsWith(".class")) {
                                 //File are different see if its an object or an interface
                                 String classname
                                     = genericEntry.getName().replace(File.separatorChar, '.');
 
                                 classname = classname.substring(0, classname.lastIndexOf(".class"));
 
                                 Class genclass = genericLoader.loadClass(classname);
 
                                 if (genclass.isInterface()) {
                                     //Interface changed   rebuild jar.
                                     log("Interface " + genclass.getName()
                                         + " has changed", Project.MSG_VERBOSE);
                                     rebuild = true;
                                     break;
                                 } else {
                                     //Object class Changed   update it.
                                     replaceEntries.put(filepath, genericEntry);
                                 }
                             } else {
                                 // is it the manifest. If so ignore it
                                 if (!genericEntry.getName().equals("META-INF/MANIFEST.MF")) {
                                     //File other then class changed   rebuild
                                     log("Non class file " + genericEntry.getName()
                                         + " has changed", Project.MSG_VERBOSE);
                                     rebuild = true;
                                 }
                                 break;
                             }
                         }
                     } else {
                         // a file doesn't exist rebuild
 
                         log("File " + filepath + " not present in websphere jar",
                             Project.MSG_VERBOSE);
                         rebuild = true;
                         break;
                     }
                 }
 
                 if (!rebuild) {
                     log("No rebuild needed - updating jar", Project.MSG_VERBOSE);
                     newwasJarFile = new File(websphereJarFile.getAbsolutePath() + ".temp");
                     if (newwasJarFile.exists()) {
                         newwasJarFile.delete();
                     }
 
                     newJarStream = new JarOutputStream(new FileOutputStream(newwasJarFile));
                     newJarStream.setLevel(0);
 
                     //Copy files from old websphere jar
                     for (Enumeration e = wasEntries.elements(); e.hasMoreElements();) {
                         byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
                         int bytesRead;
                         InputStream is;
                         JarEntry je = (JarEntry) e.nextElement();
 
                         if (je.getCompressedSize() == -1
                             || je.getCompressedSize() == je.getSize()) {
                             newJarStream.setLevel(0);
                         } else {
                             newJarStream.setLevel(JAR_COMPRESS_LEVEL);
                         }
 
                         // Update with changed Bean class
                         if (replaceEntries.containsKey(je.getName())) {
                             log("Updating Bean class from generic Jar " + je.getName(),
                                 Project.MSG_VERBOSE);
                             // Use the entry from the generic jar
                             je = (JarEntry) replaceEntries.get(je.getName());
                             is = genericJar.getInputStream(je);
                         } else {
                             //use fle from original websphere jar
 
                             is = wasJar.getInputStream(je);
                         }
                         newJarStream.putNextEntry(new JarEntry(je.getName()));
 
                         while ((bytesRead = is.read(buffer)) != -1) {
                             newJarStream.write(buffer, 0, bytesRead);
                         }
                         is.close();
                     }
                 } else {
                     log("websphere Jar rebuild needed due to changed "
                         + "interface or XML", Project.MSG_VERBOSE);
                 }
             } else {
                 rebuild = true;
             }
         } catch (ClassNotFoundException cnfe) {
             String cnfmsg = "ClassNotFoundException while processing ejb-jar file"
                  + ". Details: "
                  + cnfe.getMessage();
 
             throw new BuildException(cnfmsg, cnfe);
         } catch (IOException ioe) {
             String msg = "IOException while processing ejb-jar file "
                  + ". Details: "
                  + ioe.getMessage();
 
             throw new BuildException(msg, ioe);
         } finally {
             // need to close files and perhaps rename output
             if (genericJar != null) {
                 try {
                     genericJar.close();
                 } catch (IOException closeException) {
                     // Ignore
                 }
             }
 
             if (wasJar != null) {
                 try {
                     wasJar.close();
                 } catch (IOException closeException) {
                     // Ignore
                 }
             }
 
             if (newJarStream != null) {
                 try {
                     newJarStream.close();
                 } catch (IOException closeException) {
                     // Ignore
                 }
 
                 try {
                     FILE_UTILS.rename(newwasJarFile, websphereJarFile);
                 } catch (IOException renameException) {
                     log(renameException.getMessage(), Project.MSG_WARN);
                     rebuild = true;
                 }
             }
             if (genericLoader != null
                 && genericLoader instanceof AntClassLoader) {
                 AntClassLoader loader = (AntClassLoader) genericLoader;
                 loader.cleanup();
             }
         }
 
         return rebuild;
     }
 
 
     /**
      * Helper method invoked by isRebuildRequired to get a ClassLoader for a
      * Jar File passed to it.
      *
      * @param classjar java.io.File representing jar file to get classes from.
      * @return a classloader for the jar file.
      * @throws IOException if there is an error.
      */
     protected ClassLoader getClassLoaderFromJar(File classjar) throws IOException {
         Path lookupPath = new Path(getTask().getProject());
 
         lookupPath.setLocation(classjar);
 
         Path classpath = getCombinedClasspath();
 
         if (classpath != null) {
             lookupPath.append(classpath);
         }
 
         return getTask().getProject().createClassLoader(lookupPath);
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/extension/Extension.java b/src/main/org/apache/tools/ant/taskdefs/optional/extension/Extension.java
index 71de84a70..c1c92f432 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/extension/Extension.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/extension/Extension.java
@@ -1,690 +1,690 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.extension;
 
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.StringTokenizer;
 import java.util.jar.Attributes;
 import java.util.jar.Manifest;
 
 import org.apache.tools.ant.util.DeweyDecimal;
 import org.apache.tools.ant.util.StringUtils;
 
 /**
  * <p>Utility class that represents either an available "Optional Package"
  * (formerly known as "Standard Extension") as described in the manifest
  * of a JAR file, or the requirement for such an optional package.</p>
  *
  * <p>For more information about optional packages, see the document
  * <em>Optional Package Versioning</em> in the documentation bundle for your
  * Java2 Standard Edition package, in file
  * <code>guide/extensions/versioning.html</code>.</p>
  *
  */
 public final class Extension {
     /**
      * Manifest Attribute Name object for EXTENSION_LIST.
      */
     public static final Attributes.Name EXTENSION_LIST
         = new Attributes.Name("Extension-List");
 
     /**
      * <code>Name</code> object for <code>Optional-Extension-List</code>
      * manifest attribute used for declaring optional dependencies on
      * installed extensions. Note that the dependencies declared by this method
      * are not required for the library to operate but if present will be used.
      * It is NOT part of the official "Optional Package" specification.
      *
-     * @see <a href="http://java.sun.com/j2se/1.3/docs/guide/extensions/spec.html#dependnecy">
+     * @see <a href="http://java.sun.com/j2se/1.3/docs/guide/extensions/spec.html#dependency">
      *      Installed extension dependency</a>
      */
     public static final Attributes.Name OPTIONAL_EXTENSION_LIST
         = new Attributes.Name("Optional-Extension-List");
 
     /**
      * Manifest Attribute Name object for EXTENSION_NAME.
      */
     public static final Attributes.Name EXTENSION_NAME =
         new Attributes.Name("Extension-Name");
     /**
      * Manifest Attribute Name object for SPECIFICATION_VERSION.
      */
     public static final Attributes.Name SPECIFICATION_VERSION
         = Attributes.Name.SPECIFICATION_VERSION;
 
     /**
      * Manifest Attribute Name object for SPECIFICATION_VENDOR.
      */
     public static final Attributes.Name SPECIFICATION_VENDOR
         = Attributes.Name.SPECIFICATION_VENDOR;
 
     /**
      * Manifest Attribute Name object for IMPLEMENTATION_VERSION.
      */
     public static final Attributes.Name IMPLEMENTATION_VERSION
         = Attributes.Name.IMPLEMENTATION_VERSION;
 
     /**
      * Manifest Attribute Name object for IMPLEMENTATION_VENDOR.
      */
     public static final Attributes.Name IMPLEMENTATION_VENDOR
         = Attributes.Name.IMPLEMENTATION_VENDOR;
 
     /**
      * Manifest Attribute Name object for IMPLEMENTATION_URL.
      */
     public static final Attributes.Name IMPLEMENTATION_URL
         = new Attributes.Name("Implementation-URL");
 
     /**
      * Manifest Attribute Name object for IMPLEMENTATION_VENDOR_ID.
      */
     public static final Attributes.Name IMPLEMENTATION_VENDOR_ID
         = new Attributes.Name("Implementation-Vendor-Id");
 
     /**
      * Enum indicating that extension is compatible with other extension.
      */
     public static final Compatibility COMPATIBLE
         = new Compatibility("COMPATIBLE");
 
     /**
      * Enum indicating that extension requires an upgrade
      * of specification to be compatible with other extension.
      */
     public static final Compatibility REQUIRE_SPECIFICATION_UPGRADE
         = new Compatibility("REQUIRE_SPECIFICATION_UPGRADE");
 
     /**
      * Enum indicating that extension requires a vendor
      * switch to be compatible with other extension.
      */
     public static final Compatibility REQUIRE_VENDOR_SWITCH
         = new Compatibility("REQUIRE_VENDOR_SWITCH");
 
     /**
      * Enum indicating that extension requires an upgrade
      * of implementation to be compatible with other extension.
      */
     public static final Compatibility REQUIRE_IMPLEMENTATION_UPGRADE
         = new Compatibility("REQUIRE_IMPLEMENTATION_UPGRADE");
 
     /**
      * Enum indicating that extension is incompatible with
      * other extension in ways other than other enums
      * indicate). For example the other extension may have
      * a different ID.
      */
     public static final Compatibility INCOMPATIBLE
         = new Compatibility("INCOMPATIBLE");
 
     /**
      * The name of the optional package being made available, or required.
      */
     private String extensionName;
 
     /**
      * The version number (dotted decimal notation) of the specification
      * to which this optional package conforms.
      */
     private DeweyDecimal specificationVersion;
 
     /**
      * The name of the company or organization that originated the
      * specification to which this optional package conforms.
      */
     private String specificationVendor;
 
     /**
      * The unique identifier of the company that produced the optional
      * package contained in this JAR file.
      */
     private String implementationVendorID;
 
     /**
      * The name of the company or organization that produced this
      * implementation of this optional package.
      */
     private String implementationVendor;
 
     /**
      * The version number (dotted decimal notation) for this implementation
      * of the optional package.
      */
     private DeweyDecimal implementationVersion;
 
     /**
      * The URL from which the most recent version of this optional package
      * can be obtained if it is not already installed.
      */
     private String implementationURL;
 
     /**
      * Return an array of <code>Extension</code> objects representing optional
      * packages that are available in the JAR file associated with the
      * specified <code>Manifest</code>.  If there are no such optional
      * packages, a zero-length array is returned.
      *
      * @param manifest Manifest to be parsed
      * @return the "available" extensions in specified manifest
      */
     public static Extension[] getAvailable(final Manifest manifest) {
         if (null == manifest) {
             return new Extension[ 0 ];
         }
 
         final ArrayList results = new ArrayList();
 
         final Attributes mainAttributes = manifest.getMainAttributes();
         if (null != mainAttributes) {
             final Extension extension = getExtension("", mainAttributes);
             if (null != extension) {
                 results.add(extension);
             }
         }
 
         final Map entries = manifest.getEntries();
         final Iterator keys = entries.keySet().iterator();
         while (keys.hasNext()) {
             final String key = (String) keys.next();
             final Attributes attributes = (Attributes) entries.get(key);
             final Extension extension = getExtension("", attributes);
             if (null != extension) {
                 results.add(extension);
             }
         }
 
         return (Extension[]) results.toArray(new Extension[results.size()]);
     }
 
     /**
      * Return the set of <code>Extension</code> objects representing optional
      * packages that are required by the application contained in the JAR
      * file associated with the specified <code>Manifest</code>.  If there
      * are no such optional packages, a zero-length list is returned.
      *
      * @param manifest Manifest to be parsed
-     * @return the dependencies that are specified in manifes
+     * @return the dependencies that are specified in manifest
      */
     public static Extension[] getRequired(final Manifest manifest) {
         return getListed(manifest, Attributes.Name.EXTENSION_LIST);
     }
 
     /**
      * Return the set of <code>Extension</code> objects representing "Optional
      * Packages" that the application declares they will use if present. If
      * there are no such optional packages, a zero-length list is returned.
      *
      * @param manifest Manifest to be parsed
      * @return the optional dependencies that are specified in manifest
      */
     public static Extension[] getOptions(final Manifest manifest) {
         return getListed(manifest, OPTIONAL_EXTENSION_LIST);
     }
 
     /**
      * Add Extension to the specified manifest Attributes.
      *
      * @param attributes the attributes of manifest to add to
      * @param extension the extension
      */
     public static void addExtension(final Extension extension,
                                      final Attributes attributes) {
         addExtension(extension, "", attributes);
     }
 
     /**
      * Add Extension to the specified manifest Attributes.
      * Use the specified prefix so that dependencies can added
      * with a prefix such as "java3d-" etc.
      *
      * @param attributes the attributes of manifest to add to
      * @param extension the extension
      * @param prefix the name to prefix to extension
      */
     public static void addExtension(final Extension extension,
                                      final String prefix,
                                      final Attributes attributes) {
         attributes.putValue(prefix + EXTENSION_NAME,
                              extension.getExtensionName());
 
         final String specificationVendor = extension.getSpecificationVendor();
         if (null != specificationVendor) {
             attributes.putValue(prefix + SPECIFICATION_VENDOR,
                                  specificationVendor);
         }
 
         final DeweyDecimal specificationVersion
             = extension.getSpecificationVersion();
         if (null != specificationVersion) {
             attributes.putValue(prefix + SPECIFICATION_VERSION,
                                  specificationVersion.toString());
         }
 
         final String implementationVendorID
             = extension.getImplementationVendorID();
         if (null != implementationVendorID) {
             attributes.putValue(prefix + IMPLEMENTATION_VENDOR_ID,
                                  implementationVendorID);
         }
 
         final String implementationVendor = extension.getImplementationVendor();
         if (null != implementationVendor) {
             attributes.putValue(prefix + IMPLEMENTATION_VENDOR,
                                  implementationVendor);
         }
 
         final DeweyDecimal implementationVersion
             = extension.getImplementationVersion();
         if (null != implementationVersion) {
             attributes.putValue(prefix + IMPLEMENTATION_VERSION,
                                  implementationVersion.toString());
         }
 
         final String implementationURL = extension.getImplementationURL();
         if (null != implementationURL) {
             attributes.putValue(prefix + IMPLEMENTATION_URL,
                                  implementationURL);
         }
     }
 
     /**
      * The constructor to create Extension object.
      * Note that every component is allowed to be specified
      * but only the extensionName is mandatory.
      *
      * @param extensionName the name of extension.
      * @param specificationVersion the specification Version of extension.
      * @param specificationVendor the specification Vendor of extension.
      * @param implementationVersion the implementation Version of extension.
      * @param implementationVendor the implementation Vendor of extension.
      * @param implementationVendorId the implementation VendorId of extension.
      * @param implementationURL the implementation URL of extension.
      */
     public Extension(final String extensionName,
                       final String specificationVersion,
                       final String specificationVendor,
                       final String implementationVersion,
                       final String implementationVendor,
                       final String implementationVendorId,
                       final String implementationURL) {
         this.extensionName = extensionName;
         this.specificationVendor = specificationVendor;
 
         if (null != specificationVersion) {
             try {
                 this.specificationVersion
                     = new DeweyDecimal(specificationVersion);
             } catch (final NumberFormatException nfe) {
                 final String error = "Bad specification version format '"
                     + specificationVersion + "' in '" + extensionName
                     + "'. (Reason: " + nfe + ")";
                 throw new IllegalArgumentException(error);
             }
         }
 
         this.implementationURL = implementationURL;
         this.implementationVendor = implementationVendor;
         this.implementationVendorID = implementationVendorId;
 
         if (null != implementationVersion) {
             try {
                 this.implementationVersion
                     = new DeweyDecimal(implementationVersion);
             } catch (final NumberFormatException nfe) {
                 final String error = "Bad implementation version format '"
                     + implementationVersion + "' in '" + extensionName
                     + "'. (Reason: " + nfe + ")";
                 throw new IllegalArgumentException(error);
             }
         }
 
         if (null == this.extensionName) {
             throw new NullPointerException("extensionName property is null");
         }
     }
 
     /**
      * Get the name of the extension.
      *
      * @return the name of the extension
      */
     public String getExtensionName() {
         return extensionName;
     }
 
     /**
      * Get the vendor of the extensions specification.
      *
      * @return the vendor of the extensions specification.
      */
     public String getSpecificationVendor() {
         return specificationVendor;
     }
 
     /**
      * Get the version of the extensions specification.
      *
      * @return the version of the extensions specification.
      */
     public DeweyDecimal getSpecificationVersion() {
         return specificationVersion;
     }
 
     /**
      * Get the url of the extensions implementation.
      *
      * @return the url of the extensions implementation.
      */
     public String getImplementationURL() {
         return implementationURL;
     }
 
     /**
      * Get the vendor of the extensions implementation.
      *
      * @return the vendor of the extensions implementation.
      */
     public String getImplementationVendor() {
         return implementationVendor;
     }
 
     /**
      * Get the vendorID of the extensions implementation.
      *
      * @return the vendorID of the extensions implementation.
      */
     public String getImplementationVendorID() {
         return implementationVendorID;
     }
 
     /**
      * Get the version of the extensions implementation.
      *
      * @return the version of the extensions implementation.
      */
     public DeweyDecimal getImplementationVersion() {
         return implementationVersion;
     }
 
     /**
      * Return a Compatibility enum indicating the relationship of this
      * <code>Extension</code> with the specified <code>Extension</code>.
      *
      * @param required Description of the required optional package
      * @return the enum indicating the compatibility (or lack thereof)
-     *         of specifed extension
+     *         of specified extension
      */
     public Compatibility getCompatibilityWith(final Extension required) {
         // Extension Name must match
         if (!extensionName.equals(required.getExtensionName())) {
             return INCOMPATIBLE;
         }
 
         // Available specification version must be >= required
         final DeweyDecimal requiredSpecificationVersion
             = required.getSpecificationVersion();
         if (null != requiredSpecificationVersion) {
             if (null == specificationVersion
                 || !isCompatible(specificationVersion, requiredSpecificationVersion)) {
                 return REQUIRE_SPECIFICATION_UPGRADE;
             }
         }
 
         // Implementation Vendor ID must match
         final String requiredImplementationVendorID
             = required.getImplementationVendorID();
         if (null != requiredImplementationVendorID) {
             if (null == implementationVendorID
                 || !implementationVendorID.equals(requiredImplementationVendorID)) {
                 return REQUIRE_VENDOR_SWITCH;
             }
         }
 
         // Implementation version must be >= required
         final DeweyDecimal requiredImplementationVersion
             = required.getImplementationVersion();
         if (null != requiredImplementationVersion) {
             if (null == implementationVersion
                 || !isCompatible(implementationVersion, requiredImplementationVersion)) {
                 return REQUIRE_IMPLEMENTATION_UPGRADE;
             }
         }
 
         // This available optional package satisfies the requirements
         return COMPATIBLE;
     }
 
     /**
      * Return <code>true</code> if the specified <code>Extension</code>
      * (which represents an optional package required by an application)
      * is satisfied by this <code>Extension</code> (which represents an
      * optional package that is already installed.  Otherwise, return
      * <code>false</code>.
      *
      * @param required Description of the required optional package
      * @return true if the specified extension is compatible with this extension
      */
     public boolean isCompatibleWith(final Extension required) {
         return (COMPATIBLE == getCompatibilityWith(required));
     }
 
     /**
      * Return a String representation of this object.
      *
      * @return string representation of object.
      */
     public String toString() {
         final String brace = ": ";
 
         final StringBuffer sb = new StringBuffer(EXTENSION_NAME.toString());
         sb.append(brace);
         sb.append(extensionName);
         sb.append(StringUtils.LINE_SEP);
 
         if (null != specificationVersion) {
             sb.append(SPECIFICATION_VERSION);
             sb.append(brace);
             sb.append(specificationVersion);
             sb.append(StringUtils.LINE_SEP);
         }
 
         if (null != specificationVendor) {
             sb.append(SPECIFICATION_VENDOR);
             sb.append(brace);
             sb.append(specificationVendor);
             sb.append(StringUtils.LINE_SEP);
         }
 
         if (null != implementationVersion) {
             sb.append(IMPLEMENTATION_VERSION);
             sb.append(brace);
             sb.append(implementationVersion);
             sb.append(StringUtils.LINE_SEP);
         }
 
         if (null != implementationVendorID) {
             sb.append(IMPLEMENTATION_VENDOR_ID);
             sb.append(brace);
             sb.append(implementationVendorID);
             sb.append(StringUtils.LINE_SEP);
         }
 
         if (null != implementationVendor) {
             sb.append(IMPLEMENTATION_VENDOR);
             sb.append(brace);
             sb.append(implementationVendor);
             sb.append(StringUtils.LINE_SEP);
         }
 
         if (null != implementationURL) {
             sb.append(IMPLEMENTATION_URL);
             sb.append(brace);
             sb.append(implementationURL);
             sb.append(StringUtils.LINE_SEP);
         }
 
         return sb.toString();
     }
 
     /**
      * Return <code>true</code> if the first version number is greater than
      * or equal to the second; otherwise return <code>false</code>.
      *
      * @param first First version number (dotted decimal)
      * @param second Second version number (dotted decimal)
      */
     private boolean isCompatible(final DeweyDecimal first,
                                  final DeweyDecimal second) {
         return first.isGreaterThanOrEqual(second);
     }
 
     /**
      * Retrieve all the extensions listed under a particular key
      * (Usually EXTENSION_LIST or OPTIONAL_EXTENSION_LIST).
      *
      * @param manifest the manifest to extract extensions from
      * @param listKey the key used to get list (Usually
      *        EXTENSION_LIST or OPTIONAL_EXTENSION_LIST)
      * @return the list of listed extensions
      */
     private static Extension[] getListed(final Manifest manifest,
                                           final Attributes.Name listKey) {
         final ArrayList results = new ArrayList();
         final Attributes mainAttributes = manifest.getMainAttributes();
 
         if (null != mainAttributes) {
             getExtension(mainAttributes, results, listKey);
         }
 
         final Map entries = manifest.getEntries();
         final Iterator keys = entries.keySet().iterator();
         while (keys.hasNext()) {
             final String key = (String) keys.next();
             final Attributes attributes = (Attributes) entries.get(key);
             getExtension(attributes, results, listKey);
         }
 
         return (Extension[]) results.toArray(new Extension[results.size()]);
     }
 
     /**
      * Add required optional packages defined in the specified
      * attributes entry, if any.
      *
      * @param attributes Attributes to be parsed
      * @param required list to add required optional packages to
      * @param listKey the key to use to lookup list, usually EXTENSION_LIST
      *    or OPTIONAL_EXTENSION_LIST
      */
     private static void getExtension(final Attributes attributes,
                                      final ArrayList required,
                                      final Attributes.Name listKey) {
         final String names = attributes.getValue(listKey);
         if (null == names) {
             return;
         }
 
         final String[] extentions = split(names, " ");
         for (int i = 0; i < extentions.length; i++) {
             final String prefix = extentions[ i ] + "-";
             final Extension extension = getExtension(prefix, attributes);
 
             if (null != extension) {
                 required.add(extension);
             }
         }
     }
 
     /**
      * Splits the string on every token into an array of strings.
      *
      * @param string the string
      * @param onToken the token
      * @return the resultant array
      */
     private static String[] split(final String string,
                                         final String onToken) {
         final StringTokenizer tokenizer = new StringTokenizer(string, onToken);
         final String[] result = new String[ tokenizer.countTokens() ];
 
         for (int i = 0; i < result.length; i++) {
             result[ i ] = tokenizer.nextToken();
         }
 
         return result;
     }
 
     /**
      * Extract an Extension from Attributes.
      * Prefix indicates the prefix checked for each string.
      * Usually the prefix is <em>"&lt;extension&gt;-"</em> if looking for a
      * <b>Required</b> extension. If you are looking for an
      * <b>Available</b> extension
      * then the prefix is <em>""</em>.
      *
      * @param prefix the prefix for each attribute name
      * @param attributes Attributes to searched
      * @return the new Extension object, or null
      */
     private static Extension getExtension(final String prefix,
                                           final Attributes attributes) {
         //WARNING: We trim the values of all the attributes because
         //Some extension declarations are badly defined (ie have spaces
         //after version or vendorID)
         final String nameKey = prefix + EXTENSION_NAME;
         final String name = getTrimmedString(attributes.getValue(nameKey));
         if (null == name) {
             return null;
         }
 
         final String specVendorKey = prefix + SPECIFICATION_VENDOR;
         final String specVendor
             = getTrimmedString(attributes.getValue(specVendorKey));
         final String specVersionKey = prefix + SPECIFICATION_VERSION;
         final String specVersion
             = getTrimmedString(attributes.getValue(specVersionKey));
 
         final String impVersionKey = prefix + IMPLEMENTATION_VERSION;
         final String impVersion
             = getTrimmedString(attributes.getValue(impVersionKey));
         final String impVendorKey = prefix + IMPLEMENTATION_VENDOR;
         final String impVendor
             = getTrimmedString(attributes.getValue(impVendorKey));
         final String impVendorIDKey = prefix + IMPLEMENTATION_VENDOR_ID;
         final String impVendorId
             = getTrimmedString(attributes.getValue(impVendorIDKey));
         final String impURLKey = prefix + IMPLEMENTATION_URL;
         final String impURL = getTrimmedString(attributes.getValue(impURLKey));
 
         return new Extension(name, specVersion, specVendor, impVersion,
                               impVendor, impVendorId, impURL);
     }
 
     /**
      * Trim the supplied string if the string is non-null
      *
      * @param value the string to trim or null
      * @return the trimmed string or null
      */
     private static String getTrimmedString(final String value) {
         return null == value ? null : value.trim();
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/extension/JarLibAvailableTask.java b/src/main/org/apache/tools/ant/taskdefs/optional/extension/JarLibAvailableTask.java
index 9787be333..a8fd9ea41 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/extension/JarLibAvailableTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/extension/JarLibAvailableTask.java
@@ -1,156 +1,156 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.extension;
 
 import java.io.File;
 import java.util.Iterator;
 import java.util.Vector;
 import java.util.jar.Manifest;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Task;
 
 /**
  * Checks whether an extension is present in a fileset or an extensionSet.
  *
  * @ant.task name="jarlib-available"
  */
 public class JarLibAvailableTask extends Task {
     /**
      * The library to display information about.
      */
     private File libraryFile;
 
     /**
      * Filesets specifying all the librarys
      * to display information about.
      */
     private final Vector extensionFileSets = new Vector();
 
     /**
      * The name of the property to set if extension is available.
      */
     private String propertyName;
 
     /**
      * The extension that is required.
      */
     private ExtensionAdapter requiredExtension;
 
     /**
      * The name of property to set if extensions are available.
      *
      * @param property The name of property to set if extensions is available.
      */
     public void setProperty(final String property) {
         this.propertyName = property;
     }
 
     /**
      * The JAR library to check.
      *
      * @param file The jar library to check.
      */
     public void setFile(final File file) {
         this.libraryFile = file;
     }
 
     /**
      * Set the Extension looking for.
      *
      * @param extension Set the Extension looking for.
      */
     public void addConfiguredExtension(final ExtensionAdapter extension) {
         if (null != requiredExtension) {
             final String message = "Can not specify extension to "
                 + "search for multiple times.";
             throw new BuildException(message);
         }
         requiredExtension = extension;
     }
 
     /**
      * Adds a set of extensions to search in.
      *
      * @param extensionSet a set of extensions to search in.
      */
     public void addConfiguredExtensionSet(final ExtensionSet extensionSet) {
         extensionFileSets.addElement(extensionSet);
     }
 
     /**
      * Execute the task.
      *
-     * @throws BuildException if somethign goes wrong.
+     * @throws BuildException if something goes wrong.
      */
     public void execute() throws BuildException {
         validate();
 
         final Extension test = requiredExtension.toExtension();
 
         // Check if list of files to check has been specified
         if (!extensionFileSets.isEmpty()) {
             final Iterator iterator = extensionFileSets.iterator();
             while (iterator.hasNext()) {
                 final ExtensionSet extensionSet
                     = (ExtensionSet) iterator.next();
                 final Extension[] extensions =
                     extensionSet.toExtensions(getProject());
                 for (int i = 0; i < extensions.length; i++) {
                     final Extension extension = extensions[ i ];
                     if (extension.isCompatibleWith(test)) {
                         getProject().setNewProperty(propertyName, "true");
                     }
                 }
             }
         } else {
             final Manifest manifest = ExtensionUtil.getManifest(libraryFile);
             final Extension[] extensions = Extension.getAvailable(manifest);
             for (int i = 0; i < extensions.length; i++) {
                 final Extension extension = extensions[ i ];
                 if (extension.isCompatibleWith(test)) {
                     getProject().setNewProperty(propertyName, "true");
                 }
             }
         }
     }
 
     /**
      * Validate the tasks parameters.
      *
      * @throws BuildException if invalid parameters found
      */
     private void validate() throws BuildException {
         if (null == requiredExtension) {
             final String message = "Extension element must be specified.";
             throw new BuildException(message);
         }
 
         if (null == libraryFile && extensionFileSets.isEmpty()) {
             final String message = "File attribute not specified.";
             throw new BuildException(message);
         }
         if (null != libraryFile && !libraryFile.exists()) {
             final String message = "File '" + libraryFile + "' does not exist.";
             throw new BuildException(message);
         }
         if (null != libraryFile && !libraryFile.isFile()) {
             final String message = "\'" + libraryFile + "\' is not a file.";
             throw new BuildException(message);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/extension/Specification.java b/src/main/org/apache/tools/ant/taskdefs/optional/extension/Specification.java
index b2755b443..1e4bb7b30 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/extension/Specification.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/extension/Specification.java
@@ -1,605 +1,605 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.extension;
 
 import java.text.ParseException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.jar.Attributes;
 import java.util.jar.Manifest;
 
 import org.apache.tools.ant.util.DeweyDecimal;
 import org.apache.tools.ant.util.StringUtils;
 
 /**
  * <p>Utility class that represents either an available "Optional Package"
  * (formerly known as "Standard Extension") as described in the manifest
  * of a JAR file, or the requirement for such an optional package.</p>
  *
  * <p>For more information about optional packages, see the document
  * <em>Optional Package Versioning</em> in the documentation bundle for your
  * Java2 Standard Edition package, in file
  * <code>guide/extensions/versioning.html</code>.</p>
  *
  */
 public final class Specification {
 
     private static final String MISSING = "Missing ";
 
     /**
      * Manifest Attribute Name object for SPECIFICATION_TITLE.
      */
     public static final Attributes.Name SPECIFICATION_TITLE
         = Attributes.Name.SPECIFICATION_TITLE;
 
     /**
      * Manifest Attribute Name object for SPECIFICATION_VERSION.
      */
     public static final Attributes.Name SPECIFICATION_VERSION
         = Attributes.Name.SPECIFICATION_VERSION;
 
     /**
      * Manifest Attribute Name object for SPECIFICATION_VENDOR.
      */
     public static final Attributes.Name SPECIFICATION_VENDOR
         = Attributes.Name.SPECIFICATION_VENDOR;
 
     /**
      * Manifest Attribute Name object for IMPLEMENTATION_TITLE.
      */
     public static final Attributes.Name IMPLEMENTATION_TITLE
         = Attributes.Name.IMPLEMENTATION_TITLE;
 
     /**
      * Manifest Attribute Name object for IMPLEMENTATION_VERSION.
      */
     public static final Attributes.Name IMPLEMENTATION_VERSION
         = Attributes.Name.IMPLEMENTATION_VERSION;
 
     /**
      * Manifest Attribute Name object for IMPLEMENTATION_VENDOR.
      */
     public static final Attributes.Name IMPLEMENTATION_VENDOR
         = Attributes.Name.IMPLEMENTATION_VENDOR;
 
     /**
      * Enum indicating that extension is compatible with other Package
      * Specification.
      */
     public static final Compatibility COMPATIBLE =
         new Compatibility("COMPATIBLE");
 
     /**
      * Enum indicating that extension requires an upgrade
      * of specification to be compatible with other Package Specification.
      */
     public static final Compatibility REQUIRE_SPECIFICATION_UPGRADE =
         new Compatibility("REQUIRE_SPECIFICATION_UPGRADE");
 
     /**
      * Enum indicating that extension requires a vendor
      * switch to be compatible with other Package Specification.
      */
     public static final Compatibility REQUIRE_VENDOR_SWITCH =
         new Compatibility("REQUIRE_VENDOR_SWITCH");
 
     /**
      * Enum indicating that extension requires an upgrade
      * of implementation to be compatible with other Package Specification.
      */
     public static final Compatibility REQUIRE_IMPLEMENTATION_CHANGE =
         new Compatibility("REQUIRE_IMPLEMENTATION_CHANGE");
 
     /**
      * This enum indicates that an extension is incompatible with
      * other Package Specification in ways other than other enums
      * indicate. For example, the other Package Specification
      * may have a different ID.
      */
     public static final Compatibility INCOMPATIBLE =
         new Compatibility("INCOMPATIBLE");
 
     /**
      * The name of the Package Specification.
      */
     private String specificationTitle;
 
     /**
      * The version number (dotted decimal notation) of the specification
      * to which this optional package conforms.
      */
     private DeweyDecimal specificationVersion;
 
     /**
      * The name of the company or organization that originated the
      * specification to which this specification conforms.
      */
     private String specificationVendor;
 
     /**
      * The title of implementation.
      */
     private String implementationTitle;
 
     /**
      * The name of the company or organization that produced this
      * implementation of this specification.
      */
     private String implementationVendor;
 
     /**
      * The version string for implementation. The version string is
      * opaque.
      */
     private String implementationVersion;
 
     /**
      * The sections of jar that the specification applies to.
      */
     private String[] sections;
 
     /**
      * Return an array of <code>Package Specification</code> objects.
      * If there are no such optional packages, a zero-length array is returned.
      *
      * @param manifest Manifest to be parsed
      * @return the Package Specifications extensions in specified manifest
      * @throws ParseException if the attributes of the specifications cannot
      * be parsed according to their expected formats.
      */
     public static Specification[] getSpecifications(final Manifest manifest)
         throws ParseException {
         if (null == manifest) {
             return new Specification[ 0 ];
         }
 
         final ArrayList results = new ArrayList();
 
         final Map entries = manifest.getEntries();
         final Iterator keys = entries.keySet().iterator();
         while (keys.hasNext()) {
             final String key = (String) keys.next();
             final Attributes attributes = (Attributes) entries.get(key);
             final Specification specification
                 = getSpecification(key, attributes);
             if (null != specification) {
                 results.add(specification);
             }
         }
 
         final ArrayList trimmedResults = removeDuplicates(results);
         return (Specification[]) trimmedResults.toArray(new Specification[trimmedResults.size()]);
     }
 
     /**
      * The constructor to create Package Specification object.
      * Note that every component is allowed to be specified
      * but only the specificationTitle is mandatory.
      *
      * @param specificationTitle the name of specification.
      * @param specificationVersion the specification Version.
      * @param specificationVendor the specification Vendor.
      * @param implementationTitle the title of implementation.
      * @param implementationVersion the implementation Version.
      * @param implementationVendor the implementation Vendor.
      */
     public Specification(final String specificationTitle,
                           final String specificationVersion,
                           final String specificationVendor,
                           final String implementationTitle,
                           final String implementationVersion,
                           final String implementationVendor) {
         this(specificationTitle, specificationVersion, specificationVendor,
               implementationTitle, implementationVersion, implementationVendor,
               null);
     }
 
     /**
      * The constructor to create Package Specification object.
      * Note that every component is allowed to be specified
      * but only the specificationTitle is mandatory.
      *
      * @param specificationTitle the name of specification.
      * @param specificationVersion the specification Version.
      * @param specificationVendor the specification Vendor.
      * @param implementationTitle the title of implementation.
      * @param implementationVersion the implementation Version.
      * @param implementationVendor the implementation Vendor.
      * @param sections the sections/packages that Specification applies to.
      */
     public Specification(final String specificationTitle,
                           final String specificationVersion,
                           final String specificationVendor,
                           final String implementationTitle,
                           final String implementationVersion,
                           final String implementationVendor,
                           final String[] sections) {
         this.specificationTitle = specificationTitle;
         this.specificationVendor = specificationVendor;
 
         if (null != specificationVersion) {
             try {
                 this.specificationVersion
                     = new DeweyDecimal(specificationVersion);
             } catch (final NumberFormatException nfe) {
                 final String error = "Bad specification version format '"
                     + specificationVersion + "' in '" + specificationTitle
                     + "'. (Reason: " + nfe + ")";
                 throw new IllegalArgumentException(error);
             }
         }
 
         this.implementationTitle = implementationTitle;
         this.implementationVendor = implementationVendor;
         this.implementationVersion = implementationVersion;
 
         if (null == this.specificationTitle) {
             throw new NullPointerException("specificationTitle");
         }
 
         String[] copy = null;
         if (null != sections) {
             copy = new String[ sections.length ];
             System.arraycopy(sections, 0, copy, 0, sections.length);
         }
         this.sections = copy;
     }
 
     /**
      * Get the title of the specification.
      *
-     * @return the title of speciication
+     * @return the title of specification
      */
     public String getSpecificationTitle() {
         return specificationTitle;
     }
 
     /**
      * Get the vendor of the specification.
      *
      * @return the vendor of the specification.
      */
     public String getSpecificationVendor() {
         return specificationVendor;
     }
 
     /**
      * Get the title of the specification.
      *
      * @return the title of the specification.
      */
     public String getImplementationTitle() {
         return implementationTitle;
     }
 
     /**
      * Get the version of the specification.
      *
      * @return the version of the specification.
      */
     public DeweyDecimal getSpecificationVersion() {
         return specificationVersion;
     }
 
     /**
      * Get the vendor of the extensions implementation.
      *
      * @return the vendor of the extensions implementation.
      */
     public String getImplementationVendor() {
         return implementationVendor;
     }
 
     /**
      * Get the version of the implementation.
      *
      * @return the version of the implementation.
      */
     public String getImplementationVersion() {
         return implementationVersion;
     }
 
     /**
      * Return an array containing sections to which specification applies
-     * or null if relevent to no sections.
+     * or null if relevant to no sections.
      *
      * @return an array containing sections to which specification applies
-     *         or null if relevent to no sections.
+     *         or null if relevant to no sections.
      */
     public String[] getSections() {
         if (null == sections) {
             return null;
         }
         final String[] newSections = new String[ sections.length ];
         System.arraycopy(sections, 0, newSections, 0, sections.length);
         return newSections;
     }
 
     /**
      * Return a Compatibility enum indicating the relationship of this
      * <code>Package Specification</code> with the specified
      * <code>Extension</code>.
      *
      * @param other the other specification
      * @return the enum indicating the compatibility (or lack thereof)
-     *         of specifed Package Specification
+     *         of specified Package Specification
      */
     public Compatibility getCompatibilityWith(final Specification other) {
         // Specification Name must match
         if (!specificationTitle.equals(other.getSpecificationTitle())) {
             return INCOMPATIBLE;
         }
 
         // Available specification version must be >= required
         final DeweyDecimal otherSpecificationVersion
             = other.getSpecificationVersion();
         if (null != specificationVersion) {
             if (null == otherSpecificationVersion
                 || !isCompatible(specificationVersion, otherSpecificationVersion)) {
                 return REQUIRE_SPECIFICATION_UPGRADE;
             }
         }
 
         // Implementation Vendor ID must match
         final String otherImplementationVendor
             = other.getImplementationVendor();
         if (null != implementationVendor) {
             if (null == otherImplementationVendor
                 || !implementationVendor.equals(otherImplementationVendor)) {
                 return REQUIRE_VENDOR_SWITCH;
             }
         }
 
         // Implementation version must be >= required
         final String otherImplementationVersion
             = other.getImplementationVersion();
         if (null != implementationVersion) {
             if (null == otherImplementationVersion
                 || !implementationVersion.equals(otherImplementationVersion)) {
                 return REQUIRE_IMPLEMENTATION_CHANGE;
             }
         }
 
         // This available optional package satisfies the requirements
         return COMPATIBLE;
     }
 
     /**
      * Return <code>true</code> if the specified <code>package</code>
      * is satisfied by this <code>Specification</code>. Otherwise, return
      * <code>false</code>.
      *
      * @param other the specification
      * @return true if the specification is compatible with this specification
      */
     public boolean isCompatibleWith(final Specification other) {
         return (COMPATIBLE == getCompatibilityWith(other));
     }
 
     /**
      * Return a String representation of this object.
      *
      * @return string representation of object.
      */
     public String toString() {
         final String brace = ": ";
 
         final StringBuffer sb
             = new StringBuffer(SPECIFICATION_TITLE.toString());
         sb.append(brace);
         sb.append(specificationTitle);
         sb.append(StringUtils.LINE_SEP);
 
         if (null != specificationVersion) {
             sb.append(SPECIFICATION_VERSION);
             sb.append(brace);
             sb.append(specificationVersion);
             sb.append(StringUtils.LINE_SEP);
         }
 
         if (null != specificationVendor) {
             sb.append(SPECIFICATION_VENDOR);
             sb.append(brace);
             sb.append(specificationVendor);
             sb.append(StringUtils.LINE_SEP);
         }
 
         if (null != implementationTitle) {
             sb.append(IMPLEMENTATION_TITLE);
             sb.append(brace);
             sb.append(implementationTitle);
             sb.append(StringUtils.LINE_SEP);
         }
 
         if (null != implementationVersion) {
             sb.append(IMPLEMENTATION_VERSION);
             sb.append(brace);
             sb.append(implementationVersion);
             sb.append(StringUtils.LINE_SEP);
         }
 
         if (null != implementationVendor) {
             sb.append(IMPLEMENTATION_VENDOR);
             sb.append(brace);
             sb.append(implementationVendor);
             sb.append(StringUtils.LINE_SEP);
         }
 
         return sb.toString();
     }
 
     /**
      * Return <code>true</code> if the first version number is greater than
      * or equal to the second; otherwise return <code>false</code>.
      *
      * @param first First version number (dotted decimal)
      * @param second Second version number (dotted decimal)
      */
     private boolean isCompatible(final DeweyDecimal first,
                                  final DeweyDecimal second) {
         return first.isGreaterThanOrEqual(second);
     }
 
     /**
      * Combine all specifications objects that are identical except
      * for the sections.
      *
      * <p>Note this is very inefficent and should probably be fixed
      * in the future.</p>
      *
      * @param list the array of results to trim
      * @return an array list with all duplicates removed
      */
     private static ArrayList removeDuplicates(final ArrayList list) {
         final ArrayList results = new ArrayList();
         final ArrayList sections = new ArrayList();
         while (list.size() > 0) {
             final Specification specification = (Specification) list.remove(0);
             final Iterator iterator = list.iterator();
             while (iterator.hasNext()) {
                 final Specification other = (Specification) iterator.next();
                 if (isEqual(specification, other)) {
                     final String[] otherSections = other.getSections();
                     if (null != otherSections) {
                         sections.addAll(Arrays.asList(otherSections));
                     }
                     iterator.remove();
                 }
             }
 
             final Specification merged =
                 mergeInSections(specification, sections);
             results.add(merged);
             //Reset list of sections
             sections.clear();
         }
 
         return results;
     }
 
     /**
      * Test if two specifications are equal except for their sections.
      *
      * @param specification one specificaiton
      * @param other the ohter specification
      * @return true if two specifications are equal except for their
      *         sections, else false
      */
     private static boolean isEqual(final Specification specification,
                                     final Specification other) {
         return
             specification.getSpecificationTitle().equals(other.getSpecificationTitle())
             && specification.getSpecificationVersion().isEqual(other.getSpecificationVersion())
             && specification.getSpecificationVendor().equals(other.getSpecificationVendor())
             && specification.getImplementationTitle().equals(other.getImplementationTitle())
             && specification.getImplementationVersion().equals(other.getImplementationVersion())
             && specification.getImplementationVendor().equals(other.getImplementationVendor());
     }
 
     /**
      * Merge the specified sections into specified section and return result.
      * If no sections to be added then just return original specification.
      *
      * @param specification the specification
      * @param sectionsToAdd the list of sections to merge
      * @return the merged specification
      */
     private static Specification mergeInSections(final Specification specification,
                                               final ArrayList sectionsToAdd) {
         if (0 == sectionsToAdd.size()) {
             return specification;
         }
         sectionsToAdd.addAll(Arrays.asList(specification.getSections()));
 
         final String[] sections =
             (String[]) sectionsToAdd.toArray(new String[sectionsToAdd.size()]);
 
         return new Specification(specification.getSpecificationTitle(),
                 specification.getSpecificationVersion().toString(),
                 specification.getSpecificationVendor(),
                 specification.getImplementationTitle(),
                 specification.getImplementationVersion(),
                 specification.getImplementationVendor(),
                 sections);
     }
 
     /**
      * Trim the supplied string if the string is non-null
      *
      * @param value the string to trim or null
      * @return the trimmed string or null
      */
     private static String getTrimmedString(final String value) {
         return value == null ? null : value.trim();
     }
 
     /**
      * Extract an Package Specification from Attributes.
      *
      * @param attributes Attributes to searched
      * @return the new Specification object, or null
      */
     private static Specification getSpecification(final String section,
                                                    final Attributes attributes)
         throws ParseException {
         //WARNING: We trim the values of all the attributes because
         //Some extension declarations are badly defined (ie have spaces
         //after version or vendor)
         final String name
             = getTrimmedString(attributes.getValue(SPECIFICATION_TITLE));
         if (null == name) {
             return null;
         }
 
         final String specVendor
             = getTrimmedString(attributes.getValue(SPECIFICATION_VENDOR));
         if (null == specVendor) {
             throw new ParseException(MISSING + SPECIFICATION_VENDOR, 0);
         }
 
         final String specVersion
             = getTrimmedString(attributes.getValue(SPECIFICATION_VERSION));
         if (null == specVersion) {
             throw new ParseException(MISSING + SPECIFICATION_VERSION, 0);
         }
 
         final String impTitle
             = getTrimmedString(attributes.getValue(IMPLEMENTATION_TITLE));
         if (null == impTitle) {
             throw new ParseException(MISSING + IMPLEMENTATION_TITLE, 0);
         }
 
         final String impVersion
             = getTrimmedString(attributes.getValue(IMPLEMENTATION_VERSION));
         if (null == impVersion) {
             throw new ParseException(MISSING + IMPLEMENTATION_VERSION, 0);
         }
 
         final String impVendor
             = getTrimmedString(attributes.getValue(IMPLEMENTATION_VENDOR));
         if (null == impVendor) {
             throw new ParseException(MISSING + IMPLEMENTATION_VENDOR, 0);
         }
 
         return new Specification(name, specVersion, specVendor,
                                   impTitle, impVersion, impVendor,
                                   new String[]{section});
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/extension/resolvers/URLResolver.java b/src/main/org/apache/tools/ant/taskdefs/optional/extension/resolvers/URLResolver.java
index 714f692fb..cfdd39852 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/extension/resolvers/URLResolver.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/extension/resolvers/URLResolver.java
@@ -1,132 +1,132 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.extension.resolvers;
 
 import java.io.File;
 import java.net.URL;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.Get;
 import org.apache.tools.ant.taskdefs.optional.extension.Extension;
 import org.apache.tools.ant.taskdefs.optional.extension.ExtensionResolver;
 
 /**
  * Resolver that just returns s specified location.
  *
  */
 public class URLResolver implements ExtensionResolver {
     private File destfile;
     private File destdir;
     private URL url;
 
     /**
      * Sets the URL
      * @param url the url
      */
     public void setUrl(final URL url) {
         this.url = url;
     }
 
     /**
      * Sets the destination file
      * @param destfile the destination file
      */
     public void setDestfile(final File destfile) {
         this.destfile = destfile;
     }
 
     /**
      * Sets the destination directory
      * @param destdir the destination directory
      */
     public void setDestdir(final File destdir) {
         this.destdir = destdir;
     }
 
     /**
      * Returns the file resolved from URL and directory
-     * @param extension the extention
+     * @param extension the extension
      * @param project the project
      * @return file the file resolved
      * @throws BuildException if the URL is invalid
      */
     public File resolve(final Extension extension,
                          final Project project) throws BuildException {
         validate();
 
         final File file = getDest();
 
         final Get get = new Get();
         get.setProject(project);
         get.setDest(file);
         get.setSrc(url);
         get.execute();
 
         return file;
     }
 
     /*
      * Gets the destination file
      */
     private File getDest() {
         File result;
         if (null != destfile) {
             result = destfile;
         } else {
             final String file = url.getFile();
             String filename;
             if (null == file || file.length() <= 1) {
                 filename = "default.file";
             } else {
                 int index = file.lastIndexOf('/');
                 if (-1 == index) {
                     index = 0;
                 }
                 filename = file.substring(index);
             }
             result = new File(destdir, filename);
         }
         return result;
     }
 
     /*
      * Validates URL
      */
     private void validate() {
         if (null == url) {
             final String message = "Must specify URL";
             throw new BuildException(message);
         }
 
         if (null == destdir && null == destfile) {
             final String message = "Must specify destination file or directory";
             throw new BuildException(message);
         } else if (null != destdir && null != destfile) {
             final String message = "Must not specify both destination file or directory";
             throw new BuildException(message);
         }
     }
 
     /**
      * Returns a string representation of the URL
      * @return the string representation
      */
     public String toString() {
         return "URL[" + url + "]";
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java b/src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java
index 34f7a37a9..2cc690bd9 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java
@@ -1,631 +1,631 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.i18n;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.util.Hashtable;
 import java.util.Locale;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.LineTokenizer;
 
 /**
  * Translates text embedded in files using Resource Bundle files.
  * Since ant 1.6 preserves line endings
  *
  */
 public class Translate extends MatchingTask {
     /**
      * search a bundle matching the specified language, the country and the variant
      */
     private static final int BUNDLE_SPECIFIED_LANGUAGE_COUNTRY_VARIANT = 0;
     /**
      * search a bundle matching the specified language, and the country
      */
     private static final int BUNDLE_SPECIFIED_LANGUAGE_COUNTRY = 1;
     /**
      * search a bundle matching the specified language only
      */
     private static final int BUNDLE_SPECIFIED_LANGUAGE = 2;
     /**
      * search a bundle matching nothing special
      */
     private static final int BUNDLE_NOMATCH = 3;
     /**
      * search a bundle matching the language, the country and the variant
      * of the current locale of the computer
      */
     private static final int BUNDLE_DEFAULT_LANGUAGE_COUNTRY_VARIANT = 4;
     /**
      * search a bundle matching the language, and the country
      * of the current locale of the computer
      */
     private static final int BUNDLE_DEFAULT_LANGUAGE_COUNTRY = 5;
     /**
      * search a bundle matching the language only
      * of the current locale of the computer
      */
     private static final int BUNDLE_DEFAULT_LANGUAGE = 6;
     /**
      * number of possibilities for the search
      */
      private static final int BUNDLE_MAX_ALTERNATIVES = BUNDLE_DEFAULT_LANGUAGE + 1;
     /**
      * Family name of resource bundle
      */
     private String bundle;
 
     /**
      * Locale specific language of the resource bundle
      */
     private String bundleLanguage;
 
     /**
      * Locale specific country of the resource bundle
      */
     private String bundleCountry;
 
     /**
      * Locale specific variant of the resource bundle
      */
     private String bundleVariant;
 
     /**
      * Destination directory
      */
     private File toDir;
 
     /**
      * Source file encoding scheme
      */
     private String srcEncoding;
 
     /**
      * Destination file encoding scheme
      */
     private String destEncoding;
 
     /**
      * Resource Bundle file encoding scheme, defaults to srcEncoding
      */
     private String bundleEncoding;
 
     /**
      * Starting token to identify keys
      */
     private String startToken;
 
     /**
      * Ending token to identify keys
      */
     private String endToken;
 
     /**
      * Whether or not to create a new destination file.
      * Defaults to <code>false</code>.
      */
     private boolean forceOverwrite;
 
     /**
      * Vector to hold source file sets.
      */
     private Vector filesets = new Vector();
 
     /**
      * Holds key value pairs loaded from resource bundle file
      */
     private Hashtable resourceMap = new Hashtable();
     /**
 
      * Used to resolve file names.
      */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Last Modified Timestamp of resource bundle file being used.
      */
     private long[] bundleLastModified = new long[BUNDLE_MAX_ALTERNATIVES];
 
     /**
      * Last Modified Timestamp of source file being used.
      */
     private long srcLastModified;
 
     /**
      * Last Modified Timestamp of destination file being used.
      */
     private long destLastModified;
 
     /**
      * Has at least one file from the bundle been loaded?
      */
     private boolean loaded = false;
 
     /**
      * Sets Family name of resource bundle; required.
      * @param bundle family name of resource bundle
      */
     public void setBundle(String bundle) {
         this.bundle = bundle;
     }
 
     /**
      * Sets locale specific language of resource bundle; optional.
-     * @param bundleLanguage langage of the bundle
+     * @param bundleLanguage language of the bundle
      */
     public void setBundleLanguage(String bundleLanguage) {
         this.bundleLanguage = bundleLanguage;
     }
 
     /**
      * Sets locale specific country of resource bundle; optional.
      * @param bundleCountry country of the bundle
      */
     public void setBundleCountry(String bundleCountry) {
         this.bundleCountry = bundleCountry;
     }
 
     /**
      * Sets locale specific variant of resource bundle; optional.
      * @param bundleVariant locale variant of resource bundle
      */
     public void setBundleVariant(String bundleVariant) {
         this.bundleVariant = bundleVariant;
     }
 
     /**
      * Sets Destination directory; required.
      * @param toDir destination directory
      */
     public void setToDir(File toDir) {
         this.toDir = toDir;
     }
 
     /**
      * Sets starting token to identify keys; required.
      * @param startToken starting token to identify keys
      */
     public void setStartToken(String startToken) {
         this.startToken = startToken;
     }
 
     /**
      * Sets ending token to identify keys; required.
      * @param endToken ending token to identify keys
      */
     public void setEndToken(String endToken) {
         this.endToken = endToken;
     }
 
     /**
      * Sets source file encoding scheme; optional,
      * defaults to encoding of local system.
      * @param srcEncoding source file encoding
      */
     public void setSrcEncoding(String srcEncoding) {
         this.srcEncoding = srcEncoding;
     }
 
     /**
      * Sets destination file encoding scheme; optional.  Defaults to source file
      * encoding
      * @param destEncoding destination file encoding scheme
      */
     public void setDestEncoding(String destEncoding) {
         this.destEncoding = destEncoding;
     }
 
     /**
      * Sets Resource Bundle file encoding scheme; optional.  Defaults to source file
      * encoding
      * @param bundleEncoding bundle file encoding scheme
      */
     public void setBundleEncoding(String bundleEncoding) {
         this.bundleEncoding = bundleEncoding;
     }
 
     /**
      * Whether or not to overwrite existing file irrespective of
      * whether it is newer than the source file as well as the
      * resource bundle file.
      * Defaults to false.
      * @param forceOverwrite whether or not to overwrite existing files
      */
     public void setForceOverwrite(boolean forceOverwrite) {
         this.forceOverwrite = forceOverwrite;
     }
 
     /**
      * Adds a set of files to translate as a nested fileset element.
      * @param set the fileset to be added
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
     /**
      * Check attributes values, load resource map and translate
      * @throws BuildException if the required attributes are not set
      * Required : <ul>
      *       <li>bundle</li>
      *       <li>starttoken</li>
      *       <li>endtoken</li>
      *            </ul>
      */
     public void execute() throws BuildException {
         if (bundle == null) {
             throw new BuildException("The bundle attribute must be set.",
                                      getLocation());
         }
 
         if (startToken == null) {
             throw new BuildException("The starttoken attribute must be set.",
                                      getLocation());
         }
 
         if (endToken == null) {
             throw new BuildException("The endtoken attribute must be set.",
                                      getLocation());
         }
 
         if (bundleLanguage == null) {
             Locale l = Locale.getDefault();
             bundleLanguage  = l.getLanguage();
         }
 
         if (bundleCountry == null) {
             bundleCountry = Locale.getDefault().getCountry();
         }
 
         if (bundleVariant == null) {
             Locale l = new Locale(bundleLanguage, bundleCountry);
             bundleVariant = l.getVariant();
         }
 
         if (toDir == null) {
             throw new BuildException("The todir attribute must be set.",
                                      getLocation());
         }
 
         if (!toDir.exists()) {
             toDir.mkdirs();
         } else if (toDir.isFile()) {
             throw new BuildException(toDir + " is not a directory");
         }
 
         if (srcEncoding == null) {
             srcEncoding = System.getProperty("file.encoding");
         }
 
         if (destEncoding == null) {
             destEncoding = srcEncoding;
         }
 
         if (bundleEncoding == null) {
             bundleEncoding = srcEncoding;
         }
 
         loadResourceMaps();
 
         translate();
     }
 
     /**
      * Load resource maps based on resource bundle encoding scheme.
      * The resource bundle lookup searches for resource files with various
      * suffixes on the basis of (1) the desired locale and (2) the default
      * locale (basebundlename), in the following order from lower-level
      * (more specific) to parent-level (less specific):
      *
      * basebundlename + "_" + language1 + "_" + country1 + "_" + variant1
      * basebundlename + "_" + language1 + "_" + country1
      * basebundlename + "_" + language1
      * basebundlename
      * basebundlename + "_" + language2 + "_" + country2 + "_" + variant2
      * basebundlename + "_" + language2 + "_" + country2
      * basebundlename + "_" + language2
      *
      * To the generated name, a ".properties" string is appeneded and
      * once this file is located, it is treated just like a properties file
      * but with bundle encoding also considered while loading.
      */
     private void loadResourceMaps() throws BuildException {
         Locale locale = new Locale(bundleLanguage,
                                    bundleCountry,
                                    bundleVariant);
         String language = locale.getLanguage().length() > 0
             ? "_" + locale.getLanguage() : "";
         String country = locale.getCountry().length() > 0
             ? "_" + locale.getCountry() : "";
         String variant = locale.getVariant().length() > 0
             ? "_" + locale.getVariant() : "";
         String bundleFile = bundle + language + country + variant;
         processBundle(bundleFile, BUNDLE_SPECIFIED_LANGUAGE_COUNTRY_VARIANT, false);
 
         bundleFile = bundle + language + country;
         processBundle(bundleFile, BUNDLE_SPECIFIED_LANGUAGE_COUNTRY, false);
 
         bundleFile = bundle + language;
         processBundle(bundleFile, BUNDLE_SPECIFIED_LANGUAGE, false);
 
         bundleFile = bundle;
         processBundle(bundleFile, BUNDLE_NOMATCH, false);
 
         //Load default locale bundle files
         //using default file encoding scheme.
         locale = Locale.getDefault();
 
         language = locale.getLanguage().length() > 0
             ? "_" + locale.getLanguage() : "";
         country = locale.getCountry().length() > 0
             ? "_" + locale.getCountry() : "";
         variant = locale.getVariant().length() > 0
             ? "_" + locale.getVariant() : "";
         bundleEncoding = System.getProperty("file.encoding");
 
         bundleFile = bundle + language + country + variant;
         processBundle(bundleFile, BUNDLE_DEFAULT_LANGUAGE_COUNTRY_VARIANT, false);
 
         bundleFile = bundle + language + country;
         processBundle(bundleFile, BUNDLE_DEFAULT_LANGUAGE_COUNTRY, false);
 
         bundleFile = bundle + language;
         processBundle(bundleFile, BUNDLE_DEFAULT_LANGUAGE, true);
     }
 
     /**
      * Process each file that makes up this bundle.
      */
     private void processBundle(final String bundleFile, final int i,
                                final boolean checkLoaded) throws BuildException {
         final File propsFile = getProject().resolveFile(bundleFile + ".properties");
         FileInputStream ins = null;
         try {
             ins = new FileInputStream(propsFile);
             loaded = true;
             bundleLastModified[i] = propsFile.lastModified();
             log("Using " + propsFile, Project.MSG_DEBUG);
             loadResourceMap(ins);
         } catch (IOException ioe) {
             log(propsFile + " not found.", Project.MSG_DEBUG);
             //if all resource files associated with this bundle
             //have been scanned for and still not able to
             //find a single resrouce file, throw exception
             if (!loaded && checkLoaded) {
                 throw new BuildException(ioe.getMessage(), getLocation());
             }
         }
     }
 
     /**
      * Load resourceMap with key value pairs.  Values of existing keys
      * are not overwritten.  Bundle's encoding scheme is used.
      */
     private void loadResourceMap(FileInputStream ins) throws BuildException {
         try {
             BufferedReader in = null;
             InputStreamReader isr = new InputStreamReader(ins, bundleEncoding);
             in = new BufferedReader(isr);
             String line = null;
             while ((line = in.readLine()) != null) {
                 //So long as the line isn't empty and isn't a comment...
                 if (line.trim().length() > 1 && '#' != line.charAt(0) && '!' != line.charAt(0)) {
                     //Legal Key-Value separators are :, = and white space.
                     int sepIndex = line.indexOf('=');
                     if (-1 == sepIndex) {
                         sepIndex = line.indexOf(':');
                     }
                     if (-1 == sepIndex) {
                         for (int k = 0; k < line.length(); k++) {
                             if (Character.isSpaceChar(line.charAt(k))) {
                                 sepIndex = k;
                                 break;
                             }
                         }
                     }
                     //Only if we do have a key is there going to be a value
                     if (-1 != sepIndex) {
                         String key = line.substring(0, sepIndex).trim();
                         String value = line.substring(sepIndex + 1).trim();
                         //Handle line continuations, if any
                         while (value.endsWith("\\")) {
                             value = value.substring(0, value.length() - 1);
                             line = in.readLine();
                             if (line != null) {
                                 value = value + line.trim();
                             } else {
                                 break;
                             }
                         }
                         if (key.length() > 0) {
                             //Has key already been loaded into resourceMap?
                             if (resourceMap.get(key) == null) {
                                 resourceMap.put(key, value);
                             }
                         }
                     }
                 }
             }
             if (in != null) {
                 in.close();
             }
         } catch (IOException ioe) {
             throw new BuildException(ioe.getMessage(), getLocation());
         }
     }
 
     /**
      * Reads source file line by line using the source encoding and
      * searches for keys that are sandwiched between the startToken
      * and endToken.  The values for these keys are looked up from
      * the hashtable and substituted.  If the hashtable doesn't
      * contain the key, they key itself is used as the value.
      * Detination files and directories are created as needed.
      * The destination file is overwritten only if
      * the forceoverwritten attribute is set to true if
      * the source file or any associated bundle resource file is
      * newer than the destination file.
      */
     private void translate() throws BuildException {
         int filesProcessed = 0;
         final int size = filesets.size();
         for (int i = 0; i < size; i++) {
             FileSet fs = (FileSet) filesets.elementAt(i);
             DirectoryScanner ds = fs.getDirectoryScanner(getProject());
             String[] srcFiles = ds.getIncludedFiles();
             for (int j = 0; j < srcFiles.length; j++) {
                 try {
                     File dest = FILE_UTILS.resolveFile(toDir, srcFiles[j]);
                     //Make sure parent dirs exist, else, create them.
                     try {
                         File destDir = new File(dest.getParent());
                         if (!destDir.exists()) {
                             destDir.mkdirs();
                         }
                     } catch (Exception e) {
                         log("Exception occurred while trying to check/create "
                             + " parent directory.  " + e.getMessage(),
                             Project.MSG_DEBUG);
                     }
                     destLastModified = dest.lastModified();
                     File src = FILE_UTILS.resolveFile(ds.getBasedir(), srcFiles[j]);
                     srcLastModified = src.lastModified();
                     //Check to see if dest file has to be recreated
                     boolean needsWork = forceOverwrite
                         || destLastModified < srcLastModified;
                     if (!needsWork) {
                         for (int icounter = 0; icounter < BUNDLE_MAX_ALTERNATIVES; icounter++) {
                             needsWork = (destLastModified < bundleLastModified[icounter]);
                             if (needsWork) {
                                 break;
                             }
                         }
                     }
                     if (needsWork) {
                         log("Processing " + srcFiles[j],
                             Project.MSG_DEBUG);
                         translateOneFile(src, dest);
                         ++filesProcessed;
                     } else {
                         log("Skipping " + srcFiles[j]
                             + " as destination file is up to date",
                             Project.MSG_VERBOSE);
                     }
                 } catch (IOException ioe) {
                     throw new BuildException(ioe.getMessage(), getLocation());
                 }
             }
         }
         log("Translation performed on " + filesProcessed + " file(s).", Project.MSG_DEBUG);
     }
 
     private void translateOneFile(File src, File dest) throws IOException {
         BufferedWriter out = null;
         BufferedReader in = null;
         try {
             FileOutputStream fos = new FileOutputStream(dest);
             out = new BufferedWriter(new OutputStreamWriter(fos, destEncoding));
             FileInputStream fis = new FileInputStream(src);
             in = new BufferedReader(new InputStreamReader(fis, srcEncoding));
             String line;
             LineTokenizer lineTokenizer = new LineTokenizer();
             lineTokenizer.setIncludeDelims(true);
             line = lineTokenizer.getToken(in);
             while ((line) != null) {
                 // 2003-02-21 new replace algorithm by tbee (tbee@tbee.org)
                 // because it wasn't able to replace something like "@aaa;@bbb;"
 
                 // is there a startToken
                 // and there is still stuff following the startToken
                 int startIndex = line.indexOf(startToken);
                 while (startIndex >= 0
                        && (startIndex + startToken.length()) <= line.length()) {
                     // the new value, this needs to be here
                     // because it is required to calculate the next position to
                     // search from at the end of the loop
                     String replace = null;
 
                     // we found a starttoken, is there an endtoken following?
                     // start at token+tokenlength because start and end
                     // token may be indentical
                     int endIndex = line.indexOf(endToken, startIndex
                                                 + startToken.length());
                     if (endIndex < 0) {
                         startIndex += 1;
                     } else {
                         // grab the token
                         String token = line.substring(startIndex
                                                       + startToken.length(),
                                                       endIndex);
 
                         // If there is a white space or = or :, then
                         // it isn't to be treated as a valid key.
                         boolean validToken = true;
                         for (int k = 0; k < token.length() && validToken; k++) {
                             char c = token.charAt(k);
                             if (c == ':' || c == '='
                                 || Character.isSpaceChar(c)) {
                                 validToken = false;
                             }
                         }
                         if (!validToken) {
                             startIndex += 1;
                         } else {
                             // find the replace string
                             if (resourceMap.containsKey(token)) {
                                 replace = (String) resourceMap.get(token);
                             } else {
                                 log("Replacement string missing for: " + token,
                                     Project.MSG_VERBOSE);
                                 replace = startToken + token + endToken;
                             }
 
 
                             // generate the new line
                             line = line.substring(0, startIndex) + replace
                                 + line.substring(endIndex + endToken.length());
 
                             // set start position for next search
                             startIndex += replace.length();
                         }
                     }
 
                     // find next starttoken
                     startIndex = line.indexOf(startToken, startIndex);
                 }
                 out.write(line);
                 line = lineTokenizer.getToken(in);
             }
         } finally {
             FileUtils.close(in);
             FileUtils.close(out);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/j2ee/GenericHotDeploymentTool.java b/src/main/org/apache/tools/ant/taskdefs/optional/j2ee/GenericHotDeploymentTool.java
index 3a25e6162..5a5abbab6 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/j2ee/GenericHotDeploymentTool.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/j2ee/GenericHotDeploymentTool.java
@@ -1,140 +1,140 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.j2ee;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.Java;
 import org.apache.tools.ant.types.Commandline;
 
 /**
  *  A generic tool for J2EE server hot deployment.
  *  <p>The simple implementation spawns a JVM with the supplied
  *  class name, jvm args, and arguments.
  *
  *  @see org.apache.tools.ant.taskdefs.optional.j2ee.HotDeploymentTool
  *  @see org.apache.tools.ant.taskdefs.optional.j2ee.AbstractHotDeploymentTool
  *  @see org.apache.tools.ant.taskdefs.optional.j2ee.ServerDeploy
  */
 public class GenericHotDeploymentTool extends AbstractHotDeploymentTool {
     /** A Java task used to run the deployment tool **/
     private Java java;
 
     /** The fully qualified class name of the deployment tool **/
     private String className;
 
     /** List of valid actions **/
     private static final String[] VALID_ACTIONS = {ACTION_DEPLOY};
 
     /**
      *  Add a nested argument element to hand to the deployment tool; optional.
      *  @return A Commandline.Argument object representing the
      *  command line argument being passed when the deployment
      *  tool is run.  IE: "-user=mark", "-password=venture"...
      */
     public Commandline.Argument createArg() {
         return java.createArg();
     }
 
     /**
-     *  Add a nested argment element to hand to the JVM running the
+     *  Add a nested argument element to hand to the JVM running the
      *  deployment tool.
      *  Creates a nested arg element.
      *  @return A Commandline.Argument object representing the
      *  JVM command line argument being passed when the deployment
      *  tool is run.  IE: "-ms64m", "-mx128m"...
      */
     public Commandline.Argument createJvmarg() {
         return java.createJvmarg();
     }
 
     /**
      *  Determines if the "action" attribute defines a valid action.
      *  <p>Subclasses should determine if the action passed in is
      *  supported by the vendor's deployment tool.
      *  For this generic implementation, the only valid action is "deploy"
      *  @return true if the "action" attribute is valid, false if not.
      */
     protected boolean isActionValid() {
         return (getTask().getAction().equals(VALID_ACTIONS[0]));
     }
 
     /**
      *  Sets the parent task.
      *  @param task An ServerDeploy object representing the parent task.
      *  @ant.attribute ignored="true"
      */
     public void setTask(ServerDeploy task) {
         super.setTask(task);
         java = new Java(task);
     }
 
     /**
      *  Perform the actual deployment.
      *  For this generic implementation, a JVM is spawned using the
      *  supplied classpath, classname, JVM args, and command line arguments.
      *  @exception org.apache.tools.ant.BuildException if the attributes are invalid or incomplete.
      */
     public void deploy() throws BuildException {
         java.setClassname(className);
         java.setClasspath(getClasspath());
         java.setFork(true);
         java.setFailonerror(true);
         java.execute();
     }
 
     /**
      *  Validates the passed in attributes.
      *  Ensures the className and arguments attribute have been set.
      *  @exception org.apache.tools.ant.BuildException if the attributes are invalid or incomplete.
      */
     public void validateAttributes() throws BuildException {
         super.validateAttributes();
 
         if (className == null) {
             throw new BuildException("The classname attribute must be set");
         }
     }
 
     /**
-     *  The name of the class to execute to perfom
+     *  The name of the class to execute to perform
      *  deployment; required.
      *  Example: "com.foobar.tools.deploy.DeployTool"
      *  @param className The fully qualified class name of the class
      *  to perform deployment.
      */
     public void setClassName(String className) {
         this.className = className;
     }
 
     /**
      * get the java attribute.
      * @return the java attribute.
      */
     public Java getJava() {
         return java;
     }
 
     /**
      * Get the classname attribute.
      * @return the classname value.
      */
     public String getClassName() {
         return className;
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/j2ee/JonasHotDeploymentTool.java b/src/main/org/apache/tools/ant/taskdefs/optional/j2ee/JonasHotDeploymentTool.java
index caed6a5ac..a2b265c58 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/j2ee/JonasHotDeploymentTool.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/j2ee/JonasHotDeploymentTool.java
@@ -1,251 +1,251 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.j2ee;
 
 import java.io.File;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.Java;
 import org.apache.tools.ant.types.Path;
 
 /**
  *  An Ant wrapper task for the weblogic.deploy tool. This is used
  *  to hot-deploy J2EE applications to a running WebLogic server.
  *  This is <b>not</b> the same as creating the application
  *  archive. This task assumes the archive (EAR, JAR, or WAR) file
  *  has been assembled and is supplied as the "source" attribute.
  *  <p>
  *
- *  In the end, this task assembles the commadline parameters and
- *  runs the weblogic.deploy tool in a seperate JVM.
+ *  In the end, this task assembles the commandline parameters and
+ *  runs the weblogic.deploy tool in a separate JVM.
  *
  *@see org.apache.tools.ant.taskdefs.optional.j2ee.HotDeploymentTool
  *@see org.apache.tools.ant.taskdefs.optional.j2ee.AbstractHotDeploymentTool
  *@see org.apache.tools.ant.taskdefs.optional.j2ee.ServerDeploy
  */
 public class JonasHotDeploymentTool extends GenericHotDeploymentTool implements HotDeploymentTool {
 
     /**
      *  Description of the Field
      */
     protected static final String DEFAULT_ORB = "RMI";
 
     /**
      *  The classname of the tool to run *
      */
     private static final String JONAS_DEPLOY_CLASS_NAME = "org.objectweb.jonas.adm.JonasAdmin";
 
     /**
      *  All the valid actions that weblogic.deploy permits *
      */
     private static final String[] VALID_ACTIONS
         = {ACTION_DELETE, ACTION_DEPLOY, ACTION_LIST, ACTION_UNDEPLOY, ACTION_UPDATE};
 
     /**
      *  Description of the Field
      */
     private File jonasroot;
 
     /**
      *  Description of the Field
      */
     private String orb = null;
 
     /**
      *  Description of the Field
      */
     private String davidHost;
 
     /**
      *  Description of the Field
      */
     private int davidPort;
 
 
     /**
      *  Set the host for the David ORB; required if
      *  ORB==david.
      *
      *@param  inValue  The new davidhost value
      */
     public void setDavidhost(final String inValue) {
         davidHost = inValue;
     }
 
 
     /**
      *  Set the port for the David ORB; required if
      *  ORB==david.
      *
      *@param  inValue  The new davidport value
      */
     public void setDavidport(final int inValue) {
         davidPort = inValue;
     }
 
 
     /**
      *  set the jonas root directory (-Dinstall.root=). This
      *  element is required.
      *
      *@param  inValue  The new jonasroot value
      */
     public void setJonasroot(final File inValue) {
         jonasroot = inValue;
     }
 
 
     /**
      *
      * Choose your ORB : RMI, JEREMIE, DAVID, ...; optional.
      * If omitted, it defaults
      * to the one present in classpath. The corresponding JOnAS JAR is
      * automatically added to the classpath. If your orb is DAVID (RMI/IIOP) you must
      * specify davidhost and davidport properties.
      *
      *@param  inValue  RMI, JEREMIE, DAVID,...
      */
     public void setOrb(final String inValue) {
         orb = inValue;
     }
 
 
     /**
      *  gets the classpath field.
      *
      *@return    A Path representing the "classpath" attribute.
      */
     public Path getClasspath() {
 
         Path aClassPath = super.getClasspath();
 
         if (aClassPath == null) {
             aClassPath = new Path(getTask().getProject());
         }
         if (orb != null) {
             String aOrbJar = new File(jonasroot, "lib/" + orb + "_jonas.jar").toString();
             String aConfigDir = new File(jonasroot, "config/").toString();
             Path aJOnASOrbPath = new Path(aClassPath.getProject(),
                     aOrbJar + File.pathSeparator + aConfigDir);
             aClassPath.append(aJOnASOrbPath);
         }
         return aClassPath;
     }
 
 
     /**
      *  Validates the passed in attributes. <p>
      *
      *  The rules are:
      *  <ol>
      *    <li> If action is "deploy" or "update" the "application"
      *    and "source" attributes must be supplied.
      *    <li> If action is "delete" or "undeploy" the
      *    "application" attribute must be supplied.
      *
      *@exception  BuildException                       Description
      *      of Exception
      */
     public void validateAttributes() throws BuildException {
         // super.validateAttributes(); // don't want to call this method
 
         Java java = getJava();
 
         String action = getTask().getAction();
         if (action == null) {
             throw new BuildException("The \"action\" attribute must be set");
         }
 
         if (!isActionValid()) {
             throw new BuildException("Invalid action \"" + action + "\" passed");
         }
 
         if (getClassName() == null) {
             setClassName(JONAS_DEPLOY_CLASS_NAME);
         }
 
         if (jonasroot == null || jonasroot.isDirectory()) {
             java.createJvmarg().setValue("-Dinstall.root=" + jonasroot);
             java.createJvmarg().setValue("-Djava.security.policy=" + jonasroot
                 + "/config/java.policy");
 
             if ("DAVID".equals(orb)) {
                 java.createJvmarg().setValue("-Dorg.omg.CORBA.ORBClass"
                     + "=org.objectweb.david.libs.binding.orbs.iiop.IIOPORB");
                 java.createJvmarg().setValue("-Dorg.omg.CORBA.ORBSingletonClass="
                     + "org.objectweb.david.libs.binding.orbs.ORBSingletonClass");
                 java.createJvmarg().setValue("-Djavax.rmi.CORBA.StubClass="
                     + "org.objectweb.david.libs.stub_factories.rmi.StubDelegate");
                 java.createJvmarg().setValue("-Djavax.rmi.CORBA.PortableRemoteObjectClass="
                     + "org.objectweb.david.libs.binding.rmi.ORBPortableRemoteObjectDelegate");
                 java.createJvmarg().setValue("-Djavax.rmi.CORBA.UtilClass="
                     + "org.objectweb.david.libs.helpers.RMIUtilDelegate");
                 java.createJvmarg().setValue("-Ddavid.CosNaming.default_method=0");
                 java.createJvmarg().setValue("-Ddavid.rmi.ValueHandlerClass="
                     + "com.sun.corba.se.internal.io.ValueHandlerImpl");
                 if (davidHost != null) {
                     java.createJvmarg().setValue("-Ddavid.CosNaming.default_host="
                         + davidHost);
                 }
                 if (davidPort != 0) {
                     java.createJvmarg().setValue("-Ddavid.CosNaming.default_port="
                         + davidPort);
                 }
             }
         }
 
         if (getServer() != null) {
             java.createArg().setLine("-n " + getServer());
         }
 
         if (action.equals(ACTION_DEPLOY)
             || action.equals(ACTION_UPDATE)
             || action.equals("redeploy")) {
             java.createArg().setLine("-a " + getTask().getSource());
         } else if (action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)) {
             java.createArg().setLine("-r " + getTask().getSource());
         } else if (action.equals(ACTION_LIST)) {
             java.createArg().setValue("-l");
         }
     }
 
 
     /**
      *  Determines if the action supplied is valid. <p>
      *
      *  Valid actions are contained in the static array
      *  VALID_ACTIONS
      *
      *@return    true if the action attribute is valid, false if
      *      not.
      */
     protected boolean isActionValid() {
         boolean valid = false;
 
         String action = getTask().getAction();
 
         for (int i = 0; i < VALID_ACTIONS.length; i++) {
             if (action.equals(VALID_ACTIONS[i])) {
                 valid = true;
                 break;
             }
         }
 
         return valid;
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/j2ee/WebLogicHotDeploymentTool.java b/src/main/org/apache/tools/ant/taskdefs/optional/j2ee/WebLogicHotDeploymentTool.java
index 6fbbad22e..da8750927 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/j2ee/WebLogicHotDeploymentTool.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/j2ee/WebLogicHotDeploymentTool.java
@@ -1,247 +1,247 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.j2ee;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.Java;
 
 /**
  *  An Ant wrapper task for the weblogic.deploy tool.  This is used to
  *  hot-deploy J2EE applications to a running WebLogic server.
  *  This is <b>not</b> the same as creating the application archive.
  *  This task assumes the archive (EAR, JAR, or WAR) file has been
  *  assembled and is supplied as the "source" attribute.
- *  <p>In the end, this task assembles the commadline parameters
- *  and runs the weblogic.deploy tool in a seperate JVM.
+ *  <p>In the end, this task assembles the commandline parameters
+ *  and runs the weblogic.deploy tool in a separate JVM.
  *
  *  @see org.apache.tools.ant.taskdefs.optional.j2ee.HotDeploymentTool
  *  @see org.apache.tools.ant.taskdefs.optional.j2ee.AbstractHotDeploymentTool
  *  @see org.apache.tools.ant.taskdefs.optional.j2ee.ServerDeploy
  */
 public class WebLogicHotDeploymentTool extends AbstractHotDeploymentTool
                                        implements HotDeploymentTool {
     private static final int STRING_BUFFER_SIZE = 1024;
     /** The classname of the tool to run **/
     private static final String WEBLOGIC_DEPLOY_CLASS_NAME = "weblogic.deploy";
 
     /** All the valid actions that weblogic.deploy permits **/
     private static final String[] VALID_ACTIONS
         = {ACTION_DELETE, ACTION_DEPLOY, ACTION_LIST, ACTION_UNDEPLOY, ACTION_UPDATE};
 
     /** Represents the "-debug" flag from weblogic.deploy **/
     private boolean debug;
 
     /** The application name that is being deployed **/
     private String application;
 
     /** The component name:target(s) for the "-component" argument of weblogic.deploy **/
     private String component;
 
     /**
      *  Perform the actual deployment.
      *  For this implementation, a JVM is spawned and the weblogic.deploy
      *  tools is executed.
      *  @exception org.apache.tools.ant.BuildException if the attributes are invalid or incomplete.
      */
     public void deploy() {
         Java java = new Java(getTask());
         java.setFork(true);
         java.setFailonerror(true);
         java.setClasspath(getClasspath());
 
         java.setClassname(WEBLOGIC_DEPLOY_CLASS_NAME);
         java.createArg().setLine(getArguments());
         java.execute();
     }
 
     /**
      *  Validates the passed in attributes.
      *  <p>The rules are:
      *  <ol><li>If action is "deploy" or "update" the "application" and "source"
      *  attributes must be supplied.
      *  <li>If action is "delete" or "undeploy" the "application" attribute must
      *  be supplied.
      *  @exception org.apache.tools.ant.BuildException if the attributes are invalid or incomplete
      */
     public void validateAttributes() throws BuildException {
         super.validateAttributes();
 
         String action = getTask().getAction();
 
         // check that the password has been set
         if ((getPassword() == null)) {
             throw new BuildException("The password attribute must be set.");
         }
 
         // check for missing application on deploy & update
         if ((action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE))
             && application == null) {
             throw new BuildException("The application attribute must be set "
                 + "if action = " + action);
         }
 
         // check for missing source on deploy & update
         if ((action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE))
             && getTask().getSource() == null) {
             throw new BuildException("The source attribute must be set if "
                 + "action = " + action);
         }
 
         // check for missing application on delete & undeploy
         if ((action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY))
             && application == null) {
             throw new BuildException("The application attribute must be set if "
                 + "action = " + action);
         }
     }
 
     /**
      *  Builds the arguments to pass to weblogic.deploy according to the
      *  supplied action.
      *  @return A String containing the arguments for the weblogic.deploy tool.
      * @throws BuildException if there is an error.
      */
     public String getArguments() throws BuildException {
         String action = getTask().getAction();
         String args = null;
 
         if (action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE)) {
             args = buildDeployArgs();
         } else if (action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)) {
             args = buildUndeployArgs();
         } else if (action.equals(ACTION_LIST)) {
             args = buildListArgs();
         }
 
         return args;
     }
 
     /**
      *  Determines if the action supplied is valid.
      *  <p>Valid actions are contained in the static array VALID_ACTIONS
      *  @return true if the action attribute is valid, false if not.
      */
     protected boolean isActionValid() {
         boolean valid = false;
 
         String action = getTask().getAction();
 
         for (int i = 0; i < VALID_ACTIONS.length; i++) {
             if (action.equals(VALID_ACTIONS[i])) {
                 valid = true;
                 break;
             }
         }
 
         return valid;
     }
 
     /**
      *  Builds the prefix arguments to pass to weblogic.deploy.
      *  These arguments are generic across all actions.
      *  @return A StringBuffer containing the prefix arguments.
      *  The action-specific build methods will append to this StringBuffer.
      */
     protected StringBuffer buildArgsPrefix() {
         ServerDeploy task = getTask();
         // constructs the "-url <url> -debug <action> <password>" portion
         // of the commmand line
         return new StringBuffer(STRING_BUFFER_SIZE)
                 .append((getServer() != null)
                     ? "-url " + getServer()
                     : "")
                 .append(" ")
                 .append(debug ? "-debug " : "")
                 .append((getUserName() != null)
                     ? "-username " + getUserName()
                     : "")
                 .append(" ")
                 .append(task.getAction()).append(" ")
                 .append(getPassword()).append(" ");
     }
 
     /**
      *  Builds the arguments to pass to weblogic.deploy for deployment actions
      *  ("deploy" and "update").
      *  @return A String containing the full argument string for weblogic.deploy.
      */
     protected String buildDeployArgs() {
         String args = buildArgsPrefix()
                 .append(application).append(" ")
                 .append(getTask().getSource())
                 .toString();
 
         if (component != null) {
             args = "-component " + component + " " + args;
         }
 
         return args;
     }
 
     /**
      *  Builds the arguments to pass to weblogic.deploy for undeployment actions
      *  ("undeploy" and "delete").
      *  @return A String containing the full argument string for weblogic.deploy.
      */
     protected String buildUndeployArgs() {
         return buildArgsPrefix()
                 .append(application).append(" ")
                 .toString();
     }
 
     /**
      *  Builds the arguments to pass to weblogic.deploy for the list action
      *  @return A String containing the full argument string for weblogic.deploy.
      */
     protected String buildListArgs() {
         return buildArgsPrefix()
                 .toString();
     }
 
     /**
      *  If set to true, additional information will be
      *  printed during the deployment process; optional.
      *  @param debug A boolean representing weblogic.deploy "-debug" flag.
      */
     public void setDebug(boolean debug) {
         this.debug = debug;
     }
 
     /**
      *  The name of the application being deployed; required.
      *  @param application A String representing the application portion of the
      *  weblogic.deploy command line.
      */
     public void setApplication(String application) {
         this.application = application;
     }
 
     /**
      * the component string for the deployment targets; optional.
      * It is in the form <code>&lt;component&gt;:&lt;target1&gt;,&lt;target2&gt;...</code>
      * Where component is the archive name (minus the .jar, .ear, .war
      * extension).  Targets are the servers where the components will be deployed
 
      *  @param component A String representing the value of the "-component"
      *  argument of the weblogic.deploy command line argument.
      */
     public void setComponent(String component) {
         this.component = component;
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/jsp/JspC.java b/src/main/org/apache/tools/ant/taskdefs/optional/jsp/JspC.java
index ee5e5af61..9c2882fa8 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/jsp/JspC.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/jsp/JspC.java
@@ -1,708 +1,708 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.jsp;
 
 import java.io.File;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.Vector;
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.taskdefs.optional.jsp.compilers.JspCompilerAdapter;
 import org.apache.tools.ant.taskdefs.optional.jsp.compilers.JspCompilerAdapterFactory;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Reference;
 
 /**
  * Runs a JSP compiler.
  *
  * <p> This task takes the given jsp files and compiles them into java
  * files. It is then up to the user to compile the java files into classes.
  *
  * <p> The task requires the srcdir and destdir attributes to be
  * set. This Task is a MatchingTask, so the files to be compiled can be
  * specified using includes/excludes attributes or nested include/exclude
  * elements. Optional attributes are verbose (set the verbosity level passed
  * to jasper), package (name of the destination package for generated java
  * classes and classpath (the classpath to use when running the jsp
  * compiler).
  * <p> This task supports the nested elements classpath (A Path) and
  * classpathref (A Reference) which can be used in preference to the
  * attribute classpath, if the jsp compiler is not already in the ant
  * classpath.
  *
  * <p><h4>Usage</h4>
  * <pre>
  * &lt;jspc srcdir="${basedir}/src/war"
  *       destdir="${basedir}/gensrc"
  *       package="com.i3sp.jsp"
  *       verbose="9"&gt;
  *   &lt;include name="**\/*.jsp" /&gt;
  * &lt;/jspc&gt;
  * </pre>
  *
  * <p> Large Amount of cutting and pasting from the Javac task...
  * @since 1.5
  */
 public class JspC extends MatchingTask {
     private Path classpath;
     private Path compilerClasspath;
     private Path src;
     private File destDir;
     private String packageName;
     /** name of the compiler to use */
     private String compilerName = "jasper";
 
     /**
      *  -ieplugin &lt;clsid&gt; Java Plugin classid for Internet Explorer
      */
     private String iepluginid;
     private boolean mapped;
     private int verbose = 0;
     // CheckStyle:VisibilityModifier OFF - bc
     protected Vector compileList = new Vector();
     Vector javaFiles = new Vector();
 
     /**
      *  flag to control action on execution trouble
      */
     protected boolean failOnError = true;
 
     /**
      *  -uriroot &lt;dir&gt; The root directory that uri files should be resolved
      *  against,
      */
     private File uriroot;
 
     /**
      *  -webinc &lt;file&gt; Creates partial servlet mappings for the -webapp option
      */
     private File webinc;
 
     /**
      *  -webxml &lt;file&gt; Creates a complete web.xml when using the -webapp option.
      */
 
     private File webxml;
 
     /**
      *  web apps
      */
     protected WebAppParameter webApp;
 
 
 
     private static final String FAIL_MSG
         = "Compile failed, messages should have been provided.";
 
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Set the path for source JSP files.
      * @param srcDir the source path.
      */
     public void setSrcDir(Path srcDir) {
         if (src == null) {
             src = srcDir;
         } else {
             src.append(srcDir);
         }
     }
 
     /**
      * Get the source dir.
      * @return the source path.
      */
     public Path getSrcDir() {
         return src;
     }
 
     /**
      * Set the destination directory into which the JSP source
      * files should be compiled.
      * @param destDir the destination directory.
      */
     public void setDestdir(File destDir) {
         this.destDir = destDir;
     }
 
     /**
      * Get the destination directory.
      * @return the directory.
      */
     public File getDestdir() {
         return destDir;
     }
 
     /**
      * Set the name of the package the compiled jsp files should be in.
      * @param pkg the name of the package.
      */
     public void setPackage(String pkg) {
         this.packageName = pkg;
     }
 
     /**
      * Get the name of the package.
      * @return the package.
      */
     public String getPackage() {
         return packageName;
     }
 
     /**
      * Set the verbose level of the compiler
      * @param i the verbose level to use.
      */
     public void setVerbose(int i) {
         verbose = i;
     }
 
     /**
      * Get the verbose level.
      * @return the level.
      */
     public int getVerbose() {
         return verbose;
     }
 
     /**
      * Whether or not the build should halt if compilation fails.
      * Defaults to <code>true</code>.
      * @param fail a <code>boolean</code> value.
      */
     public void setFailonerror(boolean fail) {
         failOnError = fail;
     }
     /**
      * Gets the failonerror flag.
      * @return the flag.
      */
     public boolean getFailonerror() {
         return failOnError;
     }
 
     /**
      * Get the IE CLASSID value.
      * @return the value.
      */
     public String getIeplugin() {
         return iepluginid;
     }
     /**
      * Java Plugin CLASSID for Internet Explorer
      * @param iepluginid the id to use.
      */
     public void setIeplugin(String iepluginid) {
         this.iepluginid = iepluginid;
     }
 
     /**
      * If true, generate separate write() calls for each HTML line
      * in the JSP.
      * @return mapping status
      */
     public boolean isMapped() {
         return mapped;
     }
 
     /**
      * If true, generate separate write() calls for each HTML line
      * in the JSP.
      * @param mapped a <code>boolean</code> value.
      */
     public void setMapped(boolean mapped) {
         this.mapped = mapped;
     }
 
     /**
      * The URI context of relative URI references in the JSP pages.
      * If it does not exist then it is derived from the location
      * of the file relative to the declared or derived value of uriroot.
      *
      * @param  uribase  The new Uribase value
      */
     public void setUribase(File uribase) {
         log("Uribase is currently an unused parameter", Project.MSG_WARN);
     }
 
     /**
      * Get the uri base value.
      * @return the value.
      */
     public File getUribase() {
         return uriroot;
     }
 
     /**
      *  The root directory that uri files should be resolved
      *  against. (Default is the directory jspc is invoked from)
      *
      * @param  uriroot  The new Uribase value
      */
     public void setUriroot(File uriroot) {
         this.uriroot = uriroot;
     }
 
     /**
      * Get the uri root value.
      * @return the value.
      */
     public File getUriroot() {
         return uriroot;
     }
 
 
     /**
      * Set the classpath to be used for this compilation.
      * @param cp the path to be used.
      */
     public void setClasspath(Path cp) {
         if (classpath == null) {
             classpath = cp;
         } else {
             classpath.append(cp);
         }
     }
 
     /**
      * Adds a path to the classpath.
      * @return a path to be configured.
      */
     public Path createClasspath() {
         if (classpath == null) {
             classpath = new Path(getProject());
         }
         return classpath.createPath();
     }
 
     /**
      * Adds a reference to a classpath defined elsewhere
      * @param r a reference to a classpath.
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * Get the classpath.
      * @return the classpath.
      */
     public Path getClasspath() {
         return classpath;
     }
 
     /**
      * Set the classpath to be used to find this compiler adapter
      * @param cp the compiler classpath.
      */
     public void setCompilerclasspath(Path cp) {
         if (compilerClasspath == null) {
             compilerClasspath = cp;
         } else {
             compilerClasspath.append(cp);
         }
     }
 
     /**
      * get the classpath used to find the compiler adapter
      * @return the compiler classpath.
      */
     public Path getCompilerclasspath() {
         return compilerClasspath;
     }
 
     /**
      * Support nested compiler classpath, used to locate compiler adapter
      * @return a path to be configured.
      */
     public Path createCompilerclasspath() {
         if (compilerClasspath == null) {
             compilerClasspath = new Path(getProject());
         }
         return compilerClasspath.createPath();
     }
 
     /**
      *  Filename for web.xml.
      *
      * @param  webxml  The new Webxml value
      */
     public void setWebxml(File webxml) {
         this.webxml = webxml;
     }
 
     /**
      * Filename for web.xml.
      * @return The filename for web.xml.
      */
     public File getWebxml() {
         return this.webxml;
     }
 
     /**
      *  output filename for the fraction of web.xml that lists
      *  servlets.
      * @param  webinc  The new Webinc value
      */
     public void setWebinc(File webinc) {
         this.webinc = webinc;
     }
 
     /**
      * Get the webinc attribute.
      * @return the webinc attribute.
      */
     public File getWebinc() {
         return this.webinc;
     }
 
     /**
      * Adds a single webapp.
      *
      * @param  webappParam  add a web app parameter
      * @throws BuildException if more than one webapp is specified.
      */
     public void addWebApp(WebAppParameter webappParam)
         throws BuildException {
         //demand create vector of filesets
         if (webApp == null) {
             webApp = webappParam;
         } else {
             throw new BuildException("Only one webapp can be specified");
         }
     }
 
     /**
      * Get the web app.
      * @return the web app attribute.
      */
     public WebAppParameter getWebApp() {
         return webApp;
     }
 
     /**
      * Class name of a JSP compiler adapter.
      * @param compiler the compiler class name.
      */
     public void setCompiler(String compiler) {
         this.compilerName = compiler;
     }
 
     /**
      * get the list of files to compile
      * @return the list of files.
      */
     public Vector getCompileList() {
         return compileList;
     }
 
     /**
      * execute by building up a list of files that
      * have changed and hand them off to a jsp compiler
      * @throws BuildException on error.
      */
     public void execute()
         throws BuildException {
 
         // make sure that we've got a destdir
         if (destDir == null) {
             throw new BuildException("destdir attribute must be set!",
                                      getLocation());
         }
 
         if (!destDir.isDirectory()) {
             throw new BuildException("destination directory \"" + destDir
                                      + "\" does not exist or is not a directory",
                                      getLocation());
         }
 
         File dest = getActualDestDir();
 
         AntClassLoader al = null;
         try {
             //bind to a compiler
             JspCompilerAdapter compiler =
                 JspCompilerAdapterFactory
                 .getCompiler(compilerName, this,
                              al = getProject().createClassLoader(compilerClasspath));
 
             //if we are a webapp, hand off to the compiler, which had
             //better handle it
             if (webApp != null) {
                 doCompilation(compiler);
                 return;
             }
 
             // make sure that we've got a srcdir
             if (src == null) {
                 throw new BuildException("srcdir attribute must be set!",
                                          getLocation());
             }
             String [] list = src.list();
             if (list.length == 0) {
                 throw new BuildException("srcdir attribute must be set!",
                                          getLocation());
             }
 
 
             // if the compiler does its own dependency stuff, we just
             // call it right now
             if (compiler.implementsOwnDependencyChecking()) {
                 doCompilation(compiler);
                 return;
             }
 
             //the remainder of this method is only for compilers that
             //need their dependency work done
             JspMangler mangler = compiler.createMangler();
 
             // scan source directories and dest directory to build up both copy
             // lists and compile lists
             resetFileLists();
             int filecount = 0;
             for (int i = 0; i < list.length; i++) {
                 File srcDir = getProject().resolveFile(list[i]);
                 if (!srcDir.exists()) {
                     throw new BuildException("srcdir \"" + srcDir.getPath()
                                              + "\" does not exist!",
                                              getLocation());
                 }
                 DirectoryScanner ds = this.getDirectoryScanner(srcDir);
                 String[] files = ds.getIncludedFiles();
                 filecount = files.length;
                 scanDir(srcDir, dest, mangler, files);
             }
 
             // compile the source files
 
             log("compiling " + compileList.size() + " files",
                 Project.MSG_VERBOSE);
 
             if (compileList.size() > 0) {
 
                 log("Compiling " + compileList.size() + " source file"
                     + (compileList.size() == 1 ? "" : "s")
                     + " to "
                     + dest);
                 doCompilation(compiler);
 
             } else {
                 if (filecount == 0) {
                     log("there were no files to compile", Project.MSG_INFO);
                 } else {
                     log("all files are up to date", Project.MSG_VERBOSE);
                 }
             }
         } finally {
             if (al != null) {
                 al.cleanup();
             }
         }
     }
 
     /**
      * calculate where the files will end up:
      * this is destDir or it id destDir + the package name
      */
     private File getActualDestDir() {
         File dest = null;
         if (packageName == null) {
             dest = destDir;
         } else {
             String path = destDir.getPath() + File.separatorChar
                 + packageName.replace('.', File.separatorChar);
             dest = new File(path);
         }
         return dest;
     }
 
     /**
      * do the compile
      */
     private void doCompilation(JspCompilerAdapter compiler)
         throws BuildException {
         // now we need to populate the compiler adapter
         compiler.setJspc(this);
 
         // finally, lets execute the compiler!!
         if (!compiler.execute()) {
             if (failOnError) {
                 throw new BuildException(FAIL_MSG, getLocation());
             } else {
                 log(FAIL_MSG, Project.MSG_ERR);
             }
         }
     }
 
     /**
      * Clear the list of files to be compiled and copied..
      */
     protected void resetFileLists() {
         compileList.removeAllElements();
     }
 
     /**
      * Scans the directory looking for source files to be compiled.
      * The results are returned in the class variable compileList
      * @param srcDir the source directory.
      * @param dest   the destination directory.
      * @param mangler the jsp filename mangler.
      * @param files   the file names to mangle.
      */
     protected void scanDir(File srcDir, File dest, JspMangler mangler,
                            String[] files) {
 
         long now = (new Date()).getTime();
 
         for (int i = 0; i < files.length; i++) {
             String filename = files[i];
             File srcFile = new File(srcDir, filename);
             File javaFile = mapToJavaFile(mangler, srcFile, srcDir, dest);
             if (javaFile == null) {
                 continue;
             }
 
             if (srcFile.lastModified() > now) {
                 log("Warning: file modified in the future: " + filename,
                     Project.MSG_WARN);
             }
             boolean shouldCompile = false;
             shouldCompile = isCompileNeeded(srcFile, javaFile);
             if (shouldCompile) {
                 compileList.addElement(srcFile.getAbsolutePath());
                 javaFiles.addElement(javaFile);
             }
         }
     }
 
     /**
      * Test whether or not compilation is needed. A return value of
      * <code>true<code> means yes, <code>false</code> means
      * our tests do not indicate this, but as the TLDs are
      * not used for dependency checking this is not guaranteed.
      * The current tests are
      * <ol>
      * <li>no dest file
      * <li>dest file out of date w.r.t source
      * <li>dest file zero bytes long
      * </ol>
      * @param srcFile JSP source file
      * @param javaFile JSP dest file
      * @return true if a compile is definately needed.
      *
      */
     private boolean isCompileNeeded(File srcFile, File javaFile) {
         boolean shouldCompile = false;
         if (!javaFile.exists()) {
             shouldCompile = true;
             log("Compiling " + srcFile.getPath()
                 + " because java file " + javaFile.getPath()
                 + " does not exist", Project.MSG_VERBOSE);
         } else {
             if (srcFile.lastModified() > javaFile.lastModified()) {
                 shouldCompile = true;
                 log("Compiling " + srcFile.getPath()
                     + " because it is out of date with respect to "
                     + javaFile.getPath(),
                     Project.MSG_VERBOSE);
             } else {
                 if (javaFile.length() == 0) {
                     shouldCompile = true;
                     log("Compiling " + srcFile.getPath()
                         + " because java file " + javaFile.getPath()
                         + " is empty", Project.MSG_VERBOSE);
                 }
             }
         }
         return shouldCompile;
     }
 
 
     /**
      * get a filename from our jsp file.
-     * @param mangler the jsp filename managler.
+     * @param mangler the jsp filename manager.
      * @param srcFile the source file.
      * @param srcDir  the source directory.
      * @param dest    the destination directory.
      * @return the filename.
      * @todo support packages and subdirs
      */
     protected File mapToJavaFile(JspMangler mangler, File srcFile, File srcDir,
                                  File dest) {
         if (!srcFile.getName().endsWith(".jsp")) {
             return null;
         }
         String javaFileName = mangler.mapJspToJavaName(srcFile);
         //        String srcFileDir=srcFile.getParent();
         return new File(dest, javaFileName);
     }
 
     /**
      * delete any java output files that are empty
      * this is to get around a little defect in jasper: when it
      * fails, it leaves incomplete files around.
      */
     public void deleteEmptyJavaFiles() {
         if (javaFiles != null) {
             Enumeration e = javaFiles.elements();
             while (e.hasMoreElements()) {
                 File file = (File) e.nextElement();
                 if (file.exists() && file.length() == 0) {
                     log("deleting empty output file " + file);
                     file.delete();
                 }
             }
         }
     }
 
     /**
      * static inner class used as a parameter element
      */
     public static class WebAppParameter {
 
         /**
          * the sole option
          */
         private File directory;
 
         /**
          * query current directory
          * @return the directory.
          */
         public File getDirectory() {
             return directory;
         }
 
         /**
          * set directory; alternate syntax
          * @param directory the base dir.
          */
         public void setBaseDir(File directory) {
             this.directory = directory;
         }
         //end inner class
     }
 
 
     //end class
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java b/src/main/org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java
index e0faf8ca3..48b2623e3 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java
@@ -1,333 +1,333 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.jsp;
 
 //apache/ant imports
 import java.io.File;
 import java.util.Date;
 import java.util.StringTokenizer;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.Java;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.types.Path;
 
 /**
  * Precompiles JSP's using WebLogic's JSP compiler (weblogic.jspc).
  *
  * Tested only on Weblogic 4.5.1 - NT4.0 and Solaris 5.7
  *
  * required attributes
  *      src : root of source tree for JSP, ie, the document root for your weblogic server
  *      dest : root of destination directory, what you have set as
  *             WorkingDir in the weblogic properties
  *      package : start package name under which your JSP's would be compiled
  *
  * other attributes
  *     classpath
  *
  * A classpath should be set which contains the weblogic classes as well as all
  * application classes referenced by the JSP. The system classpath is also
  * appended when the jspc is called, so you may choose to put everything in
  * the classpath while calling Ant. However, since presumably the JSP's will
  * reference classes being build by Ant, it would be better to explicitly add
  * the classpath in the task
  *
  * The task checks timestamps on the JSP's and the generated classes, and compiles
  * only those files that have changed.
  *
  * It follows the weblogic naming convention of putting classes in
  *  <b> _dirName/_fileName.class for dirname/fileName.jsp   </b>
  *
  * Limitation: It compiles the files thru the Classic compiler only.
  * Limitation: Since it is my experience that weblogic jspc throws out of
  *             memory error on being given too many files at one go, it is
  *             called multiple times with one jsp file each.
  *
  * <pre>
  * example
  * &lt;target name="jspcompile" depends="compile"&gt;
  *   &lt;wljspc src="c:\\weblogic\\myserver\\public_html"
  *           dest="c:\\weblogic\\myserver\\serverclasses" package="myapp.jsp"&gt;
  *   &lt;classpath&gt;
  *          &lt;pathelement location="${weblogic.classpath}" /&gt;
  *           &lt;pathelement path="${compile.dest}" /&gt;
  *      &lt;/classpath&gt;
  *
  *   &lt;/wljspc&gt;
  * &lt;/target&gt;
  * </pre>
  *
  */
 
 public class WLJspc extends MatchingTask {
     //TODO Test on other versions of weblogic
     //TODO add more attributes to the task, to take care of all jspc options
     //TODO Test on Unix
 
     /** root of compiled files tree */
     private File destinationDirectory;
 
     /** root of source files tree */
     private File sourceDirectory;
 
     /** package under which resultant classes will reside */
     private String destinationPackage;
 
     /** classpath used to compile the jsp files. */
     private Path compileClasspath;
 
     //private String compilerPath; //fully qualified name for the compiler executable
 
     private String pathToPackage = "";
     private Vector filesToDo = new Vector();
 
     /**
      * Run the task.
      * @throws BuildException if there is an error.
      */
     public void execute() throws BuildException {
         if (!destinationDirectory.isDirectory()) {
             throw new BuildException("destination directory "
                 + destinationDirectory.getPath() + " is not valid");
         }
 
         if (!sourceDirectory.isDirectory()) {
             throw new BuildException("src directory "
                 + sourceDirectory.getPath() + " is not valid");
         }
 
         if (destinationPackage == null) {
             throw new BuildException("package attribute must be present.",
                                      getLocation());
         }
 
 
         pathToPackage
             = this.destinationPackage.replace('.', File.separatorChar);
         // get all the files in the sourceDirectory
         DirectoryScanner ds = super.getDirectoryScanner(sourceDirectory);
 
         //use the systemclasspath as well, to include the ant jar
         if (compileClasspath == null) {
             compileClasspath = new Path(getProject());
         }
 
         compileClasspath = compileClasspath.concatSystemClasspath();
         String[] files = ds.getIncludedFiles();
 
         //Weblogic.jspc calls System.exit() ... have to fork
         // Therefore, takes loads of time
         // Can pass directories at a time (*.jsp) but easily runs out of
         // memory on hefty dirs (even on  a Sun)
         Java helperTask = new Java(this);
         helperTask.setFork(true);
         helperTask.setClassname("weblogic.jspc");
         helperTask.setTaskName(getTaskName());
         // CheckStyle:MagicNumber OFF
         String[] args = new String[12];
         // CheckStyle:MagicNumber ON
 
         File jspFile = null;
         String parents = "";
         int j = 0;
         //XXX  this array stuff is a remnant of prev trials.. gotta remove.
         args[j++] = "-d";
         args[j++] = destinationDirectory.getAbsolutePath().trim();
         args[j++] = "-docroot";
         args[j++] = sourceDirectory.getAbsolutePath().trim();
         args[j++] = "-keepgenerated";
         //Call compiler as class... dont want to fork again
         //Use classic compiler -- can be parameterised?
         args[j++] =  "-compilerclass";
         args[j++] = "sun.tools.javac.Main";
         //Weblogic jspc does not seem to work unless u explicitly set this...
         // Does not take the classpath from the env....
         // Am i missing something about the Java task??
         args[j++] = "-classpath";
         args[j++] = compileClasspath.toString();
 
         this.scanDir(files);
         log("Compiling " + filesToDo.size() + " JSP files");
 
         final int size = filesToDo.size();
         for (int i = 0; i < size; i++) {
             //XXX
             // All this to get package according to weblogic standards
             // Can be written better... this is too hacky!
             // Careful.. similar code in scanDir , but slightly different!!
             String filename = (String) filesToDo.elementAt(i);
             jspFile = new File(filename);
             args[j] = "-package";
             parents = jspFile.getParent();
             if ((parents != null)  && (!("").equals(parents))) {
                 parents =  this.replaceString(parents, File.separator, "_.");
                 args[j + 1] = destinationPackage + "." + "_" + parents;
             } else {
                 args[j + 1] = destinationPackage;
             }
 
 
             args[j + 2] =  sourceDirectory + File.separator + filename;
             helperTask.clearArgs();
 
             // CheckStyle:MagicNumber OFF
             for (int x = 0; x < j + 3; x++) {
                 helperTask.createArg().setValue(args[x]);
             }
             // CheckStyle:MagicNumber ON
 
             helperTask.setClasspath(compileClasspath);
             if (helperTask.executeJava() != 0) {
                 log(filename + " failed to compile", Project.MSG_WARN);
             }
         }
     }
 
 
 
     /**
      * Set the classpath to be used for this compilation.
      * @param classpath the classpath to use.
      */
     public void setClasspath(Path classpath) {
         if (compileClasspath == null) {
             compileClasspath = classpath;
         } else {
             compileClasspath.append(classpath);
         }
     }
 
     /**
      * Maybe creates a nested classpath element.
      * @return a path to be configured.
      */
     public Path createClasspath() {
         if (compileClasspath == null) {
             compileClasspath = new Path(getProject());
         }
         return compileClasspath;
     }
 
     /**
      * Set the directory containing the source jsp's
      *
      *
      * @param dirName the directory containg the source jsp's
      */
     public void setSrc(File dirName) {
 
         sourceDirectory = dirName;
     }
 
      /**
      * Set the directory containing the source jsp's
      *
      *
      * @param dirName the directory containg the source jsp's
      */
     public void setDest(File dirName) {
 
         destinationDirectory = dirName;
     }
 
     /**
      * Set the package under which the compiled classes go
      *
-     * @param packageName the package name for the clases
+     * @param packageName the package name for the classes
      */
     public void setPackage(String packageName) {
 
         destinationPackage = packageName;
     }
 
     /**
      * Scan the array of files and add the jsp
      * files that need to be compiled to the filesToDo field.
      * @param files the files to scan.
      */
     protected void scanDir(String[] files) {
 
         long now = (new Date()).getTime();
         File jspFile = null;
         String parents = null;
         String pack = "";
         for (int i = 0; i < files.length; i++) {
             File srcFile = new File(this.sourceDirectory, files[i]);
             //XXX
             // All this to convert source to destination directory according
             // to weblogic standards Can be written better... this is too hacky!
             jspFile = new File(files[i]);
             parents = jspFile.getParent();
 
             if ((parents != null)  && (!("").equals(parents))) {
                 parents =  this.replaceString(parents, File.separator, "_/");
                 pack = pathToPackage + File.separator + "_" + parents;
             } else {
                 pack = pathToPackage;
             }
 
             String filePath = pack + File.separator + "_";
             int startingIndex = files[i].lastIndexOf(File.separator) != -1
                     ? files[i].lastIndexOf(File.separator) + 1 : 0;
             int endingIndex = files[i].indexOf(".jsp");
             if (endingIndex == -1) {
                 log("Skipping " + files[i] + ". Not a JSP",
                     Project.MSG_VERBOSE);
                 continue;
             }
 
             filePath += files[i].substring(startingIndex, endingIndex);
             filePath += ".class";
             File classFile = new File(this.destinationDirectory, filePath);
 
             if (srcFile.lastModified() > now) {
                 log("Warning: file modified in the future: "
                     + files[i], Project.MSG_WARN);
             }
             if (srcFile.lastModified() > classFile.lastModified()) {
                 filesToDo.addElement(files[i]);
                 log("Recompiling File " + files[i], Project.MSG_VERBOSE);
             }
         }
     }
 
 
     /**
      * Replace occurances of a string with a replacement string.
      * @param inpString the string to convert.
      * @param escapeChars the string to replace.
      * @param replaceChars the string to place.
      * @return the converted string.
      */
     protected String replaceString(String inpString, String escapeChars,
                                    String replaceChars) {
         String localString = "";
         int numTokens = 0;
         StringTokenizer st = new StringTokenizer(inpString, escapeChars, true);
         numTokens = st.countTokens();
         for (int i = 0; i < numTokens; i++) {
             String test = st.nextToken();
             test = (test.equals(escapeChars) ? replaceChars : test);
             localString += test;
         }
         return localString;
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/jsp/compilers/JspCompilerAdapter.java b/src/main/org/apache/tools/ant/taskdefs/optional/jsp/compilers/JspCompilerAdapter.java
index 56d2e0613..34897d5bf 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/jsp/compilers/JspCompilerAdapter.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/jsp/compilers/JspCompilerAdapter.java
@@ -1,64 +1,64 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.jsp.compilers;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.optional.jsp.JspC;
 import org.apache.tools.ant.taskdefs.optional.jsp.JspMangler;
 
 /**
  * The interface that all jsp compiler adapters must adher to.
  *
  * <p>A compiler adapter is an adapter that interprets the jspc's
- * parameters in preperation to be passed off to the compier this
+ * parameters in preperation to be passed off to the compiler this
  * adapter represents.  As all the necessary values are stored in the
  * Jspc task itself, the only thing all adapters need is the jsp
  * task, the execute command and a parameterless constructor (for
  * reflection).</p>
  *
  */
 
 public interface JspCompilerAdapter {
 
     /**
      * Sets the compiler attributes, which are stored in the Jspc task.
      * @param attributes the jsp compiler attributes
      */
     void setJspc(JspC attributes);
 
     /**
      * Executes the task.
      *
      * @return has the compilation been successful
      * @throws BuildException on error
      */
     boolean execute() throws BuildException;
 
     /**
      * @return an instance of the mangler this compiler uses
      */
 
     JspMangler createMangler();
 
     /**
      * ask if compiler can sort out its own dependencies
      * @return true if the compiler wants to do its own
      * depends
      */
     boolean implementsOwnDependencyChecking();
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java b/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java
index b30eb61d4..88d35c740 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java
@@ -1,1647 +1,1647 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.junit;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.lang.reflect.Constructor;
 import java.net.URL;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Vector;
 
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.Execute;
 import org.apache.tools.ant.taskdefs.ExecuteWatchdog;
 import org.apache.tools.ant.taskdefs.LogOutputStream;
 import org.apache.tools.ant.taskdefs.PumpStreamHandler;
 import org.apache.tools.ant.types.Assertions;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.types.CommandlineJava;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.Environment;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Permissions;
 import org.apache.tools.ant.types.PropertySet;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.LoaderUtils;
 import org.apache.tools.ant.util.SplitClassLoader;
 
 /**
  * Runs JUnit tests.
  *
  * <p> JUnit is a framework to create unit tests. It has been initially
  * created by Erich Gamma and Kent Beck.  JUnit can be found at <a
  * href="http://www.junit.org">http://www.junit.org</a>.
  *
  * <p> <code>JUnitTask</code> can run a single specific
  * <code>JUnitTest</code> using the <code>test</code> element.</p>
  * For example, the following target <code><pre>
  *   &lt;target name="test-int-chars" depends="jar-test"&gt;
  *       &lt;echo message="testing international characters"/&gt;
  *       &lt;junit printsummary="no" haltonfailure="yes" fork="false"&gt;
  *           &lt;classpath refid="classpath"/&gt;
  *           &lt;formatter type="plain" usefile="false" /&gt;
  *           &lt;test name="org.apache.ecs.InternationalCharTest" /&gt;
  *       &lt;/junit&gt;
  *   &lt;/target&gt;
  * </pre></code>
  * <p>runs a single junit test
  * (<code>org.apache.ecs.InternationalCharTest</code>) in the current
  * VM using the path with id <code>classpath</code> as classpath and
  * presents the results formatted using the standard
  * <code>plain</code> formatter on the command line.</p>
  *
  * <p> This task can also run batches of tests.  The
  * <code>batchtest</code> element creates a <code>BatchTest</code>
  * based on a fileset.  This allows, for example, all classes found in
  * directory to be run as testcases.</p>
  *
  * <p>For example,</p><code><pre>
  * &lt;target name="run-tests" depends="dump-info,compile-tests" if="junit.present"&gt;
  *   &lt;junit printsummary="no" haltonfailure="yes" fork="${junit.fork}"&gt;
  *     &lt;jvmarg value="-classic"/&gt;
  *     &lt;classpath refid="tests-classpath"/&gt;
  *     &lt;sysproperty key="build.tests" value="${build.tests}"/&gt;
  *     &lt;formatter type="brief" usefile="false" /&gt;
  *     &lt;batchtest&gt;
  *       &lt;fileset dir="${tests.dir}"&gt;
  *         &lt;include name="**&#047;*Test*" /&gt;
  *       &lt;/fileset&gt;
  *     &lt;/batchtest&gt;
  *   &lt;/junit&gt;
  * &lt;/target&gt;
  * </pre></code>
  * <p>this target finds any classes with a <code>test</code> directory
  * anywhere in their path (under the top <code>${tests.dir}</code>, of
  * course) and creates <code>JUnitTest</code>'s for each one.</p>
  *
  * <p> Of course, <code>&lt;junit&gt;</code> and
  * <code>&lt;batch&gt;</code> elements can be combined for more
  * complex tests. For an example, see the ant <code>build.xml</code>
  * target <code>run-tests</code> (the second example is an edited
  * version).</p>
  *
  * <p> To spawn a new Java VM to prevent interferences between
  * different testcases, you need to enable <code>fork</code>.  A
  * number of attributes and elements allow you to set up how this JVM
  * runs.
  *
  *
  * @since Ant 1.2
  *
  * @see JUnitTest
  * @see BatchTest
  */
 public class JUnitTask extends Task {
 
     private static final String LINE_SEP
         = System.getProperty("line.separator");
     private static final String CLASSPATH = "CLASSPATH";
     private CommandlineJava commandline;
     private Vector tests = new Vector();
     private Vector batchTests = new Vector();
     private Vector formatters = new Vector();
     private File dir = null;
 
     private Integer timeout = null;
     private boolean summary = false;
     private boolean reloading = true;
     private String summaryValue = "";
     private JUnitTaskMirror.JUnitTestRunnerMirror runner = null;
 
     private boolean newEnvironment = false;
     private Environment env = new Environment();
 
     private boolean includeAntRuntime = true;
     private Path antRuntimeClasses = null;
 
     // Do we send output to System.out/.err in addition to the formatters?
     private boolean showOutput = false;
 
     // Do we send output to the formatters ?
     private boolean outputToFormatters = true;
 
     private boolean logFailedTests = true;
 
     private File tmpDir;
     private AntClassLoader classLoader = null;
     private Permissions perm = null;
     private ForkMode forkMode = new ForkMode("perTest");
 
     private boolean splitJunit = false;
     private boolean enableTestListenerEvents = false;
     private JUnitTaskMirror delegate;
     private ClassLoader mirrorLoader;
 
     /** A boolean on whether to get the forked path for ant classes */
     private boolean forkedPathChecked = false;
 
     //   Attributes for basetest
     private boolean haltOnError = false;
     private boolean haltOnFail  = false;
     private boolean filterTrace = true;
     private boolean fork        = false;
     private String  failureProperty;
     private String  errorProperty;
 
     private static final int STRING_BUFFER_SIZE = 128;
     /**
      * @since Ant 1.7
      */
     public static final String TESTLISTENER_PREFIX =
         "junit.framework.TestListener: ";
 
     /**
      * Name of magic property that enables test listener events.
      */
     public static final String ENABLE_TESTLISTENER_EVENTS =
         "ant.junit.enabletestlistenerevents";
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * If true, force ant to re-classload all classes for each JUnit TestCase
      *
      * @param value force class reloading for each test case
      */
     public void setReloading(boolean value) {
         reloading = value;
     }
 
     /**
      * If true, smartly filter the stack frames of
      * JUnit errors and failures before reporting them.
      *
      * <p>This property is applied on all BatchTest (batchtest) and
      * JUnitTest (test) however it can possibly be overridden by their
      * own properties.</p>
      * @param value <tt>false</tt> if it should not filter, otherwise
      * <tt>true<tt>
      *
      * @since Ant 1.5
      */
     public void setFiltertrace(boolean value) {
         this.filterTrace = value;
     }
 
     /**
      * If true, stop the build process when there is an error in a test.
      * This property is applied on all BatchTest (batchtest) and JUnitTest
      * (test) however it can possibly be overridden by their own
      * properties.
      * @param value <tt>true</tt> if it should halt, otherwise
      * <tt>false</tt>
      *
      * @since Ant 1.2
      */
     public void setHaltonerror(boolean value) {
         this.haltOnError = value;
     }
 
     /**
      * Property to set to "true" if there is a error in a test.
      *
      * <p>This property is applied on all BatchTest (batchtest) and
-     * JUnitTest (test), however, it can possibly be overriden by
+     * JUnitTest (test), however, it can possibly be overridden by
      * their own properties.</p>
      * @param propertyName the name of the property to set in the
      * event of an error.
      *
      * @since Ant 1.4
      */
     public void setErrorProperty(String propertyName) {
         this.errorProperty = propertyName;
     }
 
     /**
      * If true, stop the build process if a test fails
      * (errors are considered failures as well).
      * This property is applied on all BatchTest (batchtest) and
      * JUnitTest (test) however it can possibly be overridden by their
      * own properties.
      * @param value <tt>true</tt> if it should halt, otherwise
      * <tt>false</tt>
      *
      * @since Ant 1.2
      */
     public void setHaltonfailure(boolean value) {
         this.haltOnFail = value;
     }
 
     /**
      * Property to set to "true" if there is a failure in a test.
      *
      * <p>This property is applied on all BatchTest (batchtest) and
-     * JUnitTest (test), however, it can possibly be overriden by
+     * JUnitTest (test), however, it can possibly be overridden by
      * their own properties.</p>
      * @param propertyName the name of the property to set in the
      * event of an failure.
      *
      * @since Ant 1.4
      */
     public void setFailureProperty(String propertyName) {
         this.failureProperty = propertyName;
     }
 
     /**
      * If true, JVM should be forked for each test.
      *
      * <p>It avoids interference between testcases and possibly avoids
      * hanging the build.  this property is applied on all BatchTest
      * (batchtest) and JUnitTest (test) however it can possibly be
      * overridden by their own properties.</p>
      * @param value <tt>true</tt> if a JVM should be forked, otherwise
      * <tt>false</tt>
      * @see #setTimeout
      *
      * @since Ant 1.2
      */
     public void setFork(boolean value) {
         this.fork = value;
     }
 
     /**
      * Set the behavior when {@link #setFork fork} fork has been enabled.
      *
      * <p>Possible values are "once", "perTest" and "perBatch".  If
      * set to "once", only a single Java VM will be forked for all
      * tests, with "perTest" (the default) each test will run in a
      * fresh Java VM and "perBatch" will run all tests from the same
      * &lt;batchtest&gt; in the same Java VM.</p>
      *
      * <p>This attribute will be ignored if tests run in the same VM
      * as Ant.</p>
      *
      * <p>Only tests with the same configuration of haltonerror,
      * haltonfailure, errorproperty, failureproperty and filtertrace
      * can share a forked Java VM, so even if you set the value to
-     * "once", Ant may need to fork mutliple VMs.</p>
+     * "once", Ant may need to fork multiple VMs.</p>
      * @param mode the mode to use.
      * @since Ant 1.6.2
      */
     public void setForkMode(ForkMode mode) {
         this.forkMode = mode;
     }
 
     /**
      * If true, print one-line statistics for each test, or "withOutAndErr"
      * to also show standard output and error.
      *
      * Can take the values on, off, and withOutAndErr.
      * @param value <tt>true</tt> to print a summary,
      * <tt>withOutAndErr</tt> to include the test&apos;s output as
      * well, <tt>false</tt> otherwise.
      * @see SummaryJUnitResultFormatter
      *
      * @since Ant 1.2
      */
     public void setPrintsummary(SummaryAttribute value) {
         summaryValue = value.getValue();
         summary = value.asBoolean();
     }
 
     /**
      * Print summary enumeration values.
      */
     public static class SummaryAttribute extends EnumeratedAttribute {
         /**
          * list the possible values
          * @return  array of allowed values
          */
         public String[] getValues() {
             return new String[] {"true", "yes", "false", "no",
                                  "on", "off", "withOutAndErr"};
         }
 
         /**
          * gives the boolean equivalent of the authorized values
          * @return boolean equivalent of the value
          */
         public boolean asBoolean() {
             String v = getValue();
             return "true".equals(v)
                 || "on".equals(v)
                 || "yes".equals(v)
                 || "withOutAndErr".equals(v);
         }
     }
 
     /**
      * Set the timeout value (in milliseconds).
      *
      * <p>If the test is running for more than this value, the test
      * will be canceled. (works only when in 'fork' mode).</p>
      * @param value the maximum time (in milliseconds) allowed before
      * declaring the test as 'timed-out'
      * @see #setFork(boolean)
      *
      * @since Ant 1.2
      */
     public void setTimeout(Integer value) {
         timeout = value;
     }
 
     /**
      * Set the maximum memory to be used by all forked JVMs.
      * @param   max     the value as defined by <tt>-mx</tt> or <tt>-Xmx</tt>
      *                  in the java command line options.
      *
      * @since Ant 1.2
      */
     public void setMaxmemory(String max) {
         getCommandline().setMaxmemory(max);
     }
 
     /**
      * The command used to invoke the Java Virtual Machine,
      * default is 'java'. The command is resolved by
      * java.lang.Runtime.exec(). Ignored if fork is disabled.
      *
      * @param   value   the new VM to use instead of <tt>java</tt>
      * @see #setFork(boolean)
      *
      * @since Ant 1.2
      */
     public void setJvm(String value) {
         getCommandline().setVm(value);
     }
 
     /**
      * Adds a JVM argument; ignored if not forking.
      *
      * @return create a new JVM argument so that any argument can be
      * passed to the JVM.
      * @see #setFork(boolean)
      *
      * @since Ant 1.2
      */
     public Commandline.Argument createJvmarg() {
         return getCommandline().createVmArgument();
     }
 
     /**
      * The directory to invoke the VM in. Ignored if no JVM is forked.
      * @param   dir     the directory to invoke the JVM from.
      * @see #setFork(boolean)
      *
      * @since Ant 1.2
      */
     public void setDir(File dir) {
         this.dir = dir;
     }
 
     /**
      * Adds a system property that tests can access.
-     * This might be useful to tranfer Ant properties to the
+     * This might be useful to transfer Ant properties to the
      * testcases when JVM forking is not enabled.
      *
      * @since Ant 1.3
      * @deprecated since ant 1.6
      * @param sysp environment variable to add
      */
     public void addSysproperty(Environment.Variable sysp) {
 
         getCommandline().addSysproperty(sysp);
     }
 
     /**
      * Adds a system property that tests can access.
-     * This might be useful to tranfer Ant properties to the
+     * This might be useful to transfer Ant properties to the
      * testcases when JVM forking is not enabled.
      * @param sysp new environment variable to add
      * @since Ant 1.6
      */
     public void addConfiguredSysproperty(Environment.Variable sysp) {
         // get a build exception if there is a missing key or value
         // see bugzilla report 21684
         String testString = sysp.getContent();
         getProject().log("sysproperty added : " + testString, Project.MSG_DEBUG);
         getCommandline().addSysproperty(sysp);
     }
 
     /**
      * Adds a set of properties that will be used as system properties
      * that tests can access.
      *
-     * This might be useful to tranfer Ant properties to the
+     * This might be useful to transfer Ant properties to the
      * testcases when JVM forking is not enabled.
      *
      * @param sysp set of properties to be added
      * @since Ant 1.6
      */
     public void addSyspropertyset(PropertySet sysp) {
         getCommandline().addSyspropertyset(sysp);
     }
 
     /**
      * Adds path to classpath used for tests.
      *
      * @return reference to the classpath in the embedded java command line
      * @since Ant 1.2
      */
     public Path createClasspath() {
         return getCommandline().createClasspath(getProject()).createPath();
     }
 
     /**
      * Adds a path to the bootclasspath.
      * @return reference to the bootclasspath in the embedded java command line
      * @since Ant 1.6
      */
     public Path createBootclasspath() {
         return getCommandline().createBootclasspath(getProject()).createPath();
     }
 
     /**
      * Adds an environment variable; used when forking.
      *
      * <p>Will be ignored if we are not forking a new VM.</p>
      * @param var environment variable to be added
      * @since Ant 1.5
      */
     public void addEnv(Environment.Variable var) {
         env.addVariable(var);
     }
 
     /**
      * If true, use a new environment when forked.
      *
      * <p>Will be ignored if we are not forking a new VM.</p>
      *
      * @param newenv boolean indicating if setting a new environment is wished
      * @since Ant 1.5
      */
     public void setNewenvironment(boolean newenv) {
         newEnvironment = newenv;
     }
 
     /**
      * Preset the attributes of the test
      * before configuration in the build
      * script.
      * This allows attributes in the <junit> task
      * be be defaults for the tests, but allows
      * individual tests to override the defaults.
      */
     private void preConfigure(BaseTest test) {
         test.setFiltertrace(filterTrace);
         test.setHaltonerror(haltOnError);
         if (errorProperty != null) {
             test.setErrorProperty(errorProperty);
         }
         test.setHaltonfailure(haltOnFail);
         if (failureProperty != null) {
             test.setFailureProperty(failureProperty);
         }
         test.setFork(fork);
     }
 
     /**
      * Add a new single testcase.
      * @param   test    a new single testcase
      * @see JUnitTest
      *
      * @since Ant 1.2
      */
     public void addTest(JUnitTest test) {
         tests.addElement(test);
         preConfigure(test);
     }
 
     /**
      * Adds a set of tests based on pattern matching.
      *
      * @return  a new instance of a batch test.
      * @see BatchTest
      *
      * @since Ant 1.2
      */
     public BatchTest createBatchTest() {
         BatchTest test = new BatchTest(getProject());
         batchTests.addElement(test);
         preConfigure(test);
         return test;
     }
 
     /**
      * Add a new formatter to all tests of this task.
      *
      * @param fe formatter element
      * @since Ant 1.2
      */
     public void addFormatter(FormatterElement fe) {
         formatters.addElement(fe);
     }
 
     /**
      * If true, include ant.jar, optional.jar and junit.jar in the forked VM.
      *
      * @param b include ant run time yes or no
      * @since Ant 1.5
      */
     public void setIncludeantruntime(boolean b) {
         includeAntRuntime = b;
     }
 
     /**
      * If true, send any output generated by tests to Ant's logging system
      * as well as to the formatters.
      * By default only the formatters receive the output.
      *
      * <p>Output will always be passed to the formatters and not by
      * shown by default.  This option should for example be set for
      * tests that are interactive and prompt the user to do
      * something.</p>
      *
      * @param showOutput if true, send output to Ant's logging system too
      * @since Ant 1.5
      */
     public void setShowOutput(boolean showOutput) {
         this.showOutput = showOutput;
     }
 
     /**
      * If true, send any output generated by tests to the formatters.
      *
      * @param outputToFormatters if true, send output to formatters (Default
      *                           is true).
      * @since Ant 1.7.0
      */
     public void setOutputToFormatters(boolean outputToFormatters) {
         this.outputToFormatters = outputToFormatters;
     }
 
     /**
      * If true, write a single "FAILED" line for failed tests to Ant's
      * log system.
      *
      * @since Ant 1.8.0
      */
     public void setLogFailedTests(boolean logFailedTests) {
         this.logFailedTests = logFailedTests;
     }
 
     /**
      * Assertions to enable in this program (if fork=true)
      * @since Ant 1.6
      * @param asserts assertion set
      */
     public void addAssertions(Assertions asserts) {
         if (getCommandline().getAssertions() != null) {
             throw new BuildException("Only one assertion declaration is allowed");
         }
         getCommandline().setAssertions(asserts);
     }
 
     /**
      * Sets the permissions for the application run inside the same JVM.
      * @since Ant 1.6
      * @return .
      */
     public Permissions createPermissions() {
         if (perm == null) {
             perm = new Permissions();
         }
         return perm;
     }
 
     /**
      * If set, system properties will be copied to the cloned VM - as
      * well as the bootclasspath unless you have explicitly specified
-     * a bootclaspath.
+     * a bootclasspath.
      *
      * <p>Doesn't have any effect unless fork is true.</p>
      * @param cloneVm a <code>boolean</code> value.
      * @since Ant 1.7
      */
     public void setCloneVm(boolean cloneVm) {
         getCommandline().setCloneVm(cloneVm);
     }
 
     /**
      * Creates a new JUnitRunner and enables fork of a new Java VM.
      *
      * @throws Exception under ??? circumstances
      * @since Ant 1.2
      */
     public JUnitTask() throws Exception {
     }
 
     /**
      * Where Ant should place temporary files.
      *
      * @param tmpDir location where temporary files should go to
      * @since Ant 1.6
      */
     public void setTempdir(File tmpDir) {
         if (tmpDir != null) {
             if (!tmpDir.exists() || !tmpDir.isDirectory()) {
                 throw new BuildException(tmpDir.toString()
                                          + " is not a valid temp directory");
             }
         }
         this.tmpDir = tmpDir;
     }
 
     /**
      * Whether test listener events shall be generated.
      *
      * <p>Defaults to false.</p>
      * 
      * <p>This value will be overridden by the magic property
      * ant.junit.enabletestlistenerevents if it has been set.</p>
      *
      * @since Ant 1.8.2
      */
     public void setEnableTestListenerEvents(boolean b) {
         enableTestListenerEvents = b;
     }
 
     /**
      * Whether test listener events shall be generated.
      * @since Ant 1.8.2
      */
     public boolean getEnableTestListenerEvents() {
         String e = getProject().getProperty(ENABLE_TESTLISTENER_EVENTS);
         if (e != null) {
             return Project.toBoolean(e);
         }
         return enableTestListenerEvents;
     }
 
     /**
      * Adds the jars or directories containing Ant, this task and
      * JUnit to the classpath - this should make the forked JVM work
      * without having to specify them directly.
      *
      * @since Ant 1.4
      */
     public void init() {
         antRuntimeClasses = new Path(getProject());
         splitJunit = !addClasspathResource("/junit/framework/TestCase.class");
         addClasspathEntry("/org/apache/tools/ant/launch/AntMain.class");
         addClasspathEntry("/org/apache/tools/ant/Task.class");
         addClasspathEntry("/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.class");
         addClasspathEntry("/org/apache/tools/ant/taskdefs/optional/junit/JUnit4TestMethodAdapter.class");
     }
 
     private static JUnitTaskMirror createMirror(JUnitTask task, ClassLoader loader) {
         try {
             loader.loadClass("junit.framework.Test"); // sanity check
         } catch (ClassNotFoundException e) {
             throw new BuildException(
                     "The <classpath> for <junit> must include junit.jar "
                     + "if not in Ant's own classpath",
                     e, task.getLocation());
         }
         try {
             Class c = loader.loadClass(JUnitTaskMirror.class.getName() + "Impl");
             if (c.getClassLoader() != loader) {
                 throw new BuildException("Overdelegating loader", task.getLocation());
             }
             Constructor cons = c.getConstructor(new Class[] {JUnitTask.class});
             return (JUnitTaskMirror) cons.newInstance(new Object[] {task});
         } catch (Exception e) {
             throw new BuildException(e, task.getLocation());
         }
     }
 
     /**
      * Sets up the delegate that will actually run the tests.
      *
      * <p>Will be invoked implicitly once the delegate is needed.</p>
      *
      * @since Ant 1.7.1
      */
     protected void setupJUnitDelegate() {
         final ClassLoader myLoader = JUnitTask.class.getClassLoader();
         if (splitJunit) {
             final Path path = new Path(getProject());
             path.add(antRuntimeClasses);
             Path extra = getCommandline().getClasspath();
             if (extra != null) {
                 path.add(extra);
             }
             mirrorLoader = (ClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
                 public Object run() {
                     return new SplitClassLoader(myLoader, path, getProject(),
                                      new String[] {
                                          "BriefJUnitResultFormatter",
                                          "JUnit4TestMethodAdapter",
                                          "JUnitResultFormatter",
                                          "JUnitTaskMirrorImpl",
                                          "JUnitTestRunner",
                                          "JUnitVersionHelper",
                                          "OutErrSummaryJUnitResultFormatter",
                                          "PlainJUnitResultFormatter",
                                          "SummaryJUnitResultFormatter",
                                          "TearDownOnVmCrash",
                                          "XMLJUnitResultFormatter",
                                      });
                 }
             });
         } else {
             mirrorLoader = myLoader;
         }
         delegate = createMirror(this, mirrorLoader);
     }
 
     /**
      * Runs the testcase.
      *
      * @throws BuildException in case of test failures or errors
      * @since Ant 1.2
      */
     public void execute() throws BuildException {
         checkMethodLists();
 
         setupJUnitDelegate();
 
         List testLists = new ArrayList();
 
         boolean forkPerTest = forkMode.getValue().equals(ForkMode.PER_TEST);
         if (forkPerTest || forkMode.getValue().equals(ForkMode.ONCE)) {
             testLists.addAll(executeOrQueue(getIndividualTests(),
                                             forkPerTest));
         } else { /* forkMode.getValue().equals(ForkMode.PER_BATCH) */
             final int count = batchTests.size();
             for (int i = 0; i < count; i++) {
                 BatchTest batchtest = (BatchTest) batchTests.elementAt(i);
                 testLists.addAll(executeOrQueue(batchtest.elements(), false));
             }
             testLists.addAll(executeOrQueue(tests.elements(), forkPerTest));
         }
 
         try {
             Iterator iter = testLists.iterator();
             while (iter.hasNext()) {
                 List l = (List) iter.next();
                 if (l.size() == 1) {
                     execute((JUnitTest) l.get(0));
                 } else {
                     execute(l);
                 }
             }
         } finally {
             cleanup();
         }
     }
 
     /**
      * Run the tests.
      * @param arg one JunitTest
      * @throws BuildException in case of test failures or errors
      */
     protected void execute(JUnitTest arg) throws BuildException {
         validateTestName(arg.getName());
 
         JUnitTest test = (JUnitTest) arg.clone();
         // set the default values if not specified
         //@todo should be moved to the test class instead.
         if (test.getTodir() == null) {
             test.setTodir(getProject().resolveFile("."));
         }
 
         if (test.getOutfile() == null) {
             test.setOutfile("TEST-" + test.getName());
         }
 
         // execute the test and get the return code
         TestResultHolder result = null;
         if (!test.getFork()) {
             result = executeInVM(test);
         } else {
             ExecuteWatchdog watchdog = createWatchdog();
             result = executeAsForked(test, watchdog, null);
             // null watchdog means no timeout, you'd better not check with null
         }
         actOnTestResult(result, test, "Test " + test.getName());
     }
 
     /**
      * Throws a <code>BuildException</code> if the given test name is invalid.
      * Validity is defined as not <code>null</code>, not empty, and not the
      * string &quot;null&quot;.
      * @param testName the test name to be validated
      * @throws BuildException if <code>testName</code> is not a valid test name
      */
     private void validateTestName(String testName) throws BuildException {
         if (testName == null || testName.length() == 0
             || testName.equals("null")) {
             throw new BuildException("test name must be specified");
         }
     }
 
     /**
      * Execute a list of tests in a single forked Java VM.
      * @param testList the list of tests to execute.
      * @throws BuildException on error.
      */
     protected void execute(List testList) throws BuildException {
         JUnitTest test = null;
         // Create a temporary file to pass the test cases to run to
         // the runner (one test case per line)
         File casesFile = createTempPropertiesFile("junittestcases");
         BufferedWriter writer = null;
         try {
             writer = new BufferedWriter(new FileWriter(casesFile));
 
             log("Creating casesfile '" + casesFile.getAbsolutePath()
                 + "' with content: ", Project.MSG_VERBOSE);
             PrintStream logWriter =
                 new PrintStream(new LogOutputStream(this, Project.MSG_VERBOSE));
 
             Iterator iter = testList.iterator();
             while (iter.hasNext()) {
                 test = (JUnitTest) iter.next();
                 printDual(writer, logWriter, test.getName());
                 if (test.getMethods() != null) {
                     printDual(writer, logWriter, ":" + test.getMethodsString().replace(',', '+'));
                 }
                 if (test.getTodir() == null) {
                     printDual(writer, logWriter,
                               "," + getProject().resolveFile("."));
                 } else {
                     printDual(writer, logWriter, "," + test.getTodir());
                 }
 
                 if (test.getOutfile() == null) {
                     printlnDual(writer, logWriter,
                                 "," + "TEST-" + test.getName());
                 } else {
                     printlnDual(writer, logWriter, "," + test.getOutfile());
                 }
             }
             writer.flush();
             writer.close();
             writer = null;
 
             // execute the test and get the return code
             ExecuteWatchdog watchdog = createWatchdog();
             TestResultHolder result =
                 executeAsForked(test, watchdog, casesFile);
             actOnTestResult(result, test, "Tests");
         } catch (IOException e) {
             log(e.toString(), Project.MSG_ERR);
             throw new BuildException(e);
         } finally {
             FileUtils.close(writer);
 
             try {
                 FILE_UTILS.tryHardToDelete(casesFile);
             } catch (Exception e) {
                 log(e.toString(), Project.MSG_ERR);
             }
         }
     }
 
     /**
      * Execute a testcase by forking a new JVM. The command will block
      * until it finishes. To know if the process was destroyed or not
      * or whether the forked Java VM exited abnormally, use the
      * attributes of the returned holder object.
      * @param  test       the testcase to execute.
      * @param  watchdog   the watchdog in charge of cancelling the test if it
      * exceeds a certain amount of time. Can be <tt>null</tt>, in this case
      * the test could probably hang forever.
      * @param casesFile list of test cases to execute. Can be <tt>null</tt>,
      * in this case only one test is executed.
      * @return the test results from the JVM itself.
      * @throws BuildException in case of error creating a temporary property file,
      * or if the junit process can not be forked
      */
     private TestResultHolder executeAsForked(JUnitTest test,
                                              ExecuteWatchdog watchdog,
                                              File casesFile)
         throws BuildException {
 
         if (perm != null) {
             log("Permissions ignored when running in forked mode!",
                 Project.MSG_WARN);
         }
 
         CommandlineJava cmd;
         try {
             cmd = (CommandlineJava) (getCommandline().clone());
         } catch (CloneNotSupportedException e) {
             throw new BuildException("This shouldn't happen", e, getLocation());
         }
         if (casesFile == null) {
             cmd.createArgument().setValue(test.getName());
             if (test.getMethods() != null) {
                 cmd.createArgument().setValue(Constants.METHOD_NAMES + test.getMethodsString());
             }
         } else {
             log("Running multiple tests in the same VM", Project.MSG_VERBOSE);
             cmd.createArgument().setValue(Constants.TESTSFILE + casesFile);
         }
 
         cmd.createArgument().setValue(Constants.FILTERTRACE + test.getFiltertrace());
         cmd.createArgument().setValue(Constants.HALT_ON_ERROR + test.getHaltonerror());
         cmd.createArgument().setValue(Constants.HALT_ON_FAILURE
                                       + test.getHaltonfailure());
         checkIncludeAntRuntime(cmd);
 
         checkIncludeSummary(cmd);
 
         cmd.createArgument().setValue(Constants.SHOWOUTPUT
                                       + String.valueOf(showOutput));
         cmd.createArgument().setValue(Constants.OUTPUT_TO_FORMATTERS
                                       + String.valueOf(outputToFormatters));
         cmd.createArgument().setValue(Constants.LOG_FAILED_TESTS
                                       + String.valueOf(logFailedTests));
 
         // #31885
         cmd.createArgument().setValue(Constants.LOGTESTLISTENEREVENTS
                                       + String.valueOf(getEnableTestListenerEvents()));
 
         StringBuffer formatterArg = new StringBuffer(STRING_BUFFER_SIZE);
         final FormatterElement[] feArray = mergeFormatters(test);
         for (int i = 0; i < feArray.length; i++) {
             FormatterElement fe = feArray[i];
             if (fe.shouldUse(this)) {
                 formatterArg.append(Constants.FORMATTER);
                 formatterArg.append(fe.getClassname());
                 File outFile = getOutput(fe, test);
                 if (outFile != null) {
                     formatterArg.append(",");
                     formatterArg.append(outFile);
                 }
                 cmd.createArgument().setValue(formatterArg.toString());
                 formatterArg = new StringBuffer();
             }
         }
 
         File vmWatcher = createTempPropertiesFile("junitvmwatcher");
         cmd.createArgument().setValue(Constants.CRASHFILE
                                       + vmWatcher.getAbsolutePath());
         File propsFile = createTempPropertiesFile("junit");
         cmd.createArgument().setValue(Constants.PROPSFILE
                                       + propsFile.getAbsolutePath());
         Hashtable p = getProject().getProperties();
         Properties props = new Properties();
         for (Enumeration e = p.keys(); e.hasMoreElements();) {
             Object key = e.nextElement();
             props.put(key, p.get(key));
         }
         try {
             FileOutputStream outstream = new FileOutputStream(propsFile);
             props.store(outstream, "Ant JUnitTask generated properties file");
             outstream.close();
         } catch (java.io.IOException e) {
             FILE_UTILS.tryHardToDelete(propsFile);
             throw new BuildException("Error creating temporary properties "
                                      + "file.", e, getLocation());
         }
 
         Execute execute = new Execute(
             new JUnitLogStreamHandler(
                 this,
                 Project.MSG_INFO,
                 Project.MSG_WARN),
             watchdog);
         execute.setCommandline(cmd.getCommandline());
         execute.setAntRun(getProject());
         if (dir != null) {
             execute.setWorkingDirectory(dir);
         }
 
         String[] environment = env.getVariables();
         if (environment != null) {
             for (int i = 0; i < environment.length; i++) {
                 log("Setting environment variable: " + environment[i],
                     Project.MSG_VERBOSE);
             }
         }
         execute.setNewenvironment(newEnvironment);
         execute.setEnvironment(environment);
 
         log(cmd.describeCommand(), Project.MSG_VERBOSE);
 
         checkForkedPath(cmd);
 
         TestResultHolder result = new TestResultHolder();
         try {
             result.exitCode = execute.execute();
         } catch (IOException e) {
             throw new BuildException("Process fork failed.", e, getLocation());
         } finally {
             String vmCrashString = "unknown";
             BufferedReader br = null;
             try {
                 if (vmWatcher.exists()) {
                     br = new BufferedReader(new FileReader(vmWatcher));
                     vmCrashString = br.readLine();
                 } else {
                     vmCrashString = "Monitor file ("
                             + vmWatcher.getAbsolutePath()
                             + ") missing, location not writable,"
                             + " testcase not started or mixing ant versions?";
                 }
             } catch (Exception e) {
                 e.printStackTrace();
                 // ignored.
             } finally {
                 FileUtils.close(br);
                 if (vmWatcher.exists()) {
                     FILE_UTILS.tryHardToDelete(vmWatcher);
                 }
             }
 
             boolean crash = (watchdog != null && watchdog.killedProcess())
                 || !Constants.TERMINATED_SUCCESSFULLY.equals(vmCrashString);
 
             if (casesFile != null && crash) {
                 test = createDummyTestForBatchTest(test);
             }
 
             if (watchdog != null && watchdog.killedProcess()) {
                 result.timedOut = true;
                 logTimeout(feArray, test, vmCrashString);
             } else if (crash) {
                 result.crashed = true;
                 logVmCrash(feArray, test, vmCrashString);
             }
 
             if (!FILE_UTILS.tryHardToDelete(propsFile)) {
                 throw new BuildException("Could not delete temporary "
                                          + "properties file '"
                                          + propsFile.getAbsolutePath() + "'.");
             }
         }
 
         return result;
     }
 
     /**
      * Adding ant runtime.
      * @param cmd command to run
      */
     private void checkIncludeAntRuntime(CommandlineJava cmd) {
         if (includeAntRuntime) {
             Map/*<String, String>*/ env = Execute.getEnvironmentVariables();
             String cp = (String) env.get(CLASSPATH);
             if (cp != null) {
                 cmd.createClasspath(getProject()).createPath()
                     .append(new Path(getProject(), cp));
             }
             log("Implicitly adding " + antRuntimeClasses + " to CLASSPATH",
                 Project.MSG_VERBOSE);
             cmd.createClasspath(getProject()).createPath()
                 .append(antRuntimeClasses);
         }
     }
 
 
     /**
      * check for the parameter being "withoutanderr" in a locale-independent way.
      * @param summaryOption the summary option -can be null
      * @return true if the run should be withoutput and error
      */
     private boolean equalsWithOutAndErr(String summaryOption) {
         return "withoutanderr".equalsIgnoreCase(summaryOption);
     }
 
     private void checkIncludeSummary(CommandlineJava cmd) {
         if (summary) {
             String prefix = "";
             if (equalsWithOutAndErr(summaryValue)) {
                 prefix = "OutErr";
             }
             cmd.createArgument()
                 .setValue(Constants.FORMATTER
                           + "org.apache.tools.ant.taskdefs.optional.junit."
                           + prefix + "SummaryJUnitResultFormatter");
         }
     }
 
     /**
      * Check the path for multiple different versions of
      * ant.
      * @param cmd command to execute
      */
     private void checkForkedPath(CommandlineJava cmd) {
         if (forkedPathChecked) {
             return;
         }
         forkedPathChecked = true;
         if (!cmd.haveClasspath()) {
             return;
         }
         AntClassLoader loader = null;
         try {
             loader =
                 AntClassLoader.newAntClassLoader(null, getProject(),
                                                  cmd.createClasspath(getProject()),
                                                  true);
             String projectResourceName =
                 LoaderUtils.classNameToResource(Project.class.getName());
             URL previous = null;
             try {
                 for (Enumeration e = loader.getResources(projectResourceName);
                      e.hasMoreElements();) {
                     URL current = (URL) e.nextElement();
                     if (previous != null && !urlEquals(current, previous)) {
                         log("WARNING: multiple versions of ant detected "
                             + "in path for junit "
                             + LINE_SEP + "         " + previous
                             + LINE_SEP + "     and " + current,
                             Project.MSG_WARN);
                         return;
                     }
                     previous = current;
                 }
             } catch (Exception ex) {
                 // Ignore exception
             }
         } finally {
             if (loader != null) {
                 loader.cleanup();
             }
         }
     }
 
     /**
      * Compares URLs for equality but takes case-sensitivity into
      * account when comparing file URLs and ignores the jar specific
      * part of the URL if present.
      */
     private static boolean urlEquals(URL u1, URL u2) {
         String url1 = maybeStripJarAndClass(u1);
         String url2 = maybeStripJarAndClass(u2);
         if (url1.startsWith("file:") && url2.startsWith("file:")) {
             return new File(FILE_UTILS.fromURI(url1))
                 .equals(new File(FILE_UTILS.fromURI(url2)));
         }
         return url1.equals(url2);
     }
 
     private static String maybeStripJarAndClass(URL u) {
         String s = u.toString();
         if (s.startsWith("jar:")) {
             int pling = s.indexOf('!');
             s = s.substring(4, pling == -1 ? s.length() : pling);
         }
         return s;
     }
 
     /**
      * Create a temporary file to pass the properties to a new process.
      * Will auto-delete on (graceful) exit.
      * The file will be in the project basedir unless tmpDir declares
      * something else.
      * @param prefix
      * @return created file
      */
     private File createTempPropertiesFile(String prefix) {
         File propsFile =
             FILE_UTILS.createTempFile(prefix, ".properties",
                 tmpDir != null ? tmpDir : getProject().getBaseDir(), true, true);
         return propsFile;
     }
 
 
     /**
      * Pass output sent to System.out to the TestRunner so it can
      * collect it for the formatters.
      *
      * @param output output coming from System.out
      * @since Ant 1.5
      */
     protected void handleOutput(String output) {
         if (output.startsWith(TESTLISTENER_PREFIX)) {
             log(output, Project.MSG_VERBOSE);
         } else if (runner != null) {
             if (outputToFormatters) {
                 runner.handleOutput(output);
             }
             if (showOutput) {
                 super.handleOutput(output);
             }
         } else {
             super.handleOutput(output);
         }
     }
 
     /**
      * Handle an input request by this task.
      * @see Task#handleInput(byte[], int, int)
      * This implementation delegates to a runner if it
      * present.
      * @param buffer the buffer into which data is to be read.
      * @param offset the offset into the buffer at which data is stored.
      * @param length the amount of data to read.
      *
      * @return the number of bytes read.
      * @exception IOException if the data cannot be read.
      *
      * @since Ant 1.6
      */
     protected int handleInput(byte[] buffer, int offset, int length)
         throws IOException {
         if (runner != null) {
             return runner.handleInput(buffer, offset, length);
         } else {
             return super.handleInput(buffer, offset, length);
         }
     }
 
 
     /**
      * Pass output sent to System.out to the TestRunner so it can
      * collect ot for the formatters.
      *
      * @param output output coming from System.out
      * @since Ant 1.5.2
      */
     protected void handleFlush(String output) {
         if (runner != null) {
             runner.handleFlush(output);
             if (showOutput) {
                 super.handleFlush(output);
             }
         } else {
             super.handleFlush(output);
         }
     }
 
     /**
      * Pass output sent to System.err to the TestRunner so it can
      * collect it for the formatters.
      *
      * @param output output coming from System.err
      * @since Ant 1.5
      */
     public void handleErrorOutput(String output) {
         if (runner != null) {
             runner.handleErrorOutput(output);
             if (showOutput) {
                 super.handleErrorOutput(output);
             }
         } else {
             super.handleErrorOutput(output);
         }
     }
 
 
     /**
      * Pass output sent to System.err to the TestRunner so it can
      * collect it for the formatters.
      *
      * @param output coming from System.err
      * @since Ant 1.5.2
      */
     public void handleErrorFlush(String output) {
         if (runner != null) {
             runner.handleErrorFlush(output);
             if (showOutput) {
                 super.handleErrorFlush(output);
             }
         } else {
             super.handleErrorFlush(output);
         }
     }
 
     // in VM is not very nice since it could probably hang the
     // whole build. IMHO this method should be avoided and it would be best
     // to remove it in future versions. TBD. (SBa)
 
     /**
      * Execute inside VM.
      * @param arg one JUnitTest
      * @throws BuildException under unspecified circumstances
      * @return the results
      */
     private TestResultHolder executeInVM(JUnitTest arg) throws BuildException {
         if (delegate == null) {
             setupJUnitDelegate();
         }
 
         JUnitTest test = (JUnitTest) arg.clone();
         test.setProperties(getProject().getProperties());
         if (dir != null) {
             log("dir attribute ignored if running in the same VM",
                 Project.MSG_WARN);
         }
 
         if (newEnvironment || null != env.getVariables()) {
             log("Changes to environment variables are ignored if running in "
                 + "the same VM.", Project.MSG_WARN);
         }
 
         if (getCommandline().getBootclasspath() != null) {
             log("bootclasspath is ignored if running in the same VM.",
                 Project.MSG_WARN);
         }
 
         CommandlineJava.SysProperties sysProperties =
                 getCommandline().getSystemProperties();
         if (sysProperties != null) {
             sysProperties.setSystem();
         }
 
         try {
             log("Using System properties " + System.getProperties(),
                 Project.MSG_VERBOSE);
             if (splitJunit) {
                 classLoader = (AntClassLoader) delegate.getClass().getClassLoader();
             } else {
                 createClassLoader();
             }
             if (classLoader != null) {
                 classLoader.setThreadContextLoader();
             }
             runner = delegate.newJUnitTestRunner(test, test.getMethods(), test.getHaltonerror(),
                                          test.getFiltertrace(),
                                          test.getHaltonfailure(), false,
                                          getEnableTestListenerEvents(),
                                          classLoader);
             if (summary) {
 
                 JUnitTaskMirror.SummaryJUnitResultFormatterMirror f =
                     delegate.newSummaryJUnitResultFormatter();
                 f.setWithOutAndErr(equalsWithOutAndErr(summaryValue));
                 f.setOutput(getDefaultOutput());
                 runner.addFormatter(f);
             }
 
             runner.setPermissions(perm);
 
             final FormatterElement[] feArray = mergeFormatters(test);
             for (int i = 0; i < feArray.length; i++) {
                 FormatterElement fe = feArray[i];
                 if (fe.shouldUse(this)) {
                     File outFile = getOutput(fe, test);
                     if (outFile != null) {
                         fe.setOutfile(outFile);
                     } else {
                         fe.setOutput(getDefaultOutput());
                     }
                     runner.addFormatter(fe.createFormatter(classLoader));
                 }
             }
 
             runner.run();
             TestResultHolder result = new TestResultHolder();
             result.exitCode = runner.getRetCode();
             return result;
         } finally {
             if (sysProperties != null) {
                 sysProperties.restoreSystem();
             }
             if (classLoader != null) {
                 classLoader.resetThreadContextLoader();
             }
         }
     }
 
     /**
      * @return <tt>null</tt> if there is a timeout value, otherwise the
      * watchdog instance.
      *
      * @throws BuildException under unspecified circumstances
      * @since Ant 1.2
      */
     protected ExecuteWatchdog createWatchdog() throws BuildException {
         if (timeout == null) {
             return null;
         }
         return new ExecuteWatchdog((long) timeout.intValue());
     }
 
     /**
      * Get the default output for a formatter.
      *
      * @return default output stream for a formatter
      * @since Ant 1.3
      */
     protected OutputStream getDefaultOutput() {
         return new LogOutputStream(this, Project.MSG_INFO);
     }
 
     /**
      * Merge all individual tests from the batchtest with all individual tests
      * and return an enumeration over all <tt>JUnitTest</tt>.
      *
      * @return enumeration over individual tests
      * @since Ant 1.3
      */
     protected Enumeration getIndividualTests() {
         final int count = batchTests.size();
         final Enumeration[] enums = new Enumeration[ count + 1];
         for (int i = 0; i < count; i++) {
             BatchTest batchtest = (BatchTest) batchTests.elementAt(i);
             enums[i] = batchtest.elements();
         }
         enums[enums.length - 1] = tests.elements();
         return Enumerations.fromCompound(enums);
     }
 
     /**
      * Verifies all <code>test</code> elements having the <code>methods</code>
      * attribute specified and having the <code>if</code>-condition resolved
      * to true, that the value of the <code>methods</code> attribute is valid.
      * @exception BuildException if some of the tests matching the described
      *                           conditions has invalid value of the
      *                           <code>methods</code> attribute
      * @since 1.8.2
      */
     private void checkMethodLists() throws BuildException {
         if (tests.isEmpty()) {
             return;
         }
 
         Enumeration testsEnum = tests.elements();
         while (testsEnum.hasMoreElements()) {
             JUnitTest test = (JUnitTest) testsEnum.nextElement();
             if (test.hasMethodsSpecified() && test.shouldRun(getProject())) {
                 test.resolveMethods();
             }
         }
     }
 
     /**
      * return an enumeration listing each test, then each batchtest
      * @return enumeration
      * @since Ant 1.3
      */
     protected Enumeration allTests() {
         Enumeration[] enums = {tests.elements(), batchTests.elements()};
         return Enumerations.fromCompound(enums);
     }
 
     /**
      * @param test junit test
      * @return array of FormatterElement
      * @since Ant 1.3
      */
     private FormatterElement[] mergeFormatters(JUnitTest test) {
         Vector feVector = (Vector) formatters.clone();
         test.addFormattersTo(feVector);
         FormatterElement[] feArray = new FormatterElement[feVector.size()];
         feVector.copyInto(feArray);
         return feArray;
     }
 
     /**
      * If the formatter sends output to a file, return that file.
      * null otherwise.
      * @param fe  formatter element
      * @param test one JUnit test
      * @return file reference
      * @since Ant 1.3
      */
     protected File getOutput(FormatterElement fe, JUnitTest test) {
         if (fe.getUseFile()) {
             String base = test.getOutfile();
             if (base == null) {
                 base = JUnitTaskMirror.JUnitTestRunnerMirror.IGNORED_FILE_NAME;
             }
             String filename = base + fe.getExtension();
             File destFile = new File(test.getTodir(), filename);
             String absFilename = destFile.getAbsolutePath();
             return getProject().resolveFile(absFilename);
         }
         return null;
     }
 
     /**
      * Search for the given resource and add the directory or archive
      * that contains it to the classpath.
      *
      * <p>Doesn't work for archives in JDK 1.1 as the URL returned by
      * getResource doesn't contain the name of the archive.</p>
      *
      * @param resource resource that one wants to lookup
      * @since Ant 1.4
      */
     protected void addClasspathEntry(String resource) {
         addClasspathResource(resource);
     }
 
     /**
      * Implementation of addClasspathEntry.
      *
      * @param resource resource that one wants to lookup
      * @return true if something was in fact added
      * @since Ant 1.7.1
      */
     private boolean addClasspathResource(String resource) {
         /*
          * pre Ant 1.6 this method used to call getClass().getResource
          * while Ant 1.6 will call ClassLoader.getResource().
          *
          * The difference is that Class.getResource expects a leading
          * slash for "absolute" resources and will strip it before
          * delegating to ClassLoader.getResource - so we now have to
          * emulate Class's behavior.
          */
         if (resource.startsWith("/")) {
             resource = resource.substring(1);
         } else {
             resource = "org/apache/tools/ant/taskdefs/optional/junit/"
                 + resource;
         }
 
         File f = LoaderUtils.getResourceSource(getClass().getClassLoader(),
                                                resource);
         if (f != null) {
             log("Found " + f.getAbsolutePath(), Project.MSG_DEBUG);
             antRuntimeClasses.createPath().setLocation(f);
             return true;
         } else {
             log("Couldn\'t find " + resource, Project.MSG_DEBUG);
             return false;
         }
     }
 
     static final String TIMEOUT_MESSAGE = 
         "Timeout occurred. Please note the time in the report does"
         + " not reflect the time until the timeout.";
 
     /**
      * Take care that some output is produced in report files if the
      * watchdog kills the test.
      *
      * @since Ant 1.5.2
      */
     private void logTimeout(FormatterElement[] feArray, JUnitTest test,
                             String testCase) {
         logVmExit(feArray, test, TIMEOUT_MESSAGE, testCase);
     }
 
     /**
      * Take care that some output is produced in report files if the
      * forked machine exited before the test suite finished but the
      * reason is not a timeout.
      *
      * @since Ant 1.7
      */
     private void logVmCrash(FormatterElement[] feArray, JUnitTest test, String testCase) {
         logVmExit(
             feArray, test,
             "Forked Java VM exited abnormally. Please note the time in the report"
             + " does not reflect the time until the VM exit.",
             testCase);
     }
 
     /**
      * Take care that some output is produced in report files if the
      * forked machine terminated before the test suite finished
      *
      * @since Ant 1.7
      */
     private void logVmExit(FormatterElement[] feArray, JUnitTest test,
                            String message, String testCase) {
         if (delegate == null) {
             setupJUnitDelegate();
         }
 
         try {
             log("Using System properties " + System.getProperties(),
                 Project.MSG_VERBOSE);
             if (splitJunit) {
                 classLoader = (AntClassLoader) delegate.getClass().getClassLoader();
             } else {
                 createClassLoader();
             }
             if (classLoader != null) {
                 classLoader.setThreadContextLoader();
             }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskMirror.java b/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskMirror.java
index 67451f8d4..84c62c96a 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskMirror.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskMirror.java
@@ -1,189 +1,189 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.junit;
 
 import java.io.IOException;
 import java.io.OutputStream;
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.types.Permissions;
 
 /**
  * Handles the portions of {@link JUnitTask} which need to directly access
  * actual JUnit classes, so that junit.jar need not be on Ant's startup classpath.
  * Neither JUnitTask.java nor JUnitTaskMirror.java nor their transitive static
  * deps may import any junit.** classes!
  * Specifically, need to not refer to
  * - JUnitResultFormatter or its subclasses
  * - JUnitVersionHelper
  * - JUnitTestRunner
  * Cf.  JUnitTask.SplitLoader#isSplit(String)
  * Public only to permit access from classes in this package; do not use directly.
  *
  * @since 1.7
  * @see "bug #38799"
  */
 public interface JUnitTaskMirror {
 
     /**
      * Add the formatter to be called when the jvm exits before
-     * the test suite finishs.
+     * the test suite finishes.
      * @param test the test.
-     * @param formatter the fomatter to use.
+     * @param formatter the formatter to use.
      * @param out the output stream to use.
      * @param message the message to write out.
      * @param testCase the name of the test.
      */
     void addVmExit(JUnitTest test, JUnitResultFormatterMirror formatter,
             OutputStream out, String message, String testCase);
 
     /**
      * Create a new test runner for a test.
      * @param test the test to run.
      * @param methods names of the test methods to be run.
      * @param haltOnError if true halt the tests if an error occurs.
      * @param filterTrace if true filter the stack traces.
      * @param haltOnFailure if true halt the test if a failure occurs.
      * @param showOutput    if true show output.
      * @param logTestListenerEvents if true log test listener events.
      * @param classLoader      the classloader to use to create the runner.
      * @return the test runner.
      */
     JUnitTestRunnerMirror newJUnitTestRunner(JUnitTest test, String[] methods, boolean haltOnError,
             boolean filterTrace, boolean haltOnFailure, boolean showOutput,
             boolean logTestListenerEvents, AntClassLoader classLoader);
 
     /**
      * Create a summary result formatter.
      * @return the created formatter.
      */
     SummaryJUnitResultFormatterMirror newSummaryJUnitResultFormatter();
 
 
     /** The interface that JUnitResultFormatter extends. */
     public interface JUnitResultFormatterMirror {
         /**
          * Set the output stream.
          * @param outputStream the stream to use.
          */
         void setOutput(OutputStream outputStream);
     }
 
     /** The interface that SummaryJUnitResultFormatter extends. */
     public interface SummaryJUnitResultFormatterMirror
         extends JUnitResultFormatterMirror {
 
         /**
          * Set where standard out and standard error should be included.
          * @param value if true include the outputs in the summary.
          */
         void setWithOutAndErr(boolean value);
     }
 
     /** Interface that test runners implement. */
     public interface JUnitTestRunnerMirror {
 
         /**
          * Used in formatter arguments as a placeholder for the basename
          * of the output file (which gets replaced by a test specific
          * output file name later).
          *
          * @since Ant 1.6.3
          */
         String IGNORED_FILE_NAME = "IGNORETHIS";
 
         /**
          * No problems with this test.
          */
         int SUCCESS = 0;
 
         /**
          * Some tests failed.
          */
         int FAILURES = 1;
 
         /**
          * An error occurred.
          */
         int ERRORS = 2;
 
         /**
          * Permissions for the test run.
          * @param perm the permissions to use.
          */
         void setPermissions(Permissions perm);
 
         /** Run the test. */
         void run();
 
         /**
          * Add a formatter to the test.
          * @param formatter the formatter to use.
          */
         void addFormatter(JUnitResultFormatterMirror formatter);
 
         /**
          * Returns what System.exit() would return in the standalone version.
          *
          * @return 2 if errors occurred, 1 if tests failed else 0.
          */
         int getRetCode();
 
         /**
          * Handle output sent to System.err.
          *
          * @param output coming from System.err
          */
         void handleErrorFlush(String output);
 
         /**
          * Handle output sent to System.err.
          *
          * @param output output for System.err
          */
         void handleErrorOutput(String output);
 
         /**
          * Handle output sent to System.out.
          *
          * @param output output for System.out.
          */
         void handleOutput(String output);
 
         /**
          * Handle an input request.
          *
          * @param buffer the buffer into which data is to be read.
          * @param offset the offset into the buffer at which data is stored.
          * @param length the amount of data to read.
          *
          * @return the number of bytes read.
          *
          * @exception IOException if the data cannot be read.
          */
         int handleInput(byte[] buffer, int offset, int length) throws IOException;
 
         /**
          * Handle output sent to System.out.
          *
          * @param output output for System.out.
          */
        void handleFlush(String output);
 
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java b/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java
index ce48fa432..05320b11f 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java
@@ -1,1171 +1,1171 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.junit;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.lang.reflect.Method;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Properties;
 import java.util.StringTokenizer;
 import java.util.Vector;
 import junit.framework.AssertionFailedError;
 import junit.framework.Test;
 import junit.framework.TestFailure;
 import junit.framework.TestListener;
 import junit.framework.TestResult;
 import junit.framework.TestSuite;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.Permissions;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.StringUtils;
 import org.apache.tools.ant.util.TeeOutputStream;
 
 /**
  * Simple Testrunner for JUnit that runs all tests of a testsuite.
  *
  * <p>This TestRunner expects a name of a TestCase class as its
  * argument. If this class provides a static suite() method it will be
  * called and the resulting Test will be run. So, the signature should be
  * <pre><code>
  *     public static junit.framework.Test suite()
  * </code></pre>
  *
  * <p> If no such method exists, all public methods starting with
  * "test" and taking no argument will be run.
  *
  * <p> Summary output is generated at the end.
  *
  * @since Ant 1.2
  */
 
 public class JUnitTestRunner implements TestListener, JUnitTaskMirror.JUnitTestRunnerMirror {
 
     /**
      * Holds the registered formatters.
      */
     private Vector formatters = new Vector();
 
     /**
      * Collects TestResults.
      */
     private TestResult res;
 
     /**
      * Do we filter junit.*.* stack frames out of failure and error exceptions.
      */
     private static boolean filtertrace = true;
 
     /**
      * Do we send output to System.out/.err in addition to the formatters?
      */
     private boolean showOutput = false;
 
     private boolean outputToFormatters = true;
 
     /**
      * The permissions set for the test to run.
      */
     private Permissions perm = null;
 
     private static final String JUNIT_4_TEST_ADAPTER
         = "junit.framework.JUnit4TestAdapter";
 
     private static final String[] DEFAULT_TRACE_FILTERS = new String[] {
                 "junit.framework.TestCase",
                 "junit.framework.TestResult",
                 "junit.framework.TestSuite",
                 "junit.framework.Assert.", // don't filter AssertionFailure
                 "junit.swingui.TestRunner",
                 "junit.awtui.TestRunner",
                 "junit.textui.TestRunner",
                 "java.lang.reflect.Method.invoke(",
                 "sun.reflect.",
                 "org.apache.tools.ant.",
                 // JUnit 4 support:
                 "org.junit.",
                 "junit.framework.JUnit4TestAdapter",
                 " more",
         };
 
 
     /**
      * Do we stop on errors.
      */
     private boolean haltOnError = false;
 
     /**
      * Do we stop on test failures.
      */
     private boolean haltOnFailure = false;
 
     /**
      * Returncode
      */
     private int retCode = SUCCESS;
 
     /**
      * The TestSuite we are currently running.
      */
     private JUnitTest junitTest;
 
     /** output written during the test */
     private PrintStream systemError;
 
     /** Error output during the test */
     private PrintStream systemOut;
 
     /** is this runner running in forked mode? */
     private boolean forked = false;
 
     /** Running more than one test suite? */
     private static boolean multipleTests = false;
 
     /** ClassLoader passed in in non-forked mode. */
     private ClassLoader loader;
 
     /** Do we print TestListener events? */
     private boolean logTestListenerEvents = false;
 
     /** Turned on if we are using JUnit 4 for this test suite. see #38811 */
     private boolean junit4;
 
     /**
      * The file used to indicate that the build crashed.
      * File will be empty in case the build did not crash.
      */
     private static String crashFile = null;
 
     /** Names of test methods to execute */
     private String[] methods = null;
     
     /**
      * Constructor for fork=true or when the user hasn't specified a
      * classpath.
      * @param test the test to run.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      */
     public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure) {
         this(test, haltOnError, filtertrace, haltOnFailure, false);
     }
 
     /**
      * Constructor for fork=true or when the user hasn't specified a
      * classpath.
      * @param test the test to run.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      * @param showOutput    whether to send output to System.out/.err as well as formatters.
      */
     public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            boolean showOutput) {
         this(test, haltOnError, filtertrace, haltOnFailure, showOutput, false);
     }
 
     /**
      * Constructor for fork=true or when the user hasn't specified a
      * classpath.
      * @param test the test to run.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      * @param showOutput    whether to send output to System.out/.err as well as formatters.
      * @param logTestListenerEvents whether to print TestListener events.
      * @since Ant 1.7
      */
     public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            boolean showOutput, boolean logTestListenerEvents) {
         this(test, null, haltOnError, filtertrace, haltOnFailure, showOutput,
              logTestListenerEvents, null);
     }
 
     /**
      * Constructor for fork=true or when the user hasn't specified a
      * classpath.
      * @param test the test to run.
      * @param methods names of methods of the test to be executed.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      * @param showOutput    whether to send output to System.out/.err as well as formatters.
      * @param logTestListenerEvents whether to print TestListener events.
      * @since 1.8.2
      */
     public JUnitTestRunner(JUnitTest test, String[] methods, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            boolean showOutput, boolean logTestListenerEvents) {
         this(test, methods, haltOnError, filtertrace, haltOnFailure, showOutput,
              logTestListenerEvents, null);
     }
 
     /**
      * Constructor to use when the user has specified a classpath.
      * @param test the test to run.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      * @param loader the classloader to use running the test.
      */
     public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            ClassLoader loader) {
         this(test, haltOnError, filtertrace, haltOnFailure, false, loader);
     }
 
     /**
      * Constructor to use when the user has specified a classpath.
      * @param test the test to run.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      * @param showOutput    whether to send output to System.out/.err as well as formatters.
      * @param loader the classloader to use running the test.
      */
     public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            boolean showOutput, ClassLoader loader) {
         this(test, haltOnError, filtertrace, haltOnFailure, showOutput,
              false, loader);
     }
 
     /**
      * Constructor to use when the user has specified a classpath.
      * @param test the test to run.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      * @param showOutput    whether to send output to System.out/.err as well as formatters.
      * @param logTestListenerEvents whether to print TestListener events.
      * @param loader the classloader to use running the test.
      * @since Ant 1.7
      */
     public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            boolean showOutput, boolean logTestListenerEvents,
                            ClassLoader loader) {
         this(test, null, haltOnError, filtertrace, haltOnFailure, showOutput, 
              logTestListenerEvents, loader);
     }
 
 
     /**
      * Constructor to use when the user has specified a classpath.
      * @since 1.8.2
      */
     public JUnitTestRunner(JUnitTest test, String[] methods, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            boolean showOutput, boolean logTestListenerEvents,
                            ClassLoader loader) {
         JUnitTestRunner.filtertrace = filtertrace; // XXX clumsy, should use instance field somehow
         this.junitTest = test;
         this.haltOnError = haltOnError;
         this.haltOnFailure = haltOnFailure;
         this.showOutput = showOutput;
         this.logTestListenerEvents = logTestListenerEvents;
         this.methods = methods != null ? (String[]) methods.clone() : null;
         this.loader = loader;
     }
 
     private PrintStream savedOut = null;
     private PrintStream savedErr = null;
 
     private PrintStream createEmptyStream() {
         return new PrintStream(
             new OutputStream() {
                 public void write(int b) {
                 }
             });
     }
 
     private PrintStream createTeePrint(PrintStream ps1, PrintStream ps2) {
         return new PrintStream(new TeeOutputStream(ps1, ps2));
     }
 
     private void setupIOStreams(ByteArrayOutputStream o,
                                 ByteArrayOutputStream e) {
         systemOut = new PrintStream(o);
         systemError = new PrintStream(e);
 
         if (forked) {
             if (!outputToFormatters) {
                 if (!showOutput) {
                     savedOut = System.out;
                     savedErr = System.err;
                     System.setOut(createEmptyStream());
                     System.setErr(createEmptyStream());
                 }
             } else {
                 savedOut = System.out;
                 savedErr = System.err;
                 if (!showOutput) {
                     System.setOut(systemOut);
                     System.setErr(systemError);
                 } else {
                     System.setOut(createTeePrint(savedOut, systemOut));
                     System.setErr(createTeePrint(savedErr, systemError));
                 }
                 perm = null;
             }
         } else {
             if (perm != null) {
                 perm.setSecurityManager();
             }
         }
     }
 
     /**
      * Run the test.
      */
     public void run() {
         res = new TestResult();
         res.addListener(wrapListener(this));
         final int size = formatters.size();
         for (int i = 0; i < size; i++) {
             res.addListener(wrapListener((TestListener) formatters.elementAt(i)));
         }
 
         ByteArrayOutputStream errStrm = new ByteArrayOutputStream();
         ByteArrayOutputStream outStrm = new ByteArrayOutputStream();
 
         setupIOStreams(outStrm, errStrm);
 
         Test suite = null;
         Throwable exception = null;
         boolean startTestSuiteSuccess = false;
 
         try {
 
             try {
                 Class testClass = null;
                 if (loader == null) {
                     testClass = Class.forName(junitTest.getName());
                 } else {
                     testClass = Class.forName(junitTest.getName(), true,
                                               loader);
                 }
 
                 final boolean testMethodsSpecified = (methods != null);
 
                 // check for a static suite method first, even when using
                 // JUnit 4
                 Method suiteMethod = null;
                 if (!testMethodsSpecified) {
                 try {
                     // check if there is a suite method
                     suiteMethod = testClass.getMethod("suite", new Class[0]);
                 } catch (NoSuchMethodException e) {
                     // no appropriate suite method found. We don't report any
                     // error here since it might be perfectly normal.
                 }
                 }
 
                 if (suiteMethod != null) {
                     // if there is a suite method available, then try
                     // to extract the suite from it. If there is an error
                     // here it will be caught below and reported.
                     suite = (Test) suiteMethod.invoke(null, new Class[0]);
 
                 } else {
                     Class junit4TestAdapterClass = null;
                     boolean useSingleMethodAdapter = false;
 
                     if (junit.framework.TestCase.class.isAssignableFrom(testClass)) {
                         // Do not use JUnit 4 API for running JUnit 3.x
                         // tests - it is not able to run individual test
                         // methods.
                         //
                         // Technical details:
                         // org.junit.runner.Request.method(Class, String).getRunner()
                         // would return a runner which always executes all
                         // test methods. The reason is that the Runner would be
                         // an instance of class
                         // org.junit.internal.runners.OldTestClassRunner
                         // that does not implement interface Filterable - so it
                         // is unable to filter out test methods not matching
                         // the requested name.
                     } else {
                     // Check for JDK 5 first. Will *not* help on JDK 1.4
                     // if only junit-4.0.jar in CP because in that case
                     // linkage of whole task will already have failed! But
                     // will help if CP has junit-3.8.2.jar:junit-4.0.jar.
 
                     // In that case first C.fN will fail with CNFE and we
                     // will avoid UnsupportedClassVersionError.
 
                     try {
                         Class.forName("java.lang.annotation.Annotation");
                         if (loader == null) {
                             junit4TestAdapterClass =
                                 Class.forName(JUNIT_4_TEST_ADAPTER);
                             if (testMethodsSpecified) {
                                 /*
                                  * We cannot try to load the JUnit4TestAdapter
                                  * before trying to load JUnit4TestMethodAdapter
                                  * because it might fail with
                                  * NoClassDefFoundException, instead of plain
                                  * ClassNotFoundException.
                                  */
                                 junit4TestAdapterClass = Class.forName(
                                     "org.apache.tools.ant.taskdefs.optional.junit.JUnit4TestMethodAdapter");
                                 useSingleMethodAdapter = true;
                             }
                         } else {
                             junit4TestAdapterClass =
                                 Class.forName(JUNIT_4_TEST_ADAPTER,
                                               true, loader);
                             if (testMethodsSpecified) {
                                 junit4TestAdapterClass =
                                     Class.forName(
                                         "org.apache.tools.ant.taskdefs.optional.junit.JUnit4TestMethodAdapter",
                                         true, loader);
                                 useSingleMethodAdapter = true;
                             }
                         }
                     } catch (ClassNotFoundException e) {
                         // OK, fall back to JUnit 3.
                     }
                     }
                     junit4 = junit4TestAdapterClass != null;
 
                     if (junit4) {
                         // Let's use it!
                         Class[] formalParams;
                         Object[] actualParams;
                         if (useSingleMethodAdapter) {
                             formalParams = new Class[] {Class.class, String[].class};
                             actualParams = new Object[] {testClass, methods};
                         } else {
                             formalParams = new Class[] {Class.class};
                             actualParams = new Object[] {testClass};
                         }
                         suite =
                             (Test) junit4TestAdapterClass
                             .getConstructor(formalParams).
                             newInstance(actualParams);
                     } else {
                         // Use JUnit 3.
 
                         // try to extract a test suite automatically this
                         // will generate warnings if the class is no
                         // suitable Test
                         if (!testMethodsSpecified) {
                             suite = new TestSuite(testClass);
                         } else if (methods.length == 1) {
                             suite = TestSuite.createTest(testClass, methods[0]);
                         } else {
                             TestSuite testSuite = new TestSuite(testClass.getName());
                             for (int i = 0; i < methods.length; i++) {
                                 testSuite.addTest(
                                     TestSuite.createTest(testClass, methods[i]));
                             }
                             suite = testSuite;
                         }
                     }
 
                 }
 
             } catch (Throwable e) {
                 retCode = ERRORS;
                 exception = e;
             }
 
             long start = System.currentTimeMillis();
 
             fireStartTestSuite();
             startTestSuiteSuccess = true;
             if (exception != null) { // had an exception constructing suite
                 final int formatterSize = formatters.size();
                 for (int i = 0; i < formatterSize; i++) {
                     ((TestListener) formatters.elementAt(i))
                         .addError(null, exception);
                 }
                 junitTest.setCounts(1, 0, 1);
                 junitTest.setRunTime(0);
             } else {
                 try {
                     logTestListenerEvent("tests to run: " + suite.countTestCases());
                     suite.run(res);
                 } finally {
                     if (junit4 ||
                         suite.getClass().getName().equals(JUNIT_4_TEST_ADAPTER)) {
                         int[] cnts = findJUnit4FailureErrorCount(res);
                         junitTest.setCounts(res.runCount(), cnts[0], cnts[1]);
                     } else {
                         junitTest.setCounts(res.runCount(), res.failureCount(),
                                 res.errorCount());
                     }
                     junitTest.setRunTime(System.currentTimeMillis() - start);
                 }
             }
         } finally {
             if (perm != null) {
                 perm.restoreSecurityManager();
             }
             if (savedOut != null) {
                 System.setOut(savedOut);
             }
             if (savedErr != null) {
                 System.setErr(savedErr);
             }
 
             systemError.close();
             systemError = null;
             systemOut.close();
             systemOut = null;
             if (startTestSuiteSuccess) {
                 sendOutAndErr(new String(outStrm.toByteArray()),
                               new String(errStrm.toByteArray()));
             }
         }
         fireEndTestSuite();
 
         // junitTest has the correct counts for JUnit4, while res doesn't
         if (retCode != SUCCESS || junitTest.errorCount() != 0) {
             retCode = ERRORS;
         } else if (junitTest.failureCount() != 0) {
             retCode = FAILURES;
         }
     }
 
     /**
      * Returns what System.exit() would return in the standalone version.
      *
      * @return 2 if errors occurred, 1 if tests failed else 0.
      */
     public int getRetCode() {
         return retCode;
     }
 
     /**
      * Interface TestListener.
      *
      * <p>A new Test is started.
      * @param t the test.
      */
     public void startTest(Test t) {
         String testName = JUnitVersionHelper.getTestCaseName(t);
         logTestListenerEvent("startTest(" + testName + ")");
     }
 
     /**
      * Interface TestListener.
      *
      * <p>A Test is finished.
      * @param test the test.
      */
     public void endTest(Test test) {
         String testName = JUnitVersionHelper.getTestCaseName(test);
         logTestListenerEvent("endTest(" + testName + ")");
     }
 
     private void logTestListenerEvent(String msg) {
         if (logTestListenerEvents) {
             PrintStream out = savedOut != null ? savedOut : System.out;
             out.flush();
             if (msg == null) {
                 msg = "null";
             }
             StringTokenizer msgLines = new StringTokenizer(msg, "\r\n", false);
             while (msgLines.hasMoreTokens()) {
                 out.println(JUnitTask.TESTLISTENER_PREFIX
                             + msgLines.nextToken());
             }
             out.flush();
         }
     }
 
     /**
      * Interface TestListener for JUnit &lt;= 3.4.
      *
      * <p>A Test failed.
      * @param test the test.
      * @param t    the exception thrown by the test.
      */
     public void addFailure(Test test, Throwable t) {
         String testName = JUnitVersionHelper.getTestCaseName(test);
         logTestListenerEvent("addFailure(" + testName + ", " + t.getMessage() + ")");
         if (haltOnFailure) {
             res.stop();
         }
     }
 
     /**
      * Interface TestListener for JUnit &gt; 3.4.
      *
      * <p>A Test failed.
      * @param test the test.
      * @param t    the assertion thrown by the test.
      */
     public void addFailure(Test test, AssertionFailedError t) {
         addFailure(test, (Throwable) t);
     }
 
     /**
      * Interface TestListener.
      *
      * <p>An error occurred while running the test.
      * @param test the test.
      * @param t    the error thrown by the test.
      */
     public void addError(Test test, Throwable t) {
         String testName = JUnitVersionHelper.getTestCaseName(test);
         logTestListenerEvent("addError(" + testName + ", " + t.getMessage() + ")");
         if (haltOnError) {
             res.stop();
         }
     }
 
     /**
      * Permissions for the test run.
      * @since Ant 1.6
      * @param permissions the permissions to use.
      */
     public void setPermissions(Permissions permissions) {
         perm = permissions;
     }
 
     /**
      * Handle a string destined for standard output.
      * @param output the string to output
      */
     public void handleOutput(String output) {
         if (!logTestListenerEvents && output.startsWith(JUnitTask.TESTLISTENER_PREFIX)) {
             // ignore
         } else if (systemOut != null) {
             systemOut.print(output);
         }
     }
 
     /**
      * Handle input.
      * @param buffer not used.
      * @param offset not used.
      * @param length not used.
      * @return -1 always.
      * @throws IOException never.
      * @see org.apache.tools.ant.Task#handleInput(byte[], int, int)
      *
      * @since Ant 1.6
      */
     public int handleInput(byte[] buffer, int offset, int length)
         throws IOException {
         return -1;
     }
 
     /** {@inheritDoc}. */
     public void handleErrorOutput(String output) {
         if (systemError != null) {
             systemError.print(output);
         }
     }
 
     /** {@inheritDoc}. */
     public void handleFlush(String output) {
         if (systemOut != null) {
             systemOut.print(output);
         }
     }
 
     /** {@inheritDoc}. */
     public void handleErrorFlush(String output) {
         if (systemError != null) {
             systemError.print(output);
         }
     }
 
     private void sendOutAndErr(String out, String err) {
         final int size = formatters.size();
         for (int i = 0; i < size; i++) {
             JUnitResultFormatter formatter =
                 ((JUnitResultFormatter) formatters.elementAt(i));
 
             formatter.setSystemOutput(out);
             formatter.setSystemError(err);
         }
     }
 
     private void fireStartTestSuite() {
         final int size = formatters.size();
         for (int i = 0; i < size; i++) {
             ((JUnitResultFormatter) formatters.elementAt(i))
                 .startTestSuite(junitTest);
         }
     }
 
     private void fireEndTestSuite() {
         final int size = formatters.size();
         for (int i = 0; i < size; i++) {
             ((JUnitResultFormatter) formatters.elementAt(i))
                 .endTestSuite(junitTest);
         }
     }
 
     /**
      * Add a formatter.
      * @param f the formatter to add.
      */
     public void addFormatter(JUnitResultFormatter f) {
         formatters.addElement(f);
     }
 
     /** {@inheritDoc}. */
     public void addFormatter(JUnitTaskMirror.JUnitResultFormatterMirror f) {
         formatters.addElement(f);
     }
 
     /**
      * Entry point for standalone (forked) mode.
      *
      * Parameters: testcaseclassname plus parameters in the format
      * key=value, none of which is required.
      *
      * <table cols="4" border="1">
      * <tr><th>key</th><th>description</th><th>default value</th></tr>
      *
      * <tr><td>haltOnError</td><td>halt test on
      * errors?</td><td>false</td></tr>
      *
      * <tr><td>haltOnFailure</td><td>halt test on
      * failures?</td><td>false</td></tr>
      *
      * <tr><td>formatter</td><td>A JUnitResultFormatter given as
-     * classname,filename. If filename is ommitted, System.out is
+     * classname,filename. If filename is omitted, System.out is
      * assumed.</td><td>none</td></tr>
      *
      * <tr><td>showoutput</td><td>send output to System.err/.out as
      * well as to the formatters?</td><td>false</td></tr>
      *
      * <tr><td>logtestlistenerevents</td><td>log TestListener events to
      * System.out.</td><td>false</td></tr>
      *
      * <tr><td>methods</td><td>Comma-separated list of names of individual
      * test methods to execute.
      * </td><td>null</td></tr>
      *
      * </table>
      * @param args the command line arguments.
      * @throws IOException on error.
      */
     public static void main(String[] args) throws IOException {
         String[] methods = null;
         boolean haltError = false;
         boolean haltFail = false;
         boolean stackfilter = true;
         Properties props = new Properties();
         boolean showOut = false;
         boolean outputToFormat = true;
         boolean logFailedTests = true;
         boolean logTestListenerEvents = false;
 
 
         if (args.length == 0) {
             System.err.println("required argument TestClassName missing");
             System.exit(ERRORS);
         }
 
         if (args[0].startsWith(Constants.TESTSFILE)) {
             multipleTests = true;
             args[0] = args[0].substring(Constants.TESTSFILE.length());
         }
 
         for (int i = 1; i < args.length; i++) {
             if (args[i].startsWith(Constants.METHOD_NAMES)) {
                 try {
                     String methodsList = args[i].substring(Constants.METHOD_NAMES.length());
                     methods = JUnitTest.parseTestMethodNamesList(methodsList);
                 } catch (IllegalArgumentException ex) {
                     System.err.println("Invalid specification of test method names: " + args[i]);
                     System.exit(ERRORS);
                 }
             } else if (args[i].startsWith(Constants.HALT_ON_ERROR)) {
                 haltError = Project.toBoolean(args[i].substring(Constants.HALT_ON_ERROR.length()));
             } else if (args[i].startsWith(Constants.HALT_ON_FAILURE)) {
                 haltFail = Project.toBoolean(args[i].substring(Constants.HALT_ON_FAILURE.length()));
             } else if (args[i].startsWith(Constants.FILTERTRACE)) {
                 stackfilter = Project.toBoolean(args[i].substring(Constants.FILTERTRACE.length()));
             } else if (args[i].startsWith(Constants.CRASHFILE)) {
                 crashFile = args[i].substring(Constants.CRASHFILE.length());
                 registerTestCase(Constants.BEFORE_FIRST_TEST);
             } else if (args[i].startsWith(Constants.FORMATTER)) {
                 try {
                     createAndStoreFormatter(args[i].substring(Constants.FORMATTER.length()));
                 } catch (BuildException be) {
                     System.err.println(be.getMessage());
                     System.exit(ERRORS);
                 }
             } else if (args[i].startsWith(Constants.PROPSFILE)) {
                 FileInputStream in = new FileInputStream(args[i]
                                                          .substring(Constants.PROPSFILE.length()));
                 props.load(in);
                 in.close();
             } else if (args[i].startsWith(Constants.SHOWOUTPUT)) {
                 showOut = Project.toBoolean(args[i].substring(Constants.SHOWOUTPUT.length()));
             } else if (args[i].startsWith(Constants.LOGTESTLISTENEREVENTS)) {
                 logTestListenerEvents = Project.toBoolean(
                     args[i].substring(Constants.LOGTESTLISTENEREVENTS.length()));
             } else if (args[i].startsWith(Constants.OUTPUT_TO_FORMATTERS)) {
                 outputToFormat = Project.toBoolean(
                     args[i].substring(Constants.OUTPUT_TO_FORMATTERS.length()));
             } else if (args[i].startsWith(Constants.LOG_FAILED_TESTS)) {
                 logFailedTests = Project.toBoolean(
                     args[i].substring(Constants.LOG_FAILED_TESTS.length()));
             }
         }
 
         // Add/overlay system properties on the properties from the Ant project
         Hashtable p = System.getProperties();
         for (Enumeration e = p.keys(); e.hasMoreElements();) {
             Object key = e.nextElement();
             props.put(key, p.get(key));
         }
 
         int returnCode = SUCCESS;
         if (multipleTests) {
             try {
                 java.io.BufferedReader reader =
                     new java.io.BufferedReader(new java.io.FileReader(args[0]));
                 String testCaseName;
                 String[] testMethodNames;
                 int code = 0;
                 boolean errorOccurred = false;
                 boolean failureOccurred = false;
                 String line = null;
                 while ((line = reader.readLine()) != null) {
                     StringTokenizer st = new StringTokenizer(line, ",");
                     String testListSpec = st.nextToken();
                     int colonIndex = testListSpec.indexOf(':');
                     if (colonIndex == -1) {
                         testCaseName = testListSpec;
                         testMethodNames = null;
                     } else {
                         testCaseName = testListSpec.substring(0, colonIndex);
                         testMethodNames = JUnitTest.parseTestMethodNamesList(
                                                     testListSpec
                                                     .substring(colonIndex + 1)
                                                     .replace('+', ','));
                     }
                     JUnitTest t = new JUnitTest(testCaseName);
                     t.setTodir(new File(st.nextToken()));
                     t.setOutfile(st.nextToken());
                     t.setProperties(props);
                     code = launch(t, testMethodNames, haltError, stackfilter, haltFail,
                                   showOut, outputToFormat,
                                   logTestListenerEvents);
                     errorOccurred = (code == ERRORS);
                     failureOccurred = (code != SUCCESS);
                     if (errorOccurred || failureOccurred) {
                         if ((errorOccurred && haltError)
                             || (failureOccurred && haltFail)) {
                             registerNonCrash();
                             System.exit(code);
                         } else {
                             if (code > returnCode) {
                                 returnCode = code;
                             }
                             if (logFailedTests) {
                                 System.out.println("TEST " + t.getName()
                                                    + " FAILED");
                             }
                         }
                     }
                 }
             } catch (IOException e) {
                 e.printStackTrace();
             }
         } else {
             JUnitTest t = new JUnitTest(args[0]);
             t.setProperties(props);
             returnCode = launch(
                 t, methods, haltError, stackfilter, haltFail,
                 showOut, outputToFormat, logTestListenerEvents);
         }
 
         registerNonCrash();
         System.exit(returnCode);
     }
 
     private static Vector fromCmdLine = new Vector();
 
     private static void transferFormatters(JUnitTestRunner runner,
                                            JUnitTest test) {
         runner.addFormatter(new JUnitResultFormatter() {
 
             public void startTestSuite(JUnitTest suite) throws BuildException {
             }
 
             public void endTestSuite(JUnitTest suite) throws BuildException {
             }
 
             public void setOutput(OutputStream out) {
             }
 
             public void setSystemOutput(String out) {
             }
 
             public void setSystemError(String err) {
             }
 
             public void addError(Test arg0, Throwable arg1) {
             }
 
             public void addFailure(Test arg0, AssertionFailedError arg1) {
             }
 
             public void endTest(Test arg0) {
             }
 
             public void startTest(Test arg0) {
                 registerTestCase(JUnitVersionHelper.getTestCaseName(arg0));
             }
         });
         final int size = fromCmdLine.size();
         for (int i = 0; i < size; i++) {
             FormatterElement fe = (FormatterElement) fromCmdLine.elementAt(i);
             if (multipleTests && fe.getUseFile()) {
                 File destFile =
                     new File(test.getTodir(),
                              test.getOutfile() + fe.getExtension());
                 fe.setOutfile(destFile);
             }
             runner.addFormatter((JUnitResultFormatter) fe.createFormatter());
         }
     }
 
     /**
      * Line format is: formatter=<classname>(,<pathname>)?
      */
     private static void createAndStoreFormatter(String line)
         throws BuildException {
         FormatterElement fe = new FormatterElement();
         int pos = line.indexOf(',');
         if (pos == -1) {
             fe.setClassname(line);
             fe.setUseFile(false);
         } else {
             fe.setClassname(line.substring(0, pos));
             fe.setUseFile(true);
             if (!multipleTests) {
                 fe.setOutfile(new File(line.substring(pos + 1)));
             } else {
                 int fName = line.indexOf(IGNORED_FILE_NAME);
                 if (fName > -1) {
                     fe.setExtension(line
                                     .substring(fName
                                                + IGNORED_FILE_NAME.length()));
                 }
             }
         }
         fromCmdLine.addElement(fe);
     }
 
     /**
      * Returns a filtered stack trace.
      * This is ripped out of junit.runner.BaseTestRunner.
      * @param t the exception to filter.
      * @return the filtered stack trace.
      */
     public static String getFilteredTrace(Throwable t) {
         String trace = StringUtils.getStackTrace(t);
         return JUnitTestRunner.filterStack(trace);
     }
 
     /**
      * Filters stack frames from internal JUnit and Ant classes
      * @param stack the stack trace to filter.
      * @return the filtered stack.
      */
     public static String filterStack(String stack) {
         if (!filtertrace) {
             return stack;
         }
         StringWriter sw = new StringWriter();
         BufferedWriter pw = new BufferedWriter(sw);
         StringReader sr = new StringReader(stack);
         BufferedReader br = new BufferedReader(sr);
 
         String line;
         try {
             boolean firstLine = true;
             while ((line = br.readLine()) != null) {
                 if (firstLine || !filterLine(line)) {
                     pw.write(line);
                     pw.newLine();
                 }
                 firstLine = false;
             }
         } catch (Exception e) {
             return stack; // return the stack unfiltered
         } finally {
             FileUtils.close(pw);
         }
         return sw.toString();
     }
 
     private static boolean filterLine(String line) {
         for (int i = 0; i < DEFAULT_TRACE_FILTERS.length; i++) {
             if (line.indexOf(DEFAULT_TRACE_FILTERS[i]) != -1) {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * @since Ant 1.6.2
      */
     private static int launch(JUnitTest t, String[] methods, boolean haltError,
                               boolean stackfilter, boolean haltFail,
                               boolean showOut, boolean outputToFormat,
                               boolean logTestListenerEvents) {
         JUnitTestRunner runner =
             new JUnitTestRunner(t, methods, haltError, stackfilter, haltFail, showOut,
                                 logTestListenerEvents, null);
         runner.forked = true;
         runner.outputToFormatters = outputToFormat;
         transferFormatters(runner, t);
 
         runner.run();
         return runner.getRetCode();
      }
 
     /**
      * @since Ant 1.7
      */
     private static void registerNonCrash()
             throws IOException {
         if (crashFile != null) {
             FileWriter out = null;
             try {
                 out = new FileWriter(crashFile);
                 out.write(Constants.TERMINATED_SUCCESSFULLY + "\n");
                 out.flush();
             } finally {
                 FileUtils.close(out);
             }
         }
     }
 
     private static void registerTestCase(String testCase) {
         if (crashFile != null) {
             try {
                 FileWriter out = null;
                 try {
                     out = new FileWriter(crashFile);
                     out.write(testCase + "\n");
                     out.flush();
                 } finally {
                     FileUtils.close(out);
                 }
             } catch (IOException e) {
                 // ignored.
             }
         }
     }
 
     /**
      * Modifies a TestListener when running JUnit 4: treats AssertionFailedError
      * as a failure not an error.
      *
      * @since Ant 1.7
      */
     private TestListener wrapListener(final TestListener testListener) {
         return new TestListener() {
             public void addError(Test test, Throwable t) {
                 if (junit4 && t instanceof AssertionFailedError) {
                     // JUnit 4 does not distinguish between errors and failures
                     // even in the JUnit 3 adapter.
                     // So we need to help it a bit to retain compatibility for JUnit 3 tests.
                     testListener.addFailure(test, (AssertionFailedError) t);
                 } else if (junit4 && t instanceof  AssertionError) {
                     // Not strictly necessary but probably desirable.
                     // JUnit 4-specific test GUIs will show just "failures".
                     // But Ant's output shows "failures" vs. "errors".
                     // We would prefer to show "failure" for things that logically are.
                     String msg = t.getMessage();
                     AssertionFailedError failure = msg != null
                         ? new AssertionFailedError(msg) : new AssertionFailedError();
                     failure.setStackTrace(t.getStackTrace());
                     testListener.addFailure(test, failure);
                 } else {
                     testListener.addError(test, t);
                 }
             }
             public void addFailure(Test test, AssertionFailedError t) {
                 testListener.addFailure(test, t);
             }
             public void addFailure(Test test, Throwable t) { // pre-3.4
                 if (t instanceof AssertionFailedError) {
                     testListener.addFailure(test, (AssertionFailedError) t);
                 } else {
                     testListener.addError(test, t);
                 }
             }
             public void endTest(Test test) {
                 testListener.endTest(test);
             }
             public void startTest(Test test) {
                 testListener.startTest(test);
             }
         };
     }
 
     /**
      * Use instead of TestResult.get{Failure,Error}Count on JUnit 4,
      * since the adapter claims that all failures are errors.
      * @since Ant 1.7
      */
     private int[] findJUnit4FailureErrorCount(TestResult result) {
         int failures = 0;
         int errors = 0;
         Enumeration e = result.failures();
         while (e.hasMoreElements()) {
             e.nextElement();
             failures++;
         }
         e = result.errors();
         while (e.hasMoreElements()) {
             Throwable t = ((TestFailure) e.nextElement()).thrownException();
             if (t instanceof AssertionFailedError
                 || t instanceof AssertionError) {
                 failures++;
             } else {
                 errors++;
             }
         }
         return new int[] {failures, errors};
     }
 
 } // JUnitTestRunner
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/junit/XMLResultAggregator.java b/src/main/org/apache/tools/ant/taskdefs/optional/junit/XMLResultAggregator.java
index fd41e08c3..c9c07f62b 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/junit/XMLResultAggregator.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/junit/XMLResultAggregator.java
@@ -1,327 +1,327 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.junit;
 
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.util.Enumeration;
 import java.util.Vector;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.util.DOMElementWriter;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.StringUtils;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.xml.sax.SAXException;
 
 
 /**
  * Aggregates all &lt;junit&gt; XML formatter testsuite data under
  * a specific directory and transforms the results via XSLT.
- * It is not particulary clean but
+ * It is not particularly clean but
  * should be helpful while I am thinking about another technique.
  *
  * <p> The main problem is due to the fact that a JVM can be forked for a testcase
  * thus making it impossible to aggregate all testcases since the listener is
  * (obviously) in the forked JVM. A solution could be to write a
  * TestListener that will receive events from the TestRunner via sockets. This
  * is IMHO the simplest way to do it to avoid this file hacking thing.
  *
  * @ant.task name="junitreport" category="testing"
  */
 public class XMLResultAggregator extends Task implements XMLConstants {
 
     // CheckStyle:VisibilityModifier OFF - bc
     /** the list of all filesets, that should contains the xml to aggregate */
     protected Vector filesets = new Vector();
 
     /** the name of the result file */
     protected String toFile;
 
     /** the directory to write the file to */
     protected File toDir;
 
     protected Vector transformers = new Vector();
 
     /** The default directory: <tt>&#046;</tt>. It is resolved from the project directory */
     public static final String DEFAULT_DIR = ".";
 
     /** the default file name: <tt>TESTS-TestSuites.xml</tt> */
     public static final String DEFAULT_FILENAME = "TESTS-TestSuites.xml";
 
     /** the current generated id */
     protected int generatedId = 0;
 
     /**
      * text checked for in tests, {@value}
      */
     static final String WARNING_IS_POSSIBLY_CORRUPTED
         = " is not a valid XML document. It is possibly corrupted.";
     /**
      * text checked for in tests, {@value}
      */
     static final String WARNING_INVALID_ROOT_ELEMENT
         = " is not a valid testsuite XML document";
     /**
      * text checked for in tests, {@value}
      */
     static final String WARNING_EMPTY_FILE
         = " is empty.\nThis can be caused by the test JVM exiting unexpectedly";
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Generate a report based on the document created by the merge.
      * @return the report
      */
     public AggregateTransformer createReport() {
         AggregateTransformer transformer = new AggregateTransformer(this);
         transformers.addElement(transformer);
         return transformer;
     }
 
     /**
      * Set the name of the aggregegated results file. It must be relative
      * from the <tt>todir</tt> attribute. If not set it will use {@link #DEFAULT_FILENAME}
      * @param  value   the name of the file.
      * @see #setTodir(File)
      */
     public void setTofile(String value) {
         toFile = value;
     }
 
     /**
      * Set the destination directory where the results should be written. If not
      * set if will use {@link #DEFAULT_DIR}. When given a relative directory
      * it will resolve it from the project directory.
      * @param value    the directory where to write the results, absolute or
      * relative.
      */
     public void setTodir(File value) {
         toDir = value;
     }
 
     /**
      * Add a new fileset containing the XML results to aggregate
      * @param    fs      the new fileset of xml results.
      */
     public void addFileSet(FileSet fs) {
         filesets.addElement(fs);
     }
 
     /**
      * Aggregate all testsuites into a single document and write it to the
      * specified directory and file.
      * @throws  BuildException  thrown if there is a serious error while writing
      *          the document.
      */
     public void execute() throws BuildException {
         Element rootElement = createDocument();
         File destFile = getDestinationFile();
         // write the document
         try {
             writeDOMTree(rootElement.getOwnerDocument(), destFile);
         } catch (IOException e) {
             throw new BuildException("Unable to write test aggregate to '" + destFile + "'", e);
         }
         // apply transformation
         Enumeration e = transformers.elements();
         while (e.hasMoreElements()) {
             AggregateTransformer transformer =
                 (AggregateTransformer) e.nextElement();
             transformer.setXmlDocument(rootElement.getOwnerDocument());
             transformer.transform();
         }
     }
 
     /**
      * Get the full destination file where to write the result. It is made of
      * the <tt>todir</tt> and <tt>tofile</tt> attributes.
      * @return the destination file where should be written the result file.
      */
     public File getDestinationFile() {
         if (toFile == null) {
             toFile = DEFAULT_FILENAME;
         }
         if (toDir == null) {
             toDir = getProject().resolveFile(DEFAULT_DIR);
         }
         return new File(toDir, toFile);
     }
 
     /**
      * Get all <code>.xml</code> files in the fileset.
      *
      * @return all files in the fileset that end with a '.xml'.
      */
     protected File[] getFiles() {
         Vector v = new Vector();
         final int size = filesets.size();
         for (int i = 0; i < size; i++) {
             FileSet fs = (FileSet) filesets.elementAt(i);
             DirectoryScanner ds = fs.getDirectoryScanner(getProject());
             ds.scan();
             String[] f = ds.getIncludedFiles();
             for (int j = 0; j < f.length; j++) {
                 String pathname = f[j];
                 if (pathname.endsWith(".xml")) {
                     File file = new File(ds.getBasedir(), pathname);
                     file = getProject().resolveFile(file.getPath());
                     v.addElement(file);
                 }
             }
         }
 
         File[] files = new File[v.size()];
         v.copyInto(files);
         return files;
     }
 
     //----- from now, the methods are all related to DOM tree manipulation
 
     /**
      * Write the DOM tree to a file.
      * @param doc the XML document to dump to disk.
-     * @param file the filename to write the document to. Should obviouslly be a .xml file.
+     * @param file the filename to write the document to. Should obviously be a .xml file.
      * @throws IOException thrown if there is an error while writing the content.
      */
     protected void writeDOMTree(Document doc, File file) throws IOException {
         OutputStream os = new FileOutputStream(file);
         try {
             PrintWriter wri = new PrintWriter(new OutputStreamWriter(new BufferedOutputStream(os), "UTF8"));
             wri.write("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n");
             (new DOMElementWriter()).write(doc.getDocumentElement(), wri, 0, "  ");
             wri.flush();
             // writers do not throw exceptions, so check for them.
             if (wri.checkError()) {
                 throw new IOException("Error while writing DOM content");
             }
         } finally {
             os.close();
         }
     }
 
     /**
      * <p> Create a DOM tree.
      * Has 'testsuites' as firstchild and aggregates all
      * testsuite results that exists in the base directory.
      * @return  the root element of DOM tree that aggregates all testsuites.
      */
     protected Element createDocument() {
         // create the dom tree
         DocumentBuilder builder = getDocumentBuilder();
         Document doc = builder.newDocument();
         Element rootElement = doc.createElement(TESTSUITES);
         doc.appendChild(rootElement);
 
         generatedId = 0;
 
         // get all files and add them to the document
         File[] files = getFiles();
         for (int i = 0; i < files.length; i++) {
             File file = files[i];
             try {
                 log("Parsing file: '" + file + "'", Project.MSG_VERBOSE);
                 if (file.length() > 0) {
                     Document testsuiteDoc
                             = builder.parse(
                                 FileUtils.getFileUtils().toURI(files[i].getAbsolutePath()));
                     Element elem = testsuiteDoc.getDocumentElement();
                     // make sure that this is REALLY a testsuite.
                     if (TESTSUITE.equals(elem.getNodeName())) {
                         addTestSuite(rootElement, elem);
                         generatedId++;
                     } else {
                         //wrong root element name
                         // issue a warning.
                         log("the file " + file
                                 + WARNING_INVALID_ROOT_ELEMENT,
                                 Project.MSG_WARN);
                     }
                 } else {
                     log("the file " + file
                             + WARNING_EMPTY_FILE,
                             Project.MSG_WARN);
                 }
             } catch (SAXException e) {
                 // a testcase might have failed and write a zero-length document,
                 // It has already failed, but hey.... mm. just put a warning
                 log("The file " + file + WARNING_IS_POSSIBLY_CORRUPTED, Project.MSG_WARN);
                 log(StringUtils.getStackTrace(e), Project.MSG_DEBUG);
             } catch (IOException e) {
                 log("Error while accessing file " + file + ": "
                     + e.getMessage(), Project.MSG_ERR);
                 log("Error while accessing file " + file + ": "
                     + e.getMessage(), e, Project.MSG_VERBOSE);
             }
         }
         return rootElement;
     }
 
     /**
      * <p> Add a new testsuite node to the document.
      * The main difference is that it
      * split the previous fully qualified name into a package and a name.
      * <p> For example: <tt>org.apache.Whatever</tt> will be split into
      * <tt>org.apache</tt> and <tt>Whatever</tt>.
      * @param root the root element to which the <tt>testsuite</tt> node should
      *        be appended.
      * @param testsuite the element to append to the given root. It will slightly
      *        modify the original node to change the name attribute and add
      *        a package one.
      */
     protected void addTestSuite(Element root, Element testsuite) {
         String fullclassname = testsuite.getAttribute(ATTR_NAME);
         int pos = fullclassname.lastIndexOf('.');
 
         // a missing . might imply no package at all. Don't get fooled.
         String pkgName = (pos == -1) ? "" : fullclassname.substring(0, pos);
         String classname = (pos == -1) ? fullclassname : fullclassname.substring(pos + 1);
         Element copy = (Element) DOMUtil.importNode(root, testsuite);
 
         // modify the name attribute and set the package
         copy.setAttribute(ATTR_NAME, classname);
         copy.setAttribute(ATTR_PACKAGE, pkgName);
         copy.setAttribute(ATTR_ID, Integer.toString(generatedId));
     }
 
     /**
      * Create a new document builder. Will issue an <tt>ExceptionInitializerError</tt>
      * if something is going wrong. It is fatal anyway.
      * @todo factorize this somewhere else. It is duplicated code.
      * @return a new document builder to create a DOM
      */
     private static DocumentBuilder getDocumentBuilder() {
         try {
             return DocumentBuilderFactory.newInstance().newDocumentBuilder();
         } catch (Exception exc) {
             throw new ExceptionInInitializerError(exc);
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/net/FTP.java b/src/main/org/apache/tools/ant/taskdefs/optional/net/FTP.java
index ef20aa089..0b4bff001 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/net/FTP.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/net/FTP.java
@@ -705,2020 +705,2020 @@ public class FTP extends Task implements FTPTaskConfig {
          * @return array of FTPFile
          */
         public FTPFile[] listFiles(String directory) {
             return listFiles(directory, true);
         }
         private void checkRemoteSensitivity(FTPFile[] array, String directory) {
             if (array == null) {
                 return;
             }
             boolean candidateFound = false;
             String target = null;
             for (int icounter = 0; icounter < array.length; icounter++) {
                 if (array[icounter] != null && array[icounter].isDirectory()) {
                     if (!array[icounter].getName().equals(".")
                         && !array[icounter].getName().equals("..")) {
                         candidateFound = true;
                         target = fiddleName(array[icounter].getName());
                         getProject().log("will try to cd to "
                                          + target + " where a directory called " + array[icounter].getName()
                                          + " exists", Project.MSG_DEBUG);
                         for (int pcounter = 0; pcounter < array.length; pcounter++) {
                             if (array[pcounter] != null
                                 && pcounter != icounter
                                 && target.equals(array[pcounter].getName())) {
                                 candidateFound = false;
                             }
                         }
                         if (candidateFound) {
                             break;
                         }
                     }
                 }
             }
             if (candidateFound) {
                 try {
                     getProject().log("testing case sensitivity, attempting to cd to "
                                      + target, Project.MSG_DEBUG);
                     remoteSystemCaseSensitive  = !ftp.changeWorkingDirectory(target);
                 } catch (IOException ioe) {
                     remoteSystemCaseSensitive = true;
                 } finally {
                     try {
                         ftp.changeWorkingDirectory(directory);
                     } catch (IOException ioe) {
                         throw new BuildException(ioe, getLocation());
                     }
                 }
                 getProject().log("remote system is case sensitive : " + remoteSystemCaseSensitive,
                                  Project.MSG_VERBOSE);
                 remoteSensitivityChecked = true;
             }
         }
         private String fiddleName(String origin) {
             StringBuffer result = new StringBuffer();
             for (int icounter = 0; icounter < origin.length(); icounter++) {
                 if (Character.isLowerCase(origin.charAt(icounter))) {
                     result.append(Character.toUpperCase(origin.charAt(icounter)));
                 } else if (Character.isUpperCase(origin.charAt(icounter))) {
                     result.append(Character.toLowerCase(origin.charAt(icounter)));
                 } else {
                     result.append(origin.charAt(icounter));
                 }
             }
             return result.toString();
         }
         /**
          * an AntFTPFile is a representation of a remote file
          * @since Ant 1.6
          */
         protected class AntFTPFile {
             /**
              * ftp client
              */
             private FTPClient client;
             /**
              * parent directory of the file
              */
             private String curpwd;
             /**
              * the file itself
              */
             private FTPFile ftpFile;
             /**
              *
              */
             private AntFTPFile parent = null;
             private boolean relativePathCalculated = false;
             private boolean traversesSymlinks = false;
             private String relativePath = "";
             /**
              * constructor
              * @param client ftp client variable
              * @param ftpFile the file
              * @param curpwd absolute remote path where the file is found
              */
             public AntFTPFile(FTPClient client, FTPFile ftpFile, String curpwd) {
                 this.client = client;
                 this.ftpFile = ftpFile;
                 this.curpwd = curpwd;
             }
             /**
              * other constructor
              * @param parent the parent file
              * @param path  a relative path to the parent file
              */
             public AntFTPFile(AntFTPFile parent, String path) {
                 this.parent = parent;
                 this.client = parent.client;
                 Vector pathElements = SelectorUtils.tokenizePath(path);
                 try {
                     boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());
                     //this should not happen, except if parent has been deleted by another process
                     if (!result) {
                         return;
                     }
                     this.curpwd = parent.getAbsolutePath();
                 } catch (IOException ioe) {
                     throw new BuildException("could not change working dir to "
                                              + parent.curpwd);
                 }
                 final int size = pathElements.size();
                 for (int fcount = 0; fcount < size - 1; fcount++) {
                     String currentPathElement = (String) pathElements.elementAt(fcount);
                     try {
                         boolean result = this.client.changeWorkingDirectory(currentPathElement);
                         if (!result && !isCaseSensitive()
                             && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) {
                             currentPathElement = findPathElementCaseUnsensitive(this.curpwd,
                                                                                 currentPathElement);
                             if (currentPathElement == null) {
                                 return;
                             }
                         } else if (!result) {
                             return;
                         }
                         this.curpwd = getCurpwdPlusFileSep()
                             + currentPathElement;
                     } catch (IOException ioe) {
                         throw new BuildException("could not change working dir to "
                                                  + (String) pathElements.elementAt(fcount)
                                                  + " from " + this.curpwd);
                     }
 
                 }
                 String lastpathelement = (String) pathElements.elementAt(size - 1);
                 FTPFile [] theFiles = listFiles(this.curpwd);
                 this.ftpFile = getFile(theFiles, lastpathelement);
             }
             /**
              * find a file in a directory in case unsensitive way
              * @param parentPath        where we are
              * @param soughtPathElement what is being sought
              * @return                  the first file found or null if not found
              */
             private String findPathElementCaseUnsensitive(String parentPath,
                                                           String soughtPathElement) {
                 // we are already in the right path, so the second parameter
                 // is false
                 FTPFile[] theFiles = listFiles(parentPath, false);
                 if (theFiles == null) {
                     return null;
                 }
                 for (int icounter = 0; icounter < theFiles.length; icounter++) {
                     if (theFiles[icounter] != null
                         && theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) {
                         return theFiles[icounter].getName();
                     }
                 }
                 return null;
             }
             /**
              * find out if the file exists
              * @return  true if the file exists
              */
             public boolean exists() {
                 return (ftpFile != null);
             }
             /**
              * if the file is a symbolic link, find out to what it is pointing
              * @return the target of the symbolic link
              */
             public String getLink() {
                 return ftpFile.getLink();
             }
             /**
              * get the name of the file
              * @return the name of the file
              */
             public String getName() {
                 return ftpFile.getName();
             }
             /**
              * find out the absolute path of the file
              * @return absolute path as string
              */
             public String getAbsolutePath() {
                 return getCurpwdPlusFileSep() + ftpFile.getName();
             }
             /**
              * find out the relative path assuming that the path used to construct
              * this AntFTPFile was spelled properly with regards to case.
              * This is OK on a case sensitive system such as UNIX
              * @return relative path
              */
             public String getFastRelativePath() {
                 String absPath = getAbsolutePath();
                 if (absPath.indexOf(rootPath + remoteFileSep) == 0) {
                     return absPath.substring(rootPath.length() + remoteFileSep.length());
                 }
                 return null;
             }
             /**
              * find out the relative path to the rootPath of the enclosing scanner.
              * this relative path is spelled exactly like on disk,
              * for instance if the AntFTPFile has been instantiated as ALPHA,
              * but the file is really called alpha, this method will return alpha.
              * If a symbolic link is encountered, it is followed, but the name of the link
              * rather than the name of the target is returned.
              * (ie does not behave like File.getCanonicalPath())
              * @return                relative path, separated by remoteFileSep
              * @throws IOException    if a change directory fails, ...
              * @throws BuildException if one of the components of the relative path cannot
              * be found.
              */
             public String getRelativePath() throws IOException, BuildException {
                 if (!relativePathCalculated) {
                     if (parent != null) {
                         traversesSymlinks = parent.isTraverseSymlinks();
                         relativePath = getRelativePath(parent.getAbsolutePath(),
                                                        parent.getRelativePath());
                     } else {
                         relativePath = getRelativePath(rootPath, "");
                         relativePathCalculated = true;
                     }
                 }
                 return relativePath;
             }
             /**
              * get thge relative path of this file
              * @param currentPath          base path
              * @param currentRelativePath  relative path of the base path with regards to remote dir
              * @return relative path
              */
             private String getRelativePath(String currentPath, String currentRelativePath) {
                 Vector pathElements = SelectorUtils.tokenizePath(getAbsolutePath(), remoteFileSep);
                 Vector pathElements2 = SelectorUtils.tokenizePath(currentPath, remoteFileSep);
                 String relPath = currentRelativePath;
                 final int size = pathElements.size();
                 for (int pcount = pathElements2.size(); pcount < size; pcount++) {
                     String currentElement = (String) pathElements.elementAt(pcount);
                     FTPFile[] theFiles = listFiles(currentPath);
                     FTPFile theFile = null;
                     if (theFiles != null) {
                         theFile = getFile(theFiles, currentElement);
                     }
                     if (!relPath.equals("")) {
                         relPath = relPath + remoteFileSep;
                     }
                     if (theFile == null) {
                         // hit a hidden file assume not a symlink
                         relPath = relPath + currentElement;
                         currentPath = currentPath + remoteFileSep + currentElement;
                         log("Hidden file " + relPath
                             + " assumed to not be a symlink.",
                             Project.MSG_VERBOSE);
                     } else {
                         traversesSymlinks = traversesSymlinks || theFile.isSymbolicLink();
                         relPath = relPath + theFile.getName();
                         currentPath = currentPath + remoteFileSep + theFile.getName();
                     }
                 }
                 return relPath;
             }
             /**
              * find a file matching a string in an array of FTPFile.
              * This method will find "alpha" when requested for "ALPHA"
              * if and only if the caseSensitive attribute is set to false.
              * When caseSensitive is set to true, only the exact match is returned.
              * @param theFiles  array of files
              * @param lastpathelement  the file name being sought
              * @return null if the file cannot be found, otherwise return the matching file.
              */
             public FTPFile getFile(FTPFile[] theFiles, String lastpathelement) {
                 if (theFiles == null) {
                     return null;
                 }
                 for (int fcount = 0; fcount < theFiles.length; fcount++) {
                     if (theFiles[fcount] != null) {
                         if (theFiles[fcount].getName().equals(lastpathelement)) {
                             return theFiles[fcount];
                         } else if (!isCaseSensitive()
                                    && theFiles[fcount].getName().equalsIgnoreCase(
                                                                                   lastpathelement)) {
                             return theFiles[fcount];
                         }
                     }
                 }
                 return null;
             }
             /**
              * tell if a file is a directory.
              * note that it will return false for symbolic links pointing to directories.
              * @return <code>true</code> for directories
              */
             public boolean isDirectory() {
                 return ftpFile.isDirectory();
             }
             /**
              * tell if a file is a symbolic link
              * @return <code>true</code> for symbolic links
              */
             public boolean isSymbolicLink() {
                 return ftpFile.isSymbolicLink();
             }
             /**
              * return the attached FTP client object.
              * Warning : this instance is really shared with the enclosing class.
              * @return  FTP client
              */
             protected FTPClient getClient() {
                 return client;
             }
 
             /**
              * sets the current path of an AntFTPFile
              * @param curpwd the current path one wants to set
              */
             protected void setCurpwd(String curpwd) {
                 this.curpwd = curpwd;
             }
             /**
              * returns the path of the directory containing the AntFTPFile.
              * of the full path of the file itself in case of AntFTPRootFile
              * @return parent directory of the AntFTPFile
              */
             public String getCurpwd() {
                 return curpwd;
             }
             /**
              * returns the path of the directory containing the AntFTPFile.
              * of the full path of the file itself in case of AntFTPRootFile
              * and appends the remote file separator if necessary.
              * @return parent directory of the AntFTPFile
              * @since Ant 1.8.2
              */
             public String getCurpwdPlusFileSep() {
                 return curpwd.endsWith(remoteFileSep) ? curpwd
                     : curpwd + remoteFileSep;
             }
             /**
              * find out if a symbolic link is encountered in the relative path of this file
              * from rootPath.
              * @return <code>true</code> if a symbolic link is encountered in the relative path.
              * @throws IOException if one of the change directory or directory listing operations
              * fails
              * @throws BuildException if a path component in the relative path cannot be found.
              */
             public boolean isTraverseSymlinks() throws IOException, BuildException {
                 if (!relativePathCalculated) {
                     // getRelativePath also finds about symlinks
                     getRelativePath();
                 }
                 return traversesSymlinks;
             }
 
             /**
              * Get a string rep of this object.
              * @return a string containing the pwd and the file.
              */
             public String toString() {
                 return "AntFtpFile: " + curpwd + "%" + ftpFile;
             }
         }
         /**
          * special class to represent the remote directory itself
          * @since Ant 1.6
          */
         protected class AntFTPRootFile extends AntFTPFile {
             private String remotedir;
             /**
              * constructor
              * @param aclient FTP client
              * @param remotedir remote directory
              */
             public AntFTPRootFile(FTPClient aclient, String remotedir) {
                 super(aclient, null, remotedir);
                 this.remotedir = remotedir;
                 try {
                     this.getClient().changeWorkingDirectory(this.remotedir);
                     this.setCurpwd(this.getClient().printWorkingDirectory());
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, getLocation());
                 }
             }
             /**
              * find the absolute path
              * @return absolute path
              */
             public String getAbsolutePath() {
                 return this.getCurpwd();
             }
             /**
              * find out the relative path to root
              * @return empty string
              * @throws BuildException actually never
              * @throws IOException  actually never
              */
             public String getRelativePath() throws BuildException, IOException {
                 return "";
             }
         }
     }
     /**
      * check FTPFiles to check whether they function as directories too
      * the FTPFile API seem to make directory and symbolic links incompatible
      * we want to find out if we can cd to a symbolic link
      * @param dir  the parent directory of the file to test
      * @param file the file to test
      * @return true if it is possible to cd to this directory
      * @since ant 1.6
      */
     private boolean isFunctioningAsDirectory(FTPClient ftp, String dir, FTPFile file) {
         boolean result = false;
         String currentWorkingDir = null;
         if (file.isDirectory()) {
             return true;
         } else if (file.isFile()) {
             return false;
         }
         try {
             currentWorkingDir = ftp.printWorkingDirectory();
         } catch (IOException ioe) {
             getProject().log("could not find current working directory " + dir
                              + " while checking a symlink",
                              Project.MSG_DEBUG);
         }
         if (currentWorkingDir != null) {
             try {
                 result = ftp.changeWorkingDirectory(file.getLink());
             } catch (IOException ioe) {
                 getProject().log("could not cd to " + file.getLink() + " while checking a symlink",
                                  Project.MSG_DEBUG);
             }
             if (result) {
                 boolean comeback = false;
                 try {
                     comeback = ftp.changeWorkingDirectory(currentWorkingDir);
                 } catch (IOException ioe) {
                     getProject().log("could not cd back to " + dir + " while checking a symlink",
                                      Project.MSG_ERR);
                 } finally {
                     if (!comeback) {
                         throw new BuildException("could not cd back to " + dir
                                                  + " while checking a symlink");
                     }
                 }
             }
         }
         return result;
     }
     /**
      * check FTPFiles to check whether they function as directories too
      * the FTPFile API seem to make directory and symbolic links incompatible
      * we want to find out if we can cd to a symbolic link
      * @param dir  the parent directory of the file to test
      * @param file the file to test
      * @return true if it is possible to cd to this directory
      * @since ant 1.6
      */
     private boolean isFunctioningAsFile(FTPClient ftp, String dir, FTPFile file) {
         if (file.isDirectory()) {
             return false;
         } else if (file.isFile()) {
             return true;
         }
         return !isFunctioningAsDirectory(ftp, dir, file);
     }
     /**
      * Sets the remote directory where files will be placed. This may be a
      * relative or absolute path, and must be in the path syntax expected by
      * the remote server. No correction of path syntax will be performed.
      *
      * @param dir the remote directory name.
      */
     public void setRemotedir(String dir) {
         this.remotedir = dir;
     }
 
 
     /**
      * Sets the FTP server to send files to.
      *
      * @param server the remote server name.
      */
     public void setServer(String server) {
         this.server = server;
     }
 
 
     /**
      * Sets the FTP port used by the remote server.
      *
      * @param port the port on which the remote server is listening.
      */
     public void setPort(int port) {
         this.port = port;
     }
 
 
     /**
      * Sets the login user id to use on the specified server.
      *
      * @param userid remote system userid.
      */
     public void setUserid(String userid) {
         this.userid = userid;
     }
 
 
     /**
      * Sets the login password for the given user id.
      *
      * @param password the password on the remote system.
      */
     public void setPassword(String password) {
         this.password = password;
     }
 
     /**
      * Sets the login account to use on the specified server.
      *
      * @param pAccount the account name on remote system
      * @since Ant 1.7
      */
     public void setAccount(String pAccount) {
         this.account = pAccount;
     }
 
 
     /**
      * If true, uses binary mode, otherwise text mode (default is binary).
      *
      * @param binary if true use binary mode in transfers.
      */
     public void setBinary(boolean binary) {
         this.binary = binary;
     }
 
 
     /**
      * Specifies whether to use passive mode. Set to true if you are behind a
      * firewall and cannot connect without it. Passive mode is disabled by
      * default.
      *
      * @param passive true is passive mode should be used.
      */
     public void setPassive(boolean passive) {
         this.passive = passive;
     }
 
 
     /**
      * Set to true to receive notification about each file as it is
      * transferred.
      *
      * @param verbose true if verbose notifications are required.
      */
     public void setVerbose(boolean verbose) {
         this.verbose = verbose;
     }
 
 
     /**
      * A synonym for <tt>depends</tt>. Set to true to transmit only new
      * or changed files.
      *
      * See the related attributes timediffmillis and timediffauto.
      *
      * @param newer if true only transfer newer files.
      */
     public void setNewer(boolean newer) {
         this.newerOnly = newer;
     }
 
     /**
      * number of milliseconds to add to the time on the remote machine
      * to get the time on the local machine.
      *
      * use in conjunction with <code>newer</code>
      *
      * @param timeDiffMillis number of milliseconds
      *
      * @since ant 1.6
      */
     public void setTimeDiffMillis(long timeDiffMillis) {
         this.timeDiffMillis = timeDiffMillis;
     }
 
     /**
      * &quot;true&quot; to find out automatically the time difference
      * between local and remote machine.
      *
      * This requires right to create
      * and delete a temporary file in the remote directory.
      *
      * @param timeDiffAuto true = find automatically the time diff
      *
      * @since ant 1.6
      */
     public void setTimeDiffAuto(boolean timeDiffAuto) {
         this.timeDiffAuto = timeDiffAuto;
     }
 
     /**
      * Set to true to preserve modification times for "gotten" files.
      *
      * @param preserveLastModified if true preserver modification times.
      */
     public void setPreserveLastModified(boolean preserveLastModified) {
         this.preserveLastModified = preserveLastModified;
     }
 
 
     /**
      * Set to true to transmit only files that are new or changed from their
      * remote counterparts. The default is to transmit all files.
      *
      * @param depends if true only transfer newer files.
      */
     public void setDepends(boolean depends) {
         this.newerOnly = depends;
     }
 
 
     /**
      * Sets the remote file separator character. This normally defaults to the
      * Unix standard forward slash, but can be manually overridden using this
      * call if the remote server requires some other separator. Only the first
      * character of the string is used.
      *
      * @param separator the file separator on the remote system.
      */
     public void setSeparator(String separator) {
         remoteFileSep = separator;
     }
 
 
     /**
      * Sets the file permission mode (Unix only) for files sent to the
      * server.
      *
      * @param theMode unix style file mode for the files sent to the remote
      *        system.
      */
     public void setChmod(String theMode) {
         this.chmod = theMode;
     }
 
 
     /**
      * Sets the default mask for file creation on a unix server.
      *
      * @param theUmask unix style umask for files created on the remote server.
      */
     public void setUmask(String theUmask) {
         this.umask = theUmask;
     }
 
 
     /**
      *  A set of files to upload or download
      *
      * @param set the set of files to be added to the list of files to be
      *        transferred.
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
 
     /**
      * Sets the FTP action to be taken. Currently accepts "put", "get", "del",
      * "mkdir", "chmod", "list", and "site".
      *
      * @deprecated since 1.5.x.
      *             setAction(String) is deprecated and is replaced with
      *      setAction(FTP.Action) to make Ant's Introspection mechanism do the
      *      work and also to encapsulate operations on the type in its own
      *      class.
      * @ant.attribute ignore="true"
      *
      * @param action the FTP action to be performed.
      *
      * @throws BuildException if the action is not a valid action.
      */
     public void setAction(String action) throws BuildException {
         log("DEPRECATED - The setAction(String) method has been deprecated."
             + " Use setAction(FTP.Action) instead.");
 
         Action a = new Action();
 
         a.setValue(action);
         this.action = a.getAction();
     }
 
 
     /**
      * Sets the FTP action to be taken. Currently accepts "put", "get", "del",
      * "mkdir", "chmod", "list", and "site".
      *
      * @param action the FTP action to be performed.
      *
      * @throws BuildException if the action is not a valid action.
      */
     public void setAction(Action action) throws BuildException {
         this.action = action.getAction();
     }
 
 
     /**
      * The output file for the "list" action. This attribute is ignored for
      * any other actions.
      *
      * @param listing file in which to store the listing.
      */
     public void setListing(File listing) {
         this.listing = listing;
     }
 
 
     /**
      * If true, enables unsuccessful file put, delete and get
      * operations to be skipped with a warning and the remainder
      * of the files still transferred.
      *
      * @param skipFailedTransfers true if failures in transfers are ignored.
      */
     public void setSkipFailedTransfers(boolean skipFailedTransfers) {
         this.skipFailedTransfers = skipFailedTransfers;
     }
 
 
     /**
      * set the flag to skip errors on directory creation.
      * (and maybe later other server specific errors)
      *
      * @param ignoreNoncriticalErrors true if non-critical errors should not
      *        cause a failure.
      */
     public void setIgnoreNoncriticalErrors(boolean ignoreNoncriticalErrors) {
         this.ignoreNoncriticalErrors = ignoreNoncriticalErrors;
     }
 
     private void configurationHasBeenSet() {
         this.isConfigurationSet = true;
     }
 
     /**
      * Sets the systemTypeKey attribute.
      * Method for setting <code>FTPClientConfig</code> remote system key.
      *
      * @param systemKey the key to be set - BUT if blank
      * the default value of null (which signifies "autodetect") will be kept.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setSystemTypeKey(FTPSystemType systemKey) {
         if (systemKey != null && !systemKey.getValue().equals("")) {
             this.systemTypeKey = systemKey;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the defaultDateFormatConfig attribute.
      * @param defaultDateFormat configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setDefaultDateFormatConfig(String defaultDateFormat) {
         if (defaultDateFormat != null && !defaultDateFormat.equals("")) {
             this.defaultDateFormatConfig = defaultDateFormat;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the recentDateFormatConfig attribute.
      * @param recentDateFormat configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setRecentDateFormatConfig(String recentDateFormat) {
         if (recentDateFormat != null && !recentDateFormat.equals("")) {
             this.recentDateFormatConfig = recentDateFormat;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the serverLanguageCode attribute.
      * @param serverLanguageCode configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setServerLanguageCodeConfig(LanguageCode serverLanguageCode) {
         if (serverLanguageCode != null && !"".equals(serverLanguageCode.getValue())) {
             this.serverLanguageCodeConfig = serverLanguageCode;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the serverTimeZoneConfig attribute.
      * @param serverTimeZoneId configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setServerTimeZoneConfig(String serverTimeZoneId) {
         if (serverTimeZoneId != null && !serverTimeZoneId.equals("")) {
             this.serverTimeZoneConfig = serverTimeZoneId;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the shortMonthNamesConfig attribute
      *
      * @param shortMonthNames configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setShortMonthNamesConfig(String shortMonthNames) {
         if (shortMonthNames != null && !shortMonthNames.equals("")) {
             this.shortMonthNamesConfig = shortMonthNames;
             configurationHasBeenSet();
         }
     }
 
 
 
     /**
      * Defines how many times to retry executing FTP command before giving up.
      * Default is 0 - try once and if failure then give up.
      *
      * @param retriesAllowed number of retries to allow.  -1 means
      * keep trying forever. "forever" may also be specified as a
      * synonym for -1.
      */
     public void setRetriesAllowed(String retriesAllowed) {
         if ("FOREVER".equalsIgnoreCase(retriesAllowed)) {
             this.retriesAllowed = Retryable.RETRY_FOREVER;
         } else {
             try {
                 int retries = Integer.parseInt(retriesAllowed);
                 if (retries < Retryable.RETRY_FOREVER) {
                     throw new BuildException(
                                              "Invalid value for retriesAllowed attribute: "
                                              + retriesAllowed);
 
                 }
                 this.retriesAllowed = retries;
             } catch (NumberFormatException px) {
                 throw new BuildException(
                                          "Invalid value for retriesAllowed attribute: "
                                          + retriesAllowed);
 
             }
 
         }
     }
     /**
      * @return Returns the systemTypeKey.
      */
     public String getSystemTypeKey() {
         return systemTypeKey.getValue();
     }
     /**
      * @return Returns the defaultDateFormatConfig.
      */
     public String getDefaultDateFormatConfig() {
         return defaultDateFormatConfig;
     }
     /**
      * @return Returns the recentDateFormatConfig.
      */
     public String getRecentDateFormatConfig() {
         return recentDateFormatConfig;
     }
     /**
      * @return Returns the serverLanguageCodeConfig.
      */
     public String getServerLanguageCodeConfig() {
         return serverLanguageCodeConfig.getValue();
     }
     /**
      * @return Returns the serverTimeZoneConfig.
      */
     public String getServerTimeZoneConfig() {
         return serverTimeZoneConfig;
     }
     /**
      * @return Returns the shortMonthNamesConfig.
      */
     public String getShortMonthNamesConfig() {
         return shortMonthNamesConfig;
     }
     /**
      * @return Returns the timestampGranularity.
      */
     Granularity getTimestampGranularity() {
         return timestampGranularity;
     }
     /**
      * Sets the timestampGranularity attribute
      * @param timestampGranularity The timestampGranularity to set.
      */
     public void setTimestampGranularity(Granularity timestampGranularity) {
         if (null == timestampGranularity || "".equals(timestampGranularity.getValue())) {
             return;
         }
         this.timestampGranularity = timestampGranularity;
     }
     /**
      * Sets the siteCommand attribute.  This attribute
      * names the command that will be executed if the action
      * is "site".
      * @param siteCommand The siteCommand to set.
      */
     public void setSiteCommand(String siteCommand) {
         this.siteCommand = siteCommand;
     }
     /**
      * Sets the initialSiteCommand attribute.  This attribute
      * names a site command that will be executed immediately
      * after connection.
      * @param initialCommand The initialSiteCommand to set.
      */
     public void setInitialSiteCommand(String initialCommand) {
         this.initialSiteCommand = initialCommand;
     }
 
     /**
      * Whether to verify that data and control connections are
      * connected to the same remote host.
      *
      * @since Ant 1.8.0
      */
     public void setEnableRemoteVerification(boolean b) {
         enableRemoteVerification = b;
     }
 
     /**
      * Checks to see that all required parameters are set.
      *
      * @throws BuildException if the configuration is not valid.
      */
     protected void checkAttributes() throws BuildException {
         if (server == null) {
             throw new BuildException("server attribute must be set!");
         }
         if (userid == null) {
             throw new BuildException("userid attribute must be set!");
         }
         if (password == null) {
             throw new BuildException("password attribute must be set!");
         }
 
         if ((action == LIST_FILES) && (listing == null)) {
             throw new BuildException("listing attribute must be set for list "
                                      + "action!");
         }
 
         if (action == MK_DIR && remotedir == null) {
             throw new BuildException("remotedir attribute must be set for "
                                      + "mkdir action!");
         }
 
         if (action == CHMOD && chmod == null) {
             throw new BuildException("chmod attribute must be set for chmod "
                                      + "action!");
         }
         if (action == SITE_CMD && siteCommand == null) {
             throw new BuildException("sitecommand attribute must be set for site "
                                      + "action!");
         }
 
 
         if (this.isConfigurationSet) {
             try {
                 Class.forName("org.apache.commons.net.ftp.FTPClientConfig");
             } catch (ClassNotFoundException e) {
                 throw new BuildException(
                                          "commons-net.jar >= 1.4.0 is required for at least one"
                                          + " of the attributes specified.");
             }
         }
     }
 
     /**
      * Executable a retryable object.
-     * @param h the retry hander.
+     * @param h the retry handler.
      * @param r the object that should be retried until it succeeds
      *          or the number of retrys is reached.
      * @param descr a description of the command that is being run.
      * @throws IOException if there is a problem.
      */
     protected void executeRetryable(RetryHandler h, Retryable r, String descr)
         throws IOException {
         h.execute(r, descr);
     }
 
 
     /**
      * For each file in the fileset, do the appropriate action: send, get,
      * delete, or list.
      *
      * @param ftp the FTPClient instance used to perform FTP actions
      * @param fs the fileset on which the actions are performed.
      *
      * @return the number of files to be transferred.
      *
      * @throws IOException if there is a problem reading a file
      * @throws BuildException if there is a problem in the configuration.
      */
     protected int transferFiles(final FTPClient ftp, FileSet fs)
         throws IOException, BuildException {
         DirectoryScanner ds;
         if (action == SEND_FILES) {
             ds = fs.getDirectoryScanner(getProject());
         } else {
             ds = new FTPDirectoryScanner(ftp);
             fs.setupDirectoryScanner(ds, getProject());
             ds.setFollowSymlinks(fs.isFollowSymlinks());
             ds.scan();
         }
 
         String[] dsfiles = null;
         if (action == RM_DIR) {
             dsfiles = ds.getIncludedDirectories();
         } else {
             dsfiles = ds.getIncludedFiles();
         }
         String dir = null;
 
         if ((ds.getBasedir() == null)
             && ((action == SEND_FILES) || (action == GET_FILES))) {
             throw new BuildException("the dir attribute must be set for send "
                                      + "and get actions");
         } else {
             if ((action == SEND_FILES) || (action == GET_FILES)) {
                 dir = ds.getBasedir().getAbsolutePath();
             }
         }
 
         // If we are doing a listing, we need the output stream created now.
         BufferedWriter bw = null;
 
         try {
             if (action == LIST_FILES) {
                 File pd = listing.getParentFile();
 
                 if (!pd.exists()) {
                     pd.mkdirs();
                 }
                 bw = new BufferedWriter(new FileWriter(listing));
             }
             RetryHandler h = new RetryHandler(this.retriesAllowed, this);
             if (action == RM_DIR) {
                 // to remove directories, start by the end of the list
                 // the trunk does not let itself be removed before the leaves
                 for (int i = dsfiles.length - 1; i >= 0; i--) {
                     final String dsfile = dsfiles[i];
                     executeRetryable(h, new Retryable() {
                             public void execute() throws IOException {
                                 rmDir(ftp, dsfile);
                             }
                         }, dsfile);
                 }
             } else {
                 final BufferedWriter fbw = bw;
                 final String fdir = dir;
                 if (this.newerOnly) {
                     this.granularityMillis =
                         this.timestampGranularity.getMilliseconds(action);
                 }
                 for (int i = 0; i < dsfiles.length; i++) {
                     final String dsfile = dsfiles[i];
                     executeRetryable(h, new Retryable() {
                             public void execute() throws IOException {
                                 switch (action) {
                                 case SEND_FILES:
                                     sendFile(ftp, fdir, dsfile);
                                     break;
                                 case GET_FILES:
                                     getFile(ftp, fdir, dsfile);
                                     break;
                                 case DEL_FILES:
                                     delFile(ftp, dsfile);
                                     break;
                                 case LIST_FILES:
                                     listFile(ftp, fbw, dsfile);
                                     break;
                                 case CHMOD:
                                     doSiteCommand(ftp, "chmod " + chmod
                                                   + " " + resolveFile(dsfile));
                                     transferred++;
                                     break;
                                 default:
                                     throw new BuildException("unknown ftp action " + action);
                                 }
                             }
                         }, dsfile);
                 }
             }
         } finally {
             FileUtils.close(bw);
         }
 
         return dsfiles.length;
     }
 
 
     /**
      * Sends all files specified by the configured filesets to the remote
      * server.
      *
      * @param ftp the FTPClient instance used to perform FTP actions
      *
      * @throws IOException if there is a problem reading a file
      * @throws BuildException if there is a problem in the configuration.
      */
     protected void transferFiles(FTPClient ftp)
         throws IOException, BuildException {
         transferred = 0;
         skipped = 0;
 
         if (filesets.size() == 0) {
             throw new BuildException("at least one fileset must be specified.");
         } else {
             // get files from filesets
             final int size = filesets.size();
             for (int i = 0; i < size; i++) {
                 FileSet fs = (FileSet) filesets.elementAt(i);
 
                 if (fs != null) {
                     transferFiles(ftp, fs);
                 }
             }
         }
 
         log(transferred + " " + ACTION_TARGET_STRS[action] + " "
             + COMPLETED_ACTION_STRS[action]);
         if (skipped != 0) {
             log(skipped + " " + ACTION_TARGET_STRS[action]
                 + " were not successfully " + COMPLETED_ACTION_STRS[action]);
         }
     }
 
 
     /**
      * Correct a file path to correspond to the remote host requirements. This
      * implementation currently assumes that the remote end can handle
      * Unix-style paths with forward-slash separators. This can be overridden
      * with the <code>separator</code> task parameter. No attempt is made to
      * determine what syntax is appropriate for the remote host.
      *
      * @param file the remote file name to be resolved
      *
      * @return the filename as it will appear on the server.
      */
     protected String resolveFile(String file) {
         return file.replace(System.getProperty("file.separator").charAt(0),
                             remoteFileSep.charAt(0));
     }
 
 
     /**
      * Creates all parent directories specified in a complete relative
      * pathname. Attempts to create existing directories will not cause
      * errors.
      *
      * @param ftp the FTP client instance to use to execute FTP actions on
      *        the remote server.
      * @param filename the name of the file whose parents should be created.
      * @throws IOException under non documented circumstances
      * @throws BuildException if it is impossible to cd to a remote directory
      *
      */
     protected void createParents(FTPClient ftp, String filename)
         throws IOException, BuildException {
 
         File dir = new File(filename);
         if (dirCache.contains(dir)) {
             return;
         }
 
         Vector parents = new Vector();
         String dirname;
 
         while ((dirname = dir.getParent()) != null) {
             File checkDir = new File(dirname);
             if (dirCache.contains(checkDir)) {
                 break;
             }
             dir = checkDir;
             parents.addElement(dir);
         }
 
         // find first non cached dir
         int i = parents.size() - 1;
 
         if (i >= 0) {
             String cwd = ftp.printWorkingDirectory();
             String parent = dir.getParent();
             if (parent != null) {
                 if (!ftp.changeWorkingDirectory(resolveFile(parent))) {
                     throw new BuildException("could not change to "
                                              + "directory: " + ftp.getReplyString());
                 }
             }
 
             while (i >= 0) {
                 dir = (File) parents.elementAt(i--);
                 // check if dir exists by trying to change into it.
                 if (!ftp.changeWorkingDirectory(dir.getName())) {
                     // could not change to it - try to create it
                     log("creating remote directory "
                         + resolveFile(dir.getPath()), Project.MSG_VERBOSE);
                     if (!ftp.makeDirectory(dir.getName())) {
                         handleMkDirFailure(ftp);
                     }
                     if (!ftp.changeWorkingDirectory(dir.getName())) {
                         throw new BuildException("could not change to "
                                                  + "directory: " + ftp.getReplyString());
                     }
                 }
                 dirCache.add(dir);
             }
             ftp.changeWorkingDirectory(cwd);
         }
     }
     /**
      * auto find the time difference between local and remote
      * @param ftp handle to ftp client
      * @return number of millis to add to remote time to make it comparable to local time
      * @since ant 1.6
      */
     private long getTimeDiff(FTPClient ftp) {
         long returnValue = 0;
         File tempFile = findFileName(ftp);
         try {
             // create a local temporary file
             FILE_UTILS.createNewFile(tempFile);
             long localTimeStamp = tempFile.lastModified();
             BufferedInputStream instream = new BufferedInputStream(new FileInputStream(tempFile));
             ftp.storeFile(tempFile.getName(), instream);
             instream.close();
             boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
             if (success) {
                 FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName());
                 if (ftpFiles.length == 1) {
                     long remoteTimeStamp = ftpFiles[0].getTimestamp().getTime().getTime();
                     returnValue = localTimeStamp - remoteTimeStamp;
                 }
                 ftp.deleteFile(ftpFiles[0].getName());
             }
             // delegate the deletion of the local temp file to the delete task
             // because of race conditions occuring on Windows
             Delete mydelete = new Delete();
             mydelete.bindToOwner(this);
             mydelete.setFile(tempFile.getCanonicalFile());
             mydelete.execute();
         } catch (Exception e) {
             throw new BuildException(e, getLocation());
         }
         return returnValue;
     }
     /**
      *  find a suitable name for local and remote temporary file
      */
     private File findFileName(FTPClient ftp) {
         FTPFile [] theFiles = null;
         final int maxIterations = 1000;
         for (int counter = 1; counter < maxIterations; counter++) {
             File localFile = FILE_UTILS.createTempFile(
                                                        "ant" + Integer.toString(counter), ".tmp",
                                                        null, false, false);
             String fileName = localFile.getName();
             boolean found = false;
             try {
                 if (theFiles == null) {
                     theFiles = ftp.listFiles();
                 }
                 for (int counter2 = 0; counter2 < theFiles.length; counter2++) {
                     if (theFiles[counter2] != null
                         && theFiles[counter2].getName().equals(fileName)) {
                         found = true;
                         break;
                     }
                 }
             } catch (IOException ioe) {
                 throw new BuildException(ioe, getLocation());
             }
             if (!found) {
                 localFile.deleteOnExit();
                 return localFile;
             }
         }
         return null;
     }
 
     /**
      * Checks to see if the remote file is current as compared with the local
      * file. Returns true if the target file is up to date.
      * @param ftp ftpclient
      * @param localFile local file
      * @param remoteFile remote file
      * @return true if the target file is up to date
      * @throws IOException  in unknown circumstances
      * @throws BuildException if the date of the remote files cannot be found and the action is
      * GET_FILES
      */
     protected boolean isUpToDate(FTPClient ftp, File localFile,
                                  String remoteFile)
         throws IOException, BuildException {
         log("checking date for " + remoteFile, Project.MSG_VERBOSE);
 
         FTPFile[] files = ftp.listFiles(remoteFile);
 
         // For Microsoft's Ftp-Service an Array with length 0 is
         // returned if configured to return listings in "MS-DOS"-Format
         if (files == null || files.length == 0) {
             // If we are sending files, then assume out of date.
             // If we are getting files, then throw an error
 
             if (action == SEND_FILES) {
                 log("Could not date test remote file: " + remoteFile
                     + "assuming out of date.", Project.MSG_VERBOSE);
                 return false;
             } else {
                 throw new BuildException("could not date test remote file: "
                                          + ftp.getReplyString());
             }
         }
 
         long remoteTimestamp = files[0].getTimestamp().getTime().getTime();
         long localTimestamp = localFile.lastModified();
         long adjustedRemoteTimestamp =
             remoteTimestamp + this.timeDiffMillis + this.granularityMillis;
 
         StringBuffer msg;
         synchronized(TIMESTAMP_LOGGING_SDF) {
             msg = new StringBuffer("   [")
                 .append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp)))
                 .append("] local");
         }
         log(msg.toString(), Project.MSG_VERBOSE);
 
         synchronized(TIMESTAMP_LOGGING_SDF) {
             msg = new StringBuffer("   [")
                 .append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp)))
                 .append("] remote");
         }
         if (remoteTimestamp != adjustedRemoteTimestamp) {
             synchronized(TIMESTAMP_LOGGING_SDF) {
                 msg.append(" - (raw: ")
                     .append(TIMESTAMP_LOGGING_SDF.format(new Date(remoteTimestamp)))
                     .append(")");
             }
         }
         log(msg.toString(), Project.MSG_VERBOSE);
 
 
 
         if (this.action == SEND_FILES) {
             return adjustedRemoteTimestamp >= localTimestamp;
         } else {
             return localTimestamp >= adjustedRemoteTimestamp;
         }
     }
 
 
     /**
      * Sends a site command to the ftp server
      * @param ftp ftp client
      * @param theCMD command to execute
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void doSiteCommand(FTPClient ftp, String theCMD)
         throws IOException, BuildException {
         boolean rc;
         String[] myReply = null;
 
         log("Doing Site Command: " + theCMD, Project.MSG_VERBOSE);
 
         rc = ftp.sendSiteCommand(theCMD);
 
         if (!rc) {
             log("Failed to issue Site Command: " + theCMD, Project.MSG_WARN);
         } else {
 
             myReply = ftp.getReplyStrings();
 
             for (int x = 0; x < myReply.length; x++) {
                 if (myReply[x] != null && myReply[x].indexOf("200") == -1) {
                     log(myReply[x], Project.MSG_WARN);
                 }
             }
         }
     }
 
 
     /**
      * Sends a single file to the remote host. <code>filename</code> may
      * contain a relative path specification. When this is the case, <code>sendFile</code>
      * will attempt to create any necessary parent directories before sending
      * the file. The file will then be sent using the entire relative path
      * spec - no attempt is made to change directories. It is anticipated that
      * this may eventually cause problems with some FTP servers, but it
      * simplifies the coding.
      * @param ftp ftp client
      * @param dir base directory of the file to be sent (local)
      * @param filename relative path of the file to be send
      *        locally relative to dir
      *        remotely relative to the remotedir attribute
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void sendFile(FTPClient ftp, String dir, String filename)
         throws IOException, BuildException {
         InputStream instream = null;
 
         try {
             // XXX - why not simply new File(dir, filename)?
             File file = getProject().resolveFile(new File(dir, filename).getPath());
 
             if (newerOnly && isUpToDate(ftp, file, resolveFile(filename))) {
                 return;
             }
 
             if (verbose) {
                 log("transferring " + file.getAbsolutePath());
             }
 
             instream = new BufferedInputStream(new FileInputStream(file));
 
             createParents(ftp, filename);
 
             ftp.storeFile(resolveFile(filename), instream);
 
             boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
 
             if (!success) {
                 String s = "could not put file: " + ftp.getReplyString();
 
                 if (skipFailedTransfers) {
                     log(s, Project.MSG_WARN);
                     skipped++;
                 } else {
                     throw new BuildException(s);
                 }
 
             } else {
                 // see if we should issue a chmod command
                 if (chmod != null) {
                     doSiteCommand(ftp, "chmod " + chmod + " " + resolveFile(filename));
                 }
                 log("File " + file.getAbsolutePath() + " copied to " + server,
                     Project.MSG_VERBOSE);
                 transferred++;
             }
         } finally {
             FileUtils.close(instream);
         }
     }
 
 
     /**
      * Delete a file from the remote host.
      * @param ftp ftp client
      * @param filename file to delete
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is set to false
      * and the deletion could not be done
      */
     protected void delFile(FTPClient ftp, String filename)
         throws IOException, BuildException {
         if (verbose) {
             log("deleting " + filename);
         }
 
         if (!ftp.deleteFile(resolveFile(filename))) {
             String s = "could not delete file: " + ftp.getReplyString();
 
             if (skipFailedTransfers) {
                 log(s, Project.MSG_WARN);
                 skipped++;
             } else {
                 throw new BuildException(s);
             }
         } else {
             log("File " + filename + " deleted from " + server,
                 Project.MSG_VERBOSE);
             transferred++;
         }
     }
 
     /**
      * Delete a directory, if empty, from the remote host.
      * @param ftp ftp client
      * @param dirname directory to delete
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is set to false
      * and the deletion could not be done
      */
     protected void rmDir(FTPClient ftp, String dirname)
         throws IOException, BuildException {
         if (verbose) {
             log("removing " + dirname);
         }
 
         if (!ftp.removeDirectory(resolveFile(dirname))) {
             String s = "could not remove directory: " + ftp.getReplyString();
 
             if (skipFailedTransfers) {
                 log(s, Project.MSG_WARN);
                 skipped++;
             } else {
                 throw new BuildException(s);
             }
         } else {
             log("Directory " + dirname + " removed from " + server,
                 Project.MSG_VERBOSE);
             transferred++;
         }
     }
 
 
     /**
      * Retrieve a single file from the remote host. <code>filename</code> may
      * contain a relative path specification. <p>
      *
-     * The file will then be retreived using the entire relative path spec -
+     * The file will then be retrieved using the entire relative path spec -
      * no attempt is made to change directories. It is anticipated that this
      * may eventually cause problems with some FTP servers, but it simplifies
      * the coding.</p>
      * @param ftp the ftp client
      * @param dir local base directory to which the file should go back
      * @param filename relative path of the file based upon the ftp remote directory
      *        and/or the local base directory (dir)
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is false
      * and the file cannot be retrieved.
      */
     protected void getFile(FTPClient ftp, String dir, String filename)
         throws IOException, BuildException {
         OutputStream outstream = null;
         try {
             File file = getProject().resolveFile(new File(dir, filename).getPath());
 
             if (newerOnly && isUpToDate(ftp, file, resolveFile(filename))) {
                 return;
             }
 
             if (verbose) {
                 log("transferring " + filename + " to "
                     + file.getAbsolutePath());
             }
 
             File pdir = file.getParentFile();
 
             if (!pdir.exists()) {
                 pdir.mkdirs();
             }
             outstream = new BufferedOutputStream(new FileOutputStream(file));
             ftp.retrieveFile(resolveFile(filename), outstream);
 
             if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                 String s = "could not get file: " + ftp.getReplyString();
 
                 if (skipFailedTransfers) {
                     log(s, Project.MSG_WARN);
                     skipped++;
                 } else {
                     throw new BuildException(s);
                 }
 
             } else {
                 log("File " + file.getAbsolutePath() + " copied from "
                     + server, Project.MSG_VERBOSE);
                 transferred++;
                 if (preserveLastModified) {
                     outstream.close();
                     outstream = null;
                     FTPFile[] remote = ftp.listFiles(resolveFile(filename));
                     if (remote.length > 0) {
                         FILE_UTILS.setFileLastModified(file,
                                                        remote[0].getTimestamp()
                                                        .getTime().getTime());
                     }
                 }
             }
         } finally {
             FileUtils.close(outstream);
         }
     }
 
 
     /**
      * List information about a single file from the remote host. <code>filename</code>
      * may contain a relative path specification. <p>
      *
      * The file listing will then be retrieved using the entire relative path
      * spec - no attempt is made to change directories. It is anticipated that
      * this may eventually cause problems with some FTP servers, but it
      * simplifies the coding.</p>
      * @param ftp ftp client
      * @param bw buffered writer
      * @param filename the directory one wants to list
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void listFile(FTPClient ftp, BufferedWriter bw, String filename)
         throws IOException, BuildException {
         if (verbose) {
             log("listing " + filename);
         }
         FTPFile[] ftpfiles = ftp.listFiles(resolveFile(filename));
 
         if (ftpfiles != null && ftpfiles.length > 0) {
             bw.write(ftpfiles[0].toString());
             bw.newLine();
             transferred++;
         }
     }
 
 
     /**
      * Create the specified directory on the remote host.
      *
      * @param ftp The FTP client connection
      * @param dir The directory to create (format must be correct for host
      *      type)
      * @throws IOException  in unknown circumstances
      * @throws BuildException if ignoreNoncriticalErrors has not been set to true
      *         and a directory could not be created, for instance because it was
      *         already existing. Precisely, the codes 521, 550 and 553 will trigger
      *         a BuildException
      */
     protected void makeRemoteDir(FTPClient ftp, String dir)
         throws IOException, BuildException {
         String workingDirectory = ftp.printWorkingDirectory();
         if (verbose) {
             if (dir.indexOf("/") == 0 || workingDirectory == null) {
                 log("Creating directory: " + dir + " in /");
             } else {
                 log("Creating directory: " + dir + " in " + workingDirectory);
             }
         }
         if (dir.indexOf("/") == 0) {
             ftp.changeWorkingDirectory("/");
         }
         String subdir = "";
         StringTokenizer st = new StringTokenizer(dir, "/");
         while (st.hasMoreTokens()) {
             subdir = st.nextToken();
             log("Checking " + subdir, Project.MSG_DEBUG);
             if (!ftp.changeWorkingDirectory(subdir)) {
                 if (!ftp.makeDirectory(subdir)) {
                     // codes 521, 550 and 553 can be produced by FTP Servers
                     //  to indicate that an attempt to create a directory has
                     //  failed because the directory already exists.
                     int rc = ftp.getReplyCode();
                     if (!(ignoreNoncriticalErrors
                           && (rc == CODE_550 || rc == CODE_553
                               || rc == CODE_521))) {
                         throw new BuildException("could not create directory: "
                                                  + ftp.getReplyString());
                     }
                     if (verbose) {
                         log("Directory already exists");
                     }
                 } else {
                     if (verbose) {
                         log("Directory created OK");
                     }
                     ftp.changeWorkingDirectory(subdir);
                 }
             }
         }
         if (workingDirectory != null) {
             ftp.changeWorkingDirectory(workingDirectory);
         }
     }
 
     /**
      * look at the response for a failed mkdir action, decide whether
      * it matters or not. If it does, we throw an exception
      * @param ftp current ftp connection
      * @throws BuildException if this is an error to signal
      */
     private void handleMkDirFailure(FTPClient ftp)
         throws BuildException {
         int rc = ftp.getReplyCode();
         if (!(ignoreNoncriticalErrors
               && (rc == CODE_550 || rc == CODE_553 || rc == CODE_521))) {
             throw new BuildException("could not create directory: "
                                      + ftp.getReplyString());
         }
     }
 
     /**
      * Runs the task.
      *
      * @throws BuildException if the task fails or is not configured
      *         correctly.
      */
     public void execute() throws BuildException {
         checkAttributes();
 
         FTPClient ftp = null;
 
         try {
             log("Opening FTP connection to " + server, Project.MSG_VERBOSE);
 
             ftp = new FTPClient();
             if (this.isConfigurationSet) {
                 ftp = FTPConfigurator.configure(ftp, this);
             }
 
             ftp.setRemoteVerificationEnabled(enableRemoteVerification);
             ftp.connect(server, port);
             if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                 throw new BuildException("FTP connection failed: "
                                          + ftp.getReplyString());
             }
 
             log("connected", Project.MSG_VERBOSE);
             log("logging in to FTP server", Project.MSG_VERBOSE);
 
             if ((this.account != null && !ftp.login(userid, password, account))
                 || (this.account == null && !ftp.login(userid, password))) {
                 throw new BuildException("Could not login to FTP server");
             }
 
             log("login succeeded", Project.MSG_VERBOSE);
 
             if (binary) {
                 ftp.setFileType(org.apache.commons.net.ftp.FTP.BINARY_FILE_TYPE);
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not set transfer type: "
                                              + ftp.getReplyString());
                 }
             } else {
                 ftp.setFileType(org.apache.commons.net.ftp.FTP.ASCII_FILE_TYPE);
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not set transfer type: "
                                              + ftp.getReplyString());
                 }
             }
 
             if (passive) {
                 log("entering passive mode", Project.MSG_VERBOSE);
                 ftp.enterLocalPassiveMode();
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not enter into passive "
                                              + "mode: " + ftp.getReplyString());
                 }
             }
 
             // If an initial command was configured then send it.
             // Some FTP servers offer different modes of operation,
             // E.G. switching between a UNIX file system mode and
             // a legacy file system.
             if (this.initialSiteCommand != null) {
                 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, FTP.this.initialSiteCommand);
                         }
                     }, "initial site command: " + this.initialSiteCommand);
             }
 
 
             // For a unix ftp server you can set the default mask for all files
             // created.
 
             if (umask != null) {
                 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, "umask " + umask);
                         }
                     }, "umask " + umask);
             }
 
             // If the action is MK_DIR, then the specified remote
             // directory is the directory to create.
 
             if (action == MK_DIR) {
                 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             makeRemoteDir(lftp, remotedir);
                         }
                     }, remotedir);
             } else if (action == SITE_CMD) {
                 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, FTP.this.siteCommand);
                         }
                     }, "Site Command: " + this.siteCommand);
             } else {
                 if (remotedir != null) {
                     log("changing the remote directory to " + remotedir,
                         Project.MSG_VERBOSE);
                     ftp.changeWorkingDirectory(remotedir);
                     if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                         throw new BuildException("could not change remote "
                                                  + "directory: " + ftp.getReplyString());
                     }
                 }
                 if (newerOnly && timeDiffAuto) {
                     // in this case we want to find how much time span there is between local
                     // and remote
                     timeDiffMillis = getTimeDiff(ftp);
                 }
                 log(ACTION_STRS[action] + " " + ACTION_TARGET_STRS[action]);
                 transferFiles(ftp);
             }
 
         } catch (IOException ex) {
             throw new BuildException("error during FTP transfer: " + ex, ex);
         } finally {
             if (ftp != null && ftp.isConnected()) {
                 try {
                     log("disconnecting", Project.MSG_VERBOSE);
                     ftp.logout();
                     ftp.disconnect();
                 } catch (IOException ex) {
                     // ignore it
                 }
             }
         }
     }
 
 
     /**
      * an action to perform, one of
      * "send", "put", "recv", "get", "del", "delete", "list", "mkdir", "chmod",
      * "rmdir"
      */
     public static class Action extends EnumeratedAttribute {
 
         private static final String[] VALID_ACTIONS = {
             "send", "put", "recv", "get", "del", "delete", "list", "mkdir",
             "chmod", "rmdir", "site"
         };
 
 
         /**
          * Get the valid values
          *
          * @return an array of the valid FTP actions.
          */
         public String[] getValues() {
             return VALID_ACTIONS;
         }
 
 
         /**
          * Get the symbolic equivalent of the action value.
          *
          * @return the SYMBOL representing the given action.
          */
         public int getAction() {
             String actionL = getValue().toLowerCase(Locale.ENGLISH);
             if (actionL.equals("send") || actionL.equals("put")) {
                 return SEND_FILES;
             } else if (actionL.equals("recv") || actionL.equals("get")) {
                 return GET_FILES;
             } else if (actionL.equals("del") || actionL.equals("delete")) {
                 return DEL_FILES;
             } else if (actionL.equals("list")) {
                 return LIST_FILES;
             } else if (actionL.equals("chmod")) {
                 return CHMOD;
             } else if (actionL.equals("mkdir")) {
                 return MK_DIR;
             } else if (actionL.equals("rmdir")) {
                 return RM_DIR;
             } else if (actionL.equals("site")) {
                 return SITE_CMD;
             }
             return SEND_FILES;
         }
     }
     /**
      * represents one of the valid timestamp adjustment values
      * recognized by the <code>timestampGranularity</code> attribute.<p>
 
      * A timestamp adjustment may be used in file transfers for checking
      * uptodateness. MINUTE means to add one minute to the server
      * timestamp.  This is done because FTP servers typically list
      * timestamps HH:mm and client FileSystems typically use HH:mm:ss.
      *
      * The default is to use MINUTE for PUT actions and NONE for GET
      * actions, since GETs have the <code>preserveLastModified</code>
      * option, which takes care of the problem in most use cases where
      * this level of granularity is an issue.
      *
      */
     public static class Granularity extends EnumeratedAttribute {
 
         private static final String[] VALID_GRANULARITIES = {
             "", "MINUTE", "NONE"
         };
 
         /**
          * Get the valid values.
          * @return the list of valid Granularity values
          */
         public String[] getValues() {
             return VALID_GRANULARITIES;
         }
         /**
          * returns the number of milliseconds associated with
          * the attribute, which can vary in some cases depending
          * on the value of the action parameter.
          * @param action SEND_FILES or GET_FILES
          * @return the number of milliseconds associated with
          * the attribute, in the context of the supplied action
          */
         public long getMilliseconds(int action) {
             String granularityU = getValue().toUpperCase(Locale.ENGLISH);
             if ("".equals(granularityU)) {
                 if (action == SEND_FILES) {
                     return GRANULARITY_MINUTE;
                 }
             } else if ("MINUTE".equals(granularityU)) {
                 return GRANULARITY_MINUTE;
             }
             return 0L;
         }
         static final Granularity getDefault() {
             Granularity g = new Granularity();
             g.setValue("");
             return g;
         }
 
     }
     /**
      * one of the valid system type keys recognized by the systemTypeKey
      * attribute.
      */
     public static class FTPSystemType extends EnumeratedAttribute {
 
         private static final String[] VALID_SYSTEM_TYPES = {
             "", "UNIX", "VMS", "WINDOWS", "OS/2", "OS/400",
             "MVS"
         };
 
 
         /**
          * Get the valid values.
          * @return the list of valid system types.
          */
         public String[] getValues() {
             return VALID_SYSTEM_TYPES;
         }
 
         static final FTPSystemType getDefault() {
             FTPSystemType ftpst = new FTPSystemType();
             ftpst.setValue("");
             return ftpst;
         }
     }
     /**
      * Enumerated class for languages.
      */
     public static class LanguageCode extends EnumeratedAttribute {
 
 
         private static final String[] VALID_LANGUAGE_CODES =
             getValidLanguageCodes();
 
         private static String[] getValidLanguageCodes() {
             Collection c = FTPClientConfig.getSupportedLanguageCodes();
             String[] ret = new String[c.size() + 1];
             int i = 0;
             ret[i++] = "";
             for (Iterator it = c.iterator(); it.hasNext(); i++) {
                 ret[i] = (String) it.next();
             }
             return ret;
         }
 
 
         /**
          * Return the value values.
          * @return the list of valid language types.
          */
         public String[] getValues() {
             return VALID_LANGUAGE_CODES;
         }
 
         static final LanguageCode getDefault() {
             LanguageCode lc = new LanguageCode();
             lc.setValue("");
             return lc;
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/net/FTPTaskMirrorImpl.java b/src/main/org/apache/tools/ant/taskdefs/optional/net/FTPTaskMirrorImpl.java
index dd5daf63d..c8fd88975 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/net/FTPTaskMirrorImpl.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/net/FTPTaskMirrorImpl.java
@@ -91,1860 +91,1860 @@ public class FTPTaskMirrorImpl implements FTPTaskMirror {
 
         /**
          * creates a proxy to a FTP file
          * @param file
          */
         public FTPFileProxy(FTPFile file) {
             super(file.getName());
             name = file.getName();
             this.file = file;
             parts = FileUtils.getPathStack(name);
         }
 
         /**
          * creates a proxy to a FTP directory
          * @param completePath the remote directory.
          */
         public FTPFileProxy(String completePath) {
             super(completePath);
             file = null;
             name = completePath;
             parts = FileUtils.getPathStack(completePath);
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#exists()
          */
         public boolean exists() {
             return true;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getAbsolutePath()
          */
         public String getAbsolutePath() {
             return name;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getName()
          */
         public String getName() {
             return parts.length > 0 ? parts[parts.length - 1] : name;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getParent()
          */
         public String getParent() {
             String result = "";
             for(int i = 0; i < parts.length - 1; i++){
                 result += File.separatorChar + parts[i];
             }
             return result;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getPath()
          */
         public String getPath() {
             return name;
         }
 
 
         /**
          * FTP files are stored as absolute paths
          * @return true
          */
         public boolean isAbsolute() {
             return true;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#isDirectory()
          */
         public boolean isDirectory() {
             return file == null;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#isFile()
          */
         public boolean isFile() {
             return file != null;
         }
 
 
         /**
          * FTP files cannot be hidden
          *
          * @return  false
          */
         public boolean isHidden() {
             return false;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#lastModified()
          */
         public long lastModified() {
             if (file != null) {
                 return file.getTimestamp().getTimeInMillis();
             }
             return 0;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#length()
          */
         public long length() {
             if (file != null) {
                 return file.getSize();
             }
             return 0;
         }
     }
 
     /**
      * internal class allowing to read the contents of a remote file system
      * using the FTP protocol
      * used in particular for ftp get operations
      * differences with DirectoryScanner
      * "" (the root of the fileset) is never included in the included directories
      * followSymlinks defaults to false
      */
     protected class FTPDirectoryScanner extends DirectoryScanner {
         // CheckStyle:VisibilityModifier OFF - bc
         protected FTPClient ftp = null;
         // CheckStyle:VisibilityModifier ON
 
         private String rootPath = null;
 
         /**
          * since ant 1.6
          * this flag should be set to true on UNIX and can save scanning time
          */
         private boolean remoteSystemCaseSensitive = false;
         private boolean remoteSensitivityChecked = false;
 
         /**
          * constructor
          * @param ftp  ftpclient object
          */
         public FTPDirectoryScanner(FTPClient ftp) {
             super();
             this.ftp = ftp;
             this.setFollowSymlinks(false);
         }
 
 
         /**
          * scans the remote directory,
          * storing internally the included files, directories, ...
          */
         public void scan() {
             if (includes == null) {
                 // No includes supplied, so set it to 'matches all'
                 includes = new String[1];
                 includes[0] = "**";
             }
             if (excludes == null) {
                 excludes = new String[0];
             }
 
             filesIncluded = new VectorSet();
             filesNotIncluded = new Vector();
             filesExcluded = new VectorSet();
             dirsIncluded = new VectorSet();
             dirsNotIncluded = new Vector();
             dirsExcluded = new VectorSet();
 
             try {
                 String cwd = ftp.printWorkingDirectory();
                 // always start from the current ftp working dir
                 forceRemoteSensitivityCheck();
 
                 checkIncludePatterns();
                 clearCaches();
                 ftp.changeWorkingDirectory(cwd);
             } catch (IOException e) {
                 throw new BuildException("Unable to scan FTP server: ", e);
             }
         }
 
 
         /**
          * this routine is actually checking all the include patterns in
          * order to avoid scanning everything under base dir
          * @since ant1.6
          */
         private void checkIncludePatterns() {
 
             Hashtable newroots = new Hashtable();
             // put in the newroots vector the include patterns without
             // wildcard tokens
             for (int icounter = 0; icounter < includes.length; icounter++) {
                 String newpattern =
                     SelectorUtils.rtrimWildcardTokens(includes[icounter]);
                 newroots.put(newpattern, includes[icounter]);
             }
             if (task.getRemotedir() == null) {
                 try {
                     task.setRemotedir(ftp.printWorkingDirectory());
                 } catch (IOException e) {
                     throw new BuildException("could not read current ftp directory",
                                              task.getLocation());
                 }
             }
             AntFTPFile baseFTPFile = new AntFTPRootFile(ftp, task.getRemotedir());
             rootPath = baseFTPFile.getAbsolutePath();
             // construct it
             if (newroots.containsKey("")) {
                 // we are going to scan everything anyway
                 scandir(rootPath, "", true);
             } else {
                 // only scan directories that can include matched files or
                 // directories
                 Enumeration enum2 = newroots.keys();
 
                 while (enum2.hasMoreElements()) {
                     String currentelement = (String) enum2.nextElement();
                     String originalpattern = (String) newroots.get(currentelement);
                     AntFTPFile myfile = new AntFTPFile(baseFTPFile, currentelement);
                     boolean isOK = true;
                     boolean traversesSymlinks = false;
                     String path = null;
 
                     if (myfile.exists()) {
                         forceRemoteSensitivityCheck();
                         if (remoteSensitivityChecked
                             && remoteSystemCaseSensitive && isFollowSymlinks()) {
                             // cool case,
                             //we do not need to scan all the subdirs in the relative path
                             path = myfile.getFastRelativePath();
                         } else {
                             // may be on a case insensitive file system.  We want
                             // the results to show what's really on the disk, so
                             // we need to double check.
                             try {
                                 path = myfile.getRelativePath();
                                 traversesSymlinks = myfile.isTraverseSymlinks();
                             }  catch (IOException be) {
                                 throw new BuildException(be, task.getLocation());
                             } catch (BuildException be) {
                                 isOK = false;
                             }
                         }
                     } else {
                         isOK = false;
                     }
                     if (isOK) {
                         currentelement = path.replace(task.getSeparator().charAt(0), File.separatorChar);
                         if (!isFollowSymlinks()
                             && traversesSymlinks) {
                             continue;
                         }
 
                         if (myfile.isDirectory()) {
                             if (isIncluded(currentelement)
                                 && currentelement.length() > 0) {
                                 accountForIncludedDir(currentelement, myfile, true);
                             }  else {
                                 if (currentelement.length() > 0) {
                                     if (currentelement.charAt(currentelement
                                                               .length() - 1)
                                         != File.separatorChar) {
                                         currentelement =
                                             currentelement + File.separatorChar;
                                     }
                                 }
                                 scandir(myfile.getAbsolutePath(), currentelement, true);
                             }
                         } else {
                             if (isCaseSensitive
                                 && originalpattern.equals(currentelement)) {
                                 accountForIncludedFile(currentelement);
                             } else if (!isCaseSensitive
                                        && originalpattern
                                        .equalsIgnoreCase(currentelement)) {
                                 accountForIncludedFile(currentelement);
                             }
                         }
                     }
                 }
             }
         }
         /**
          * scans a particular directory. populates the scannedDirs cache.
          *
          * @param dir directory to scan
          * @param vpath  relative path to the base directory of the remote fileset
          * always ended with a File.separator
          * @param fast seems to be always true in practice
          */
         protected void scandir(String dir, String vpath, boolean fast) {
             // avoid double scanning of directories, can only happen in fast mode
             if (fast && hasBeenScanned(vpath)) {
                 return;
             }
             try {
                 if (!ftp.changeWorkingDirectory(dir)) {
                     return;
                 }
                 String completePath = null;
                 if (!vpath.equals("")) {
                     completePath = rootPath + task.getSeparator()
                         + vpath.replace(File.separatorChar, task.getSeparator().charAt(0));
                 } else {
                     completePath = rootPath;
                 }
                 FTPFile[] newfiles = listFiles(completePath, false);
 
                 if (newfiles == null) {
                     ftp.changeToParentDirectory();
                     return;
                 }
                 for (int i = 0; i < newfiles.length; i++) {
                     FTPFile file = newfiles[i];
                     if (file != null
                         && !file.getName().equals(".")
                         && !file.getName().equals("..")) {
                         String name = vpath + file.getName();
                         scannedDirs.put(name, new FTPFileProxy(file));
                         if (isFunctioningAsDirectory(ftp, dir, file)) {
                             boolean slowScanAllowed = true;
                             if (!isFollowSymlinks() && file.isSymbolicLink()) {
                                 dirsExcluded.addElement(name);
                                 slowScanAllowed = false;
                             } else if (isIncluded(name)) {
                                 accountForIncludedDir(name,
                                                       new AntFTPFile(ftp, file, completePath) , fast);
                             } else {
                                 dirsNotIncluded.addElement(name);
                                 if (fast && couldHoldIncluded(name)) {
                                     scandir(file.getName(),
                                             name + File.separator, fast);
                                 }
                             }
                             if (!fast && slowScanAllowed) {
                                 scandir(file.getName(),
                                         name + File.separator, fast);
                             }
                         } else {
                             if (!isFollowSymlinks() && file.isSymbolicLink()) {
                                 filesExcluded.addElement(name);
                             } else if (isFunctioningAsFile(ftp, dir, file)) {
                                 accountForIncludedFile(name);
                             }
                         }
                     }
                 }
                 ftp.changeToParentDirectory();
             } catch (IOException e) {
                 throw new BuildException("Error while communicating with FTP "
                                          + "server: ", e);
             }
         }
         /**
          * process included file
          * @param name  path of the file relative to the directory of the fileset
          */
         private void accountForIncludedFile(String name) {
             if (!filesIncluded.contains(name)
                 && !filesExcluded.contains(name)) {
 
                 if (isIncluded(name)) {
                     if (!isExcluded(name)
                         && isSelected(name, (File) scannedDirs.get(name))) {
                         filesIncluded.addElement(name);
                     } else {
                         filesExcluded.addElement(name);
                     }
                 } else {
                     filesNotIncluded.addElement(name);
                 }
             }
         }
 
         /**
          *
          * @param name path of the directory relative to the directory of
          * the fileset
          * @param file directory as file
          * @param fast
          */
         private void accountForIncludedDir(String name, AntFTPFile file, boolean fast) {
             if (!dirsIncluded.contains(name)
                 && !dirsExcluded.contains(name)) {
 
                 if (!isExcluded(name)) {
                     if (fast) {
                         if (file.isSymbolicLink()) {
                             try {
                                 file.getClient().changeWorkingDirectory(file.curpwd);
                             } catch (IOException ioe) {
                                 throw new BuildException("could not change directory to curpwd");
                             }
                             scandir(file.getLink(),
                                     name + File.separator, fast);
                         } else {
                             try {
                                 file.getClient().changeWorkingDirectory(file.curpwd);
                             } catch (IOException ioe) {
                                 throw new BuildException("could not change directory to curpwd");
                             }
                             scandir(file.getName(),
                                     name + File.separator, fast);
                         }
                     }
                     dirsIncluded.addElement(name);
                 } else {
                     dirsExcluded.addElement(name);
                     if (fast && couldHoldIncluded(name)) {
                         try {
                             file.getClient().changeWorkingDirectory(file.curpwd);
                         } catch (IOException ioe) {
                             throw new BuildException("could not change directory to curpwd");
                         }
                         scandir(file.getName(),
                                 name + File.separator, fast);
                     }
                 }
             }
         }
         /**
          * temporary table to speed up the various scanning methods below
          *
          * @since Ant 1.6
          */
         private Map fileListMap = new HashMap();
         /**
          * List of all scanned directories.
          *
          * @since Ant 1.6
          */
 
         private Map scannedDirs = new HashMap();
 
         /**
          * Has the directory with the given path relative to the base
          * directory already been scanned?
          *
          * @since Ant 1.6
          */
         private boolean hasBeenScanned(String vpath) {
             return scannedDirs.containsKey(vpath);
         }
 
         /**
          * Clear internal caches.
          *
          * @since Ant 1.6
          */
         private void clearCaches() {
             fileListMap.clear();
             scannedDirs.clear();
         }
         /**
          * list the files present in one directory.
          * @param directory full path on the remote side
          * @param changedir if true change to directory directory before listing
          * @return array of FTPFile
          */
         public FTPFile[] listFiles(String directory, boolean changedir) {
             //task.log("listing files in directory " + directory, Project.MSG_DEBUG);
             String currentPath = directory;
             if (changedir) {
                 try {
                     boolean result = ftp.changeWorkingDirectory(directory);
                     if (!result) {
                         return null;
                     }
                     currentPath = ftp.printWorkingDirectory();
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, task.getLocation());
                 }
             }
             if (fileListMap.containsKey(currentPath)) {
                 task.log("filelist map used in listing files", Project.MSG_DEBUG);
                 return ((FTPFile[]) fileListMap.get(currentPath));
             }
             FTPFile[] result = null;
             try {
                 result = ftp.listFiles();
             } catch (IOException ioe) {
                 throw new BuildException(ioe, task.getLocation());
             }
             fileListMap.put(currentPath, result);
             if (!remoteSensitivityChecked) {
                 checkRemoteSensitivity(result, directory);
             }
             return result;
         }
 
         private void forceRemoteSensitivityCheck() {
             if (!remoteSensitivityChecked) {
                 try {
                     checkRemoteSensitivity(ftp.listFiles(), ftp.printWorkingDirectory());
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, task.getLocation());
                 }
             }
         }
         /**
          * cd into one directory and
          * list the files present in one directory.
          * @param directory full path on the remote side
          * @return array of FTPFile
          */
         public FTPFile[] listFiles(String directory) {
             return listFiles(directory, true);
         }
         private void checkRemoteSensitivity(FTPFile[] array, String directory) {
             if (array == null) {
                 return;
             }
             boolean candidateFound = false;
             String target = null;
             for (int icounter = 0; icounter < array.length; icounter++) {
                 if (array[icounter] != null && array[icounter].isDirectory()) {
                     if (!array[icounter].getName().equals(".")
                         && !array[icounter].getName().equals("..")) {
                         candidateFound = true;
                         target = fiddleName(array[icounter].getName());
                         task.log("will try to cd to "
                                          + target + " where a directory called " + array[icounter].getName()
                                          + " exists", Project.MSG_DEBUG);
                         for (int pcounter = 0; pcounter < array.length; pcounter++) {
                             if (array[pcounter] != null
                                 && pcounter != icounter
                                 && target.equals(array[pcounter].getName())) {
                                 candidateFound = false;
                             }
                         }
                         if (candidateFound) {
                             break;
                         }
                     }
                 }
             }
             if (candidateFound) {
                 try {
                     task.log("testing case sensitivity, attempting to cd to "
                                      + target, Project.MSG_DEBUG);
                     remoteSystemCaseSensitive  = !ftp.changeWorkingDirectory(target);
                 } catch (IOException ioe) {
                     remoteSystemCaseSensitive = true;
                 } finally {
                     try {
                         ftp.changeWorkingDirectory(directory);
                     } catch (IOException ioe) {
                         throw new BuildException(ioe, task.getLocation());
                     }
                 }
                 task.log("remote system is case sensitive : "
                                       + remoteSystemCaseSensitive,
                                       Project.MSG_VERBOSE);
                 remoteSensitivityChecked = true;
             }
         }
         private String fiddleName(String origin) {
             StringBuffer result = new StringBuffer();
             for (int icounter = 0; icounter < origin.length(); icounter++) {
                 if (Character.isLowerCase(origin.charAt(icounter))) {
                     result.append(Character.toUpperCase(origin.charAt(icounter)));
                 } else if (Character.isUpperCase(origin.charAt(icounter))) {
                     result.append(Character.toLowerCase(origin.charAt(icounter)));
                 } else {
                     result.append(origin.charAt(icounter));
                 }
             }
             return result.toString();
         }
         /**
          * an AntFTPFile is a representation of a remote file
          * @since Ant 1.6
          */
         protected class AntFTPFile {
             /**
              * ftp client
              */
             private FTPClient client;
             /**
              * parent directory of the file
              */
             private String curpwd;
             /**
              * the file itself
              */
             private FTPFile ftpFile;
             /**
              *
              */
             private AntFTPFile parent = null;
             private boolean relativePathCalculated = false;
             private boolean traversesSymlinks = false;
             private String relativePath = "";
             /**
              * constructor
              * @param client ftp client variable
              * @param ftpFile the file
              * @param curpwd absolute remote path where the file is found
              */
             public AntFTPFile(FTPClient client, FTPFile ftpFile, String curpwd) {
                 this.client = client;
                 this.ftpFile = ftpFile;
                 this.curpwd = curpwd;
             }
             /**
              * other constructor
              * @param parent the parent file
              * @param path  a relative path to the parent file
              */
             public AntFTPFile(AntFTPFile parent, String path) {
                 this.parent = parent;
                 this.client = parent.client;
                 Vector pathElements = SelectorUtils.tokenizePath(path);
                 try {
                     boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());
                     //this should not happen, except if parent has been deleted by another process
                     if (!result) {
                         return;
                     }
                     this.curpwd = parent.getAbsolutePath();
                 } catch (IOException ioe) {
                     throw new BuildException("could not change working dir to "
                                              + parent.curpwd);
                 }
                 final int size = pathElements.size();
                 for (int fcount = 0; fcount < size - 1; fcount++) {
                     String currentPathElement = (String) pathElements.elementAt(fcount);
                     try {
                         boolean result = this.client.changeWorkingDirectory(currentPathElement);
                         if (!result && !isCaseSensitive()
                             && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) {
                             currentPathElement = findPathElementCaseUnsensitive(this.curpwd,
                                                                                 currentPathElement);
                             if (currentPathElement == null) {
                                 return;
                             }
                         } else if (!result) {
                             return;
                         }
                         this.curpwd = getCurpwdPlusFileSep()
                             + currentPathElement;
                     } catch (IOException ioe) {
                         throw new BuildException("could not change working dir to "
                                                  + (String) pathElements.elementAt(fcount)
                                                  + " from " + this.curpwd);
                     }
 
                 }
                 String lastpathelement = (String) pathElements.elementAt(size - 1);
                 FTPFile [] theFiles = listFiles(this.curpwd);
                 this.ftpFile = getFile(theFiles, lastpathelement);
             }
             /**
              * find a file in a directory in case unsensitive way
              * @param parentPath        where we are
              * @param soughtPathElement what is being sought
              * @return                  the first file found or null if not found
              */
             private String findPathElementCaseUnsensitive(String parentPath,
                                                           String soughtPathElement) {
                 // we are already in the right path, so the second parameter
                 // is false
                 FTPFile[] theFiles = listFiles(parentPath, false);
                 if (theFiles == null) {
                     return null;
                 }
                 for (int icounter = 0; icounter < theFiles.length; icounter++) {
                     if (theFiles[icounter] != null
                         && theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) {
                         return theFiles[icounter].getName();
                     }
                 }
                 return null;
             }
             /**
              * find out if the file exists
              * @return  true if the file exists
              */
             public boolean exists() {
                 return (ftpFile != null);
             }
             /**
              * if the file is a symbolic link, find out to what it is pointing
              * @return the target of the symbolic link
              */
             public String getLink() {
                 return ftpFile.getLink();
             }
             /**
              * get the name of the file
              * @return the name of the file
              */
             public String getName() {
                 return ftpFile.getName();
             }
             /**
              * find out the absolute path of the file
              * @return absolute path as string
              */
             public String getAbsolutePath() {
                 return getCurpwdPlusFileSep() + ftpFile.getName();
             }
             /**
              * find out the relative path assuming that the path used to construct
              * this AntFTPFile was spelled properly with regards to case.
              * This is OK on a case sensitive system such as UNIX
              * @return relative path
              */
             public String getFastRelativePath() {
                 String absPath = getAbsolutePath();
                 if (absPath.indexOf(rootPath + task.getSeparator()) == 0) {
                     return absPath.substring(rootPath.length()
                                              + task.getSeparator().length());
                 }
                 return null;
             }
             /**
              * find out the relative path to the rootPath of the enclosing scanner.
              * this relative path is spelled exactly like on disk,
              * for instance if the AntFTPFile has been instantiated as ALPHA,
              * but the file is really called alpha, this method will return alpha.
              * If a symbolic link is encountered, it is followed, but the name of the link
              * rather than the name of the target is returned.
              * (ie does not behave like File.getCanonicalPath())
              * @return                relative path, separated by remoteFileSep
              * @throws IOException    if a change directory fails, ...
              * @throws BuildException if one of the components of the relative path cannot
              * be found.
              */
             public String getRelativePath() throws IOException, BuildException {
                 if (!relativePathCalculated) {
                     if (parent != null) {
                         traversesSymlinks = parent.isTraverseSymlinks();
                         relativePath = getRelativePath(parent.getAbsolutePath(),
                                                        parent.getRelativePath());
                     } else {
                         relativePath = getRelativePath(rootPath, "");
                         relativePathCalculated = true;
                     }
                 }
                 return relativePath;
             }
             /**
              * get thge relative path of this file
              * @param currentPath          base path
              * @param currentRelativePath  relative path of the base path with regards to remote dir
              * @return relative path
              */
             private String getRelativePath(String currentPath, String currentRelativePath) {
                 Vector pathElements = SelectorUtils.tokenizePath(getAbsolutePath(), task.getSeparator());
                 Vector pathElements2 = SelectorUtils.tokenizePath(currentPath,
                                                                   task.getSeparator());
                 String relPath = currentRelativePath;
                 final int size = pathElements.size();
                 for (int pcount = pathElements2.size(); pcount < size; pcount++) {
                     String currentElement = (String) pathElements.elementAt(pcount);
                     FTPFile[] theFiles = listFiles(currentPath);
                     FTPFile theFile = null;
                     if (theFiles != null) {
                         theFile = getFile(theFiles, currentElement);
                     }
                     if (!relPath.equals("")) {
                         relPath = relPath + task.getSeparator();
                     }
                     if (theFile == null) {
                         // hit a hidden file assume not a symlink
                         relPath = relPath + currentElement;
                         currentPath = currentPath + task.getSeparator()
                             + currentElement;
                         task.log("Hidden file " + relPath
                                  + " assumed to not be a symlink.",
                                  Project.MSG_VERBOSE);
                     } else {
                         traversesSymlinks = traversesSymlinks || theFile.isSymbolicLink();
                         relPath = relPath + theFile.getName();
                         currentPath = currentPath + task.getSeparator()
                             + theFile.getName();
                     }
                 }
                 return relPath;
             }
             /**
              * find a file matching a string in an array of FTPFile.
              * This method will find "alpha" when requested for "ALPHA"
              * if and only if the caseSensitive attribute is set to false.
              * When caseSensitive is set to true, only the exact match is returned.
              * @param theFiles  array of files
              * @param lastpathelement  the file name being sought
              * @return null if the file cannot be found, otherwise return the matching file.
              */
             public FTPFile getFile(FTPFile[] theFiles, String lastpathelement) {
                 if (theFiles == null) {
                     return null;
                 }
                 for (int fcount = 0; fcount < theFiles.length; fcount++) {
                     if (theFiles[fcount] != null) {
                         if (theFiles[fcount].getName().equals(lastpathelement)) {
                             return theFiles[fcount];
                         } else if (!isCaseSensitive()
                                    && theFiles[fcount].getName().equalsIgnoreCase(
                                                                                   lastpathelement)) {
                             return theFiles[fcount];
                         }
                     }
                 }
                 return null;
             }
             /**
              * tell if a file is a directory.
              * note that it will return false for symbolic links pointing to directories.
              * @return <code>true</code> for directories
              */
             public boolean isDirectory() {
                 return ftpFile.isDirectory();
             }
             /**
              * tell if a file is a symbolic link
              * @return <code>true</code> for symbolic links
              */
             public boolean isSymbolicLink() {
                 return ftpFile.isSymbolicLink();
             }
             /**
              * return the attached FTP client object.
              * Warning : this instance is really shared with the enclosing class.
              * @return  FTP client
              */
             protected FTPClient getClient() {
                 return client;
             }
 
             /**
              * sets the current path of an AntFTPFile
              * @param curpwd the current path one wants to set
              */
             protected void setCurpwd(String curpwd) {
                 this.curpwd = curpwd;
             }
             /**
              * returns the path of the directory containing the AntFTPFile.
              * of the full path of the file itself in case of AntFTPRootFile
              * @return parent directory of the AntFTPFile
              */
             public String getCurpwd() {
                 return curpwd;
             }
             /**
              * returns the path of the directory containing the AntFTPFile.
              * of the full path of the file itself in case of AntFTPRootFile
              * and appends the remote file separator if necessary.
              * @return parent directory of the AntFTPFile
              * @since Ant 1.8.2
              */
             public String getCurpwdPlusFileSep() {
                 String sep = task.getSeparator();
                 return curpwd.endsWith(sep) ? curpwd : curpwd + sep;
             }
             /**
              * find out if a symbolic link is encountered in the relative path of this file
              * from rootPath.
              * @return <code>true</code> if a symbolic link is encountered in the relative path.
              * @throws IOException if one of the change directory or directory listing operations
              * fails
              * @throws BuildException if a path component in the relative path cannot be found.
              */
             public boolean isTraverseSymlinks() throws IOException, BuildException {
                 if (!relativePathCalculated) {
                     // getRelativePath also finds about symlinks
                     getRelativePath();
                 }
                 return traversesSymlinks;
             }
 
             /**
              * Get a string rep of this object.
              * @return a string containing the pwd and the file.
              */
             public String toString() {
                 return "AntFtpFile: " + curpwd + "%" + ftpFile;
             }
         }
         /**
          * special class to represent the remote directory itself
          * @since Ant 1.6
          */
         protected class AntFTPRootFile extends AntFTPFile {
             private String remotedir;
             /**
              * constructor
              * @param aclient FTP client
              * @param remotedir remote directory
              */
             public AntFTPRootFile(FTPClient aclient, String remotedir) {
                 super(aclient, null, remotedir);
                 this.remotedir = remotedir;
                 try {
                     this.getClient().changeWorkingDirectory(this.remotedir);
                     this.setCurpwd(this.getClient().printWorkingDirectory());
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, task.getLocation());
                 }
             }
             /**
              * find the absolute path
              * @return absolute path
              */
             public String getAbsolutePath() {
                 return this.getCurpwd();
             }
             /**
              * find out the relative path to root
              * @return empty string
              * @throws BuildException actually never
              * @throws IOException  actually never
              */
             public String getRelativePath() throws BuildException, IOException {
                 return "";
             }
         }
     }
     /**
      * check FTPFiles to check whether they function as directories too
      * the FTPFile API seem to make directory and symbolic links incompatible
      * we want to find out if we can cd to a symbolic link
      * @param dir  the parent directory of the file to test
      * @param file the file to test
      * @return true if it is possible to cd to this directory
      * @since ant 1.6
      */
     private boolean isFunctioningAsDirectory(FTPClient ftp, String dir, FTPFile file) {
         boolean result = false;
         String currentWorkingDir = null;
         if (file.isDirectory()) {
             return true;
         } else if (file.isFile()) {
             return false;
         }
         try {
             currentWorkingDir = ftp.printWorkingDirectory();
         } catch (IOException ioe) {
             task.log("could not find current working directory " + dir
                                   + " while checking a symlink", Project.MSG_DEBUG);
         }
         if (currentWorkingDir != null) {
             try {
                 result = ftp.changeWorkingDirectory(file.getLink());
             } catch (IOException ioe) {
                 task.log("could not cd to " + file.getLink()
                                       + " while checking a symlink",
                                       Project.MSG_DEBUG);
             }
             if (result) {
                 boolean comeback = false;
                 try {
                     comeback = ftp.changeWorkingDirectory(currentWorkingDir);
                 } catch (IOException ioe) {
                     task.log("could not cd back to " + dir + " while checking a symlink",
                                           Project.MSG_ERR);
                 } finally {
                     if (!comeback) {
                         throw new BuildException("could not cd back to " + dir
                                                  + " while checking a symlink");
                     }
                 }
             }
         }
         return result;
     }
     /**
      * check FTPFiles to check whether they function as directories too
      * the FTPFile API seem to make directory and symbolic links incompatible
      * we want to find out if we can cd to a symbolic link
      * @param dir  the parent directory of the file to test
      * @param file the file to test
      * @return true if it is possible to cd to this directory
      * @since ant 1.6
      */
     private boolean isFunctioningAsFile(FTPClient ftp, String dir, FTPFile file) {
         if (file.isDirectory()) {
             return false;
         } else if (file.isFile()) {
             return true;
         }
         return !isFunctioningAsDirectory(ftp, dir, file);
     }
 
     /**
      * Executable a retryable object.
-     * @param h the retry hander.
+     * @param h the retry handler.
      * @param r the object that should be retried until it succeeds
      *          or the number of retrys is reached.
      * @param descr a description of the command that is being run.
      * @throws IOException if there is a problem.
      */
     protected void executeRetryable(RetryHandler h, Retryable r, String descr)
         throws IOException {
         h.execute(r, descr);
     }
 
 
     /**
      * For each file in the fileset, do the appropriate action: send, get,
      * delete, or list.
      *
      * @param ftp the FTPClient instance used to perform FTP actions
      * @param fs the fileset on which the actions are performed.
      *
      * @return the number of files to be transferred.
      *
      * @throws IOException if there is a problem reading a file
      * @throws BuildException if there is a problem in the configuration.
      */
     protected int transferFiles(final FTPClient ftp, FileSet fs)
         throws IOException, BuildException {
         DirectoryScanner ds;
         if (task.getAction() == FTPTask.SEND_FILES) {
             ds = fs.getDirectoryScanner(task.getProject());
         } else {
             ds = new FTPDirectoryScanner(ftp);
             fs.setupDirectoryScanner(ds, task.getProject());
             ds.setFollowSymlinks(fs.isFollowSymlinks());
             ds.scan();
         }
 
         String[] dsfiles = null;
         if (task.getAction() == FTPTask.RM_DIR) {
             dsfiles = ds.getIncludedDirectories();
         } else {
             dsfiles = ds.getIncludedFiles();
         }
         String dir = null;
 
         if ((ds.getBasedir() == null)
             && ((task.getAction() == FTPTask.SEND_FILES) || (task.getAction() == FTPTask.GET_FILES))) {
             throw new BuildException("the dir attribute must be set for send "
                                      + "and get actions");
         } else {
             if ((task.getAction() == FTPTask.SEND_FILES) || (task.getAction() == FTPTask.GET_FILES)) {
                 dir = ds.getBasedir().getAbsolutePath();
             }
         }
 
         // If we are doing a listing, we need the output stream created now.
         BufferedWriter bw = null;
 
         try {
             if (task.getAction() == FTPTask.LIST_FILES) {
                 File pd = task.getListing().getParentFile();
 
                 if (!pd.exists()) {
                     pd.mkdirs();
                 }
                 bw = new BufferedWriter(new FileWriter(task.getListing()));
             }
             RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
             if (task.getAction() == FTPTask.RM_DIR) {
                 // to remove directories, start by the end of the list
                 // the trunk does not let itself be removed before the leaves
                 for (int i = dsfiles.length - 1; i >= 0; i--) {
                     final String dsfile = dsfiles[i];
                     executeRetryable(h, new Retryable() {
                             public void execute() throws IOException {
                                 rmDir(ftp, dsfile);
                             }
                         }, dsfile);
                 }
             } else {
                 final BufferedWriter fbw = bw;
                 final String fdir = dir;
                 if (task.isNewer()) {
                     task.setGranularityMillis(task.getTimestampGranularity()
                                               .getMilliseconds(task.getAction()));
                 }
                 for (int i = 0; i < dsfiles.length; i++) {
                     final String dsfile = dsfiles[i];
                     executeRetryable(h, new Retryable() {
                             public void execute() throws IOException {
                                 switch (task.getAction()) {
                                 case FTPTask.SEND_FILES:
                                     sendFile(ftp, fdir, dsfile);
                                     break;
                                 case FTPTask.GET_FILES:
                                     getFile(ftp, fdir, dsfile);
                                     break;
                                 case FTPTask.DEL_FILES:
                                     delFile(ftp, dsfile);
                                     break;
                                 case FTPTask.LIST_FILES:
                                     listFile(ftp, fbw, dsfile);
                                     break;
                                 case FTPTask.CHMOD:
                                     doSiteCommand(ftp, "chmod " + task.getChmod() + " "
                                                   + resolveFile(dsfile));
                                     transferred++;
                                     break;
                                 default:
                                     throw new BuildException("unknown ftp action "
                                                              + task.getAction());
                                 }
                             }
                         }, dsfile);
                 }
             }
         } finally {
             if (bw != null) {
                 bw.close();
             }
         }
 
         return dsfiles.length;
     }
 
 
     /**
      * Sends all files specified by the configured filesets to the remote
      * server.
      *
      * @param ftp the FTPClient instance used to perform FTP actions
      *
      * @throws IOException if there is a problem reading a file
      * @throws BuildException if there is a problem in the configuration.
      */
     protected void transferFiles(FTPClient ftp)
         throws IOException, BuildException {
         transferred = 0;
         skipped = 0;
 
         if (task.getFilesets().size() == 0) {
             throw new BuildException("at least one fileset must be specified.");
         } else {
             // get files from filesets
             final int size = task.getFilesets().size();
             for (int i = 0; i < size; i++) {
                 FileSet fs = (FileSet) task.getFilesets().elementAt(i);
 
                 if (fs != null) {
                     transferFiles(ftp, fs);
                 }
             }
         }
 
         task.log(transferred + " " + FTPTask.ACTION_TARGET_STRS[task.getAction()] + " "
                  + FTPTask.COMPLETED_ACTION_STRS[task.getAction()]);
         if (skipped != 0) {
             task.log(skipped + " " + FTPTask.ACTION_TARGET_STRS[task.getAction()]
                      + " were not successfully " + FTPTask.COMPLETED_ACTION_STRS[task.getAction()]);
         }
     }
 
 
     /**
      * Correct a file path to correspond to the remote host requirements. This
      * implementation currently assumes that the remote end can handle
      * Unix-style paths with forward-slash separators. This can be overridden
      * with the <code>separator</code> task parameter. No attempt is made to
      * determine what syntax is appropriate for the remote host.
      *
      * @param file the remote file name to be resolved
      *
      * @return the filename as it will appear on the server.
      */
     protected String resolveFile(String file) {
         return file.replace(System.getProperty("file.separator").charAt(0),
                             task.getSeparator().charAt(0));
     }
 
 
     /**
      * Creates all parent directories specified in a complete relative
      * pathname. Attempts to create existing directories will not cause
      * errors.
      *
      * @param ftp the FTP client instance to use to execute FTP actions on
      *        the remote server.
      * @param filename the name of the file whose parents should be created.
      * @throws IOException under non documented circumstances
      * @throws BuildException if it is impossible to cd to a remote directory
      *
      */
     protected void createParents(FTPClient ftp, String filename)
         throws IOException, BuildException {
 
         File dir = new File(filename);
         if (dirCache.contains(dir)) {
             return;
         }
 
         Vector parents = new Vector();
         String dirname;
 
         while ((dirname = dir.getParent()) != null) {
             File checkDir = new File(dirname);
             if (dirCache.contains(checkDir)) {
                 break;
             }
             dir = checkDir;
             parents.addElement(dir);
         }
 
         // find first non cached dir
         int i = parents.size() - 1;
 
         if (i >= 0) {
             String cwd = ftp.printWorkingDirectory();
             String parent = dir.getParent();
             if (parent != null) {
                 if (!ftp.changeWorkingDirectory(resolveFile(parent))) {
                     throw new BuildException("could not change to "
                                              + "directory: " + ftp.getReplyString());
                 }
             }
 
             while (i >= 0) {
                 dir = (File) parents.elementAt(i--);
                 // check if dir exists by trying to change into it.
                 if (!ftp.changeWorkingDirectory(dir.getName())) {
                     // could not change to it - try to create it
                     task.log("creating remote directory "
                              + resolveFile(dir.getPath()), Project.MSG_VERBOSE);
                     if (!ftp.makeDirectory(dir.getName())) {
                         handleMkDirFailure(ftp);
                     }
                     if (!ftp.changeWorkingDirectory(dir.getName())) {
                         throw new BuildException("could not change to "
                                                  + "directory: " + ftp.getReplyString());
                     }
                 }
                 dirCache.add(dir);
             }
             ftp.changeWorkingDirectory(cwd);
         }
     }
     /**
      * auto find the time difference between local and remote
      * @param ftp handle to ftp client
      * @return number of millis to add to remote time to make it comparable to local time
      * @since ant 1.6
      */
     private long getTimeDiff(FTPClient ftp) {
         long returnValue = 0;
         File tempFile = findFileName(ftp);
         try {
             // create a local temporary file
             FILE_UTILS.createNewFile(tempFile);
             long localTimeStamp = tempFile.lastModified();
             BufferedInputStream instream = new BufferedInputStream(new FileInputStream(tempFile));
             ftp.storeFile(tempFile.getName(), instream);
             instream.close();
             boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
             if (success) {
                 FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName());
                 if (ftpFiles.length == 1) {
                     long remoteTimeStamp = ftpFiles[0].getTimestamp().getTime().getTime();
                     returnValue = localTimeStamp - remoteTimeStamp;
                 }
                 ftp.deleteFile(ftpFiles[0].getName());
             }
             // delegate the deletion of the local temp file to the delete task
             // because of race conditions occuring on Windows
             Delete mydelete = new Delete();
             mydelete.bindToOwner(task);
             mydelete.setFile(tempFile.getCanonicalFile());
             mydelete.execute();
         } catch (Exception e) {
             throw new BuildException(e, task.getLocation());
         }
         return returnValue;
     }
     /**
      *  find a suitable name for local and remote temporary file
      */
     private File findFileName(FTPClient ftp) {
         FTPFile [] theFiles = null;
         final int maxIterations = 1000;
         for (int counter = 1; counter < maxIterations; counter++) {
             File localFile = FILE_UTILS.createTempFile(
                                                        "ant" + Integer.toString(counter), ".tmp",
                                                        null, false, false);
             String fileName = localFile.getName();
             boolean found = false;
             try {
                 if (theFiles == null) {
                     theFiles = ftp.listFiles();
                 }
                 for (int counter2 = 0; counter2 < theFiles.length; counter2++) {
                     if (theFiles[counter2] != null
                         && theFiles[counter2].getName().equals(fileName)) {
                         found = true;
                         break;
                     }
                 }
             } catch (IOException ioe) {
                 throw new BuildException(ioe, task.getLocation());
             }
             if (!found) {
                 localFile.deleteOnExit();
                 return localFile;
             }
         }
         return null;
     }
 
     /**
      * Checks to see if the remote file is current as compared with the local
      * file. Returns true if the target file is up to date.
      * @param ftp ftpclient
      * @param localFile local file
      * @param remoteFile remote file
      * @return true if the target file is up to date
      * @throws IOException  in unknown circumstances
      * @throws BuildException if the date of the remote files cannot be found and the action is
      * GET_FILES
      */
     protected boolean isUpToDate(FTPClient ftp, File localFile,
                                  String remoteFile)
         throws IOException, BuildException {
         task.log("checking date for " + remoteFile, Project.MSG_VERBOSE);
 
         FTPFile[] files = ftp.listFiles(remoteFile);
 
         // For Microsoft's Ftp-Service an Array with length 0 is
         // returned if configured to return listings in "MS-DOS"-Format
         if (files == null || files.length == 0) {
             // If we are sending files, then assume out of date.
             // If we are getting files, then throw an error
 
             if (task.getAction() == FTPTask.SEND_FILES) {
                 task.log("Could not date test remote file: " + remoteFile
                          + "assuming out of date.", Project.MSG_VERBOSE);
                 return false;
             } else {
                 throw new BuildException("could not date test remote file: "
                                          + ftp.getReplyString());
             }
         }
 
         long remoteTimestamp = files[0].getTimestamp().getTime().getTime();
         long localTimestamp = localFile.lastModified();
         long adjustedRemoteTimestamp = remoteTimestamp + task.getTimeDiffMillis()
             + task.getGranularityMillis();
 
         StringBuffer msg;
         synchronized(TIMESTAMP_LOGGING_SDF) {
             msg = new StringBuffer("   [")
                 .append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp)))
                 .append("] local");
         }
         task.log(msg.toString(), Project.MSG_VERBOSE);
 
         synchronized(TIMESTAMP_LOGGING_SDF) {
             msg = new StringBuffer("   [")
                 .append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp)))
                 .append("] remote");
         }
         if (remoteTimestamp != adjustedRemoteTimestamp) {
             synchronized(TIMESTAMP_LOGGING_SDF) {
                 msg.append(" - (raw: ")
                     .append(TIMESTAMP_LOGGING_SDF.format(new Date(remoteTimestamp)))
                     .append(")");
             }
         }
         task.log(msg.toString(), Project.MSG_VERBOSE);
 
         if (task.getAction() == FTPTask.SEND_FILES) {
             return adjustedRemoteTimestamp >= localTimestamp;
         } else {
             return localTimestamp >= adjustedRemoteTimestamp;
         }
     }
 
 
     /**
      * Sends a site command to the ftp server
      * @param ftp ftp client
      * @param theCMD command to execute
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void doSiteCommand(FTPClient ftp, String theCMD)
         throws IOException, BuildException {
         boolean rc;
         String[] myReply = null;
 
         task.log("Doing Site Command: " + theCMD, Project.MSG_VERBOSE);
 
         rc = ftp.sendSiteCommand(theCMD);
 
         if (!rc) {
             task.log("Failed to issue Site Command: " + theCMD, Project.MSG_WARN);
         } else {
 
             myReply = ftp.getReplyStrings();
 
             for (int x = 0; x < myReply.length; x++) {
                 if (myReply[x].indexOf("200") == -1) {
                     task.log(myReply[x], Project.MSG_WARN);
                 }
             }
         }
     }
 
 
     /**
      * Sends a single file to the remote host. <code>filename</code> may
      * contain a relative path specification. When this is the case, <code>sendFile</code>
      * will attempt to create any necessary parent directories before sending
      * the file. The file will then be sent using the entire relative path
      * spec - no attempt is made to change directories. It is anticipated that
      * this may eventually cause problems with some FTP servers, but it
      * simplifies the coding.
      * @param ftp ftp client
      * @param dir base directory of the file to be sent (local)
      * @param filename relative path of the file to be send
      *        locally relative to dir
      *        remotely relative to the remotedir attribute
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void sendFile(FTPClient ftp, String dir, String filename)
         throws IOException, BuildException {
         InputStream instream = null;
 
         try {
             // XXX - why not simply new File(dir, filename)?
             File file = task.getProject().resolveFile(new File(dir, filename).getPath());
 
             if (task.isNewer() && isUpToDate(ftp, file, resolveFile(filename))) {
                 return;
             }
 
             if (task.isVerbose()) {
                 task.log("transferring " + file.getAbsolutePath());
             }
 
             instream = new BufferedInputStream(new FileInputStream(file));
 
             createParents(ftp, filename);
 
             ftp.storeFile(resolveFile(filename), instream);
 
             boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
 
             if (!success) {
                 String s = "could not put file: " + ftp.getReplyString();
 
                 if (task.isSkipFailedTransfers()) {
                     task.log(s, Project.MSG_WARN);
                     skipped++;
                 } else {
                     throw new BuildException(s);
                 }
 
             } else {
                 // see if we should issue a chmod command
                 if (task.getChmod() != null) {
                     doSiteCommand(ftp, "chmod " + task.getChmod() + " "
                                   + resolveFile(filename));
                 }
                 task.log("File " + file.getAbsolutePath() + " copied to " + task.getServer(),
                          Project.MSG_VERBOSE);
                 transferred++;
             }
         } finally {
             if (instream != null) {
                 try {
                     instream.close();
                 } catch (IOException ex) {
                     // ignore it
                 }
             }
         }
     }
 
 
     /**
      * Delete a file from the remote host.
      * @param ftp ftp client
      * @param filename file to delete
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is set to false
      * and the deletion could not be done
      */
     protected void delFile(FTPClient ftp, String filename)
         throws IOException, BuildException {
         if (task.isVerbose()) {
             task.log("deleting " + filename);
         }
 
         if (!ftp.deleteFile(resolveFile(filename))) {
             String s = "could not delete file: " + ftp.getReplyString();
 
             if (task.isSkipFailedTransfers()) {
                 task.log(s, Project.MSG_WARN);
                 skipped++;
             } else {
                 throw new BuildException(s);
             }
         } else {
             task.log("File " + filename + " deleted from " + task.getServer(),
                      Project.MSG_VERBOSE);
             transferred++;
         }
     }
 
     /**
      * Delete a directory, if empty, from the remote host.
      * @param ftp ftp client
      * @param dirname directory to delete
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is set to false
      * and the deletion could not be done
      */
     protected void rmDir(FTPClient ftp, String dirname)
         throws IOException, BuildException {
         if (task.isVerbose()) {
             task.log("removing " + dirname);
         }
 
         if (!ftp.removeDirectory(resolveFile(dirname))) {
             String s = "could not remove directory: " + ftp.getReplyString();
 
             if (task.isSkipFailedTransfers()) {
                 task.log(s, Project.MSG_WARN);
                 skipped++;
             } else {
                 throw new BuildException(s);
             }
         } else {
             task.log("Directory " + dirname + " removed from " + task.getServer(),
                      Project.MSG_VERBOSE);
             transferred++;
         }
     }
 
 
     /**
      * Retrieve a single file from the remote host. <code>filename</code> may
      * contain a relative path specification. <p>
      *
      * The file will then be retreived using the entire relative path spec -
      * no attempt is made to change directories. It is anticipated that this
      * may eventually cause problems with some FTP servers, but it simplifies
      * the coding.</p>
      * @param ftp the ftp client
      * @param dir local base directory to which the file should go back
      * @param filename relative path of the file based upon the ftp remote directory
      *        and/or the local base directory (dir)
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is false
      * and the file cannot be retrieved.
      */
     protected void getFile(FTPClient ftp, String dir, String filename)
         throws IOException, BuildException {
         OutputStream outstream = null;
         try {
             File file = task.getProject().resolveFile(new File(dir, filename).getPath());
 
             if (task.isNewer() && isUpToDate(ftp, file, resolveFile(filename))) {
                 return;
             }
 
             if (task.isVerbose()) {
                 task.log("transferring " + filename + " to "
                          + file.getAbsolutePath());
             }
 
             File pdir = file.getParentFile();
 
             if (!pdir.exists()) {
                 pdir.mkdirs();
             }
             outstream = new BufferedOutputStream(new FileOutputStream(file));
             ftp.retrieveFile(resolveFile(filename), outstream);
 
             if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                 String s = "could not get file: " + ftp.getReplyString();
 
                 if (task.isSkipFailedTransfers()) {
                     task.log(s, Project.MSG_WARN);
                     skipped++;
                 } else {
                     throw new BuildException(s);
                 }
 
             } else {
                 task.log(
                          "File " + file.getAbsolutePath() + " copied from "
                          + task.getServer(), Project.MSG_VERBOSE);
                 transferred++;
                 if (task.isPreserveLastModified()) {
                     outstream.close();
                     outstream = null;
                     FTPFile[] remote = ftp.listFiles(resolveFile(filename));
                     if (remote.length > 0) {
                         FILE_UTILS.setFileLastModified(file,
                                                        remote[0].getTimestamp()
                                                        .getTime().getTime());
                     }
                 }
             }
         } finally {
             if (outstream != null) {
                 try {
                     outstream.close();
                 } catch (IOException ex) {
                     // ignore it
                 }
             }
         }
     }
 
 
     /**
      * List information about a single file from the remote host. <code>filename</code>
      * may contain a relative path specification. <p>
      *
      * The file listing will then be retrieved using the entire relative path
      * spec - no attempt is made to change directories. It is anticipated that
      * this may eventually cause problems with some FTP servers, but it
      * simplifies the coding.</p>
      * @param ftp ftp client
      * @param bw buffered writer
      * @param filename the directory one wants to list
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void listFile(FTPClient ftp, BufferedWriter bw, String filename)
         throws IOException, BuildException {
         if (task.isVerbose()) {
             task.log("listing " + filename);
         }
         FTPFile[] ftpfiles = ftp.listFiles(resolveFile(filename));
 
         if (ftpfiles != null && ftpfiles.length > 0) {
             bw.write(ftpfiles[0].toString());
             bw.newLine();
             transferred++;
         }
     }
 
 
     /**
      * Create the specified directory on the remote host.
      *
      * @param ftp The FTP client connection
      * @param dir The directory to create (format must be correct for host
      *      type)
      * @throws IOException  in unknown circumstances
      * @throws BuildException if ignoreNoncriticalErrors has not been set to true
      *         and a directory could not be created, for instance because it was
      *         already existing. Precisely, the codes 521, 550 and 553 will trigger
      *         a BuildException
      */
     protected void makeRemoteDir(FTPClient ftp, String dir)
         throws IOException, BuildException {
         String workingDirectory = ftp.printWorkingDirectory();
         if (task.isVerbose()) {
             if (dir.indexOf("/") == 0 || workingDirectory == null) {
                 task.log("Creating directory: " + dir + " in /");
             } else {
                 task.log("Creating directory: " + dir + " in " + workingDirectory);
             }
         }
         if (dir.indexOf("/") == 0) {
             ftp.changeWorkingDirectory("/");
         }
         String subdir = "";
         StringTokenizer st = new StringTokenizer(dir, "/");
         while (st.hasMoreTokens()) {
             subdir = st.nextToken();
             task.log("Checking " + subdir, Project.MSG_DEBUG);
             if (!ftp.changeWorkingDirectory(subdir)) {
                 if (!ftp.makeDirectory(subdir)) {
                     // codes 521, 550 and 553 can be produced by FTP Servers
                     //  to indicate that an attempt to create a directory has
                     //  failed because the directory already exists.
                     int rc = ftp.getReplyCode();
                     if (!(task.isIgnoreNoncriticalErrors() && (rc == CODE_550
                                                                || rc == CODE_553
                                                                || rc == CODE_521))) {
                         throw new BuildException("could not create directory: "
                                                  + ftp.getReplyString());
                     }
                     if (task.isVerbose()) {
                         task.log("Directory already exists");
                     }
                 } else {
                     if (task.isVerbose()) {
                         task.log("Directory created OK");
                     }
                     ftp.changeWorkingDirectory(subdir);
                 }
             }
         }
         if (workingDirectory != null) {
             ftp.changeWorkingDirectory(workingDirectory);
         }
     }
 
     /**
      * look at the response for a failed mkdir action, decide whether
      * it matters or not. If it does, we throw an exception
      * @param ftp current ftp connection
      * @throws BuildException if this is an error to signal
      */
     private void handleMkDirFailure(FTPClient ftp)
         throws BuildException {
         int rc = ftp.getReplyCode();
         if (!(task.isIgnoreNoncriticalErrors() && (rc == CODE_550
                                                    || rc == CODE_553
                                                    || rc == CODE_521))) {
             throw new BuildException("could not create directory: "
                                      + ftp.getReplyString());
         }
     }
 
     public void doFTP() throws BuildException {
         FTPClient ftp = null;
 
         try {
             task.log("Opening FTP connection to " + task.getServer(), Project.MSG_VERBOSE);
 
             ftp = new FTPClient();
             if (task.isConfigurationSet()) {
                 ftp = FTPConfigurator.configure(ftp, task);
             }
 
             ftp.setRemoteVerificationEnabled(task.getEnableRemoteVerification());
             ftp.connect(task.getServer(), task.getPort());
             if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                 throw new BuildException("FTP connection failed: "
                                          + ftp.getReplyString());
             }
 
             task.log("connected", Project.MSG_VERBOSE);
             task.log("logging in to FTP server", Project.MSG_VERBOSE);
 
             if ((task.getAccount() != null && !ftp.login(task.getUserid(), task.getPassword(), task.getAccount()))
                 || (task.getAccount() == null && !ftp.login(task.getUserid(), task.getPassword()))) {
                 throw new BuildException("Could not login to FTP server");
             }
 
             task.log("login succeeded", Project.MSG_VERBOSE);
 
             if (task.isBinary()) {
                 ftp.setFileType(org.apache.commons.net.ftp.FTP.BINARY_FILE_TYPE);
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not set transfer type: "
                                              + ftp.getReplyString());
                 }
             } else {
                 ftp.setFileType(org.apache.commons.net.ftp.FTP.ASCII_FILE_TYPE);
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not set transfer type: "
                                              + ftp.getReplyString());
                 }
             }
 
             if (task.isPassive()) {
                 task.log("entering passive mode", Project.MSG_VERBOSE);
                 ftp.enterLocalPassiveMode();
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not enter into passive "
                                              + "mode: " + ftp.getReplyString());
                 }
             }
 
             // If an initial command was configured then send it.
             // Some FTP servers offer different modes of operation,
             // E.G. switching between a UNIX file system mode and
             // a legacy file system.
             if (task.getInitialSiteCommand() != null) {
                 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, task.getInitialSiteCommand());
                         }
                     }, "initial site command: " + task.getInitialSiteCommand());
             }
 
 
             // For a unix ftp server you can set the default mask for all files
             // created.
 
             if (task.getUmask() != null) {
                 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, "umask " + task.getUmask());
                         }
                     }, "umask " + task.getUmask());
             }
 
             // If the action is MK_DIR, then the specified remote
             // directory is the directory to create.
 
             if (task.getAction() == FTPTask.MK_DIR) {
                 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             makeRemoteDir(lftp, task.getRemotedir());
                         }
                     }, task.getRemotedir());
             } else if (task.getAction() == FTPTask.SITE_CMD) {
                 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, task.getSiteCommand());
                         }
                     }, "Site Command: " + task.getSiteCommand());
             } else {
                 if (task.getRemotedir() != null) {
                     task.log("changing the remote directory", Project.MSG_VERBOSE);
                     ftp.changeWorkingDirectory(task.getRemotedir());
                     if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                         throw new BuildException("could not change remote "
                                                  + "directory: " + ftp.getReplyString());
                     }
                 }
                 if (task.isNewer() && task.isTimeDiffAuto()) {
                     // in this case we want to find how much time span there is between local
                     // and remote
                     task.setTimeDiffMillis(getTimeDiff(ftp));
                 }
                 task.log(FTPTask.ACTION_STRS[task.getAction()] + " " + FTPTask.ACTION_TARGET_STRS[task.getAction()]);
                 transferFiles(ftp);
             }
 
         } catch (IOException ex) {
             throw new BuildException("error during FTP transfer: " + ex, ex);
         } finally {
             if (ftp != null && ftp.isConnected()) {
                 try {
                     task.log("disconnecting", Project.MSG_VERBOSE);
                     ftp.logout();
                     ftp.disconnect();
                 } catch (IOException ex) {
                     // ignore it
                 }
             }
         }
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/net/RExecTask.java b/src/main/org/apache/tools/ant/taskdefs/optional/net/RExecTask.java
index b6e4b9515..71e97ac9e 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/net/RExecTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/net/RExecTask.java
@@ -1,479 +1,479 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.net;
 
 import org.apache.commons.net.bsd.RExecClient;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.Calendar;
 import java.util.Enumeration;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 
 /**
  * Automates the rexec protocol.
  *
  * @since Ant 1.6
  */
 
 public class RExecTask extends Task {
 
     private static final int PAUSE_TIME = 250;
 
     /**
      *  The userid to login with, if automated login is used
      */
     private String userid  = null;
 
     /**
      *  The password to login with, if automated login is used
      */
     private String password = null;
 
     /**
      *  The command to execute
      */
     private String command = null;
 
     /**
      *  The server to connect to.
      */
     private String server  = null;
 
     /**
      *  The tcp port to connect to.
      */
     private int port = RExecClient.DEFAULT_PORT;
 
     /**
      *  The list of read/write commands for this session
      */
     private Vector rexecTasks = new Vector();
 
     /**
      *  If true, adds a CR to beginning of login script
      */
     private boolean addCarriageReturn = false;
 
     /**
      *  Default time allowed for waiting for a valid response
      *  for all child reads.  A value of 0 means no limit.
      */
     private Integer defaultTimeout = null;
 
     /**
      *  This class is the parent of the Read and Write tasks.
      *  It handles the common attributes for both.
      */
     public class RExecSubTask {
         // CheckStyle:VisibilityModifier OFF - bc
         protected String taskString = "";
         // CheckStyle:VisibilityModifier ON
 
         /**
          * Execute the subtask.
          * @param rexec the client
          * @throws BuildException always as it is not allowed to instantiate this object
          */
         public void execute(AntRExecClient rexec)
                 throws BuildException {
             throw new BuildException("Shouldn't be able instantiate a SubTask directly");
         }
 
         /**
          *  the message as nested text
          * @param s the nested text
          */
         public void addText(String s) {
             setString(getProject().replaceProperties(s));
         }
 
         /**
          * the message as an attribute
          * @param s a <code>String</code> value
          */
         public void setString(String s) {
            taskString += s;
         }
     }
 
     /**
      *  Sends text to the connected server
      */
     public class RExecWrite extends RExecSubTask {
         private boolean echoString = true;
         /**
          * Execute the write exec task.
          * @param rexec the task to use
          * @throws BuildException on error
          */
         public void execute(AntRExecClient rexec)
                throws BuildException {
            rexec.sendString(taskString, echoString);
         }
 
         /**
          * Whether or not the message should be echoed to the log.
          * Defaults to <code>true</code>.
          * @param b a <code>boolean</code> value
          */
         public void setEcho(boolean b) {
            echoString = b;
         }
     }
 
     /**
      *  Reads the output from the connected server
      *  until the required string is found or we time out.
      */
     public class RExecRead extends RExecSubTask {
         private Integer timeout = null;
         /**
          * Execute the read exec task.
          * @param rexec the task to use
          * @throws BuildException on error
          */
         public void execute(AntRExecClient rexec)
                throws BuildException {
             rexec.waitForString(taskString, timeout);
         }
         /**
          *  a timeout value that overrides any task wide timeout.
          * @param i an <code>Integer</code> value
          */
         public void setTimeout(Integer i) {
            this.timeout = i;
         }
 
         /**
          * Sets the default timeout if none has been set already
          * @param defaultTimeout an <code>Integer</code> value
          * @ant.attribute ignore="true"
          */
         public void setDefaultTimeout(Integer defaultTimeout) {
            if (timeout == null) {
               timeout = defaultTimeout;
            }
         }
     }
 
     /**
      *  This class handles the abstraction of the rexec protocol.
      *  Currently it is a wrapper around <a
      *  href="http://jakarta.apache.org/commons/net/index.html">Jakarta
      *  Commons Net</a>.
      */
     public class AntRExecClient extends RExecClient {
         /**
          * Read from the rexec session until the string we are
          * waiting for is found
          * @param s The string to wait on
          */
         public void waitForString(String s) {
             waitForString(s, null);
         }
 
         /**
          * Read from the rexec session until the string we are
          * waiting for is found or the timeout has been reached
          * @param s The string to wait on
          * @param timeout The maximum number of seconds to wait
          */
         public void waitForString(String s, Integer timeout) {
             InputStream is = this.getInputStream();
             try {
                 StringBuffer sb = new StringBuffer();
                 int windowStart = -s.length();
                 if (timeout == null || timeout.intValue() == 0) {
                     while (windowStart < 0
                            || !sb.substring(windowStart).equals(s)) {
                         sb.append((char) is.read());
                         windowStart++;
                     }
                 } else {
                     Calendar endTime = Calendar.getInstance();
                     endTime.add(Calendar.SECOND, timeout.intValue());
                     while (windowStart < 0
                            || !sb.substring(windowStart).equals(s)) {
                         while (Calendar.getInstance().before(endTime)
                             && is.available() == 0) {
                             Thread.sleep(PAUSE_TIME);
                         }
                         if (is.available() == 0) {
                             throw new BuildException(
                                 "Response timed-out waiting for \"" + s + '\"',
                                 getLocation());
                         }
                         sb.append((char) is.read());
                         windowStart++;
                     }
                 }
                 log(sb.toString(), Project.MSG_INFO);
             } catch (BuildException be) {
                 throw be;
             } catch (Exception e) {
                 throw new BuildException(e, getLocation());
             }
         }
 
         /**
          * Write this string to the rexec session.
          * @param s          the string to write
          * @param echoString if true log the string sent
          */
         public void sendString(String s, boolean echoString) {
             OutputStream os = this.getOutputStream();
             try {
                 os.write((s + "\n").getBytes());
                 if (echoString) {
                     log(s, Project.MSG_INFO);
                 }
                 os.flush();
             } catch (Exception e) {
                 throw new BuildException(e, getLocation());
             }
         }
         /**
          * Read from the rexec session until the EOF is found or
          * the timeout has been reached
          * @param timeout The maximum number of seconds to wait
          */
         public void waitForEOF(Integer timeout) {
             InputStream is = this.getInputStream();
             try {
                 StringBuffer sb = new StringBuffer();
                 if (timeout == null || timeout.intValue() == 0) {
                 int read;
                     while ((read = is.read()) != -1) {
                         char c = (char) read;
                         sb.append(c);
                         if (c == '\n') {
                         log(sb.toString(), Project.MSG_INFO);
                         sb.delete(0, sb.length());
                         }
                     }
                 } else {
                     Calendar endTime = Calendar.getInstance();
                     endTime.add(Calendar.SECOND, timeout.intValue());
                 int read = 0;
                     while (read != -1) {
                         while (Calendar.getInstance().before(endTime) && is.available() == 0) {
                             Thread.sleep(PAUSE_TIME);
                         }
                         if (is.available() == 0) {
                         log(sb.toString(), Project.MSG_INFO);
                             throw new BuildException(
                                                      "Response timed-out waiting for EOF",
                                                      getLocation());
                         }
                         read =  is.read();
                         if (read != -1) {
                         char c = (char) read;
                         sb.append(c);
                         if (c == '\n') {
                                 log(sb.toString(), Project.MSG_INFO);
                                 sb.delete(0, sb.length());
                         }
                         }
                     }
                 }
                 if (sb.length() > 0) {
                 log(sb.toString(), Project.MSG_INFO);
                 }
             } catch (BuildException be) {
                 throw be;
             } catch (Exception e) {
                 throw new BuildException(e, getLocation());
             }
         }
 
     }
     /**
      *  A string to wait for from the server.
      *  A subTask &lt;read&gt; tag was found.  Create the object,
      *  Save it in our list, and return it.
      * @return a read sub task
      */
 
     public RExecSubTask createRead() {
         RExecSubTask task = (RExecSubTask) new RExecRead();
         rexecTasks.addElement(task);
         return task;
     }
     /**
      *  Add text to send to the server
      *  A subTask &lt;write&gt; tag was found.  Create the object,
      *  Save it in our list, and return it.
      * @return a write sub task
      */
     public RExecSubTask createWrite() {
         RExecSubTask task = (RExecSubTask) new RExecWrite();
         rexecTasks.addElement(task);
         return task;
     }
     /**
      *  Verify that all parameters are included.
      *  Connect and possibly login.
      *  Iterate through the list of Reads and writes.
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
         /**  A server name is required to continue */
         if (server == null) {
             throw new BuildException("No Server Specified");
         }
         /**  A userid and password must appear together
          *   if they appear.  They are not required.
          */
         if (userid == null && password != null) {
             throw new BuildException("No Userid Specified");
         }
         if (password == null && userid != null) {
             throw new BuildException("No Password Specified");
         }
 
         /**  Create the telnet client object */
         AntRExecClient rexec = null;
         try {
             rexec = new AntRExecClient();
             try {
                 rexec.connect(server, port);
             } catch (IOException e) {
                 throw new BuildException("Can't connect to " + server);
             }
             if (userid != null && password != null && command != null
                 && rexecTasks.size() == 0) {
                 // simple one-shot execution
                 rexec.rexec(userid, password, command);
             } else {
                 // need nested read/write elements
                 handleMultipleTasks(rexec);
             }
 
             /** Keep reading input stream until end of it or time-out */
             rexec.waitForEOF(defaultTimeout);
         } catch (IOException e) {
             throw new BuildException("Error r-executing command", e);
         } finally {
             if (rexec != null && rexec.isConnected()) {
                 try {
                     rexec.disconnect();
                 } catch (IOException e) {
                     throw new BuildException("Error disconnecting from "
                                              + server);
                 }
             }
         }
     }
     /**
      *  Process a 'typical' login.  If it differs, use the read
      *  and write tasks explicitely
      */
     private void login(AntRExecClient rexec) {
         if (addCarriageReturn) {
             rexec.sendString("\n", true);
         }
         rexec.waitForString("ogin:");
         rexec.sendString(userid, true);
         rexec.waitForString("assword:");
         rexec.sendString(password, false);
     }
     /**
-     * Set the the comand to execute on the server;
+     * Set the the command to execute on the server;
      * @param c a <code>String</code> value
      */
     public void setCommand(String c) {
         this.command = c;
     }
 
     /**
      *  send a carriage return after connecting; optional, defaults to false.
      * @param b a <code>boolean</code> value
      */
     public void setInitialCR(boolean b) {
         this.addCarriageReturn = b;
     }
     /**
      *  Set the the login password to use
      * required if <tt>userid</tt> is set.
      * @param p a <code>String</code> value
      */
     public void setPassword(String p) {
         this.password = p;
     }
 
     /**
      *  Set the tcp port to connect to; default is 23.
      * @param p an <code>int</code> value
      */
     public void setPort(int p) {
         this.port = p;
     }
 
     /**
      *  Set the hostname or address of the remote server.
      * @param m a <code>String</code> value
      */
     public void setServer(String m) {
         this.server = m;
     }
 
     /**
      * set a default timeout in seconds to wait for a response,
      * zero means forever (the default)
      * @param i an <code>Integer</code> value
      */
     public void setTimeout(Integer i) {
         this.defaultTimeout = i;
     }
     /**
      * Set the the login id to use on the server;
      * required if <tt>password</tt> is set.
      * @param u a <code>String</code> value
      */
     public void setUserid(String u) {
         this.userid = u;
     }
 
     /**
      * Deals with multiple read/write calls.
      *
      * @since Ant 1.6.3
      */
     private void handleMultipleTasks(AntRExecClient rexec) {
 
         /**  Login if userid and password were specified */
         if (userid != null && password != null) {
             login(rexec);
         }
         /**  Process each sub command */
         Enumeration tasksToRun = rexecTasks.elements();
         while (tasksToRun != null && tasksToRun.hasMoreElements()) {
             RExecSubTask task = (RExecSubTask) tasksToRun.nextElement();
             if (task instanceof RExecRead && defaultTimeout != null) {
                 ((RExecRead) task).setDefaultTimeout(defaultTimeout);
             }
             task.execute(rexec);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Resolve.java b/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Resolve.java
index 39cc81e18..3fd7f4725 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Resolve.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Resolve.java
@@ -1,187 +1,187 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 /*
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */
 
 package org.apache.tools.ant.taskdefs.optional.perforce;
 
 import org.apache.tools.ant.BuildException;
 
 /**
  * @ant.task category="scm"
  */
 public class P4Resolve extends P4Base {
     private String resolvemode = null;
 
 
     private boolean redoall; /* -f */
     private boolean simulationmode;  /* -n */
     private boolean forcetextmode;  /* -t */
     private boolean markersforall; /* -v */
     private static final String AUTOMATIC = "automatic";
     private static final String FORCE = "force";
     private static final String SAFE = "safe";
     private static final String THEIRS = "theirs";
     private static final String YOURS = "yours";
     private static final String[] RESOLVE_MODES = {
         AUTOMATIC,
         FORCE,
         SAFE,
         THEIRS,
         YOURS
     };
    /**
     * returns the resolve mode
     * @return  returns the resolve mode
     */
     public String getResolvemode() {
         return resolvemode;
     }
     /**
      * values for resolvemode
      * <ul>
      * <li> automatic -am</li>
      * <li> force -af </li>
      * <li> safe -as </li>
      * <li> theirs -at </li>
      * <li> yours -ay </li>
      * </ul>
      * @param resolvemode one of automatic, force, safe, theirs, yours
      */
     public void setResolvemode(String resolvemode) {
         boolean found = false;
         for (int counter = 0; counter < RESOLVE_MODES.length; counter++) {
             if (resolvemode.equals(RESOLVE_MODES[counter])) {
                 found = true;
                 break;
             }
         }
         if (!found) {
             throw new BuildException("Unacceptable value for resolve mode");
         }
         this.resolvemode = resolvemode;
     }
 
     /**
      * allows previously resolved files to be resolved again
      * @return flag indicating whether one wants to
      * allow previously resolved files to be resolved again
      */
     public boolean isRedoall() {
         return redoall;
     }
 
     /**
      * set the redoall flag
      * @param redoall flag indicating whether one want to
      * allow previously resolved files to be resolved again
      */
     public void setRedoall(boolean redoall) {
         this.redoall = redoall;
     }
 
     /**
      * read the simulation mode flag
      * @return flag indicating whether one wants just to simulate
-     * the p4 resolve operation whithout actually doing it
+     * the p4 resolve operation without actually doing it
      */
     public boolean isSimulationmode() {
         return simulationmode;
     }
 
     /**
      * sets a flag
      * @param simulationmode set to true, lists the integrations which would be performed,
      * without actually doing them.
      */
     public void setSimulationmode(boolean simulationmode) {
         this.simulationmode = simulationmode;
     }
 
     /**
      * If set to true, attempts a textual merge, even for binary files
      * @return flag value
      */
     public boolean isForcetextmode() {
         return forcetextmode;
     }
 
     /**
      * If set to true, attempts a textual merge, even for binary files
      * @param forcetextmode set the flag value
      */
     public void setForcetextmode(boolean forcetextmode) {
         this.forcetextmode = forcetextmode;
     }
 
     /**
      * If set to true, puts in markers for all changes, conflicting or not
      * @return  flag markersforall value
      */
     public boolean isMarkersforall() {
         return markersforall;
     }
 
     /**
       * If set to true, puts in markers for all changes, conflicting or not
      * @param markersforall flag true or false
      */
     public void setMarkersforall(boolean markersforall) {
         this.markersforall = markersforall;
     }
 
     /**
      *  execute the p4 resolve
      * @throws BuildException if there is a wrong resolve mode specified
      *  or no view specified
      */
     public void execute() throws BuildException {
         if (this.resolvemode.equals(AUTOMATIC)) {
             P4CmdOpts = P4CmdOpts + " -am";
         } else if (this.resolvemode.equals(FORCE)) {
             P4CmdOpts = P4CmdOpts + " -af";
         } else if (this.resolvemode.equals(SAFE)) {
             P4CmdOpts = P4CmdOpts + " -as";
         } else if (this.resolvemode.equals(THEIRS)) {
             P4CmdOpts = P4CmdOpts + " -at";
         } else if (this.resolvemode.equals(YOURS)) {
             P4CmdOpts = P4CmdOpts + " -ay";
         } else {
             throw new BuildException("unsupported or absent resolve mode");
         }
         if (P4View == null) {
             throw new BuildException("please specify a view");
         }
         if (this.isRedoall()) {
             P4CmdOpts = P4CmdOpts + " -f";
         }
         if (this.isSimulationmode()) {
             P4CmdOpts = P4CmdOpts + " -n";
         }
         if (this.isForcetextmode()) {
             P4CmdOpts = P4CmdOpts + " -t";
         }
         if (this.isMarkersforall()) {
             P4CmdOpts = P4CmdOpts + " -v";
         }
         execP4Command("-s resolve " + P4CmdOpts + " " + P4View, new SimpleP4OutputHandler(this));
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/sos/SOS.java b/src/main/org/apache/tools/ant/taskdefs/optional/sos/SOS.java
index d7805b0a5..8c1992a59 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/sos/SOS.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/sos/SOS.java
@@ -1,478 +1,478 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.sos;
 
 import java.io.File;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.Execute;
 import org.apache.tools.ant.taskdefs.LogStreamHandler;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * A base class for creating tasks for executing commands on SourceOffSite.
  *
  *  These tasks were inspired by the VSS tasks.
  *
  */
 
 public abstract class SOS extends Task implements SOSCmd {
 
     private static final int ERROR_EXIT_STATUS = 255;
 
     private String sosCmdDir = null;
     private String sosUsername = null;
     private String sosPassword = "";
     private String projectPath = null;
     private String vssServerPath = null;
     private String sosServerPath = null;
     private String sosHome = null;
     private String localPath = null;
     private String version = null;
     private String label = null;
     private String comment = null;
     private String filename = null;
 
     private boolean noCompress = false;
     private boolean noCache = false;
     private boolean recursive = false;
     private boolean verbose = false;
 
     // CheckStyle:VisibilityModifier OFF - bc
     /** Commandline to be executed. */
     protected Commandline commandLine;
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Flag to disable the cache when set.
      * Required if SOSHOME is set as an environment variable.
      * Defaults to false.
      *
      * @param  nocache  True to disable caching.
      */
     public final void setNoCache(boolean nocache) {
         noCache = nocache;
     }
 
     /**
      * Flag to disable compression when set. Defaults to false.
      *
      * @param  nocompress  True to disable compression.
      */
     public final void setNoCompress(boolean nocompress) {
         noCompress = nocompress;
     }
 
     /**
      * The directory where soscmd(.exe) is located.
      * soscmd must be on the path if omitted.
      *
      * @param  dir  The new sosCmd value.
      */
     public final void setSosCmd(String dir) {
         sosCmdDir = FileUtils.translatePath(dir);
     }
 
     /**
      * The SourceSafe username.
      *
      * @param  username  The new username value.
      *
      * @ant.attribute group="required"
      */
     public final void setUsername(String username) {
         sosUsername = username;
     }
 
     /**
      * The SourceSafe password.
      *
      * @param  password  The new password value.
      */
     public final void setPassword(String password) {
         sosPassword = password;
     }
 
     /**
      * The SourceSafe project path.
      *
      * @param  projectpath  The new projectpath value.
      *
      * @ant.attribute group="required"
      */
     public final void setProjectPath(String projectpath) {
         if (projectpath.startsWith(SOSCmd.PROJECT_PREFIX)) {
             projectPath = projectpath;
         } else {
             projectPath = SOSCmd.PROJECT_PREFIX + projectpath;
         }
     }
 
     /**
      * The path to the location of the ss.ini file.
      *
      * @param  vssServerPath  The new vssServerPath value.
      *
      * @ant.attribute group="required"
      */
     public final void setVssServerPath(String vssServerPath) {
         this.vssServerPath = vssServerPath;
     }
 
     /**
      * Path to the SourceOffSite home directory.
      *
      * @param  sosHome  The new sosHome value.
      */
     public final void setSosHome(String sosHome) {
         this.sosHome = sosHome;
     }
 
     /**
      * The address and port of SourceOffSite Server,
      * for example 192.168.0.1:8888.
      *
      * @param  sosServerPath  The new sosServerPath value.
      *
      * @ant.attribute group="required"
      */
     public final void setSosServerPath(String sosServerPath) {
         this.sosServerPath = sosServerPath;
     }
 
     /**
      * Override the working directory and get to the specified path.
      *
      * @param  path  The new localPath value.
      */
     public final void setLocalPath(Path path) {
         localPath = path.toString();
     }
 
     /**
      * Enable verbose output. Defaults to false.
      *
      * @param  verbose  True for verbose output.
      */
     public void setVerbose(boolean verbose) {
         this.verbose = verbose;
     }
 
     // Special setters for the sub-classes
 
     /**
      * Set the file name.
      * @param file the filename to use.
      */
     protected void setInternalFilename(String file) {
         filename = file;
     }
 
     /**
      * Set the recursive flag.
      * @param recurse if true use the recursive flag on the command line.
      */
     protected void setInternalRecursive(boolean recurse) {
         recursive = recurse;
     }
 
     /**
      * Set the comment text.
      * @param text the comment text to use.
      */
     protected void setInternalComment(String text) {
         comment = text;
     }
 
     /**
      * Set the label.
      * @param text the label to use.
      */
     protected void setInternalLabel(String text) {
         label = text;
     }
 
     /**
      * Set the version.
      * @param text the version to use.
      */
     protected void setInternalVersion(String text) {
         version = text;
     }
 
     /**
-     * Get the executable to run. Add the path if it was specifed in the build file
+     * Get the executable to run. Add the path if it was specified in the build file
      *
      * @return the executable to run.
      */
     protected String getSosCommand() {
         if (sosCmdDir == null) {
             return COMMAND_SOS_EXE;
         } else {
             return sosCmdDir + File.separator + COMMAND_SOS_EXE;
         }
     }
 
     /**
      * Get the comment
      * @return if it was set, null if not.
      */
     protected String getComment() {
         return comment;
     }
 
     /**
      * Get the version
      * @return if it was set, null if not.
      */
     protected String getVersion() {
         return version;
     }
 
     /**
      * Get the label
      * @return if it was set, null if not.
      */
     protected String getLabel() {
         return label;
     }
 
     /**
      * Get the username
      * @return if it was set, null if not.
      */
     protected String getUsername() {
         return sosUsername;
     }
 
     /**
      * Get the password
      * @return empty string if it wasn't set.
      */
     protected String getPassword() {
         return sosPassword;
     }
 
     /**
      * Get the project path
      * @return if it was set, null if not.
      */
     protected String getProjectPath() {
         return projectPath;
     }
 
     /**
      * Get the VSS server path
      * @return if it was set, null if not.
      */
     protected String getVssServerPath() {
         return vssServerPath;
     }
 
     /**
      * Get the SOS home directory.
      * @return if it was set, null if not.
      */
     protected String getSosHome() {
         return sosHome;
     }
 
     /**
      * Get the SOS serve path.
      * @return if it was set, null if not.
      */
     protected String getSosServerPath() {
         return sosServerPath;
     }
 
     /**
      * Get the filename to be acted upon.
      * @return if it was set, null if not.
      */
     protected String getFilename() {
         return filename;
     }
 
     /**
      * Get the NoCompress flag.
      *
      * @return the 'nocompress' Flag if the attribute was 'true',
      *         otherwise an empty string.
      */
     protected String getNoCompress() {
         return noCompress ? FLAG_NO_COMPRESSION : "";
     }
 
     /**
      * Get the NoCache flag.
      *
      * @return the 'nocache' Flag if the attribute was 'true', otherwise an empty string.
      */
     protected String getNoCache() {
         return noCache ? FLAG_NO_CACHE : "";
     }
 
     /**
      * Get the 'verbose' Flag.
      *
      * @return the 'verbose' Flag if the attribute was 'true', otherwise an empty string.
      */
     protected String getVerbose() {
         return verbose ? FLAG_VERBOSE : "";
     }
 
     /**
      * Get the 'recursive' Flag.
      *
      * @return the 'recursive' Flag if the attribute was 'true', otherwise an empty string.
      */
     protected String getRecursive() {
         return recursive ? FLAG_RECURSION : "";
     }
 
     /**
      * Builds and returns the working directory.
      * <p>
      * The localpath is created if it didn't exist.
      *
      * @return the absolute path of the working directory.
      */
     protected String getLocalPath() {
         if (localPath == null) {
             return getProject().getBaseDir().getAbsolutePath();
         } else {
             // make sure localDir exists, create it if it doesn't
             File dir = getProject().resolveFile(localPath);
             if (!dir.exists()) {
                 boolean done = dir.mkdirs();
                 if (!done) {
                     String msg = "Directory " + localPath + " creation was not "
                         + "successful for an unknown reason";
                     throw new BuildException(msg, getLocation());
                 }
                 getProject().log("Created dir: " + dir.getAbsolutePath());
             }
             return dir.getAbsolutePath();
         }
     }
 
     /**
      * Subclasses implement the logic required to construct the command line.
      *
      * @return   The command line to execute.
      */
     abstract Commandline buildCmdLine();
 
 
     /**
      * Execute the created command line.
      *
      * @throws BuildException on error.
      */
     public void execute()
         throws BuildException {
         int result = 0;
         buildCmdLine();
         result = run(commandLine);
         if (result == ERROR_EXIT_STATUS) {  // This is the exit status
             String msg = "Failed executing: " + commandLine.toString();
             throw new BuildException(msg, getLocation());
         }
     }
 
     /**
      * Execute the created command line.
      *
      * @param  cmd              The command line to run.
      * @return                  int the exit code.
      * @throws  BuildException
      */
     protected int run(Commandline cmd) {
         try {
             Execute exe = new Execute(new LogStreamHandler(this,
                     Project.MSG_INFO,
                     Project.MSG_WARN));
 
             exe.setAntRun(getProject());
             exe.setWorkingDirectory(getProject().getBaseDir());
             exe.setCommandline(cmd.getCommandline());
             exe.setVMLauncher(false);  // Use the OS VM launcher so we get environment variables
             return exe.execute();
         } catch (java.io.IOException e) {
             throw new BuildException(e, getLocation());
         }
     }
 
     /** Sets the executable and add the required attributes to the command line. */
     protected void getRequiredAttributes() {
         // Get the path to the soscmd(.exe)
         commandLine.setExecutable(getSosCommand());
         // SOS server address is required
         if (getSosServerPath() == null) {
             throw new BuildException("sosserverpath attribute must be set!", getLocation());
         }
         commandLine.createArgument().setValue(FLAG_SOS_SERVER);
         commandLine.createArgument().setValue(getSosServerPath());
         // Login info is required
         if (getUsername() == null) {
             throw new BuildException("username attribute must be set!", getLocation());
         }
         commandLine.createArgument().setValue(FLAG_USERNAME);
         commandLine.createArgument().setValue(getUsername());
         // The SOS class knows that the SOS server needs the password flag,
         // even if there is no password ,so we send a " "
         commandLine.createArgument().setValue(FLAG_PASSWORD);
         commandLine.createArgument().setValue(getPassword());
         // VSS Info is required
         if (getVssServerPath() == null) {
             throw new BuildException("vssserverpath attribute must be set!", getLocation());
         }
         commandLine.createArgument().setValue(FLAG_VSS_SERVER);
         commandLine.createArgument().setValue(getVssServerPath());
         // VSS project is required
         if (getProjectPath() == null) {
             throw new BuildException("projectpath attribute must be set!", getLocation());
         }
         commandLine.createArgument().setValue(FLAG_PROJECT);
         commandLine.createArgument().setValue(getProjectPath());
     }
 
     /** Adds the optional attributes to the command line. */
     protected void getOptionalAttributes() {
         // -verbose
         commandLine.createArgument().setValue(getVerbose());
         // Disable Compression
         commandLine.createArgument().setValue(getNoCompress());
         // Path to the SourceOffSite home directory /home/user/.sos
         if (getSosHome() == null) {
             // If -soshome was not specified then we can look for nocache
             commandLine.createArgument().setValue(getNoCache());
         } else {
             commandLine.createArgument().setValue(FLAG_SOS_HOME);
             commandLine.createArgument().setValue(getSosHome());
         }
         //If a working directory was specified then add it to the command line
         if (getLocalPath() != null) {
             commandLine.createArgument().setValue(FLAG_WORKING_DIR);
             commandLine.createArgument().setValue(getLocalPath());
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/sound/SoundTask.java b/src/main/org/apache/tools/ant/taskdefs/optional/sound/SoundTask.java
index b55470a72..f2ebae83e 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/sound/SoundTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/sound/SoundTask.java
@@ -1,192 +1,192 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.sound;
 
 import java.io.File;
 import java.util.Random;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 
 /**
  * Plays a sound file at the end of the build, according to whether the build failed or succeeded.
  *
  * There are three attributes to be set:
  *
  * <code>source</code>: the location of the audio file to be played
  * <code>duration</code>: play the sound file continuously until "duration" milliseconds has expired
  * <code>loops</code>: the number of times the sound file should be played until stopped
  *
  * I have only tested this with .WAV and .AIFF sound file formats. Both seem
  * to work fine.
  *
  * plans for the future:
  * - use the midi api to define sounds (or drum beat etc) in xml and have
  *   Ant play them back
  *
  */
 
 public class SoundTask extends Task {
 
     private BuildAlert success = null;
     private BuildAlert fail = null;
 
     /**
      * add a sound when the build succeeds
      * @return a BuildAlert to be configured
      */
     public BuildAlert createSuccess() {
         success = new BuildAlert();
         return success;
     }
 
     /**
      * add a sound when the build fails
      * @return a BuildAlert to be configured
      */
     public BuildAlert createFail() {
         fail = new BuildAlert();
         return fail;
      }
 
     /** Constructor for SoundTask. */
     public SoundTask() {
     }
 
     /**
      * Initialize the task.
      */
     public void init() {
     }
 
     /**
      * Execute the task.
      */
     public void execute() {
 
         AntSoundPlayer soundPlayer = new AntSoundPlayer();
 
         if (success == null) {
             log("No nested success element found.", Project.MSG_WARN);
         } else {
             soundPlayer.addBuildSuccessfulSound(success.getSource(),
               success.getLoops(), success.getDuration());
         }
 
         if (fail == null) {
             log("No nested failure element found.", Project.MSG_WARN);
         } else {
             soundPlayer.addBuildFailedSound(fail.getSource(),
               fail.getLoops(), fail.getDuration());
         }
 
         getProject().addBuildListener(soundPlayer);
 
     }
 
     /**
      * A class to be extended by any BuildAlert's that require the output
      * of sound.
      */
     public class BuildAlert {
         private File source = null;
         private int loops = 0;
         private Long duration = null;
 
         /**
          * Sets the duration in milliseconds the file should be played; optional.
-         * @param duration the duration in millisconds
+         * @param duration the duration in milliseconds
          */
         public void setDuration(Long duration) {
             this.duration = duration;
         }
 
         /**
          * Sets the location of the file to get the audio; required.
          *
          * @param source the name of a sound-file directory or of the audio file
          */
         public void setSource(File source) {
             this.source = source;
         }
 
         /**
          * Sets the number of times the source file should be played; optional.
          *
          * @param loops the number of loops to play the source file
          */
         public void setLoops(int loops) {
             this.loops = loops;
         }
 
         /**
          * Gets the location of the file to get the audio.
          * @return the file location
          */
         public File getSource() {
             File nofile = null;
             // Check if source is a directory
             if (source.exists()) {
                 if (source.isDirectory()) {
                     // get the list of files in the dir
                     String[] entries = source.list();
                     Vector files = new Vector();
                     for (int i = 0; i < entries.length; i++) {
                         File f = new File(source, entries[i]);
                         if (f.isFile()) {
                             files.addElement(f);
                         }
                     }
                     if (files.size() < 1) {
                         throw new BuildException("No files found in directory " + source);
                     }
                     int numfiles = files.size();
                     // get a random number between 0 and the number of files
                     Random rn = new Random();
                     int x = rn.nextInt(numfiles);
                     // set the source to the file at that location
                     this.source = (File) files.elementAt(x);
                 }
             } else {
                 log(source + ": invalid path.", Project.MSG_WARN);
                 this.source = nofile;
             }
             return this.source;
         }
 
         /**
          * Sets the number of times the source file should be played.
          *
          * @return the number of loops to play the source file
          */
         public int getLoops() {
             return this.loops;
         }
 
         /**
          * Gets the duration in milliseconds the file should be played.
          * @return the duration in milliseconds
          */
         public Long getDuration() {
             return this.duration;
         }
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/splash/SplashTask.java b/src/main/org/apache/tools/ant/taskdefs/optional/splash/SplashTask.java
index 10c53c358..2a87854e5 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/splash/SplashTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/splash/SplashTask.java
@@ -1,289 +1,289 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.splash;
 
 import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.net.URLConnection;
 import javax.swing.ImageIcon;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.util.Base64Converter;
 import org.apache.tools.ant.taskdefs.optional.net.SetProxy;
 
 /**
  * Creates a splash screen. The splash screen is displayed
  * for the duration of the build and includes a handy progress bar as
  * well. Use in conjunction with the sound task to provide interest
  * whilst waiting for your builds to complete...
  * @since Ant1.5
  */
 public class SplashTask extends Task {
     private static final int DEFAULT_SHOW_DURATION = 5000;
 
     private String imgurl = null;
     private String proxy = null;
     private String user = null;
     private String password = null;
     private String port = "80";
     private int showDuration = DEFAULT_SHOW_DURATION;
     private boolean useProxy = false;
     private String progressRegExp = null;
     private String displayText = null;
 
     private static SplashScreen splash = null;
 
     /**
      * A URL pointing to an image to display; optional, default antlogo.gif
      * from the classpath.
      * @param imgurl the url string pointing to the image
      */
     public void setImageURL(String imgurl) {
         this.imgurl = imgurl;
     }
 
     /**
      * flag to enable proxy settings; optional, deprecated : consider
      * using &lt;setproxy&gt; instead
      * @param useProxy if ture, enable proxy settings
      * @deprecated since 1.5.x.
      *             Use org.apache.tools.ant.taskdefs.optional.net.SetProxy
      */
     public void setUseproxy(boolean useProxy) {
         this.useProxy = useProxy;
     }
 
     /**
      * name of proxy; optional.
      * @param proxy the name of the proxy host
      * @deprecated since 1.5.x.
      *             Use org.apache.tools.ant.taskdefs.optional.net.SetProxy
      */
     public void setProxy(String proxy) {
         this.proxy = proxy;
     }
 
     /**
      * Proxy port; optional, default 80.
      * @param port the proxy port
      * @deprecated since 1.5.x.
      *             Use org.apache.tools.ant.taskdefs.optional.net.SetProxy
      */
     public void setPort(String port) {
         this.port = port;
     }
 
     /**
      * Proxy user; optional, default =none.
      * @param user the proxy user
      * @deprecated since 1.5.x.
      *             Use org.apache.tools.ant.taskdefs.optional.net.SetProxy
      */
     public void setUser(String user) {
         this.user = user;
     }
 
     /**
      * Proxy password; required if <tt>user</tt> is set.
      * @param password the proxy password
      * @deprecated since 1.5.x.
      *             Use org.apache.tools.ant.taskdefs.optional.net.SetProxy
      */
     public void setPassword(String password) {
         this.password = password;
     }
 
     /**
      * how long to show the splash screen in milliseconds,
      * optional; default 5000 ms.
-     * @param duration the spash duration in milliseconds
+     * @param duration the splash duration in milliseconds
      */
     public void setShowduration(int duration) {
         this.showDuration = duration;
     }
 
 
     /**
      * Progress regular expression which is used to parse the output
      * and dig out current progress optional; if not provided,
      * progress is increased every action and log output line
      * @param progressRegExp Progress regular expression, exactly one
      * group pattern must exists, and it represents the progress
      * number (0-100) (i.e "Progress: (.*)%")
      * @since Ant 1.8.0
      */
     public void setProgressRegExp(String progressRegExp) {
         this.progressRegExp = progressRegExp;
     }
 
     /**
      * Sets the display text presented in the splash window.
      * optional; defaults to "Building ..." 
      * @param displayText the display text presented the splash window
      * @since Ant 1.8.0
      */
     public void setDisplayText(String displayText) {
         this.displayText = displayText;
     }
 
     /**
      * Execute the task.
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
         if (splash != null) {
             splash.setVisible(false);
             getProject().removeBuildListener(splash);
             splash.dispose();
             splash = null;
         }
 
         log("Creating new SplashScreen", Project.MSG_VERBOSE);
         InputStream in = null;
 
         if (imgurl != null) {
             try {
                 URLConnection conn = null;
 
                 SetProxy sp = new SetProxy();
                 sp.setProxyHost(proxy);
                 if (port != null) {
                     sp.setProxyPort(Integer.parseInt(port));
                 }
                 sp.setProxyUser(user);
                 sp.setProxyPassword(password);
                 sp.applyWebProxySettings();
 
                 if (useProxy && (proxy != null && proxy.length() > 0)
                     && (port != null && port.length() > 0)) {
 
                     log("Using proxied Connection",  Project.MSG_DEBUG);
                     System.getProperties().put("http.proxySet", "true");
 
                     URL url = new URL(imgurl);
 
                     conn = url.openConnection();
                     if (user != null && user.length() > 0) {
                         // converted from sun internal classes to
                         // new Base64Converter
                         // utility class extracted from Get task
                         String encodedcreds =
                             new Base64Converter().encode(user + ":" + password);
                         conn.setRequestProperty("Proxy-Authorization",
                                                 encodedcreds);
                     }
 
                 } else {
                     System.getProperties().put("http.proxySet", "false");
                     log("Using Direction HTTP Connection", Project.MSG_DEBUG);
                     URL url = new URL(imgurl);
                     conn = url.openConnection();
                 }
                 conn.setDoInput(true);
                 conn.setDoOutput(false);
 
                 in = conn.getInputStream();
 
                 // Catch everything - some of the above return nulls,
                 // throw exceptions or generally misbehave
                 // in the event of a problem etc
 
             } catch (Throwable ioe) {
                 log("Unable to download image, trying default Ant Logo",
                     Project.MSG_DEBUG);
                 log("(Exception was \"" + ioe.getMessage() + "\"",
                     Project.MSG_DEBUG);
             }
         }
 
         if (in == null) {
             ClassLoader cl = SplashTask.class.getClassLoader();
             if (cl != null) {
                 in = cl.getResourceAsStream("images/ant_logo_large.gif");
             } else {
                 in = ClassLoader
                     .getSystemResourceAsStream("images/ant_logo_large.gif");
             }
         }
 
         boolean success = false;
         if (in != null) {
             DataInputStream din = new DataInputStream(in);
             try {
                 ByteArrayOutputStream bout = new ByteArrayOutputStream();
                 int data;
                 while ((data = din.read()) != -1) {
                     bout.write((byte) data);
                 }
 
                 log("Got ByteArray, creating splash",  Project.MSG_DEBUG);
 
                 try {
                     ImageIcon img = new ImageIcon(bout.toByteArray());
                     splash = new SplashScreen(img, progressRegExp, displayText);
                     success = true;
                 } catch (Throwable e) {
                     logHeadless(e);
                 }
             } catch (Exception e) {
                 throw new BuildException(e);
             } finally {
                 try {
                     din.close();
                 } catch (IOException ioe) {
                     // swallow if there was an error before so that
                     // original error will be passed up
                     if (success) {
                         throw new BuildException(ioe);
                     }
                 }
             }
         } else {
             try {
                 splash = new SplashScreen("Image Unavailable.", progressRegExp,
                                           displayText);
                 success = true;
             } catch (Throwable e) {
                 logHeadless(e);
             }
         }
 
         if (success) {
             splash.setVisible(true);
             splash.toFront();
             getProject().addBuildListener(splash);
             try {
                 Thread.sleep(showDuration);
             } catch (InterruptedException e) {
                 // Ignore Exception
             }
         }
     }
 
     private void logHeadless(Throwable e) {
         log("failed to display SplashScreen, caught "
             + e.getClass().getName() + " with message: " + e.getMessage(),
             Project.MSG_WARN);
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ssh/Directory.java b/src/main/org/apache/tools/ant/taskdefs/optional/ssh/Directory.java
index 439cb40e5..f25ec7d95 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ssh/Directory.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ssh/Directory.java
@@ -1,195 +1,195 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.ssh;
 
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.io.File;
 
 /**
  * A helper object for Scp representing a directory in a file system.
  */
 public class Directory {
 
     private File directory;
     private Set childDirectories;
     private ArrayList files;
     private Directory parent;
 
     /**
      * Constructor for a Directory.
      * @param directory a directory.
      */
     public Directory(File directory) {
         this(directory,  null);
     }
 
     /**
      * Constructor for a Directory.
      * @param directory a directory
      * @param parent    a parent Directory
      */
     public Directory(File directory , Directory parent) {
         this.parent = parent;
         this.childDirectories = new LinkedHashSet();
         this.files = new ArrayList();
         this.directory = directory;
     }
 
     /**
      * Add a directory to the child directories.
      * @param directory a Directory
      */
     public void addDirectory(Directory directory) {
         if (!childDirectories.contains(directory)) {
             childDirectories.add(directory);
         }
     }
 
     /**
      * Add a file to the list of files.
      * @param file a file to add
      */
     public void addFile(File file) {
         files.add(file);
     }
 
     /**
      * Get an iterator over the child Directories.
      * @return an iterator
      */
     public Iterator directoryIterator() {
         return childDirectories.iterator();
     }
 
     /**
      * Get an iterator over the files.
      * @return an iterator
      */
     public Iterator filesIterator() {
         return files.iterator();
     }
 
     /**
      * Get the parent Directory.
      * @return the parent Directory.
      */
     public Directory getParent() {
         return parent;
     }
 
     /**
      * Is this a root Directory?
      * @return true if there is no parent Directory
      */
     public boolean isRoot() {
         return parent == null;
     }
 
     /**
      * Get the directory file.
      * @return the directory file
      */
     public File getDirectory() {
         return directory;
     }
 
     /**
      * Get a child directory of this directory.
      * @param dir the directory to look for
      * @return the child directory, or null if not found
      */
     public Directory getChild(File dir) {
         for (Iterator i = childDirectories.iterator(); i.hasNext(); ) {
             Directory current = (Directory) i.next();
             if (current.getDirectory().equals(dir)) {
                 return current;
             }
         }
 
         return null;
     }
 
     /**
      * The equality method.
      * This checks if the directory field is the same.
      * @param obj the object to compare to
      * @return true if this object has an equal directory field as the other object
      */
     public boolean equals(Object obj) {
         if (obj == this) {
             return true;
         }
 
         if (!(obj instanceof Directory)) {
             return false;
         }
 
         Directory d = (Directory) obj;
 
         return this.directory.equals(d.directory);
     }
 
     /**
      * The hashcode method.
      * @return the hash code of the directory field
      */
     public int hashCode() {
         return directory.hashCode();
     }
 
     /**
      * Get the path components of this directory.
      * @return the path components as an array of strings.
      */
     public String[] getPath() {
         return getPath(directory.getAbsolutePath());
     }
 
     /**
      * Convert a file path to an array of path components.
-     * This uses File.sepatator to split the file path string.
+     * This uses File.separator to split the file path string.
      * @param thePath the file path string to convert
      * @return an array of path components
      */
     public static String[] getPath(String thePath) {
         StringTokenizer tokenizer = new StringTokenizer(thePath,
                 File.separator);
         String[] path = new String[ tokenizer.countTokens() ];
 
         int i = 0;
         while (tokenizer.hasMoreTokens()) {
             path[i] = tokenizer.nextToken();
             i++;
         }
 
         return path;
     }
 
     /**
      * Get the number of files in the files attribute.
      * @return the number of files
      */
     public int fileSize() {
         return files.size();
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ssh/LogListener.java b/src/main/org/apache/tools/ant/taskdefs/optional/ssh/LogListener.java
index 824e257ec..41209ceb9 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ssh/LogListener.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ssh/LogListener.java
@@ -1,30 +1,30 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.ssh;
 
 /**
  * Interface for ssh log listeners to implement.
  */
 public interface LogListener {
     /**
-     * Method for the loglistener to implement to recieve log messages.
+     * Method for the loglistener to implement to receive log messages.
      * @param message the message to log
      */
     void log(String message);
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ssh/SSHBase.java b/src/main/org/apache/tools/ant/taskdefs/optional/ssh/SSHBase.java
index 1c56bb2d5..9250be93a 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ssh/SSHBase.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ssh/SSHBase.java
@@ -1,234 +1,234 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.ssh;
 
 import com.jcraft.jsch.JSchException;
 import com.jcraft.jsch.Session;
 import com.jcraft.jsch.JSch;
 
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 
 /**
  * Base class for Ant tasks using jsch.
  *
  * @since Ant 1.6
  */
 public abstract class SSHBase extends Task implements LogListener {
 
     /** Default listen port for SSH daemon */
     private static final int SSH_PORT = 22;
 
     private String host;
     private String knownHosts;
     private int port = SSH_PORT;
     private boolean failOnError = true;
     private boolean verbose;
     private SSHUserInfo userInfo;
 
     /**
      * Constructor for SSHBase.
      */
     public SSHBase() {
         super();
         userInfo = new SSHUserInfo();
     }
 
     /**
      * Remote host, either DNS name or IP.
      *
      * @param host  The new host value
      */
     public void setHost(String host) {
         this.host = host;
     }
 
     /**
      * Get the host.
      * @return the host
      */
     public String getHost() {
         return host;
     }
 
     /**
      * Set the failonerror flag.
      * Default is true
      * @param failure if true throw a build exception when a failure occuries,
      *                otherwise just log the failure and continue
      */
     public void setFailonerror(boolean failure) {
         failOnError = failure;
     }
 
     /**
      * Get the failonerror flag.
      * @return the failonerror flag
      */
     public boolean getFailonerror() {
         return failOnError;
     }
 
     /**
      * Set the verbose flag.
      * @param verbose if true output more verbose logging
      * @since Ant 1.6.2
      */
     public void setVerbose(boolean verbose) {
         this.verbose = verbose;
     }
 
     /**
      * Get the verbose flag.
      * @return the verbose flag
      * @since Ant 1.6.2
      */
     public boolean getVerbose() {
         return verbose;
     }
 
     /**
      * Username known to remote host.
      *
      * @param username  The new username value
      */
     public void setUsername(String username) {
         userInfo.setName(username);
     }
 
 
     /**
      * Sets the password for the user.
      *
      * @param password  The new password value
      */
     public void setPassword(String password) {
         userInfo.setPassword(password);
     }
 
     /**
      * Sets the keyfile for the user.
      *
      * @param keyfile  The new keyfile value
      */
     public void setKeyfile(String keyfile) {
         userInfo.setKeyfile(keyfile);
     }
 
     /**
      * Sets the passphrase for the users key.
      *
      * @param passphrase  The new passphrase value
      */
     public void setPassphrase(String passphrase) {
         userInfo.setPassphrase(passphrase);
     }
 
     /**
      * Sets the path to the file that has the identities of
      * all known hosts.  This is used by SSH protocol to validate
      * the identity of the host.  The default is
      * <i>${user.home}/.ssh/known_hosts</i>.
      *
      * @param knownHosts a path to the known hosts file.
      */
     public void setKnownhosts(String knownHosts) {
         this.knownHosts = knownHosts;
     }
 
     /**
      * Setting this to true trusts hosts whose identity is unknown.
      *
      * @param yesOrNo if true trust the identity of unknown hosts.
      */
     public void setTrust(boolean yesOrNo) {
         userInfo.setTrust(yesOrNo);
     }
 
     /**
      * Changes the port used to connect to the remote host.
      *
      * @param port port number of remote host.
      */
     public void setPort(int port) {
         this.port = port;
     }
 
     /**
      * Get the port attribute.
      * @return the port
      */
     public int getPort() {
         return port;
     }
 
     /**
      * Initialize the task.
      * This initializizs the known hosts and sets the default port.
      * @throws BuildException on error
      */
     public void init() throws BuildException {
         super.init();
         this.knownHosts = System.getProperty("user.home") + "/.ssh/known_hosts";
         this.port = SSH_PORT;
     }
 
     /**
-     * Open an ssh seession.
+     * Open an ssh session.
      * @return the opened session
      * @throws JSchException on error
      */
     protected Session openSession() throws JSchException {
         JSch jsch = new JSch();
         final SSHBase base = this;
         if(verbose) {
         	JSch.setLogger(new com.jcraft.jsch.Logger(){
         		public boolean isEnabled(int level){
         			return true;
         		}
         		public void log(int level, String message){
         			base.log(message, Project.MSG_INFO);
         		}
         	});
         }
         if (null != userInfo.getKeyfile()) {
             jsch.addIdentity(userInfo.getKeyfile());
         }
 
         if (!userInfo.getTrust() && knownHosts != null) {
             log("Using known hosts: " + knownHosts, Project.MSG_DEBUG);
             jsch.setKnownHosts(knownHosts);
         }
 
         Session session = jsch.getSession(userInfo.getName(), host, port);
         session.setUserInfo(userInfo);
         log("Connecting to " + host + ":" + port);
         session.connect();
         return session;
     }
 
     /**
      * Get the user information.
      * @return the user information
      */
     protected SSHUserInfo getUserInfo() {
         return userInfo;
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ssh/Scp.java b/src/main/org/apache/tools/ant/taskdefs/optional/ssh/Scp.java
index 67421d964..a67dc56dc 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ssh/Scp.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ssh/Scp.java
@@ -1,456 +1,456 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.ssh;
 
 import com.jcraft.jsch.JSchException;
 import com.jcraft.jsch.Session;
 
 import java.io.IOException;
 import java.io.File;
 
 import java.util.List;
 import java.util.LinkedList;
 import java.util.Iterator;
 import java.util.ArrayList;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.FileSet;
 
 /**
  * Ant task for sending files to remote machine over ssh/scp.
  *
  * @since Ant 1.6
  */
 public class Scp extends SSHBase {
 
     private static final String[] FROM_ATTRS = {
         "file", "localfile", "remotefile" };
 
     private static final String[] TO_ATTRS = {
         "todir", "localtodir", "remotetodir", "localtofile", "remotetofile" };
 
     private String fromUri;
     private String toUri;
     private boolean preserveLastModified = false;
     private List fileSets = null;
     private boolean isFromRemote, isToRemote;
     private boolean isSftp = false;
 
     /**
      * Sets the file to be transferred.  This can either be a remote
      * file or a local file.  Remote files take the form:<br>
      * <i>user:password@host:/directory/path/file.example</i><br>
      * Files to transfer can also include a wildcard to include all
      * files in a remote directory.  For example:<br>
      * <i>user:password@host:/directory/path/*</i><br>
      * @param aFromUri a string representing the file to transfer.
      */
     public void setFile(String aFromUri) {
         setFromUri(aFromUri);
         this.isFromRemote = isRemoteUri(this.fromUri);
     }
 
     /**
      * Sets the location where files will be transferred to.
      * This can either be a remote directory or a local directory.
      * Remote directories take the form of:<br>
      * <i>user:password@host:/directory/path/</i><br>
      * This parameter is required.
 
      * @param aToUri a string representing the target of the copy.
      */
     public void setTodir(String aToUri) {
         setToUri(aToUri);
         this.isToRemote = isRemoteUri(this.toUri);
     }
 
     /**
      * Similiar to {@link #setFile setFile} but explicitly states that
      * the file is a local file.  This is the only way to specify a
      * local file with a @ character.
      * @param aFromUri a string representing the source of the copy.
      * @since Ant 1.6.2
      */
     public void setLocalFile(String aFromUri) {
         setFromUri(aFromUri);
         this.isFromRemote = false;
     }
 
     /**
      * Similiar to {@link #setFile setFile} but explicitly states that
      * the file is a remote file.
      * @param aFromUri a string representing the source of the copy.
      * @since Ant 1.6.2
      */
     public void setRemoteFile(String aFromUri) {
         validateRemoteUri("remoteFile", aFromUri);
         setFromUri(aFromUri);
         this.isFromRemote = true;
      }
 
     /**
      * Similiar to {@link #setTodir setTodir} but explicitly states
      * that the directory is a local.  This is the only way to specify
      * a local directory with a @ character.
      * @param aToUri a string representing the target of the copy.
      * @since Ant 1.6.2
      */
     public void setLocalTodir(String aToUri) {
         setToUri(aToUri);
         this.isToRemote = false;
     }
 
     /**
      * Sets flag to determine if file timestamp from
      * remote system is to be preserved during copy.
      * @since Ant 1.8.0
      */
     public void setPreservelastmodified(boolean yesOrNo) {
     	this.preserveLastModified = yesOrNo;
     }    
 
     /**
      * Similiar to {@link #setTodir setTodir} but explicitly states
      * that the directory is a remote.
      * @param aToUri a string representing the target of the copy.
      * @since Ant 1.6.2
      */
     public void setRemoteTodir(String aToUri) {
         validateRemoteUri("remoteToDir", aToUri);
         setToUri(aToUri);
         this.isToRemote = true;
     }
 
     private static void validateRemoteUri(String type, String aToUri) {
     	if (!isRemoteUri(aToUri)) {
             throw new BuildException(type + " '" + aToUri + "' is invalid. "
                                      + "The 'remoteToDir' attribute must "
                                      + "have syntax like the "
                                      + "following: user:password@host:/path"
                                      + " - the :password part is optional");
     	}
     } 
 
     /**
      * Changes the file name to the given name while receiving it,
      * only useful if receiving a single file.
      * @param aToUri a string representing the target of the copy.
      * @since Ant 1.6.2
      */
     public void setLocalTofile(String aToUri) {
         setToUri(aToUri);
         this.isToRemote = false;
     }
 
     /**
      * Changes the file name to the given name while sending it,
      * only useful if sending a single file.
      * @param aToUri a string representing the target of the copy.
      * @since Ant 1.6.2
      */
     public void setRemoteTofile(String aToUri) {
         validateRemoteUri("remoteToFile", aToUri);
         setToUri(aToUri);
         this.isToRemote = true;
     }
 
     /**
      * Setting this to true to use sftp protocol.
      *
      * @param yesOrNo if true sftp protocol will be used.
      */
     public void setSftp(boolean yesOrNo) {
         isSftp = yesOrNo;
     }
 
     /**
-     * Adds a FileSet tranfer to remote host.  NOTE: Either
+     * Adds a FileSet transfer to remote host.  NOTE: Either
      * addFileSet() or setFile() are required.  But, not both.
      *
      * @param set FileSet to send to remote host.
      */
     public void addFileset(FileSet set) {
         if (fileSets == null) {
             fileSets = new LinkedList();
         }
         fileSets.add(set);
     }
 
     /**
      * Initialize this task.
      * @throws BuildException on error
      */
     public void init() throws BuildException {
         super.init();
         this.toUri = null;
         this.fromUri = null;
         this.fileSets = null;
     }
 
     /**
      * Execute this task.
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
         if (toUri == null) {
             throw exactlyOne(TO_ATTRS);
         }
         if (fromUri == null && fileSets == null) {
             throw exactlyOne(FROM_ATTRS, "one or more nested filesets");
         }
         try {
             if (isFromRemote && !isToRemote) {
                 download(fromUri, toUri);
             } else if (!isFromRemote && isToRemote) {
                 if (fileSets != null) {
                     upload(fileSets, toUri);
                 } else {
                     upload(fromUri, toUri);
                 }
             } else if (isFromRemote && isToRemote) {
                 throw new BuildException(
                     "Copying from a remote server to a remote server is not supported.");
             } else {
                 throw new BuildException("'todir' and 'file' attributes "
                     + "must have syntax like the following: "
                     + "user:password@host:/path");
             }
         } catch (Exception e) {
             if (getFailonerror()) {
                 if(e instanceof BuildException) {
                     BuildException be = (BuildException) e;
                     if(be.getLocation() == null) {
                         be.setLocation(getLocation());
                     }
                     throw be;
                 } else {
                     throw new BuildException(e);
                 }
             } else {
                 log("Caught exception: " + e.getMessage(), Project.MSG_ERR);
             }
         }
     }
 
     private void download(String fromSshUri, String toPath)
         throws JSchException, IOException {
         String file = parseUri(fromSshUri);
 
         Session session = null;
         try {
             session = openSession();
             ScpFromMessage message = null;
             if (!isSftp) {
                 message =
                     new ScpFromMessage(getVerbose(), session, file,
                                        getProject().resolveFile(toPath),
                                        fromSshUri.endsWith("*"),
                                        preserveLastModified);
             } else {
                 message =
                     new ScpFromMessageBySftp(getVerbose(), session, file,
                                              getProject().resolveFile(toPath),
                                              fromSshUri.endsWith("*"),
                                              preserveLastModified);
             }
             log("Receiving file: " + file);
             message.setLogListener(this);
             message.execute();
         } finally {
             if (session != null) {
                 session.disconnect();
             }
         }
     }
 
     private void upload(List fileSet, String toSshUri)
         throws IOException, JSchException {
         String file = parseUri(toSshUri);
 
         Session session = null;
         try {
             List list = new ArrayList(fileSet.size());
             for (Iterator i = fileSet.iterator(); i.hasNext();) {
                 FileSet set = (FileSet) i.next();
                 Directory d = createDirectory(set);
                 if (d != null) {
                     list.add(d);
                 }
             }
             if (!list.isEmpty()) {
                 session = openSession();
                 ScpToMessage message = null;
                 if (!isSftp) {
                     message = new ScpToMessage(getVerbose(), session,
                                                list, file);
                 } else {
                     message = new ScpToMessageBySftp(getVerbose(), session,
                                                      list, file);
                 }
                 message.setLogListener(this);
                 message.execute();
             }
         } finally {
             if (session != null) {
                 session.disconnect();
             }
         }
     }
 
     private void upload(String fromPath, String toSshUri)
         throws IOException, JSchException {
         String file = parseUri(toSshUri);
 
         Session session = null;
         try {
             session = openSession();
             ScpToMessage message = null;
             if (!isSftp) {
                 message =
                     new ScpToMessage(getVerbose(), session,
                                      getProject().resolveFile(fromPath), file);
             } else {
                 message =
                     new ScpToMessageBySftp(getVerbose(), session,
                                            getProject().resolveFile(fromPath),
                                            file);
             }
             message.setLogListener(this);
             message.execute();
         } finally {
             if (session != null) {
                 session.disconnect();
             }
         }
     }
 
     private String parseUri(String uri) {
 
         int indexOfAt = uri.indexOf('@');
         int indexOfColon = uri.indexOf(':');
 
         if (indexOfColon > -1 && indexOfColon < indexOfAt) {
             // user:password@host:/path notation
             // everything upto the last @ before the last : is considered
             // password. (so if the path contains an @ and a : it will not work)
             int indexOfCurrentAt = indexOfAt;
             int indexOfLastColon = uri.lastIndexOf(':');
             while (indexOfCurrentAt > -1 && indexOfCurrentAt < indexOfLastColon)
             {
                 indexOfAt = indexOfCurrentAt;
                 indexOfCurrentAt = uri.indexOf('@', indexOfCurrentAt + 1);
             }
             setUsername(uri.substring(0, indexOfColon));
             setPassword(uri.substring(indexOfColon + 1, indexOfAt));
         } else if (indexOfAt > -1) {
             // no password, will require keyfile
             setUsername(uri.substring(0, indexOfAt));
         } else {
             throw new BuildException("no username was given.  Can't authenticate."); 
         }
 
         if (getUserInfo().getPassword() == null
             && getUserInfo().getKeyfile() == null) {
             throw new BuildException("neither password nor keyfile for user "
                                      + getUserInfo().getName() + " has been "
                                      + "given.  Can't authenticate.");
         }
 
         int indexOfPath = uri.indexOf(':', indexOfAt + 1);
         if (indexOfPath == -1) {
             throw new BuildException("no remote path in " + uri);
         }
 
         setHost(uri.substring(indexOfAt + 1, indexOfPath));
         String remotePath = uri.substring(indexOfPath + 1);
         if (remotePath.equals("")) {
             remotePath = ".";
         }
         return remotePath;
     }
 
     private static boolean isRemoteUri(String uri) {
         boolean isRemote = true;
         int indexOfAt = uri.indexOf('@');
         if (indexOfAt < 0) {
             isRemote = false;
         }
         return isRemote;
     }
 
     private Directory createDirectory(FileSet set) {
         DirectoryScanner scanner = set.getDirectoryScanner(getProject());
         Directory root = new Directory(scanner.getBasedir());
         String[] files = scanner.getIncludedFiles();
         if (files.length != 0) {
             for (int j = 0; j < files.length; j++) {
                 String[] path = Directory.getPath(files[j]);
                 Directory current = root;
                 File currentParent = scanner.getBasedir();
                 for (int i = 0; i < path.length; i++) {
                     File file = new File(currentParent, path[i]);
                     if (file.isDirectory()) {
                         current.addDirectory(new Directory(file));
                         current = current.getChild(file);
                         currentParent = current.getDirectory();
                     } else if (file.isFile()) {
                         current.addFile(file);
                     }
                 }
             }
         } else {
             // skip
             root = null;
         }
         return root;
     }
 
     private void setFromUri(String fromUri) {
         if (this.fromUri != null) {
             throw exactlyOne(FROM_ATTRS);
         }
         this.fromUri = fromUri;
     }
 
     private void setToUri(String toUri) {
         if (this.toUri != null) {
             throw exactlyOne(TO_ATTRS);
         }
         this.toUri = toUri;
     }
 
     private BuildException exactlyOne(String[] attrs) {
         return exactlyOne(attrs, null);
     }
 
     private BuildException exactlyOne(String[] attrs, String alt) {
         StringBuffer buf = new StringBuffer("Exactly one of ").append(
                 '[').append(attrs[0]);
         for (int i = 1; i < attrs.length; i++) {
             buf.append('|').append(attrs[i]);
         }
         buf.append(']');
         if (alt != null) {
             buf.append(" or ").append(alt);
         }
         return new BuildException(buf.append(" is required.").toString());
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/testing/Funtest.java b/src/main/org/apache/tools/ant/taskdefs/optional/testing/Funtest.java
index 910ded4a6..7560cd4f5 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/testing/Funtest.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/testing/Funtest.java
@@ -1,577 +1,577 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.testing;
 
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.TaskAdapter;
 import org.apache.tools.ant.util.WorkerAnt;
 import org.apache.tools.ant.taskdefs.condition.Condition;
 import org.apache.tools.ant.taskdefs.condition.ConditionBase;
 import org.apache.tools.ant.taskdefs.Parallel;
 import org.apache.tools.ant.taskdefs.Sequential;
 import org.apache.tools.ant.taskdefs.WaitFor;
 
 /**
- * Task to provide functional testing under Ant, with a fairly complex worflow of:
+ * Task to provide functional testing under Ant, with a fairly complex workflow of:
  *
  * <ul>
  * <li>Conditional execution</li>
  * <li>Application to start</li>
  * <li>A probe to "waitfor" before running tests</li>
  * <li>A tests sequence</li>
  * <li>A reporting sequence that runs after the tests have finished</li>
  * <li>A "teardown" clause that runs after the rest.</li>
  * <li>Automated termination of the program it executes, if a timeout is not met</li>
  * <li>Checking of a failure property and automatic raising of a fault
  *     (with the text in failureText)
  * if test shutdown and reporting succeeded</li>
  *  </ul>
  *
  * The task is designed to be framework neutral; it will work with JUnit,
  *  TestNG and other test frameworks That can be
  * executed from Ant. It bears a resemblance to the FunctionalTest task from
  * SmartFrog, as the attribute names were
  * chosen to make migration easier. However, this task benefits from the
  * ability to tweak Ant's internals, and so
  * simplify the workflow, and from the experience of using the SmartFrog task.
  * No code has been shared.
  *
  * @since Ant 1.8
  */
 
 public class Funtest extends Task {
 
     /**
      * A condition that must be true before the tests are run. This makes it
      * easier to define complex tests that only
      * run if certain conditions are met, such as OS or network state.
      */
 
     private NestedCondition condition;
 
 
     /**
      * Used internally to set the workflow up
      */
     private Parallel timedTests;
 
     /**
      * Setup runs if the condition is met. Once setup is complete, teardown
      * will be run when the task finishes
      */
     private Sequential setup;
 
     /**
      * The application to run
      */
     private Sequential application;
 
     /**
      * A block that halts the tests until met.
      */
     private BlockFor block;
 
     /**
      * Tests to run
      */
     private Sequential tests;
 
     /**
      * Reporting only runs if the tests were executed. If the block stopped
      * them, reporting is skipped.
      */
     private Sequential reporting;
 
     /**
      * Any teardown operations.
      */
     private Sequential teardown;
 
     /**
      * time for the tests to time out
      */
     private long timeout;
 
     private long timeoutUnitMultiplier = WaitFor.ONE_MILLISECOND;
 
     /**
      * time for the execution to time out.
      */
     private long shutdownTime = 10 * WaitFor.ONE_SECOND;
 
     private long shutdownUnitMultiplier = WaitFor.ONE_MILLISECOND;
 
     /**
      * Name of a property to look for
      */
     private String failureProperty;
 
     /**
      * Message to send when tests failed
      */
     private String failureMessage = "Tests failed";
 
     /**
      * Flag to set to true if you don't care about any shutdown errors.
      * <p/>
      * In that situation, errors raised during teardown are logged but not
      * turned into BuildFault events. Similar to catching and ignoring
      * <code>finally {}</code> clauses in Java/
      */
     private boolean failOnTeardownErrors = true;
 
 
     /**
      * What was thrown in the test run (including reporting)
      */
     private BuildException testException;
     /**
      * What got thrown during teardown
      */
     private BuildException teardownException;
 
     /**
      * Did the application throw an exception
      */
     private BuildException applicationException;
 
     /**
      * Did the task throw an exception
      */
     private BuildException taskException;
 
     /** {@value} */
     public static final String WARN_OVERRIDING = "Overriding previous definition of ";
     /** {@value} */
     public static final String APPLICATION_FORCIBLY_SHUT_DOWN = "Application forcibly shut down";
     /** {@value} */
     public static final String SHUTDOWN_INTERRUPTED = "Shutdown interrupted";
     /** {@value} */
     public static final String SKIPPING_TESTS
         = "Condition failed -skipping tests";
     /** Application exception : {@value} */
     public static final String APPLICATION_EXCEPTION = "Application Exception";
     /** Teardown exception : {@value} */
     public static final String TEARDOWN_EXCEPTION = "Teardown Exception";
 
     /**
      * Log if the definition is overriding something
      *
      * @param name       what is being defined
      * @param definition what should be null if you don't want a warning
      */
     private void logOverride(String name, Object definition) {
         if (definition != null) {
             log(WARN_OVERRIDING + '<' + name + '>', Project.MSG_INFO);
         }
     }
 
     /**
       * Add a condition element.
       * @return <code>ConditionBase</code>.
       * @since Ant 1.6.2
       */
      public ConditionBase createCondition() {
         logOverride("condition", condition);
         condition = new NestedCondition();
         return condition;
     }
 
     /**
      * Add an application.
      * @param sequence the application to add.
      */
     public void addApplication(Sequential sequence) {
         logOverride("application", application);
         application = sequence;
     }
 
     /**
      * Add a setup sequence.
      * @param sequence the setup sequence to add.
      */
     public void addSetup(Sequential sequence) {
         logOverride("setup", setup);
         setup = sequence;
     }
 
     /**
      * Add a block.
      * @param sequence the block for to add.
      */
     public void addBlock(BlockFor sequence) {
         logOverride("block", block);
         block = sequence;
     }
 
     /**
      * add tests.
      * @param sequence a sequence to add.
      */
     public void addTests(Sequential sequence) {
         logOverride("tests", tests);
         tests = sequence;
     }
 
     /**
      * set reporting sequence of tasks.
      * @param sequence a reporting sequence to use.
      */
     public void addReporting(Sequential sequence) {
         logOverride("reporting", reporting);
         reporting = sequence;
     }
 
     /**
      * set teardown sequence of tasks.
      * @param sequence a teardown sequence to use.
      */
     public void addTeardown(Sequential sequence) {
         logOverride("teardown", teardown);
         teardown = sequence;
     }
 
     /**
      * Set the failOnTeardownErrors attribute.
      * @param failOnTeardownErrors the value to use.
      */
     public void setFailOnTeardownErrors(boolean failOnTeardownErrors) {
         this.failOnTeardownErrors = failOnTeardownErrors;
     }
 
     /**
      * Set the failureMessage attribute.
      * @param failureMessage the value to use.
      */
     public void setFailureMessage(String failureMessage) {
         this.failureMessage = failureMessage;
     }
 
     /**
      * Set the failureProperty attribute.
      * @param failureProperty the value to use.
      */
     public void setFailureProperty(String failureProperty) {
         this.failureProperty = failureProperty;
     }
 
     /**
      * Set the shutdownTime attribute.
      * @param shutdownTime the value to use.
      */
     public void setShutdownTime(long shutdownTime) {
         this.shutdownTime = shutdownTime;
     }
 
     /**
      * Set the timeout attribute.
      * @param timeout the value to use.
      */
     public void setTimeout(long timeout) {
         this.timeout = timeout;
     }
 
     /**
      * Set the timeoutunit attribute.
      * @param unit the value to use.
      */
     public void setTimeoutUnit(WaitFor.Unit unit) {
         timeoutUnitMultiplier = unit.getMultiplier();
     }
 
     /**
      * Set the shutdownunit attribute.
      * @param unit the value to use.
      */
     public void setShutdownUnit(WaitFor.Unit unit) {
         shutdownUnitMultiplier = unit.getMultiplier();
     }
 
 
     /**
      * Get the application exception.
      * @return the application exception.
      */
     public BuildException getApplicationException() {
         return applicationException;
     }
 
     /**
      * Get the teardown exception.
      * @return the teardown exception.
      */
     public BuildException getTeardownException() {
         return teardownException;
     }
 
     /**
      * Get the test exception.
      * @return the test exception.
      */
     public BuildException getTestException() {
         return testException;
     }
 
     /**
      * Get the task exception.
      * @return the task exception.
      */
     public BuildException getTaskException() {
         return taskException;
     }
 
     /**
      * Bind and initialise a task
      * @param task task to bind
      */
     private void bind(Task task) {
         task.bindToOwner(this);
         task.init();
     }
 
     /**
      * Create a newly bound parallel instance
      * @param parallelTimeout timeout
      * @return a bound and initialised parallel instance.
      */
     private Parallel newParallel(long parallelTimeout) {
         Parallel par = new Parallel();
         bind(par);
         par.setFailOnAny(true);
         par.setTimeout(parallelTimeout);
         return par;
     }
 
     /**
      * Create a newly bound parallel instance with one child
      * @param parallelTimeout timeout
      * @param child task
      * @return a bound and initialised parallel instance.
      */
     private Parallel newParallel(long parallelTimeout, Task child) {
         Parallel par = newParallel(parallelTimeout);
         par.addTask(child);
         return par;
     }
 
     /**
      * Add any task validation needed to ensure internal code quality
      * @param task task
      * @param role role of the task
      */
     private void validateTask(Task task, String role) {
         if (task!=null && task.getProject() == null) {
             throw new BuildException(role + " task is not bound to the project" + task);
         }
     }
 
     /**
      * Run the functional test sequence.
      * <p/>
      * This is a fairly complex workflow -what is going on is that we try to clean up
      * no matter how the run ended, and to retain the innermost exception that got thrown
      * during cleanup. That is, if teardown fails after the tests themselves failed, it is the
      * test failing that is more important.
      * @throws BuildException if something was caught during the run or teardown.
      */
     public void execute() throws BuildException {
 
         //validation
         validateTask(setup, "setup");
         validateTask(application, "application");
         validateTask(tests, "tests");
         validateTask(reporting, "reporting");
         validateTask(teardown, "teardown");
 
         //check the condition
         //and bail out if it is defined but not true
         if (condition != null && !condition.eval()) {
             //we are skipping the test
             log(SKIPPING_TESTS);
             return;
         }
 
         long timeoutMillis = timeout * timeoutUnitMultiplier;
 
         //set up the application to run in a separate thread
         Parallel applicationRun = newParallel(timeoutMillis);
         //with a worker which we can use to manage it
         WorkerAnt worker = new WorkerAnt(applicationRun, null);
         if (application != null) {
             applicationRun.addTask(application);
         }
 
         //The test run consists of the block followed by the tests.
         long testRunTimeout = 0;
         Sequential testRun = new Sequential();
         bind(testRun);
         if (block != null) {
             //waitfor is not a task, it needs to be adapted
             TaskAdapter ta = new TaskAdapter(block);
             ta.bindToOwner(this);
             validateTask(ta, "block");
             testRun.addTask(ta);
             //add the block time to the total test run timeout
             testRunTimeout = block.calculateMaxWaitMillis();
         }
 
         //add the tests and more delay
         if (tests != null) {
             testRun.addTask(tests);
             testRunTimeout += timeoutMillis;
         }
         //add the reporting and more delay
         if (reporting != null) {
             testRun.addTask(reporting);
             testRunTimeout += timeoutMillis;
         }
 
         //wrap this in a parallel purely to set up timeouts for the
         //test run
         timedTests = newParallel(testRunTimeout, testRun);
 
         try {
             //run any setup task
             if (setup != null) {
                 Parallel setupRun = newParallel(timeoutMillis, setup);
                 setupRun.execute();
             }
             //start the worker thread and leave it running
             worker.start();
             //start the probe+test sequence
             timedTests.execute();
         } catch (BuildException e) {
             //Record the exception and continue
             testException = e;
         } finally {
             //teardown always runs; its faults are filed away
             if (teardown != null) {
                 try {
                     Parallel teardownRun = newParallel(timeoutMillis, teardown);
                     teardownRun.execute();
                 } catch (BuildException e) {
                     teardownException = e;
                 }
             }
         }
 
         //we get here whether or not the tests/teardown have thrown a BuildException.
         //do a forced shutdown of the running application, before processing the faults
 
         try {
             //wait for the worker to have finished
             long shutdownTimeMillis = shutdownTime * shutdownUnitMultiplier;
             worker.waitUntilFinished(shutdownTimeMillis);
             if (worker.isAlive()) {
                 //then, if it is still running, interrupt it a second time.
                 log(APPLICATION_FORCIBLY_SHUT_DOWN, Project.MSG_WARN);
                 worker.interrupt();
                 worker.waitUntilFinished(shutdownTimeMillis);
             }
         } catch (InterruptedException e) {
             //success, something interrupted the shutdown. There may be a leaked
             //worker;
             log(SHUTDOWN_INTERRUPTED, e, Project.MSG_VERBOSE);
         }
         applicationException = worker.getBuildException();
 
         //Now faults are analysed
 
         processExceptions();
     }
 
     /**
      * Now faults are analysed.
      * <p> The priority is
      * <ol>
      * <li>testexceptions, except those indicating a build timeout when the application itself
      failed.<br>
      (because often it is the application fault that is more interesting than the probe
      failure, which is usually triggered by the application not starting
      </li><li>
      Application exceptions (above test timeout exceptions)
      </li><li>
      Teardown exceptions -except when they are being ignored
      </li><li>
      Test failures as indicated by the failure property
      </li></ol>
 
      */
     protected void processExceptions() {
         taskException = testException;
 
         //look for an application fault
         if (applicationException != null) {
             if (taskException == null || taskException instanceof BuildTimeoutException) {
                 taskException = applicationException;
             } else {
                 ignoringThrowable(APPLICATION_EXCEPTION, applicationException);
             }
         }
 
         //now look for teardown faults, which may be ignored
         if (teardownException != null) {
             if (taskException == null && failOnTeardownErrors) {
                 taskException = teardownException;
             } else {
                 //don't let the cleanup exception get in the way of any other failure
                 ignoringThrowable(TEARDOWN_EXCEPTION, teardownException);
             }
         }
 
         //now, analyse the tests
         if (failureProperty != null
              && getProject().getProperty(failureProperty) != null) {
             //we've failed
             log(failureMessage);
             if (taskException == null) {
                 taskException = new BuildException(failureMessage);
             }
         }
 
         //at this point taskException is null or not.
         //if not, throw the exception
         if (taskException != null) {
             throw taskException;
         }
     }
 
     /**
      * log that we are ignoring something rather than rethrowing it.
      * @param type name of exception
      * @param thrown what was thrown
      */
     protected void ignoringThrowable(String type, Throwable thrown) {
         log(type + ": " + thrown.toString(),
                 thrown,
                 Project.MSG_WARN);
     }
 
     private static class NestedCondition extends ConditionBase implements Condition {
         public boolean eval() {
             if (countConditions() != 1) {
                 throw new BuildException(
                     "A single nested condition is required.");
             }
             return ((Condition) (getConditions().nextElement())).eval();
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/unix/AbstractAccessTask.java b/src/main/org/apache/tools/ant/taskdefs/optional/unix/AbstractAccessTask.java
index 40b8e8a2f..d3385e6cc 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/unix/AbstractAccessTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/unix/AbstractAccessTask.java
@@ -1,110 +1,110 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 /*
  * Since the initial version of this file was deveolped on the clock on
  * an NSF grant I should say the following boilerplate:
  *
  * This material is based upon work supported by the National Science
  * Foundaton under Grant No. EIA-0196404. Any opinions, findings, and
  * conclusions or recommendations expressed in this material are those
  * of the author and do not necessarily reflect the views of the
  * National Science Foundation.
  */
 
 package org.apache.tools.ant.taskdefs.optional.unix;
 
 import java.io.File;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.condition.Os;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.types.FileSet;
 
 /**
  * @since Ant 1.6
  *
  * @ant.task category="filesystem"
  */
 
 public abstract class AbstractAccessTask
     extends org.apache.tools.ant.taskdefs.ExecuteOn {
 
     /**
      * Chmod task for setting file and directory permissions.
      */
     public AbstractAccessTask() {
         super.setParallel(true);
         super.setSkipEmptyFilesets(true);
     }
 
     /**
      * Set the file which should have its access attributes modified.
      * @param src the file to modify
      */
     public void setFile(File src) {
         FileSet fs = new FileSet();
         fs.setFile(src);
         addFileset(fs);
     }
 
     /**
      * Prevent the user from specifying a different command.
      *
      * @ant.attribute ignore="true"
      * @param cmdl A user supplied command line that we won't accept.
      */
     public void setCommand(Commandline cmdl) {
         throw new BuildException(getTaskType()
                                  + " doesn\'t support the command attribute",
                                  getLocation());
     }
 
     /**
      * Prevent the skipping of empty filesets
      *
      * @ant.attribute ignore="true"
      * @param skip A user supplied boolean we won't accept.
      */
     public void setSkipEmptyFilesets(boolean skip) {
         throw new BuildException(getTaskType() + " doesn\'t support the "
                                  + "skipemptyfileset attribute",
                                  getLocation());
     }
 
     /**
-     * Prevent the use of the addsourcefile atribute.
+     * Prevent the use of the addsourcefile attribute.
      *
      * @ant.attribute ignore="true"
      * @param b A user supplied boolean we won't accept.
      */
     public void setAddsourcefile(boolean b) {
         throw new BuildException(getTaskType()
             + " doesn\'t support the addsourcefile attribute", getLocation());
     }
 
     /**
      * Automatically approve Unix OS's.
      * @return true if a valid OS, for unix this is always true, otherwise
      *              use the superclasses' test (user set).
      */
     protected boolean isValidOs() {
         return getOs() == null && getOsFamily() == null
             ? Os.isFamily(Os.FAMILY_UNIX) : super.isValidOs();
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/unix/Chgrp.java b/src/main/org/apache/tools/ant/taskdefs/optional/unix/Chgrp.java
index 403fc2d8d..1279a2c82 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/unix/Chgrp.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/unix/Chgrp.java
@@ -1,84 +1,84 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 /*
  * Since the initial version of this file was deveolped on the clock on
  * an NSF grant I should say the following boilerplate:
  *
  * This material is based upon work supported by the National Science
  * Foundaton under Grant No. EIA-0196404. Any opinions, findings, and
  * conclusions or recommendations expressed in this material are those
  * of the author and do not necessarily reflect the views of the
  * National Science Foundation.
  */
 
 package org.apache.tools.ant.taskdefs.optional.unix;
 
 import org.apache.tools.ant.BuildException;
 
 /**
  * Chgrp equivalent for unix-like environments.
  *
  * @since Ant 1.6
  *
  * @ant.task category="filesystem"
  */
 public class Chgrp extends AbstractAccessTask {
 
     private boolean haveGroup = false;
 
     /**
      * Chgrp task for setting unix group of a file.
      */
     public Chgrp() {
         super.setExecutable("chgrp");
     }
 
     /**
-     * Set the group atribute.
+     * Set the group attribute.
      *
      * @param group    The new group for the file(s) or directory(ies)
      */
     public void setGroup(String group) {
         createArg().setValue(group);
         haveGroup = true;
     }
 
     /**
      * Ensure that all the required arguments and other conditions have
      * been set.
      */
     protected void checkConfiguration() {
         if (!haveGroup) {
             throw new BuildException("Required attribute group not set in "
                                      + "chgrp", getLocation());
         }
         super.checkConfiguration();
     }
 
     /**
-     * We don't want to expose the executable atribute, so overide it.
+     * We don't want to expose the executable attribute, so override it.
      *
      * @param e User supplied executable that we won't accept.
      */
     public void setExecutable(String e) {
         throw new BuildException(getTaskType()
                                  + " doesn\'t support the executable"
                                  + " attribute", getLocation());
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/unix/Chown.java b/src/main/org/apache/tools/ant/taskdefs/optional/unix/Chown.java
index ba1028b64..53f72536b 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/unix/Chown.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/unix/Chown.java
@@ -1,84 +1,84 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 /*
  * Since the initial version of this file was deveolped on the clock on
  * an NSF grant I should say the following boilerplate:
  *
  * This material is based upon work supported by the National Science
  * Foundaton under Grant No. EIA-0196404. Any opinions, findings, and
  * conclusions or recommendations expressed in this material are those
  * of the author and do not necessarily reflect the views of the
  * National Science Foundation.
  */
 
 package org.apache.tools.ant.taskdefs.optional.unix;
 
 import org.apache.tools.ant.BuildException;
 
 /**
  * Chown equivalent for unix-like environments.
  *
  * @since Ant 1.6
  *
  * @ant.task category="filesystem"
  */
 public class Chown extends AbstractAccessTask {
 
     private boolean haveOwner = false;
 
     /**
      * Chown task for setting file and directory permissions.
      */
     public Chown() {
         super.setExecutable("chown");
     }
 
     /**
-     * Set the owner atribute.
+     * Set the owner attribute.
      *
      * @param owner    The new owner for the file(s) or directory(ies)
      */
     public void setOwner(String owner) {
         createArg().setValue(owner);
         haveOwner = true;
     }
 
     /**
      * Ensure that all the required arguments and other conditions have
      * been set.
      */
     protected void checkConfiguration() {
         if (!haveOwner) {
             throw new BuildException("Required attribute owner not set in"
                                      + " chown", getLocation());
         }
         super.checkConfiguration();
     }
 
     /**
-     * We don't want to expose the executable atribute, so overide it.
+     * We don't want to expose the executable attribute, so override it.
      *
      * @param e User supplied executable that we won't accept.
      */
     public void setExecutable(String e) {
         throw new BuildException(getTaskType()
                                  + " doesn\'t support the executable"
                                  + " attribute", getLocation());
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/vss/MSVSSConstants.java b/src/main/org/apache/tools/ant/taskdefs/optional/vss/MSVSSConstants.java
index 4144d4492..9e5ec6060 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/vss/MSVSSConstants.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/vss/MSVSSConstants.java
@@ -1,127 +1,127 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.vss;
 
 /**
  *  Holds all the constants for the VSS tasks.
  *
  */
 // CheckStyle:InterfaceIsType OFF (bc)
 public interface MSVSSConstants {
     /**  Constant for the thing to execute  */
     String SS_EXE = "ss";
     /** Dollar Sigh to prefix the project path */
     String PROJECT_PREFIX = "$";
 
     /**  The 'CP' command  */
     String COMMAND_CP = "CP";
     /**  The 'Add' command  */
     String COMMAND_ADD = "Add";
     /**  The 'Get' command  */
     String COMMAND_GET = "Get";
     /**  The 'Checkout' command  */
     String COMMAND_CHECKOUT = "Checkout";
     /**  The 'Checkin' command  */
     String COMMAND_CHECKIN = "Checkin";
     /**  The 'Label' command  */
     String COMMAND_LABEL = "Label";
     /**  The 'History' command  */
     String COMMAND_HISTORY = "History";
     /**  The 'Create' command  */
     String COMMAND_CREATE = "Create";
 
     /**  The brief style flag  */
     String STYLE_BRIEF = "brief";
     /**  The codediff style flag  */
     String STYLE_CODEDIFF = "codediff";
     /**  The nofile style flag  */
     String STYLE_NOFILE = "nofile";
     /**  The default style flag  */
     String STYLE_DEFAULT = "default";
 
     /**  The text for  current (default) timestamp */
     String TIME_CURRENT = "current";
     /**  The text for  modified timestamp */
     String TIME_MODIFIED = "modified";
     /**  The text for  updated timestamp */
     String TIME_UPDATED = "updated";
 
     /**  The text for replacing writable files   */
     String WRITABLE_REPLACE = "replace";
-    /**  The text for skiping writable files  */
+    /**  The text for skipping writable files  */
     String WRITABLE_SKIP = "skip";
     /**  The text for failing on writable files  */
     String WRITABLE_FAIL = "fail";
 
     /** -Y flag */
     String FLAG_LOGIN = "-Y";
     /** -GL flag */
     String FLAG_OVERRIDE_WORKING_DIR = "-GL";
     /** -I- flag */
     String FLAG_AUTORESPONSE_DEF = "-I-";
     /** -I-Y flag */
     String FLAG_AUTORESPONSE_YES = "-I-Y";
     /** -I-N flag */
     String FLAG_AUTORESPONSE_NO = "-I-N";
     /** -R flag */
     String FLAG_RECURSION = "-R";
     /** -V flag */
     String FLAG_VERSION = "-V";
     /** -Vd flag */
     String FLAG_VERSION_DATE = "-Vd";
     /** -VL flag */
     String FLAG_VERSION_LABEL = "-VL";
     /** -W flag */
     String FLAG_WRITABLE = "-W";
     /** -N flag */
     String VALUE_NO = "-N";
     /** -Y flag */
     String VALUE_YES = "-Y";
     /** -O- flag */
     String FLAG_QUIET = "-O-";
     /** -C flag */
     String FLAG_COMMENT = "-C";
     /** -L flag */
     String FLAG_LABEL = "-L";
     /** ~d flag */
     String VALUE_FROMDATE = "~d";
     /** ~L flag */
     String VALUE_FROMLABEL = "~L";
     /** -O flag */
     String FLAG_OUTPUT = "-O";
     /** -U flag */
     String FLAG_USER = "-U";
     /** -F- flag */
     String FLAG_NO_FILE = "-F-";
     /** -B flag */
     String FLAG_BRIEF = "-B";
     /** -D flag */
     String FLAG_CODEDIFF = "-D";
     /** -GTC flag */
     String FLAG_FILETIME_DEF = "-GTC";
     /** -GTM flag */
     String FLAG_FILETIME_MODIFIED = "-GTM";
     /** -GTU flag */
     String FLAG_FILETIME_UPDATED = "-GTU";
     /** -GWR flag */
     String FLAG_REPLACE_WRITABLE = "-GWR";
     /** -GWS flag */
     String FLAG_SKIP_WRITABLE = "-GWS";
     /** -G- flag */
     String FLAG_NO_GET = "-G-";
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/windows/Attrib.java b/src/main/org/apache/tools/ant/taskdefs/optional/windows/Attrib.java
index fc729e777..68a0d35d3 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/windows/Attrib.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/windows/Attrib.java
@@ -1,196 +1,196 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.windows;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.ExecuteOn;
 import org.apache.tools.ant.taskdefs.condition.Os;
 import org.apache.tools.ant.types.FileSet;
 
 import java.io.File;
 
 /**
  * Attrib equivalent for Win32 environments.
  * Note: Attrib parameters /S and /D are not handled.
  *
  * @since Ant 1.6
  */
 public class Attrib extends ExecuteOn {
 
     private static final String ATTR_READONLY = "R";
     private static final String ATTR_ARCHIVE  = "A";
     private static final String ATTR_SYSTEM   = "S";
     private static final String ATTR_HIDDEN   = "H";
     private static final String SET    = "+";
     private static final String UNSET  = "-";
 
     private boolean haveAttr = false;
 
     /** Constructor for Attrib. */
     public Attrib() {
         super.setExecutable("attrib");
         super.setParallel(false);
     }
 
     /**
      * A file to be attribed.
      * @param src a file
      */
     public void setFile(File src) {
         FileSet fs = new FileSet();
         fs.setFile(src);
         addFileset(fs);
     }
 
     /**
      * Set the ReadOnly file attribute.
      * @param value a <code>boolean</code> value
      */
     public void setReadonly(boolean value) {
         addArg(value, ATTR_READONLY);
     }
 
     /**
      * Set the Archive file attribute.
      * @param value a <code>boolean</code> value
      */
     public void setArchive(boolean value) {
         addArg(value, ATTR_ARCHIVE);
     }
 
     /**
      * Set the System file attribute.
      * @param value a <code>boolean</code> value
      */
     public void setSystem(boolean value) {
         addArg(value, ATTR_SYSTEM);
     }
 
     /**
      * Set the Hidden file attribute.
      * @param value a <code>boolean</code> value
      */
     public void setHidden(boolean value) {
         addArg(value, ATTR_HIDDEN);
     }
 
     /**
      * Check the attributes.
      */
     protected void checkConfiguration() {
         if (!haveAttr()) {
             throw new BuildException("Missing attribute parameter",
                                      getLocation());
         }
         super.checkConfiguration();
     }
 
     /**
      * Set the executable.
      * This is not allowed, and it always throws a BuildException.
      * @param e ignored
      * @ant.attribute ignore="true"
      */
     public void setExecutable(String e) {
         throw new BuildException(getTaskType()
             + " doesn\'t support the executable attribute", getLocation());
     }
 
     /**
      * Set the executable.
      * This is not allowed, and it always throws a BuildException.
      * @param e ignored
      * @ant.attribute ignore="true"
      */
     public void setCommand(String e) {
         throw new BuildException(getTaskType()
             + " doesn\'t support the command attribute", getLocation());
     }
 
     /**
      * Add source file.
      * This is not allowed, and it always throws a BuildException.
      * @param b ignored
      * @ant.attribute ignore="true"
      */
     public void setAddsourcefile(boolean b) {
         throw new BuildException(getTaskType()
             + " doesn\'t support the addsourcefile attribute", getLocation());
     }
 
     /**
      * Set skip empty file sets.
      * This is not allowed, and it always throws a BuildException.
      * @param skip ignored
      * @ant.attribute ignore="true"
      */
     public void setSkipEmptyFilesets(boolean skip) {
         throw new BuildException(getTaskType() + " doesn\'t support the "
                                  + "skipemptyfileset attribute",
                                  getLocation());
     }
 
     /**
      * Set parallel.
      * This is not allowed, and it always throws a BuildException.
      * @param parallel ignored
      * @ant.attribute ignore="true"
      */
     public void setParallel(boolean parallel) {
         throw new BuildException(getTaskType()
                                  + " doesn\'t support the parallel attribute",
                                  getLocation());
     }
 
     /**
      * Set max parallel.
      * This is not allowed, and it always throws a BuildException.
      * @param max ignored
      * @ant.attribute ignore="true"
      */
     public void setMaxParallel(int max) {
         throw new BuildException(getTaskType()
                                  + " doesn\'t support the maxparallel attribute",
                                  getLocation());
     }
 
     /**
      * Check if the os is valid.
-     * Defauls is to allow windows
+     * Default is to allow windows
      * @return true if the os is valid.
      */
     protected boolean isValidOs() {
         return getOs() == null && getOsFamily() == null ?
             Os.isFamily(Os.FAMILY_WINDOWS) : super.isValidOs();
     }
 
     private static String getSignString(boolean attr) {
         return (attr ? SET : UNSET);
     }
 
     private void addArg(boolean sign, String attribute) {
         createArg().setValue(getSignString(sign) + attribute);
         haveAttr = true;
     }
 
     private boolean haveAttr() {
         return haveAttr;
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/rmic/DefaultRmicAdapter.java b/src/main/org/apache/tools/ant/taskdefs/rmic/DefaultRmicAdapter.java
index 575868223..07139f48b 100644
--- a/src/main/org/apache/tools/ant/taskdefs/rmic/DefaultRmicAdapter.java
+++ b/src/main/org/apache/tools/ant/taskdefs/rmic/DefaultRmicAdapter.java
@@ -1,493 +1,493 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.rmic;
 
 import java.io.File;
 import java.util.Random;
 import java.util.Vector;
 import java.util.List;
 import java.util.ArrayList;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.Rmic;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.StringUtils;
 
 /**
  * This is the default implementation for the RmicAdapter interface.
  * Currently, this is a cut-and-paste of the original rmic task and
- * DefaultCopmpilerAdapter.
+ * DefaultCompilerAdapter.
  *
  * @since Ant 1.4
  */
 public abstract class DefaultRmicAdapter implements RmicAdapter {
 
     private Rmic attributes;
     private FileNameMapper mapper;
     private static final Random RAND = new Random();
     /** suffix denoting a stub file: {@value} */
     public static final String RMI_STUB_SUFFIX = "_Stub";
     /** suffix denoting a skel file: {@value} */
     public static final String RMI_SKEL_SUFFIX = "_Skel";
     /** suffix denoting a tie file: {@value} */
     public static final String RMI_TIE_SUFFIX = "_Tie";
     /** arg for compat: {@value} */
     public static final String STUB_COMPAT = "-vcompat";
     /** arg for 1.1: {@value} */
     public static final String STUB_1_1 = "-v1.1";
     /** arg for 1.2: {@value} */
     public static final String STUB_1_2 = "-v1.2";
 
     /**
      * option for stub 1.1 in the rmic task: {@value}
      */
     public static final String STUB_OPTION_1_1 = "1.1";
     /**
      * option for stub 1.2 in the rmic task: {@value}
      */
     public static final String STUB_OPTION_1_2 = "1.2";
     /**
      * option for stub compat in the rmic task: {@value}
      */
     public static final String STUB_OPTION_COMPAT = "compat";
 
     /**
      * Default constructor
      */
     public DefaultRmicAdapter() {
     }
 
     /**
      * Sets Rmic attributes
      * @param attributes the rmic attributes
      */
     public void setRmic(final Rmic attributes) {
         this.attributes = attributes;
         mapper = new RmicFileNameMapper();
     }
 
     /**
      * Get the Rmic attributes
      * @return the attributes as a Rmic taskdef
      */
     public Rmic getRmic() {
         return attributes;
     }
 
     /**
      * Gets the stub class suffix
      * @return the stub suffix &quot;_Stub&quot;
      */
     protected String getStubClassSuffix() {
         return RMI_STUB_SUFFIX;
     }
 
     /**
      * Gets the skeleton class suffix
      * @return the skeleton suffix &quot;_Skel&quot;
      */
     protected String getSkelClassSuffix() {
         return RMI_SKEL_SUFFIX;
     }
 
     /**
      * Gets the tie class suffix
      * @return the tie suffix &quot;_Tie&quot;
      */
     protected String getTieClassSuffix() {
         return RMI_TIE_SUFFIX;
     }
 
     /**
      * This implementation returns a mapper that may return up to two
      * file names.
      *
      * <ul>
      *   <li>for JRMP it will return *_getStubClassSuffix (and
      *   *_getSkelClassSuffix if JDK 1.1 is used)</li>
      *
      *   <li>for IDL it will return a random name, causing &lt;rmic&gt; to
      *     always recompile.</li>
      *
      *   <li>for IIOP it will return _*_getStubClassSuffix for
      *   interfaces and _*_getStubClassSuffix for non-interfaces (and
      *   determine the interface and create _*_Stub from that).</li>
      * </ul>
      * @return a <code>FileNameMapper</code>
      */
     public FileNameMapper getMapper() {
         return mapper;
     }
 
     /**
      * Gets the CLASSPATH this rmic process will use.
      * @return the classpath
      */
     public Path getClasspath() {
         return getCompileClasspath();
     }
 
     /**
      * Builds the compilation classpath.
      * @return the classpath
      */
     protected Path getCompileClasspath() {
         Path classpath = new Path(attributes.getProject());
         // add dest dir to classpath so that previously compiled and
         // untouched classes are on classpath
         classpath.setLocation(attributes.getBase());
 
         // Combine the build classpath with the system classpath, in an
         // order determined by the value of build.sysclasspath
 
         Path cp = attributes.getClasspath();
         if (cp == null) {
             cp = new Path(attributes.getProject());
         }
         if (attributes.getIncludeantruntime()) {
             classpath.addExisting(cp.concatSystemClasspath("last"));
         } else {
             classpath.addExisting(cp.concatSystemClasspath("ignore"));
         }
 
         if (attributes.getIncludejavaruntime()) {
             classpath.addJavaRuntime();
         }
         return classpath;
     }
 
     /**
      * Setup rmic argument for rmic.
      * @return the command line
      */
     protected Commandline setupRmicCommand() {
         return setupRmicCommand(null);
     }
 
     /**
      * Setup rmic argument for rmic.
      * @param options additional parameters needed by a specific
      *                implementation.
      * @return the command line
      */
     protected Commandline setupRmicCommand(String[] options) {
         Commandline cmd = new Commandline();
 
         if (options != null) {
             for (int i = 0; i < options.length; i++) {
                 cmd.createArgument().setValue(options[i]);
             }
         }
 
         Path classpath = getCompileClasspath();
 
         cmd.createArgument().setValue("-d");
         cmd.createArgument().setFile(attributes.getOutputDir());
 
         if (attributes.getExtdirs() != null) {
             cmd.createArgument().setValue("-extdirs");
             cmd.createArgument().setPath(attributes.getExtdirs());
         }
 
         cmd.createArgument().setValue("-classpath");
         cmd.createArgument().setPath(classpath);
         String stubOption = addStubVersionOptions();
         if (stubOption != null) {
             //set the non-null stubOption
             cmd.createArgument().setValue(stubOption);
         }
 
 
         if (null != attributes.getSourceBase()) {
             cmd.createArgument().setValue("-keepgenerated");
         }
 
         if (attributes.getIiop()) {
             attributes.log("IIOP has been turned on.", Project.MSG_INFO);
             cmd.createArgument().setValue("-iiop");
             if (attributes.getIiopopts() != null) {
                 attributes.log("IIOP Options: " + attributes.getIiopopts(),
                                Project.MSG_INFO);
                 cmd.createArgument().setValue(attributes.getIiopopts());
             }
         }
 
         if (attributes.getIdl())  {
             cmd.createArgument().setValue("-idl");
             attributes.log("IDL has been turned on.", Project.MSG_INFO);
             if (attributes.getIdlopts() != null) {
                 cmd.createArgument().setValue(attributes.getIdlopts());
                 attributes.log("IDL Options: " + attributes.getIdlopts(),
                                Project.MSG_INFO);
             }
         }
 
         if (attributes.getDebug()) {
             cmd.createArgument().setValue("-g");
         }
 
         String[] compilerArgs = attributes.getCurrentCompilerArgs();
         compilerArgs = preprocessCompilerArgs(compilerArgs);
         cmd.addArguments(compilerArgs);
 
         logAndAddFilesToCompile(cmd);
         return cmd;
      }
 
     /**
      * This is an override point; get the stub version off the rmic command and
      * translate that into a compiler-specific argument
      * @return a string to use for the stub version; can be null
      * @since Ant1.7.1
      */
     protected String addStubVersionOptions() {
         //handle the many different stub options.
         String stubVersion = attributes.getStubVersion();
         //default is compatibility
         String stubOption = null;
         if (null != stubVersion) {
             if (STUB_OPTION_1_1.equals(stubVersion)) {
                 stubOption = STUB_1_1;
             } else if (STUB_OPTION_1_2.equals(stubVersion)) {
                 stubOption = STUB_1_2;
             } else if (STUB_OPTION_COMPAT.equals(stubVersion)) {
                 stubOption = STUB_COMPAT;
             } else {
                 //anything else
                 attributes.log("Unknown stub option " + stubVersion);
                 //do nothing with the value? or go -v+stubVersion??
             }
         }
         //for java1.5+, we generate compatible stubs, that is, unless
         //the caller asked for IDL or IIOP support.
         if (stubOption == null
             && !attributes.getIiop()
             && !attributes.getIdl()) {
             stubOption = STUB_COMPAT;
         }
         return stubOption;
     }
 
     /**
      * Preprocess the compiler arguments in any way you see fit.
      * This is to allow compiler adapters to validate or filter the arguments.
      * The base implementation returns the original compiler arguments unchanged.
      * @param compilerArgs the original compiler arguments
      * @return the filtered set.
      */
     protected String[] preprocessCompilerArgs(String[] compilerArgs) {
         return compilerArgs;
     }
 
 
     /**
      * Strip out all -J args from the command list. Invoke this from
      * {@link #preprocessCompilerArgs(String[])} if you have a non-forking
      * compiler.
      * @param compilerArgs the original compiler arguments
      * @return the filtered set.
      */
     protected String[] filterJvmCompilerArgs(String[] compilerArgs) {
         int len = compilerArgs.length;
         List args = new ArrayList(len);
         for (int i = 0; i < len; i++) {
             String arg = compilerArgs[i];
             if (!arg.startsWith("-J")) {
                 args.add(arg);
             } else {
                 attributes.log("Dropping " + arg + " from compiler arguments");
             }
         }
         int count = args.size();
         return (String[]) args.toArray(new String[count]);
     }
 
 
     /**
      * Logs the compilation parameters, adds the files to compile and logs the
      * &quot;niceSourceList&quot;
      * @param cmd the commandline args
      */
     protected void logAndAddFilesToCompile(Commandline cmd) {
         Vector compileList = attributes.getCompileList();
 
         attributes.log("Compilation " + cmd.describeArguments(),
                        Project.MSG_VERBOSE);
 
         StringBuffer niceSourceList = new StringBuffer("File");
         int cListSize = compileList.size();
         if (cListSize != 1) {
             niceSourceList.append("s");
         }
         niceSourceList.append(" to be compiled:");
 
         for (int i = 0; i < cListSize; i++) {
             String arg = (String) compileList.elementAt(i);
             cmd.createArgument().setValue(arg);
             niceSourceList.append("    ");
             niceSourceList.append(arg);
         }
 
         attributes.log(niceSourceList.toString(), Project.MSG_VERBOSE);
     }
 
     /**
      * Mapper that may return up to two file names.
      *
      * <ul>
      *   <li>for JRMP it will return *_getStubClassSuffix (and
      *   *_getSkelClassSuffix if JDK 1.1 is used)</li>
      *
      *   <li>for IDL it will return a random name, causing <rmic> to
      *     always recompile.</li>
      *
      *   <li>for IIOP it will return _*_getStubClassSuffix for
      *   interfaces and _*_getStubClassSuffix for non-interfaces (and
      *   determine the interface and create _*_Stub from that).</li>
      * </ul>
      */
     private class RmicFileNameMapper implements FileNameMapper {
 
         RmicFileNameMapper() {
         }
 
         /**
          * Empty implementation.
          */
         public void setFrom(String s) {
         }
         /**
          * Empty implementation.
          */
         public void setTo(String s) {
         }
 
         public String[] mapFileName(String name) {
             if (name == null
                 || !name.endsWith(".class")
                 || name.endsWith(getStubClassSuffix() + ".class")
                 || name.endsWith(getSkelClassSuffix() + ".class")
                 || name.endsWith(getTieClassSuffix() + ".class")) {
                 // Not a .class file or the one we'd generate
                 return null;
             }
 
             // we know that name.endsWith(".class")
             String base = StringUtils.removeSuffix(name, ".class");
 
             String classname = base.replace(File.separatorChar, '.');
             if (attributes.getVerify()
                 && !attributes.isValidRmiRemote(classname)) {
                 return null;
             }
 
             /*
              * fallback in case we have trouble loading the class or
              * don't know how to handle it (there is no easy way to
              * know what IDL mode would generate.
              *
              * This is supposed to make Ant always recompile the
              * class, as a file of that name should not exist.
              */
             String[] target = new String[] {name + ".tmp." + RAND.nextLong()};
 
             if (!attributes.getIiop() && !attributes.getIdl()) {
                 // JRMP with simple naming convention
                 if (STUB_OPTION_1_2.equals(attributes.getStubVersion())) {
                     target = new String[] {
                         base + getStubClassSuffix() + ".class"
                     };
                 } else {
                     target = new String[] {
                         base + getStubClassSuffix() + ".class",
                         base + getSkelClassSuffix() + ".class",
                     };
                 }
             } else if (!attributes.getIdl()) {
                 int lastSlash = base.lastIndexOf(File.separatorChar);
 
                 String dirname = "";
                 /*
                  * I know, this is not necessary, but I prefer it explicit (SB)
                  */
                 int index = -1;
                 if (lastSlash == -1) {
                     // no package
                     index = 0;
                 } else {
                     index = lastSlash + 1;
                     dirname = base.substring(0, index);
                 }
 
                 String filename = base.substring(index);
 
                 try {
                     Class c = attributes.getLoader().loadClass(classname);
 
                     if (c.isInterface()) {
                         // only stub, no tie
                         target = new String[] {
                             dirname + "_" + filename + getStubClassSuffix()
                             + ".class"
                         };
                     } else {
                         /*
                          * stub is derived from implementation,
                          * tie from interface name.
                          */
                         Class interf = attributes.getRemoteInterface(c);
                         String iName = interf.getName();
                         String iDir = "";
                         int iIndex = -1;
                         int lastDot = iName.lastIndexOf(".");
                         if (lastDot == -1) {
                             // no package
                             iIndex = 0;
                         } else {
                             iIndex = lastDot + 1;
                             iDir = iName.substring(0, iIndex);
                             iDir = iDir.replace('.', File.separatorChar);
                         }
 
                         target = new String[] {
                             dirname + "_" + filename + getTieClassSuffix()
                             + ".class",
                             iDir + "_" + iName.substring(iIndex)
                             + getStubClassSuffix() + ".class"
                         };
                     }
                 } catch (ClassNotFoundException e) {
                     attributes.log("Unable to verify class " + classname
                                    + ". It could not be found.",
                                    Project.MSG_WARN);
                 } catch (NoClassDefFoundError e) {
                     attributes.log("Unable to verify class " + classname
                                    + ". It is not defined.", Project.MSG_WARN);
                 } catch (Throwable t) {
                     attributes.log("Unable to verify class " + classname
                                    + ". Loading caused Exception: "
                                    + t.getMessage(), Project.MSG_WARN);
                 }
             }
             return target;
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/rmic/RmicAdapter.java b/src/main/org/apache/tools/ant/taskdefs/rmic/RmicAdapter.java
index 8493d4eaa..851f3d5a5 100644
--- a/src/main/org/apache/tools/ant/taskdefs/rmic/RmicAdapter.java
+++ b/src/main/org/apache/tools/ant/taskdefs/rmic/RmicAdapter.java
@@ -1,67 +1,67 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.rmic;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.Rmic;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.FileNameMapper;
 
 /**
  * The interface that all rmic adapters must adhere to.
  *
  * <p>A rmic adapter is an adapter that interprets the rmic's
  * parameters in preperation to be passed off to the compiler this
  * adapter represents.  As all the necessary values are stored in the
  * Rmic task itself, the only thing all adapters need is the rmic
  * task, the execute command and a parameterless constructor (for
  * reflection).</p>
  *
  * @since Ant 1.4
  */
 
 public interface RmicAdapter {
 
     /**
      * Sets the rmic attributes, which are stored in the Rmic task.
      * @param attributes the rmic attributes to use
      */
     void setRmic(Rmic attributes);
 
     /**
      * Call the rmic compiler.
      *
      * @return true if has the compilation been successful
      * @throws BuildException on error
      */
     boolean execute() throws BuildException;
 
     /**
      * Maps source class files to the files generated by this rmic
      * implementation.
      * @return the filename mapper used by this implementation
      */
     FileNameMapper getMapper();
 
     /**
      * The CLASSPATH this rmic process will use.
-     * @return the classpaht this rmic process will use
+     * @return the classpath this rmic process will use
      */
     Path getClasspath();
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/rmic/WLRmic.java b/src/main/org/apache/tools/ant/taskdefs/rmic/WLRmic.java
index 613de52ea..3b1f2a19e 100644
--- a/src/main/org/apache/tools/ant/taskdefs/rmic/WLRmic.java
+++ b/src/main/org/apache/tools/ant/taskdefs/rmic/WLRmic.java
@@ -1,136 +1,136 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.rmic;
 
 import java.lang.reflect.Method;
 
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.Commandline;
 
 /**
  * The implementation of the rmic for WebLogic
  *
  * @since Ant 1.4
  */
 public class WLRmic extends DefaultRmicAdapter {
     /** The classname of the weblogic rmic */
     public static final String WLRMIC_CLASSNAME = "weblogic.rmic";
     /**
      * the name of this adapter for users to select
      */
     public static final String COMPILER_NAME = "weblogic";
 
     /** The error string to use if not able to find the weblogic rmic */
     public static final String ERROR_NO_WLRMIC_ON_CLASSPATH =
         "Cannot use WebLogic rmic, as it is not "
         + "available. Add it to Ant's classpath with the -lib option";
 
     /** The error string to use if not able to start the weblogic rmic */
     public static final String ERROR_WLRMIC_FAILED = "Error starting WebLogic rmic: ";
     /** The stub suffix */
     public static final String WL_RMI_STUB_SUFFIX = "_WLStub";
     /** The skeleton suffix */
     public static final String WL_RMI_SKEL_SUFFIX = "_WLSkel";
-    /** upsupported error message */
+    /** unsupported error message */
     public static final String UNSUPPORTED_STUB_OPTION = "Unsupported stub option: ";
 
     /**
      * Carry out the rmic compilation.
      * @return true if the compilation succeeded
      * @throws  BuildException on error
      */
     public boolean execute() throws BuildException {
         getRmic().log("Using WebLogic rmic", Project.MSG_VERBOSE);
         Commandline cmd = setupRmicCommand(new String[] {"-noexit"});
 
         AntClassLoader loader = null;
         try {
             // Create an instance of the rmic
             Class c = null;
             if (getRmic().getClasspath() == null) {
                 c = Class.forName(WLRMIC_CLASSNAME);
             } else {
                 loader
                     = getRmic().getProject().createClassLoader(getRmic().getClasspath());
                 c = Class.forName(WLRMIC_CLASSNAME, true, loader);
             }
             Method doRmic = c.getMethod("main",
                                         new Class [] {String[].class});
             doRmic.invoke(null, new Object[] {cmd.getArguments()});
             return true;
         } catch (ClassNotFoundException ex) {
             throw new BuildException(ERROR_NO_WLRMIC_ON_CLASSPATH, getRmic().getLocation());
         } catch (Exception ex) {
             if (ex instanceof BuildException) {
                 throw (BuildException) ex;
             } else {
                 throw new BuildException(ERROR_WLRMIC_FAILED, ex,
                                          getRmic().getLocation());
             }
         } finally {
             if (loader != null) {
                 loader.cleanup();
             }
         }
     }
 
     /**
      * Get the suffix for the rmic stub classes
      * @return the stub suffix
      */
     public String getStubClassSuffix() {
         return WL_RMI_STUB_SUFFIX;
     }
 
     /**
      * Get the suffix for the rmic skeleton classes
      * @return the skeleton suffix
      */
     public String getSkelClassSuffix() {
         return WL_RMI_SKEL_SUFFIX;
     }
 
     /**
      * Strip out all -J args from the command list.
      *
      * @param compilerArgs the original compiler arguments
      * @return the filtered set.
      */
     protected String[] preprocessCompilerArgs(String[] compilerArgs) {
         return filterJvmCompilerArgs(compilerArgs);
     }
 
     /**
      * This is an override point; no stub version is returned. If any
      * stub option is set, a warning is printed.
      * @return null, for no stub version
      */
     protected String addStubVersionOptions() {
         //handle the many different stub options.
         String stubVersion = getRmic().getStubVersion();
         if (null != stubVersion) {
             getRmic().log(UNSUPPORTED_STUB_OPTION + stubVersion,
                           Project.MSG_WARN);
         }
         return null;
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/AbstractFileSet.java b/src/main/org/apache/tools/ant/types/AbstractFileSet.java
index 247a71284..60e0b900a 100644
--- a/src/main/org/apache/tools/ant/types/AbstractFileSet.java
+++ b/src/main/org/apache/tools/ant/types/AbstractFileSet.java
@@ -1,928 +1,928 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types;
 
 import java.io.File;
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.Stack;
 import java.util.Vector;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.FileScanner;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.types.selectors.OrSelector;
 import org.apache.tools.ant.types.selectors.AndSelector;
 import org.apache.tools.ant.types.selectors.NotSelector;
 import org.apache.tools.ant.types.selectors.DateSelector;
 import org.apache.tools.ant.types.selectors.FileSelector;
 import org.apache.tools.ant.types.selectors.NoneSelector;
 import org.apache.tools.ant.types.selectors.SizeSelector;
 import org.apache.tools.ant.types.selectors.TypeSelector;
 import org.apache.tools.ant.types.selectors.DepthSelector;
 import org.apache.tools.ant.types.selectors.DependSelector;
 import org.apache.tools.ant.types.selectors.ExtendSelector;
 import org.apache.tools.ant.types.selectors.SelectSelector;
 import org.apache.tools.ant.types.selectors.PresentSelector;
 import org.apache.tools.ant.types.selectors.SelectorScanner;
 import org.apache.tools.ant.types.selectors.ContainsSelector;
 import org.apache.tools.ant.types.selectors.FilenameSelector;
 import org.apache.tools.ant.types.selectors.MajoritySelector;
 import org.apache.tools.ant.types.selectors.DifferentSelector;
 import org.apache.tools.ant.types.selectors.SelectorContainer;
 import org.apache.tools.ant.types.selectors.ContainsRegexpSelector;
 import org.apache.tools.ant.types.selectors.ReadableSelector;
 import org.apache.tools.ant.types.selectors.WritableSelector;
 import org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector;
 
 /**
  * Class that holds an implicit patternset and supports nested
  * patternsets and creates a DirectoryScanner using these patterns.
  *
  * <p>Common base class for DirSet and FileSet.</p>
  *
  */
 public abstract class AbstractFileSet extends DataType
     implements Cloneable, SelectorContainer {
 
     private PatternSet defaultPatterns = new PatternSet();
     private Vector additionalPatterns = new Vector();
     private Vector selectors = new Vector();
 
     private File dir;
     private boolean useDefaultExcludes = true;
     private boolean caseSensitive = true;
     private boolean followSymlinks = true;
     private boolean errorOnMissingDir = true;
     private int maxLevelsOfSymlinks = DirectoryScanner.MAX_LEVELS_OF_SYMLINKS;
 
     /* cached DirectoryScanner instance for our own Project only */
     private DirectoryScanner directoryScanner = null;
 
     /**
      * Construct a new <code>AbstractFileSet</code>.
      */
     public AbstractFileSet() {
         super();
     }
 
     /**
      * Construct a new <code>AbstractFileSet</code>, shallowly cloned
      * from the specified <code>AbstractFileSet</code>.
      * @param fileset the <code>AbstractFileSet</code> to use as a template.
      */
     protected AbstractFileSet(AbstractFileSet fileset) {
         this.dir = fileset.dir;
         this.defaultPatterns = fileset.defaultPatterns;
         this.additionalPatterns = fileset.additionalPatterns;
         this.selectors = fileset.selectors;
         this.useDefaultExcludes = fileset.useDefaultExcludes;
         this.caseSensitive = fileset.caseSensitive;
         this.followSymlinks = fileset.followSymlinks;
         this.errorOnMissingDir = fileset.errorOnMissingDir;
         this.maxLevelsOfSymlinks = fileset.maxLevelsOfSymlinks;
         setProject(fileset.getProject());
     }
 
     /**
      * Makes this instance in effect a reference to another instance.
      *
      * <p>You must not set another attribute or nest elements inside
      * this element if you make it a reference.</p>
      * @param r the <code>Reference</code> to use.
      * @throws BuildException on error
      */
     public void setRefid(Reference r) throws BuildException {
         if (dir != null || defaultPatterns.hasPatterns(getProject())) {
             throw tooManyAttributes();
         }
         if (!additionalPatterns.isEmpty()) {
             throw noChildrenAllowed();
         }
         if (!selectors.isEmpty()) {
             throw noChildrenAllowed();
         }
         super.setRefid(r);
     }
 
     /**
      * Sets the base-directory for this instance.
      * @param dir the directory's <code>File</code> instance.
      * @throws BuildException on error
      */
     public synchronized void setDir(File dir) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         this.dir = dir;
         directoryScanner = null;
     }
 
     /**
      * Retrieves the base-directory for this instance.
      * @return <code>File</code>.
      */
     public File getDir() {
         return getDir(getProject());
     }
 
     /**
      * Retrieves the base-directory for this instance.
      * @param p the <code>Project</code> against which the
      *          reference is resolved, if set.
      * @return <code>File</code>.
      */
     public synchronized File getDir(Project p) {
         if (isReference()) {
             return getRef(p).getDir(p);
         }
         dieOnCircularReference();
         return dir;
     }
 
     /**
      * Creates a nested patternset.
      * @return <code>PatternSet</code>.
      */
     public synchronized PatternSet createPatternSet() {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         PatternSet patterns = new PatternSet();
         additionalPatterns.addElement(patterns);
         directoryScanner = null;
         return patterns;
     }
 
     /**
      * Add a name entry to the include list.
      * @return <code>PatternSet.NameEntry</code>.
      */
     public synchronized PatternSet.NameEntry createInclude() {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         directoryScanner = null;
         return defaultPatterns.createInclude();
     }
 
     /**
      * Add a name entry to the include files list.
      * @return <code>PatternSet.NameEntry</code>.
      */
     public synchronized PatternSet.NameEntry createIncludesFile() {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         directoryScanner = null;
         return defaultPatterns.createIncludesFile();
     }
 
     /**
      * Add a name entry to the exclude list.
      * @return <code>PatternSet.NameEntry</code>.
      */
     public synchronized PatternSet.NameEntry createExclude() {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         directoryScanner = null;
         return defaultPatterns.createExclude();
     }
 
     /**
      * Add a name entry to the excludes files list.
      * @return <code>PatternSet.NameEntry</code>.
      */
     public synchronized PatternSet.NameEntry createExcludesFile() {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         directoryScanner = null;
         return defaultPatterns.createExcludesFile();
     }
 
     /**
      * Creates a single file fileset.
      * @param file the single <code>File</code> included in this
      *             <code>AbstractFileSet</code>.
      */
     public synchronized void setFile(File file) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         setDir(file.getParentFile());
         createInclude().setName(file.getName());
     }
 
     /**
      * Appends <code>includes</code> to the current list of include
      * patterns.
      *
      * <p>Patterns may be separated by a comma or a space.</p>
      *
      * @param includes the <code>String</code> containing the include patterns.
      */
     public synchronized void setIncludes(String includes) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         defaultPatterns.setIncludes(includes);
         directoryScanner = null;
     }
 
     /**
      * Appends <code>includes</code> to the current list of include
      * patterns.
      *
      * @param includes array containing the include patterns.
      * @since Ant 1.7
      */
     public synchronized void appendIncludes(String[] includes) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         if (includes != null) {
             for (int i = 0; i < includes.length; i++) {
                 defaultPatterns.createInclude().setName(includes[i]);
             }
             directoryScanner = null;
         }
     }
 
     /**
      * Appends <code>excludes</code> to the current list of exclude
      * patterns.
      *
      * <p>Patterns may be separated by a comma or a space.</p>
      *
      * @param excludes the <code>String</code> containing the exclude patterns.
      */
     public synchronized void setExcludes(String excludes) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         defaultPatterns.setExcludes(excludes);
         directoryScanner = null;
     }
 
     /**
      * Appends <code>excludes</code> to the current list of include
      * patterns.
      *
      * @param excludes array containing the exclude patterns.
      * @since Ant 1.7
      */
     public synchronized void appendExcludes(String[] excludes) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         if (excludes != null) {
             for (int i = 0; i < excludes.length; i++) {
                 defaultPatterns.createExclude().setName(excludes[i]);
             }
             directoryScanner = null;
         }
     }
 
     /**
      * Sets the <code>File</code> containing the includes patterns.
      *
      * @param incl <code>File</code> instance.
      * @throws BuildException on error
      */
     public synchronized void setIncludesfile(File incl) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         defaultPatterns.setIncludesfile(incl);
         directoryScanner = null;
     }
 
     /**
      * Sets the <code>File</code> containing the excludes patterns.
      *
      * @param excl <code>File</code> instance.
      * @throws BuildException on error
      */
     public synchronized void setExcludesfile(File excl) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         defaultPatterns.setExcludesfile(excl);
         directoryScanner = null;
     }
 
     /**
      * Sets whether default exclusions should be used or not.
      *
      * @param useDefaultExcludes <code>boolean</code>.
      */
     public synchronized void setDefaultexcludes(boolean useDefaultExcludes) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         this.useDefaultExcludes = useDefaultExcludes;
         directoryScanner = null;
     }
 
     /**
      * Whether default exclusions should be used or not.
      * @return the default exclusions value.
      * @since Ant 1.6.3
      */
     public synchronized boolean getDefaultexcludes() {
         if (isReference()) {
             return getRef(getProject()).getDefaultexcludes();
         }
         dieOnCircularReference();
         return useDefaultExcludes;
     }
 
     /**
      * Sets case sensitivity of the file system.
      *
      * @param caseSensitive <code>boolean</code>.
      */
     public synchronized void setCaseSensitive(boolean caseSensitive) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         this.caseSensitive = caseSensitive;
         directoryScanner = null;
     }
 
     /**
      * Find out if the fileset is case sensitive.
      *
      * @return <code>boolean</code> indicating whether the fileset is
      * case sensitive.
      *
      * @since Ant 1.7
      */
     public synchronized boolean isCaseSensitive() {
         if (isReference()) {
             return getRef(getProject()).isCaseSensitive();
         }
         dieOnCircularReference();
         return caseSensitive;
     }
 
     /**
      * Sets whether or not symbolic links should be followed.
      *
      * @param followSymlinks whether or not symbolic links should be followed.
      */
     public synchronized void setFollowSymlinks(boolean followSymlinks) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         this.followSymlinks = followSymlinks;
         directoryScanner = null;
     }
 
     /**
      * Find out if the fileset wants to follow symbolic links.
      *
      * @return <code>boolean</code> indicating whether symbolic links
      *         should be followed.
      *
      * @since Ant 1.6
      */
     public synchronized boolean isFollowSymlinks() {
         if (isReference()) {
             return getRef(getProject()).isCaseSensitive();
         }
         dieOnCircularReference();
         return followSymlinks;
     }
 
     /**
      * The maximum number of times a symbolic link may be followed
      * during a scan.
      *
      * @since Ant 1.8.0
      */
     public void setMaxLevelsOfSymlinks(int max) {
         maxLevelsOfSymlinks = max;
     }
 
     /**
      * The maximum number of times a symbolic link may be followed
      * during a scan.
      *
      * @since Ant 1.8.0
      */
     public int getMaxLevelsOfSymlinks() {
         return maxLevelsOfSymlinks;
     }
 
     /**
      * Sets whether an error is thrown if a directory does not exist.
      *
      * @param errorOnMissingDir true if missing directories cause errors,
      *                        false if not.
      */
      public void setErrorOnMissingDir(boolean errorOnMissingDir) {
          this.errorOnMissingDir = errorOnMissingDir;
      }
 
     /**
-     * Gets whether an error is/shold be thrown if the base directory
+     * Gets whether an error is/should be thrown if the base directory
      * does not exist.
      * @since Ant 1.8.2
      */
      public boolean getErrorOnMissingDir() {
          return errorOnMissingDir;
      }
 
     /**
      * Returns the directory scanner needed to access the files to process.
      * @return a <code>DirectoryScanner</code> instance.
      */
     public DirectoryScanner getDirectoryScanner() {
         return getDirectoryScanner(getProject());
     }
 
     /**
      * Returns the directory scanner needed to access the files to process.
      * @param p the Project against which the DirectoryScanner should be configured.
      * @return a <code>DirectoryScanner</code> instance.
      */
     public DirectoryScanner getDirectoryScanner(Project p) {
         if (isReference()) {
             return getRef(p).getDirectoryScanner(p);
         }
         dieOnCircularReference();
         DirectoryScanner ds = null;
         synchronized (this) {
             if (directoryScanner != null && p == getProject()) {
                 ds = directoryScanner;
             } else {
                 if (dir == null) {
                     throw new BuildException("No directory specified for "
                                              + getDataTypeName() + ".");
                 }
                 if (!dir.exists() && errorOnMissingDir) {
                     throw new BuildException(dir.getAbsolutePath()
                                              + DirectoryScanner
                                              .DOES_NOT_EXIST_POSTFIX);
                 }
                 if (!dir.isDirectory() && dir.exists()) {
                     throw new BuildException(dir.getAbsolutePath()
                                              + " is not a directory.");
                 }
                 ds = new DirectoryScanner();
                 setupDirectoryScanner(ds, p);
                 ds.setFollowSymlinks(followSymlinks);
                 ds.setErrorOnMissingDir(errorOnMissingDir);
                 ds.setMaxLevelsOfSymlinks(maxLevelsOfSymlinks);
                 directoryScanner = (p == getProject()) ? ds : directoryScanner;
             }
         }
         ds.scan();
         return ds;
     }
 
     /**
      * Set up the specified directory scanner against this
      * AbstractFileSet's Project.
      * @param ds a <code>FileScanner</code> instance.
      */
     public void setupDirectoryScanner(FileScanner ds) {
         setupDirectoryScanner(ds, getProject());
     }
 
     /**
      * Set up the specified directory scanner against the specified project.
      * @param ds a <code>FileScanner</code> instance.
      * @param p an Ant <code>Project</code> instance.
      */
     public synchronized void setupDirectoryScanner(FileScanner ds, Project p) {
         if (isReference()) {
             getRef(p).setupDirectoryScanner(ds, p);
             return;
         }
         dieOnCircularReference(p);
         if (ds == null) {
             throw new IllegalArgumentException("ds cannot be null");
         }
         ds.setBasedir(dir);
 
         PatternSet ps = mergePatterns(p);
         p.log(getDataTypeName() + ": Setup scanner in dir " + dir
             + " with " + ps, Project.MSG_DEBUG);
 
         ds.setIncludes(ps.getIncludePatterns(p));
         ds.setExcludes(ps.getExcludePatterns(p));
         if (ds instanceof SelectorScanner) {
             SelectorScanner ss = (SelectorScanner) ds;
             ss.setSelectors(getSelectors(p));
         }
         if (useDefaultExcludes) {
             ds.addDefaultExcludes();
         }
         ds.setCaseSensitive(caseSensitive);
     }
 
     /**
      * Performs the check for circular references and returns the
      * referenced FileSet.
      * @param p the current project
      * @return the referenced FileSet
      */
     protected AbstractFileSet getRef(Project p) {
         return (AbstractFileSet) getCheckedRef(p);
     }
 
     // SelectorContainer methods
 
     /**
      * Indicates whether there are any selectors here.
      *
      * @return whether any selectors are in this container.
      */
     public synchronized boolean hasSelectors() {
         if (isReference()) {
             return getRef(getProject()).hasSelectors();
         }
         dieOnCircularReference();
         return !(selectors.isEmpty());
     }
 
     /**
      * Indicates whether there are any patterns here.
      *
      * @return whether any patterns are in this container.
      */
     public synchronized boolean hasPatterns() {
         if (isReference() && getProject() != null) {
             return getRef(getProject()).hasPatterns();
         }
         dieOnCircularReference();
         if (defaultPatterns.hasPatterns(getProject())) {
             return true;
         }
         Enumeration e = additionalPatterns.elements();
         while (e.hasMoreElements()) {
             PatternSet ps = (PatternSet) e.nextElement();
             if (ps.hasPatterns(getProject())) {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * Gives the count of the number of selectors in this container.
      *
      * @return the number of selectors in this container as an <code>int</code>.
      */
     public synchronized int selectorCount() {
         if (isReference()) {
             return getRef(getProject()).selectorCount();
         }
         dieOnCircularReference();
         return selectors.size();
     }
 
     /**
      * Returns the set of selectors as an array.
      * @param p the current project
      * @return a <code>FileSelector[]</code> of the selectors in this container.
      */
     public synchronized FileSelector[] getSelectors(Project p) {
         if (isReference()) {
             return getRef(getProject()).getSelectors(p);
         }
         dieOnCircularReference(p);
         return (FileSelector[]) (selectors.toArray(
             new FileSelector[selectors.size()]));
     }
 
     /**
      * Returns an enumerator for accessing the set of selectors.
      *
      * @return an <code>Enumeration</code> of selectors.
      */
     public synchronized Enumeration selectorElements() {
         if (isReference()) {
             return getRef(getProject()).selectorElements();
         }
         dieOnCircularReference();
         return selectors.elements();
     }
 
     /**
      * Add a new selector into this container.
      *
      * @param selector the new <code>FileSelector</code> to add.
      */
     public synchronized void appendSelector(FileSelector selector) {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         selectors.addElement(selector);
         directoryScanner = null;
         setChecked(false);
     }
 
     /* Methods below all add specific selectors */
 
     /**
      * Add a "Select" selector entry on the selector list.
      * @param selector the <code>SelectSelector</code> to add.
      */
     public void addSelector(SelectSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add an "And" selector entry on the selector list.
      * @param selector the <code>AndSelector</code> to add.
      */
     public void addAnd(AndSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add an "Or" selector entry on the selector list.
      * @param selector the <code>OrSelector</code> to add.
      */
     public void addOr(OrSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a "Not" selector entry on the selector list.
      * @param selector the <code>NotSelector</code> to add.
      */
     public void addNot(NotSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a "None" selector entry on the selector list.
      * @param selector the <code>NoneSelector</code> to add.
      */
     public void addNone(NoneSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a majority selector entry on the selector list.
      * @param selector the <code>MajoritySelector</code> to add.
      */
     public void addMajority(MajoritySelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a selector date entry on the selector list.
      * @param selector the <code>DateSelector</code> to add.
      */
     public void addDate(DateSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a selector size entry on the selector list.
      * @param selector the <code>SizeSelector</code> to add.
      */
     public void addSize(SizeSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a DifferentSelector entry on the selector list.
      * @param selector the <code>DifferentSelector</code> to add.
      */
     public void addDifferent(DifferentSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a selector filename entry on the selector list.
      * @param selector the <code>FilenameSelector</code> to add.
      */
     public void addFilename(FilenameSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a selector type entry on the selector list.
      * @param selector the <code>TypeSelector</code> to add.
      */
     public void addType(TypeSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add an extended selector entry on the selector list.
      * @param selector the <code>ExtendSelector</code> to add.
      */
     public void addCustom(ExtendSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a contains selector entry on the selector list.
      * @param selector the <code>ContainsSelector</code> to add.
      */
     public void addContains(ContainsSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a present selector entry on the selector list.
      * @param selector the <code>PresentSelector</code> to add.
      */
     public void addPresent(PresentSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a depth selector entry on the selector list.
      * @param selector the <code>DepthSelector</code> to add.
      */
     public void addDepth(DepthSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a depends selector entry on the selector list.
      * @param selector the <code>DependSelector</code> to add.
      */
     public void addDepend(DependSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add a regular expression selector entry on the selector list.
      * @param selector the <code>ContainsRegexpSelector</code> to add.
      */
     public void addContainsRegexp(ContainsRegexpSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Add the modified selector.
      * @param selector the <code>ModifiedSelector</code> to add.
      * @since ant 1.6
      */
     public void addModified(ModifiedSelector selector) {
         appendSelector(selector);
     }
 
     public void addReadable(ReadableSelector r) {
         appendSelector(r);
     }
 
     public void addWritable(WritableSelector w) {
         appendSelector(w);
     }
 
     /**
-     * Add an arbitary selector.
+     * Add an arbitrary selector.
      * @param selector the <code>FileSelector</code> to add.
      * @since Ant 1.6
      */
     public void add(FileSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * Returns included files as a list of semicolon-separated filenames.
      *
      * @return a <code>String</code> of included filenames.
      */
     public String toString() {
         if (isReference()) {
             return getRef(getProject()).toString();
         }
         dieOnCircularReference();
         DirectoryScanner ds = getDirectoryScanner(getProject());
         String[] files = ds.getIncludedFiles();
         StringBuffer sb = new StringBuffer();
 
         for (int i = 0; i < files.length; i++) {
             if (i > 0) {
                 sb.append(';');
             }
             sb.append(files[i]);
         }
         return sb.toString();
     }
 
     /**
      * Creates a deep clone of this instance, except for the nested
      * selectors (the list of selectors is a shallow clone of this
      * instance's list).
      * @return the cloned object
      * @since Ant 1.6
      */
     public synchronized Object clone() {
         if (isReference()) {
             return (getRef(getProject())).clone();
         } else {
             try {
                 AbstractFileSet fs = (AbstractFileSet) super.clone();
                 fs.defaultPatterns = (PatternSet) defaultPatterns.clone();
                 fs.additionalPatterns = new Vector(additionalPatterns.size());
                 Enumeration e = additionalPatterns.elements();
                 while (e.hasMoreElements()) {
                     fs.additionalPatterns
                         .addElement(((PatternSet) e.nextElement()).clone());
                 }
                 fs.selectors = new Vector(selectors);
                 return fs;
             } catch (CloneNotSupportedException e) {
                 throw new BuildException(e);
             }
         }
     }
 
     /**
      * Get the merged include patterns for this AbstractFileSet.
      * @param p the project to use.
      * @return the include patterns of the default pattern set and all
      * nested patternsets.
      *
      * @since Ant 1.7
      */
     public String[] mergeIncludes(Project p) {
         return mergePatterns(p).getIncludePatterns(p);
     }
 
     /**
      * Get the merged exclude patterns for this AbstractFileSet.
      * @param p the project to use.
      * @return the exclude patterns of the default pattern set and all
      * nested patternsets.
      *
      * @since Ant 1.7
      */
     public String[] mergeExcludes(Project p) {
         return mergePatterns(p).getExcludePatterns(p);
     }
 
     /**
      * Get the merged patterns for this AbstractFileSet.
      * @param p the project to use.
      * @return the default patternset merged with the additional sets
      * in a new PatternSet instance.
      *
      * @since Ant 1.7
      */
     public synchronized PatternSet mergePatterns(Project p) {
         if (isReference()) {
             return getRef(p).mergePatterns(p);
         }
         dieOnCircularReference();
         PatternSet ps = (PatternSet) defaultPatterns.clone();
         final int count = additionalPatterns.size();
         for (int i = 0; i < count; i++) {
             Object o = additionalPatterns.elementAt(i);
             ps.append((PatternSet) o, p);
         }
         return ps;
     }
 
     protected synchronized void dieOnCircularReference(Stack stk, Project p)
         throws BuildException {
         if (isChecked()) {
             return;
         }
         if (isReference()) {
             super.dieOnCircularReference(stk, p);
         } else {
             for (Iterator i = selectors.iterator(); i.hasNext(); ) {
                 Object o = i.next();
                 if (o instanceof DataType) {
                     pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);
                 }
             }
             for (Iterator i = additionalPatterns.iterator(); i.hasNext(); ) {
                 PatternSet ps = (PatternSet) i.next();
                 pushAndInvokeCircularReferenceCheck(ps, stk, p);
             }
             setChecked(true);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/ArchiveFileSet.java b/src/main/org/apache/tools/ant/types/ArchiveFileSet.java
index a5890a048..4f77bc737 100644
--- a/src/main/org/apache/tools/ant/types/ArchiveFileSet.java
+++ b/src/main/org/apache/tools/ant/types/ArchiveFileSet.java
@@ -1,564 +1,564 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types;
 
 import java.io.File;
 import java.util.Iterator;
 import java.util.Stack;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.zip.UnixStat;
 
 /**
  * A ArchiveFileSet is a FileSet with extra attributes useful in the
  * context of archiving tasks.
  *
  * It includes a prefix attribute which is prepended to each entry in
  * the output archive file as well as a fullpath attribute.  It also
  * supports Unix file permissions for files and directories.
  *
  * @since Ant 1.7
  */
 public abstract class ArchiveFileSet extends FileSet {
 
     private static final int BASE_OCTAL = 8;
 
     /**
      * Default value for the dirmode attribute.
      *
      * @since Ant 1.5.2
      */
     public static final int DEFAULT_DIR_MODE =
         UnixStat.DIR_FLAG | UnixStat.DEFAULT_DIR_PERM;
 
     /**
      * Default value for the filemode attribute.
      *
      * @since Ant 1.5.2
      */
     public static final int DEFAULT_FILE_MODE =
         UnixStat.FILE_FLAG | UnixStat.DEFAULT_FILE_PERM;
 
     private Resource src          = null;
     private String prefix         = "";
     private String fullpath       = "";
     private boolean hasDir        = false;
     private int fileMode          = DEFAULT_FILE_MODE;
     private int dirMode           = DEFAULT_DIR_MODE;
 
     private boolean fileModeHasBeenSet = false;
     private boolean dirModeHasBeenSet  = false;
     private static final String ERROR_DIR_AND_SRC_ATTRIBUTES = "Cannot set both dir and src attributes";
     private static final String ERROR_PATH_AND_PREFIX = "Cannot set both fullpath and prefix attributes";
 
     private boolean errorOnMissingArchive = true;
 
     /** Constructor for ArchiveFileSet */
     public ArchiveFileSet() {
         super();
     }
 
     /**
-     * Constructor using a fileset arguement.
+     * Constructor using a fileset argument.
      * @param fileset the fileset to use
      */
     protected ArchiveFileSet(FileSet fileset) {
         super(fileset);
     }
 
     /**
-     * Constructor using a archive fileset arguement.
+     * Constructor using a archive fileset argument.
      * @param fileset the archivefileset to use
      */
     protected ArchiveFileSet(ArchiveFileSet fileset) {
         super(fileset);
         src = fileset.src;
         prefix = fileset.prefix;
         fullpath = fileset.fullpath;
         hasDir = fileset.hasDir;
         fileMode = fileset.fileMode;
         dirMode = fileset.dirMode;
         fileModeHasBeenSet = fileset.fileModeHasBeenSet;
         dirModeHasBeenSet = fileset.dirModeHasBeenSet;
         errorOnMissingArchive = fileset.errorOnMissingArchive;
     }
 
     /**
      * Set the directory for the fileset.
      * @param dir the directory for the fileset
      * @throws BuildException on error
      */
     public void setDir(File dir) throws BuildException {
         checkAttributesAllowed();
         if (src != null) {
             throw new BuildException(ERROR_DIR_AND_SRC_ATTRIBUTES);
         }
         super.setDir(dir);
         hasDir = true;
     }
 
     /**
      * Set the source Archive file for the archivefileset.  Prevents both
      * "dir" and "src" from being specified.
      * @param a the archive as a single element Resource collection.
      */
     public void addConfigured(ResourceCollection a) {
         checkChildrenAllowed();
         if (a.size() != 1) {
             throw new BuildException("only single argument resource collections"
                                      + " are supported as archives");
         }
         setSrcResource(a.iterator().next());
     }
 
     /**
      * Set the source Archive file for the archivefileset.  Prevents both
      * "dir" and "src" from being specified.
      *
      * @param srcFile The archive from which to extract entries.
      */
     public void setSrc(File srcFile) {
         setSrcResource(new FileResource(srcFile));
     }
 
     /**
      * Set the source Archive file for the archivefileset.  Prevents both
      * "dir" and "src" from being specified.
      *
      * @param src The archive from which to extract entries.
      */
     public void setSrcResource(Resource src) {
         checkArchiveAttributesAllowed();
         if (hasDir) {
             throw new BuildException(ERROR_DIR_AND_SRC_ATTRIBUTES);
         }
         this.src = src;
         setChecked(false);
     }
 
     /**
      * Get the archive from which entries will be extracted.
      * @param p the project to use
      * @return the source file
      */
     public File getSrc(Project p) {
         if (isReference()) {
             return ((ArchiveFileSet) getRef(p)).getSrc(p);
         }
         return getSrc();
     }
 
     /**
      * Sets whether an error is thrown if an archive does not exist.
      *
      * @param errorOnMissingArchive true if missing archives cause errors,
      *                        false if not.
      * @since Ant 1.8.0
      */
     public void setErrorOnMissingArchive(boolean errorOnMissingArchive) {
         checkAttributesAllowed();
         this.errorOnMissingArchive = errorOnMissingArchive;
     }
 
     /**
      * Get the archive file from which entries will be extracted.
      * @return the archive in case the archive is a file, null otherwise.
      */
     public File getSrc() {
         if (isReference()) {
             return ((ArchiveFileSet) getCheckedRef()).getSrc();
         }
         dieOnCircularReference();
         if (src != null) {
             FileProvider fp = src.as(FileProvider.class);
             if (fp != null) {
                 return fp.getFile();
             }
         }
         return null;
     }
 
     /**
      * Performs the check for circular references and returns the
      * referenced object.
      * This is an override which does not delegate to the superclass; instead it invokes
-     * {@link #getRef(Project)}, because that conains the special support for fileset
+     * {@link #getRef(Project)}, because that contains the special support for fileset
      * references, which can be handled by all ArchiveFileSets.
      * @param p the Ant Project instance against which to resolve references.
      * @return the dereferenced object.
      * @throws BuildException if the reference is invalid (circular ref, wrong class, etc).
      * @since Ant 1.8
      */
     protected Object getCheckedRef(Project p) {
         return getRef(p);
     }
 
     /**
      * Prepend this prefix to the path for each archive entry.
      * Prevents both prefix and fullpath from being specified
      *
      * @param prefix The prefix to prepend to entries in the archive file.
      */
     public void setPrefix(String prefix) {
         checkArchiveAttributesAllowed();
         if (!"".equals(prefix) && !"".equals(fullpath)) {
             throw new BuildException(ERROR_PATH_AND_PREFIX);
         }
         this.prefix = prefix;
     }
 
     /**
      * Return the prefix prepended to entries in the archive file.
      * @param p the project to use
      * @return the prefix
      */
     public String getPrefix(Project p) {
         if (isReference()) {
             return ((ArchiveFileSet) getRef(p)).getPrefix(p);
         }
         dieOnCircularReference(p);
         return prefix;
     }
 
     /**
      * Set the full pathname of the single entry in this fileset.
      * Prevents both prefix and fullpath from being specified
      *
      * @param fullpath the full pathname of the single entry in this fileset.
      */
     public void setFullpath(String fullpath) {
         checkArchiveAttributesAllowed();
         if (!"".equals(prefix) && !"".equals(fullpath)) {
             throw new BuildException(ERROR_PATH_AND_PREFIX);
         }
         this.fullpath = fullpath;
     }
 
     /**
      * Return the full pathname of the single entry in this fileset.
      * @param p the project to use
      * @return the full path
      */
     public String getFullpath(Project p) {
         if (isReference()) {
             return ((ArchiveFileSet) getRef(p)).getFullpath(p);
         }
         dieOnCircularReference(p);
         return fullpath;
     }
 
     /**
      * Creates a scanner for this type of archive.
      * @return the scanner.
      */
     protected abstract ArchiveScanner newArchiveScanner();
 
     /**
      * Return the DirectoryScanner associated with this FileSet.
      * If the ArchiveFileSet defines a source Archive file, then an ArchiveScanner
      * is returned instead.
      * @param p the project to use
      * @return a directory scanner
      */
     public DirectoryScanner getDirectoryScanner(Project p) {
         if (isReference()) {
             return getRef(p).getDirectoryScanner(p);
         }
         dieOnCircularReference();
         if (src == null) {
             return super.getDirectoryScanner(p);
         }
         if (!src.isExists() && errorOnMissingArchive) {
             throw new BuildException(
                 "The archive " + src.getName() + " doesn't exist");
         }
         if (src.isDirectory()) {
             throw new BuildException("The archive " + src.getName()
                                      + " can't be a directory");
         }
         ArchiveScanner as = newArchiveScanner();
         as.setErrorOnMissingArchive(errorOnMissingArchive);
         as.setSrc(src);
         super.setDir(p.getBaseDir());
         setupDirectoryScanner(as, p);
         as.init();
         return as;
     }
 
     /**
      * Fulfill the ResourceCollection contract.
      * @return Iterator of Resources.
      * @since Ant 1.7
      */
     public Iterator<Resource> iterator() {
         if (isReference()) {
             return ((ResourceCollection) (getRef(getProject()))).iterator();
         }
         if (src == null) {
             return super.iterator();
         }
         ArchiveScanner as = (ArchiveScanner) getDirectoryScanner(getProject());
         return as.getResourceFiles(getProject());
     }
 
     /**
      * Fulfill the ResourceCollection contract.
      * @return size of the collection as int.
      * @since Ant 1.7
      */
     public int size() {
         if (isReference()) {
             return ((ResourceCollection) (getRef(getProject()))).size();
         }
         if (src == null) {
             return super.size();
         }
         ArchiveScanner as = (ArchiveScanner) getDirectoryScanner(getProject());
         return as.getIncludedFilesCount();
     }
 
     /**
      * Indicate whether this ResourceCollection is composed entirely of
      * Resources accessible via local filesystem conventions.  If true,
      * all Resources returned from this ResourceCollection should be
      * instances of FileResource.
      * @return whether this is a filesystem-only resource collection.
      * @since Ant 1.7
      */
     public boolean isFilesystemOnly() {
         if (isReference()) {
             return ((ArchiveFileSet) getCheckedRef()).isFilesystemOnly();
         }
         dieOnCircularReference();
         return src == null;
     }
 
     /**
      * A 3 digit octal string, specify the user, group and
      * other modes in the standard Unix fashion;
      * optional, default=0644
      * @param octalString a <code>String</code> value
      */
     public void setFileMode(String octalString) {
         checkArchiveAttributesAllowed();
         integerSetFileMode(Integer.parseInt(octalString, BASE_OCTAL));
     }
 
     /**
      * specify the user, group and
      * other modes in the standard Unix fashion;
      * optional, default=0644
      *
      * <p>We use the strange name so this method doesn't appear in
      * IntrospectionHelpers list of attribute setters.</p>
      * @param mode a <code>int</code> value
      * @since Ant 1.7
      */
     public void integerSetFileMode(int mode) {
         fileModeHasBeenSet = true;
         this.fileMode = UnixStat.FILE_FLAG | mode;
     }
 
     /**
      * Get the mode of the archive fileset
      * @param p the project to use
      * @return the mode
      */
     public int getFileMode(Project p) {
         if (isReference()) {
             return ((ArchiveFileSet) getRef(p)).getFileMode(p);
         }
         dieOnCircularReference();
         return fileMode;
     }
 
     /**
      * Whether the user has specified the mode explicitly.
      * @return true if it has been set
      */
     public boolean hasFileModeBeenSet() {
         if (isReference()) {
             return ((ArchiveFileSet) getRef(getProject())).hasFileModeBeenSet();
         }
         dieOnCircularReference();
         return fileModeHasBeenSet;
     }
 
     /**
      * A 3 digit octal string, specify the user, group and
      * other modes in the standard Unix fashion;
      * optional, default=0755
      * @param octalString a <code>String</code> value
      */
     public void setDirMode(String octalString) {
         checkArchiveAttributesAllowed();
         integerSetDirMode(Integer.parseInt(octalString, BASE_OCTAL));
     }
 
     /**
      * specify the user, group and
      * other modes in the standard Unix fashion;
      * optional, default=0755
      * <p>We use the strange name so this method doesn't appear in
      * IntrospectionHelpers list of attribute setters.</p>
      * @param mode a <code>int</code> value
      * @since Ant 1.7
      */
     public void integerSetDirMode(int mode) {
         dirModeHasBeenSet = true;
         this.dirMode = UnixStat.DIR_FLAG | mode;
     }
 
     /**
      * Get the dir mode of the archive fileset
      * @param p the project to use
      * @return the mode
      */
     public int getDirMode(Project p) {
         if (isReference()) {
             return ((ArchiveFileSet) getRef(p)).getDirMode(p);
         }
         dieOnCircularReference();
         return dirMode;
     }
 
     /**
      * Whether the user has specified the mode explicitly.
      *
      * @return true if it has been set
      */
     public boolean hasDirModeBeenSet() {
         if (isReference()) {
             return ((ArchiveFileSet) getRef(getProject())).hasDirModeBeenSet();
         }
         dieOnCircularReference();
         return dirModeHasBeenSet;
     }
 
     /**
      * A ArchiveFileset accepts another ArchiveFileSet or a FileSet as reference
      * FileSets are often used by the war task for the lib attribute
      * @param zfs the project to use
      */
     protected void configureFileSet(ArchiveFileSet zfs) {
         zfs.setPrefix(prefix);
         zfs.setFullpath(fullpath);
         zfs.fileModeHasBeenSet = fileModeHasBeenSet;
         zfs.fileMode = fileMode;
         zfs.dirModeHasBeenSet = dirModeHasBeenSet;
         zfs.dirMode = dirMode;
     }
 
     /**
      * Return a ArchiveFileSet that has the same properties
      * as this one.
      * @return the cloned archiveFileSet
      * @since Ant 1.6
      */
     public Object clone() {
         if (isReference()) {
             return ((ArchiveFileSet) getRef(getProject())).clone();
         }
         return super.clone();
     }
 
     /**
      * For file-based archivefilesets, return the same as for normal filesets;
      * else just return the path of the zip.
      * @return for file based archivefilesets, included files as a list
      * of semicolon-separated filenames. else just the name of the zip.
      */
     public String toString() {
         if (hasDir && getProject() != null) {
             return super.toString();
         }
         return src == null ? null : src.getName();
     }
 
     /**
      * Return the prefix prepended to entries in the archive file.
      * @return the prefix.
      * @deprecated since 1.7.
      */
     public String getPrefix() {
         return prefix;
     }
 
     /**
      * Return the full pathname of the single entryZ in this fileset.
      * @return the full pathname.
      * @deprecated since 1.7.
      */
     public String getFullpath() {
         return fullpath;
     }
 
     /**
      * @return the file mode.
      * @deprecated since 1.7.
      */
     public int getFileMode() {
         return fileMode;
     }
 
     /**
      * @return the dir mode.
      * @deprecated since 1.7.
      */
     public int getDirMode() {
         return dirMode;
     }
 
     /**
      * A check attributes for archiveFileSet.
      * If there is a reference, and
      * it is a ArchiveFileSet, the archive fileset attributes
      * cannot be used.
      * (Note, we can only see if the reference is an archive
      * fileset if the project has been set).
      */
     private void checkArchiveAttributesAllowed() {
         if (getProject() == null
             || (isReference()
                 && (getRefid().getReferencedObject(
                         getProject())
                     instanceof ArchiveFileSet))) {
             checkAttributesAllowed();
         }
     }
 
     protected synchronized void dieOnCircularReference(Stack stk, Project p)
         throws BuildException {
         if (isChecked()) {
             return;
         }
 
         // takes care of nested selectors
         super.dieOnCircularReference(stk, p);
 
         if (!isReference()) {
             if (src != null) {
                 pushAndInvokeCircularReferenceCheck(src, stk, p);
             }
             setChecked(true);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/ArchiveScanner.java b/src/main/org/apache/tools/ant/types/ArchiveScanner.java
index da5a97d02..4d2f3ad81 100644
--- a/src/main/org/apache/tools/ant/types/ArchiveScanner.java
+++ b/src/main/org/apache/tools/ant/types/ArchiveScanner.java
@@ -1,360 +1,360 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types;
 
 import java.io.File;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
 import java.util.Iterator;
 
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.FileResourceIterator;
 import org.apache.tools.ant.types.resources.FileProvider;
 
 /**
  * ArchiveScanner accesses the pattern matching algorithm in DirectoryScanner,
  * which are protected methods that can only be accessed by subclassing.
  *
  * This implementation of FileScanner defines getIncludedFiles to return
  * the matching archive entries.
  *
  * @since Ant 1.7
  */
 public abstract class ArchiveScanner extends DirectoryScanner {
     // CheckStyle:VisibilityModifier OFF - bc
 
     /**
      * The archive file which should be scanned.
      */
     protected File srcFile;
 
     // CheckStyle:VisibilityModifier ON
 
     /**
      * The archive resource which should be scanned.
      */
     private Resource src;
 
     /**
      * to record the last scanned zip file with its modification date
      */
     private Resource lastScannedResource;
 
     /**
      * record list of all file zip entries
      */
     private TreeMap fileEntries = new TreeMap();
 
     /**
      * record list of all directory zip entries
      */
     private TreeMap dirEntries = new TreeMap();
 
     /**
      * record list of matching file zip entries
      */
     private TreeMap matchFileEntries = new TreeMap();
 
     /**
      * record list of matching directory zip entries
      */
     private TreeMap matchDirEntries = new TreeMap();
 
     /**
      * encoding of file names.
      *
      * @since Ant 1.6
      */
     private String encoding;
 
     /**
      * @since Ant 1.8.0
      */
     private boolean errorOnMissingArchive = true;
 
     /**
      * Sets whether an error is thrown if an archive does not exist.
      *
      * @param errorOnMissingArchive true if missing archives cause errors,
      *                        false if not.
      * @since Ant 1.8.0
      */
     public void setErrorOnMissingArchive(boolean errorOnMissingArchive) {
         this.errorOnMissingArchive = errorOnMissingArchive;
     }
 
     /**
      * Don't scan when we have no zipfile.
      * @since Ant 1.7
      */
     public void scan() {
         if (src == null || (!src.isExists() && !errorOnMissingArchive)) {
             return;
         }
         super.scan();
     }
 
     /**
      * Sets the srcFile for scanning. This is the jar or zip file that
      * is scanned for matching entries.
      *
      * @param srcFile the (non-null) archive file name for scanning
      */
     public void setSrc(File srcFile) {
         setSrc(new FileResource(srcFile));
     }
 
     /**
      * Sets the src for scanning. This is the jar or zip file that
      * is scanned for matching entries.
      *
      * @param src the (non-null) archive resource
      */
     public void setSrc(Resource src) {
         this.src = src;
         FileProvider fp = src.as(FileProvider.class);
         if (fp != null) {
             srcFile = fp.getFile();
         }
     }
 
     /**
      * Sets encoding of file names.
      * @param encoding the encoding format
      * @since Ant 1.6
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * Returns the names of the files which matched at least one of the
      * include patterns and none of the exclude patterns.
      * The names are relative to the base directory.
      *
      * @return the names of the files which matched at least one of the
      *         include patterns and none of the exclude patterns.
      */
     public String[] getIncludedFiles() {
         if (src == null) {
             return super.getIncludedFiles();
         }
         scanme();
         Set s = matchFileEntries.keySet();
         return (String[]) (s.toArray(new String[s.size()]));
     }
 
     /**
      * Override parent implementation.
      * @return count of included files.
      * @since Ant 1.7
      */
     public int getIncludedFilesCount() {
         if (src == null) {
             return super.getIncludedFilesCount();
         }
         scanme();
         return matchFileEntries.size();
     }
 
     /**
      * Returns the names of the directories which matched at least one of the
      * include patterns and none of the exclude patterns.
      * The names are relative to the base directory.
      *
      * @return the names of the directories which matched at least one of the
      * include patterns and none of the exclude patterns.
      */
     public String[] getIncludedDirectories() {
         if (src == null) {
             return super.getIncludedDirectories();
         }
         scanme();
         Set s = matchDirEntries.keySet();
         return (String[]) (s.toArray(new String[s.size()]));
     }
 
     /**
      * Override parent implementation.
      * @return count of included directories.
      * @since Ant 1.7
      */
     public int getIncludedDirsCount() {
         if (src == null) {
             return super.getIncludedDirsCount();
         }
         scanme();
         return matchDirEntries.size();
     }
 
     /**
      * Get the set of Resources that represent files.
      * @param project since Ant 1.8
      * @return an Iterator of Resources.
      * @since Ant 1.7
      */
     /* package-private for now */ Iterator getResourceFiles(Project project) {
         if (src == null) {
             return new FileResourceIterator(project, getBasedir(), getIncludedFiles());
         }
         scanme();
         return matchFileEntries.values().iterator();
     }
 
     /**
      * Get the set of Resources that represent directories.
      * @param project since Ant 1.8
      * @return an Iterator of Resources.
      * @since Ant 1.7
      */
     /* package-private for now */  Iterator getResourceDirectories(Project project) {
         if (src == null) {
             return new FileResourceIterator(project, getBasedir(), getIncludedDirectories());
         }
         scanme();
         return matchDirEntries.values().iterator();
     }
 
     /**
      * Initialize DirectoryScanner data structures.
      */
     public void init() {
         if (includes == null) {
             // No includes supplied, so set it to 'matches all'
             includes = new String[1];
             includes[0] = "**";
         }
         if (excludes == null) {
             excludes = new String[0];
         }
     }
 
     /**
      * Matches a jar entry against the includes/excludes list,
      * normalizing the path separator.
      *
      * @param path the (non-null) path name to test for inclusion
      *
      * @return <code>true</code> if the path should be included
      *         <code>false</code> otherwise.
      */
     public boolean match(String path) {
         String vpath = path.replace('/', File.separatorChar).
             replace('\\', File.separatorChar);
         return isIncluded(vpath) && !isExcluded(vpath);
     }
 
     /**
      * Get the named Resource.
      * @param name path name of the file sought in the archive
      * @return the resource
      * @since Ant 1.5.2
      */
     public Resource getResource(String name) {
         if (src == null) {
             return super.getResource(name);
         }
         if (name.equals("")) {
             // special case in ZIPs, we do not want this thing included
             return new Resource("", true, Long.MAX_VALUE, true);
         }
         // first check if the archive needs to be scanned again
         scanme();
         if (fileEntries.containsKey(name)) {
             return (Resource) fileEntries.get(name);
         }
         name = trimSeparator(name);
 
         if (dirEntries.containsKey(name)) {
             return (Resource) dirEntries.get(name);
         }
         return new Resource(name);
     }
 
     /**
      * Fills the file and directory maps with resources read from the archive.
      *
      * @param archive the archive to scan.
      * @param encoding encoding used to encode file names inside the archive.
      * @param fileEntries Map (name to resource) of non-directory
      * resources found inside the archive.
      * @param matchFileEntries Map (name to resource) of non-directory
      * resources found inside the archive that matched all include
      * patterns and didn't match any exclude patterns.
      * @param dirEntries Map (name to resource) of directory
      * resources found inside the archive.
      * @param matchDirEntries Map (name to resource) of directory
      * resources found inside the archive that matched all include
      * patterns and didn't match any exclude patterns.
      */
     protected abstract void fillMapsFromArchive(Resource archive,
                                                 String encoding,
                                                 Map fileEntries,
                                                 Map matchFileEntries,
                                                 Map dirEntries,
                                                 Map matchDirEntries);
 
     /**
      * if the datetime of the archive did not change since
      * lastScannedResource was initialized returns immediately else if
      * the archive has not been scanned yet, then all the zip entries
      * are put into the appropriate tables.
      */
     private void scanme() {
         if (!src.isExists() && !errorOnMissingArchive) {
             return;
         }
 
         //do not use a FileResource b/c it pulls File info from the filesystem:
         Resource thisresource = new Resource(src.getName(),
                                              src.isExists(),
                                              src.getLastModified());
         // spare scanning again and again
         if (lastScannedResource != null
             && lastScannedResource.getName().equals(thisresource.getName())
             && lastScannedResource.getLastModified()
             == thisresource.getLastModified()) {
             return;
         }
         init();
 
         fileEntries.clear();
         dirEntries.clear();
         matchFileEntries.clear();
         matchDirEntries.clear();
         fillMapsFromArchive(src, encoding, fileEntries, matchFileEntries,
                             dirEntries, matchDirEntries);
 
         // record data about the last scanned resource
         lastScannedResource = thisresource;
     }
 
     /**
      * Remove trailing slash if present.
      * @param s the file name to trim.
-     * @return the trimed file name.
+     * @return the trimmed file name.
      */
     protected static final String trimSeparator(String s) {
         return s.endsWith("/") ? s.substring(0, s.length() - 1) : s;
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/CommandlineJava.java b/src/main/org/apache/tools/ant/types/CommandlineJava.java
index db3bfd894..94461fc62 100644
--- a/src/main/org/apache/tools/ant/types/CommandlineJava.java
+++ b/src/main/org/apache/tools/ant/types/CommandlineJava.java
@@ -1,703 +1,703 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.util.JavaEnvUtils;
 
 import java.util.Enumeration;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Properties;
 import java.util.Vector;
 
 /**
  * A representation of a Java command line that is
  * a composite of 2 <tt>Commandline</tt>s. One is used for the
  * vm/options and one for the classname/arguments. It provides
  * specific methods for a Java command line.
  *
  */
 public class CommandlineJava implements Cloneable {
 
     /**
      * commands to the JVM
      */
     private Commandline vmCommand = new Commandline();
     /**
      * actual java commands
      */
     private Commandline javaCommand = new Commandline();
     /**
      * properties to add using -D
      */
     private SysProperties sysProperties = new SysProperties();
     private Path classpath = null;
     private Path bootclasspath = null;
     private String vmVersion;
     private String maxMemory = null;
     /**
      *  any assertions to make? Currently only supported in forked JVMs
      */
     private Assertions assertions = null;
 
     /**
      * Indicate whether it will execute a jar file or not, in this case
      * the first vm option must be a -jar and the 'executable' is a jar file.
      */
      private boolean executeJar = false;
 
     /**
      * Whether system properties and bootclasspath shall be cloned.
      * @since Ant 1.7
      */
     private boolean cloneVm = false;
 
     /**
      * Specialized Environment class for System properties.
      */
     public static class SysProperties extends Environment implements Cloneable {
         // CheckStyle:VisibilityModifier OFF - bc
         /** the system properties. */
         Properties sys = null;
         // CheckStyle:VisibilityModifier ON
         private Vector propertySets = new Vector();
 
         /**
          * Get the properties as an array; this is an override of the
          * superclass, as it evaluates all the properties.
          * @return the array of definitions; may be null.
          * @throws BuildException on error.
          */
         public String[] getVariables() throws BuildException {
 
             List definitions = new LinkedList();
             ListIterator list = definitions.listIterator();
             addDefinitionsToList(list);
             if (definitions.size() == 0) {
                 return null;
             } else {
                 return (String[]) definitions.toArray(new String[definitions.size()]);
             }
         }
 
         /**
          * Add all definitions (including property sets) to a list.
          * @param listIt list iterator supporting add method.
          */
         public void addDefinitionsToList(ListIterator listIt) {
             String[] props = super.getVariables();
             if (props != null) {
                 for (int i = 0; i < props.length; i++) {
                     listIt.add("-D" + props[i]);
                 }
             }
             Properties propertySetProperties = mergePropertySets();
             for (Enumeration e = propertySetProperties.keys();
                  e.hasMoreElements();) {
                 String key = (String) e.nextElement();
                 String value = propertySetProperties.getProperty(key);
                 listIt.add("-D" + key + "=" + value);
             }
         }
 
         /**
          * Get the size of the sysproperties instance. This merges all
          * property sets, so is not an O(1) operation.
          * @return the size of the sysproperties instance.
          */
         public int size() {
             Properties p = mergePropertySets();
             return variables.size() + p.size();
         }
 
         /**
          * Cache the system properties and set the system properties to the
          * new values.
          * @throws BuildException if Security prevented this operation.
          */
         public void setSystem() throws BuildException {
             try {
                 sys = System.getProperties();
                 Properties p = new Properties();
                 for (Enumeration e = sys.propertyNames(); e.hasMoreElements();) {
                     String name = (String) e.nextElement();
                     String value = sys.getProperty(name);
                     if (name != null && value != null) {
                         p.put(name, value);
                     }
                 }
                 p.putAll(mergePropertySets());
                 for (Enumeration e = variables.elements(); e.hasMoreElements();) {
                     Environment.Variable v = (Environment.Variable) e.nextElement();
                     v.validate();
                     p.put(v.getKey(), v.getValue());
                 }
                 System.setProperties(p);
             } catch (SecurityException e) {
                 throw new BuildException("Cannot modify system properties", e);
             }
         }
 
         /**
          * Restore the system properties to the cached value.
          * @throws BuildException  if Security prevented this operation, or
          * there were no system properties to restore.
          */
         public void restoreSystem() throws BuildException {
             if (sys == null) {
                 throw new BuildException("Unbalanced nesting of SysProperties");
             }
 
             try {
                 System.setProperties(sys);
                 sys = null;
             } catch (SecurityException e) {
                 throw new BuildException("Cannot modify system properties", e);
             }
         }
 
         /**
          * Create a deep clone.
          * @return a cloned instance of SysProperties.
          * @exception CloneNotSupportedException for signature.
          */
         public Object clone() throws CloneNotSupportedException {
             try {
                 SysProperties c = (SysProperties) super.clone();
                 c.variables = (Vector) variables.clone();
                 c.propertySets = (Vector) propertySets.clone();
                 return c;
             } catch (CloneNotSupportedException e) {
                 return null;
             }
         }
 
         /**
          * Add a propertyset to the total set.
          * @param ps the new property set.
          */
         public void addSyspropertyset(PropertySet ps) {
             propertySets.addElement(ps);
         }
 
         /**
          * Add a propertyset to the total set.
          * @param ps the new property set.
          * @since Ant 1.6.3
          */
         public void addSysproperties(SysProperties ps) {
             variables.addAll(ps.variables);
             propertySets.addAll(ps.propertySets);
         }
 
         /**
          * Merge all property sets into a single Properties object.
          * @return the merged object.
          */
         private Properties mergePropertySets() {
             Properties p = new Properties();
             for (Enumeration e = propertySets.elements();
                  e.hasMoreElements();) {
                 PropertySet ps = (PropertySet) e.nextElement();
                 p.putAll(ps.getProperties());
             }
             return p;
         }
 
     }
 
     /**
      * Constructor uses the VM we are running on now.
      */
     public CommandlineJava() {
         setVm(JavaEnvUtils.getJreExecutable("java"));
         setVmversion(JavaEnvUtils.getJavaVersion());
     }
 
     /**
      * Create a new argument to the java program.
      * @return an argument to be configured.
      */
     public Commandline.Argument createArgument() {
         return javaCommand.createArgument();
     }
 
     /**
      * Create a new JVM argument.
      * @return an argument to be configured.
      */
     public Commandline.Argument createVmArgument() {
         return vmCommand.createArgument();
     }
 
     /**
      * Add a system property.
      * @param sysp a property to be set in the JVM.
      */
     public void addSysproperty(Environment.Variable sysp) {
         sysProperties.addVariable(sysp);
     }
 
     /**
      * Add a set of system properties.
      * @param sysp a set of properties.
      */
     public void addSyspropertyset(PropertySet sysp) {
         sysProperties.addSyspropertyset(sysp);
     }
 
     /**
      * Add a set of system properties.
      * @param sysp a set of properties.
      * @since Ant 1.6.3
      */
     public void addSysproperties(SysProperties sysp) {
         sysProperties.addSysproperties(sysp);
     }
 
     /**
      * Set the executable used to start the new JVM.
      * @param vm the executable to use.
      */
     public void setVm(String vm) {
         vmCommand.setExecutable(vm);
     }
 
     /**
      * Set the JVM version required.
      * @param value the version required.
      */
     public void setVmversion(String value) {
         vmVersion = value;
     }
 
     /**
      * Set whether system properties will be copied to the cloned VM--as
      * well as the bootclasspath unless you have explicitly specified
      * a bootclasspath.
      * @param cloneVm if true copy the system properties.
      * @since Ant 1.7
      */
     public void setCloneVm(boolean cloneVm) {
         this.cloneVm = cloneVm;
     }
 
     /**
      * Get the current assertions.
      * @return assertions or null.
      */
     public Assertions getAssertions() {
         return assertions;
     }
 
     /**
      * Add an assertion set to the command.
      * @param assertions assertions to make.
      */
     public void setAssertions(Assertions assertions) {
         this.assertions = assertions;
     }
 
     /**
      * Set a jar file to execute via the -jar option.
      * @param jarpathname the pathname of the jar to execute.
      */
     public void setJar(String jarpathname) {
         javaCommand.setExecutable(jarpathname);
         executeJar = true;
     }
 
     /**
      * Get the name of the jar to be run.
      * @return the pathname of the jar file to run via -jar option
      * or <tt>null</tt> if there is no jar to run.
      * @see #getClassname()
      */
     public String getJar() {
         if (executeJar) {
             return javaCommand.getExecutable();
         }
         return null;
     }
 
     /**
      * Set the classname to execute.
      * @param classname the fully qualified classname.
      */
     public void setClassname(String classname) {
         javaCommand.setExecutable(classname);
         executeJar = false;
     }
 
     /**
      * Get the name of the class to be run.
      * @return the name of the class to run or <tt>null</tt> if there is no class.
      * @see #getJar()
      */
     public String getClassname() {
         if (!executeJar) {
             return javaCommand.getExecutable();
         }
         return null;
     }
 
     /**
      * Create a classpath.
      * @param p the project to use to create the path.
      * @return a path to be configured.
      */
     public Path createClasspath(Project p) {
         if (classpath == null) {
             classpath = new Path(p);
         }
         return classpath;
     }
 
     /**
      * Create a boot classpath.
      * @param p the project to use to create the path.
      * @return a path to be configured.
      * @since Ant 1.6
      */
     public Path createBootclasspath(Project p) {
         if (bootclasspath == null) {
             bootclasspath = new Path(p);
         }
         return bootclasspath;
     }
 
     /**
      * Get the vm version.
      * @return the vm version.
      */
     public String getVmversion() {
         return vmVersion;
     }
 
     /**
      * Get the command line to run a Java vm.
      * @return the list of all arguments necessary to run the vm.
      */
     public String[] getCommandline() {
         //create the list
         List commands = new LinkedList();
         final ListIterator listIterator = commands.listIterator();
         //fill it
         addCommandsToList(listIterator);
         //convert to an array
         return (String[]) commands.toArray(new String[commands.size()]);
     }
 
     /**
      * Add all the commands to a list identified by the iterator passed in.
      * @param listIterator an iterator that supports the add method.
      * @since Ant 1.6
      */
     private void addCommandsToList(final ListIterator listIterator) {
         //create the command to run Java, including user specified options
         getActualVMCommand().addCommandToList(listIterator);
         // properties are part of the vm options...
         sysProperties.addDefinitionsToList(listIterator);
 
         if (isCloneVm()) {
             SysProperties clonedSysProperties = new SysProperties();
             PropertySet ps = new PropertySet();
             PropertySet.BuiltinPropertySetName sys =
                 new PropertySet.BuiltinPropertySetName();
             sys.setValue("system");
             ps.appendBuiltin(sys);
             clonedSysProperties.addSyspropertyset(ps);
             clonedSysProperties.addDefinitionsToList(listIterator);
         }
         //boot classpath
         Path bcp = calculateBootclasspath(true);
         if (bcp.size() > 0) {
             listIterator.add("-Xbootclasspath:" + bcp.toString());
         }
         //main classpath
         if (haveClasspath()) {
             listIterator.add("-classpath");
             listIterator.add(
                     classpath.concatSystemClasspath("ignore").toString());
         }
         //now any assertions are added
         if (getAssertions() != null) {
             getAssertions().applyAssertions(listIterator);
         }
         // JDK usage command line says that -jar must be the first option, as there is
         // a bug in JDK < 1.4 that forces the jvm type to be specified as the first
         // option, it is appended here as specified in the docs even though there is
         // in fact no order.
         if (executeJar) {
             listIterator.add("-jar");
         }
         // this is the classname to run as well as its arguments.
         // in case of 'executeJar', the executable is a jar file.
         javaCommand.addCommandToList(listIterator);
     }
 
     /**
      * Specify max memory of the JVM.
      * -mx or -Xmx depending on VM version.
-     * @param max the string to pass to the jvm to specifiy the max memory.
+     * @param max the string to pass to the jvm to specify the max memory.
      */
     public void setMaxmemory(String max) {
         this.maxMemory = max;
     }
 
     /**
      * Get a string description.
      * @return the command line as a string.
      */
     public String toString() {
         return Commandline.toString(getCommandline());
     }
 
     /**
      * Return a String that describes the command and arguments suitable for
      * verbose output before a call to <code>Runtime.exec(String[])<code>.
      * @return the description string.
      * @since Ant 1.5
      */
     public String describeCommand() {
         return Commandline.describeCommand(getCommandline());
     }
 
     /**
      * Return a String that describes the java command and arguments
      * for in-VM executions.
      *
      * <p>The class name is the executable in this context.</p>
      * @return the description string.
      * @since Ant 1.5
      */
     public String describeJavaCommand() {
         return Commandline.describeCommand(getJavaCommand());
     }
 
     /**
      * Get the VM command parameters, including memory settings.
      * @return the VM command parameters.
      */
     protected Commandline getActualVMCommand() {
         Commandline actualVMCommand = (Commandline) vmCommand.clone();
         if (maxMemory != null) {
             if (vmVersion.startsWith("1.1")) {
                 actualVMCommand.createArgument().setValue("-mx" + maxMemory);
             } else {
                 actualVMCommand.createArgument().setValue("-Xmx" + maxMemory);
             }
         }
         return actualVMCommand;
     }
 
     /**
      * Get the size of the java command line. This is a fairly intensive
      * operation, as it has to evaluate the size of many components.
      * @return the total number of arguments in the java command line.
      * @see #getCommandline()
      * @deprecated since 1.7.
      *             Please dont use this, it effectively creates the
      *             entire command.
      */
     public int size() {
         int size = getActualVMCommand().size() + javaCommand.size()
             + sysProperties.size();
         // cloned system properties
         if (isCloneVm()) {
             size += System.getProperties().size();
         }
         // classpath is "-classpath <classpath>" -> 2 args
         if (haveClasspath()) {
             size += 2;
         }
         // bootclasspath is "-Xbootclasspath:<classpath>" -> 1 arg
         if (calculateBootclasspath(true).size() > 0) {
             size++;
         }
         // jar execution requires an additional -jar option
         if (executeJar) {
             size++;
         }
         //assertions take up space too
         if (getAssertions() != null) {
             size += getAssertions().size();
         }
         return size;
     }
 
     /**
      * Get the Java command to be used.
      * @return the java command--not a clone.
      */
     public Commandline getJavaCommand() {
         return javaCommand;
     }
 
     /**
      * Get the VM command, including memory.
      * @return A deep clone of the instance's VM command, with memory settings added.
      */
     public Commandline getVmCommand() {
         return getActualVMCommand();
     }
 
     /**
      * Get the classpath for the command.
      * @return the classpath or null.
      */
     public Path getClasspath() {
         return classpath;
     }
 
     /**
      * Get the boot classpath.
      * @return boot classpath or null.
      */
     public Path getBootclasspath() {
         return bootclasspath;
     }
 
     /**
      * Cache current system properties and set them to those in this
      * Java command.
      * @throws BuildException  if Security prevented this operation.
      */
     public void setSystemProperties() throws BuildException {
         sysProperties.setSystem();
     }
 
     /**
      * Restore the cached system properties.
      * @throws BuildException  if Security prevented this operation, or
      * there was no system properties to restore
      */
     public void restoreSystemProperties() throws BuildException {
         sysProperties.restoreSystem();
     }
 
     /**
      * Get the system properties object.
      * @return The system properties object.
      */
     public SysProperties getSystemProperties() {
         return sysProperties;
     }
 
     /**
      * Deep clone the object.
      * @return a CommandlineJava object.
      * @throws BuildException if anything went wrong.
      * @throws CloneNotSupportedException never.
      */
     public Object clone() throws CloneNotSupportedException {
         try {
             CommandlineJava c = (CommandlineJava) super.clone();
             c.vmCommand = (Commandline) vmCommand.clone();
             c.javaCommand = (Commandline) javaCommand.clone();
             c.sysProperties = (SysProperties) sysProperties.clone();
             if (classpath != null) {
                 c.classpath = (Path) classpath.clone();
             }
             if (bootclasspath != null) {
                 c.bootclasspath = (Path) bootclasspath.clone();
             }
             if (assertions != null) {
                 c.assertions = (Assertions) assertions.clone();
             }
             return c;
         } catch (CloneNotSupportedException e) {
             throw new BuildException(e);
         }
     }
 
     /**
      * Clear out the java arguments.
      */
     public void clearJavaArgs() {
         javaCommand.clearArgs();
     }
 
     /**
      * Determine whether the classpath has been specified, and whether it shall
      * really be used or be nulled by build.sysclasspath.
      * @return true if the classpath is to be used.
      * @since Ant 1.6
      */
     public boolean haveClasspath() {
         Path fullClasspath = classpath != null
             ? classpath.concatSystemClasspath("ignore") : null;
         return fullClasspath != null
             && fullClasspath.toString().trim().length() > 0;
     }
 
     /**
      * Determine whether the bootclasspath has been specified, and whether it
      * shall really be used (build.sysclasspath could be set or the VM may not
      * support it).
      *
      * @param log whether to log a warning if a bootclasspath has been
      * specified but will be ignored.
      * @return true if the bootclasspath is to be used.
      * @since Ant 1.6
      */
     protected boolean haveBootclasspath(boolean log) {
         return calculateBootclasspath(log).size() > 0;
     }
 
     /**
      * Calculate the bootclasspath based on the bootclasspath
      * specified, the build.sysclasspath and ant.build.clonevm magic
      * properties as well as the cloneVm attribute.
      * @param log whether to write messages to the log.
      * @since Ant 1.7
      */
     private Path calculateBootclasspath(boolean log) {
         if (vmVersion.startsWith("1.1")) {
             if (bootclasspath != null && log) {
                 bootclasspath.log("Ignoring bootclasspath as "
                                   + "the target VM doesn't support it.");
             }
         } else {
             Path b = bootclasspath;
             if (b == null) {
                 b = new Path(null);
             }
             // even with no user-supplied bootclasspath
             // build.sysclasspath could be set to something other than
             // "ignore" and thus create one
             return b.concatSystemBootClasspath(isCloneVm() ? "last" : "ignore");
         }
         return new Path(null);
     }
 
     /**
      * Find out whether either of the cloneVm attribute or the magic property
      * ant.build.clonevm has been set.
      * @return <code>boolean</code>.
      * @since 1.7
      */
     private boolean isCloneVm() {
         return cloneVm
             || "true".equals(System.getProperty("ant.build.clonevm"));
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/Environment.java b/src/main/org/apache/tools/ant/types/Environment.java
index 05695b919..326a9956b 100644
--- a/src/main/org/apache/tools/ant/types/Environment.java
+++ b/src/main/org/apache/tools/ant/types/Environment.java
@@ -1,176 +1,176 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types;
 
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 
 /**
  * Wrapper for environment variables.
  *
  */
 public class Environment {
     // CheckStyle:VisibilityModifier OFF - bc
 
     /**
-     * a vector of type Enviromment.Variable
+     * a vector of type Environment.Variable
      * @see Variable
      */
     protected Vector variables;
 
     // CheckStyle:VisibilityModifier ON
 
     /**
      * representation of a single env value
      */
     public static class Variable {
 
         /**
          * env key and value pair; everything gets expanded to a string
          * during assignment
          */
         private String key, value;
 
         /**
          * Constructor for variable
          *
          */
         public Variable() {
             super();
         }
 
         /**
          * set the key
          * @param key string
          */
         public void setKey(String key) {
             this.key = key;
         }
 
         /**
          * set the value
          * @param value string value
          */
         public void setValue(String value) {
             this.value = value;
         }
 
         /**
          * key accessor
          * @return key
          */
         public String getKey() {
             return this.key;
         }
 
         /**
          * value accessor
          * @return value
          */
         public String getValue() {
             return this.value;
         }
 
         /**
          * stringify path and assign to the value.
          * The value will contain all path elements separated by the appropriate
          * separator
          * @param path path
          */
         public void setPath(Path path) {
             this.value = path.toString();
         }
 
         /**
          * get the absolute path of a file and assign it to the value
          * @param file file to use as the value
          */
         public void setFile(java.io.File file) {
             this.value = file.getAbsolutePath();
         }
 
         /**
          * get the assigment string
          * This is not ready for insertion into a property file without following
          * the escaping rules of the properties class.
          * @return a string of the form key=value.
          * @throws BuildException if key or value are unassigned
          */
         public String getContent() throws BuildException {
             validate();
             StringBuffer sb = new StringBuffer(key.trim());
             sb.append("=").append(value.trim());
             return sb.toString();
         }
 
         /**
          * checks whether all required attributes have been specified.
          * @throws BuildException if key or value are unassigned
          */
         public void validate() {
             if (key == null || value == null) {
                 throw new BuildException("key and value must be specified "
                     + "for environment variables.");
             }
         }
     }
 
     /**
      * constructor
      */
     public Environment() {
         variables = new Vector();
     }
 
     /**
      * add a variable.
      * Validity checking is <i>not</i> performed at this point. Duplicates
      * are not caught either.
      * @param var new variable.
      */
     public void addVariable(Variable var) {
         variables.addElement(var);
     }
 
     /**
      * get the variable list as an array
      * @return array of key=value assignment strings
      * @throws BuildException if any variable is misconfigured
      */
     public String[] getVariables() throws BuildException {
         if (variables.size() == 0) {
             return null;
         }
         String[] result = new String[variables.size()];
         for (int i = 0; i < result.length; i++) {
             result[i] = ((Variable) variables.elementAt(i)).getContent();
         }
         return result;
     }
 
     /**
      * Get the raw vector of variables. This is not a clone.
      * @return a potentially empty (but never null) vector of elements of type
      * Variable
      * @since Ant 1.7
      */
     public Vector getVariablesVector() {
         return variables;
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/FilterSet.java b/src/main/org/apache/tools/ant/types/FilterSet.java
index a90a4a600..6faa7e94e 100644
--- a/src/main/org/apache/tools/ant/types/FilterSet.java
+++ b/src/main/org/apache/tools/ant/types/FilterSet.java
@@ -1,629 +1,629 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Properties;
 import java.util.Vector;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.VectorSet;
 
 /**
  * A set of filters to be applied to something.
  *
  * A filter set may have begintoken and endtokens defined.
  *
  */
 public class FilterSet extends DataType implements Cloneable {
 
     /**
      * Individual filter component of filterset.
      *
      */
     public static class Filter {
         // CheckStyle:VisibilityModifier OFF - bc
         /** Token which will be replaced in the filter operation. */
         String token;
 
         /** The value which will replace the token in the filtering operation. */
         String value;
         // CheckStyle:VisibilityModifier ON
 
         /**
          * Constructor for the Filter object.
          *
          * @param token  The token which will be replaced when filtering.
          * @param value  The value which will replace the token when filtering.
          */
         public Filter(String token, String value) {
            setToken(token);
            setValue(value);
         }
 
         /**
-         * No-argument conmstructor.
+         * No-argument constructor.
          */
         public Filter() {
         }
 
         /**
          * Sets the Token attribute of the Filter object.
          *
          * @param token  The new Token value.
          */
         public void setToken(String token) {
            this.token = token;
         }
 
         /**
          * Sets the Value attribute of the Filter object.
          *
          * @param value  The new Value value.
          */
         public void setValue(String value) {
            this.value = value;
         }
 
         /**
          * Gets the Token attribute of the Filter object.
          *
          * @return   The Token value.
          */
         public String getToken() {
            return token;
         }
 
         /**
          * Gets the Value attribute of the Filter object.
          *
          * @return   The Value value.
          */
         public String getValue() {
            return value;
         }
      }
 
     /**
      * The filtersfile nested element.
      *
      */
     public class FiltersFile {
 
         /**
          * Constructor for the FiltersFile object.
          */
         public FiltersFile() {
         }
 
         /**
          * Sets the file from which filters will be read.
          *
          * @param file the file from which filters will be read.
          */
         public void setFile(File file) {
            filtersFiles.add(file);
         }
     }
 
     /**
      * EnumeratedAttribute to set behavior WRT missing filtersfiles:
      * "fail" (default), "warn", "ignore".
      * @since Ant 1.7
      */
     public static class OnMissing extends EnumeratedAttribute {
         private static final String[] VALUES
             = new String[] {"fail", "warn", "ignore"};
 
         /** Fail value */
         public static final OnMissing FAIL = new OnMissing("fail");
         /** Warn value */
         public static final OnMissing WARN = new OnMissing("warn");
         /** Ignore value */
         public static final OnMissing IGNORE = new OnMissing("ignore");
 
         private static final int FAIL_INDEX = 0;
         private static final int WARN_INDEX = 1;
         private static final int IGNORE_INDEX = 2;
 
         /**
          * Default constructor.
          */
         public OnMissing() {
         }
 
         /**
          * Convenience constructor.
          * @param value the value to set.
          */
         public OnMissing(String value) {
             setValue(value);
         }
 
         //inherit doc
         /** {@inheritDoc}. */
         public String[] getValues() {
             return VALUES;
         }
     }
 
     /** The default token start string */
     public static final String DEFAULT_TOKEN_START = "@";
 
     /** The default token end string */
     public static final String DEFAULT_TOKEN_END = "@";
 
     private String startOfToken = DEFAULT_TOKEN_START;
     private String endOfToken = DEFAULT_TOKEN_END;
 
     /** Contains a list of parsed tokens */
     private Vector passedTokens;
     /** if a duplicate token is found, this is set to true */
     private boolean duplicateToken = false;
 
     private boolean recurse = true;
     private Hashtable filterHash = null;
     private Vector filtersFiles = new Vector();
     private OnMissing onMissingFiltersFile = OnMissing.FAIL;
     private boolean readingFiles = false;
 
     private int recurseDepth = 0;
 
     /**
      * List of ordered filters and filter files.
      */
     private Vector filters = new Vector();
 
     /**
      * Default constructor.
      */
     public FilterSet() {
     }
 
     /**
      * Create a Filterset from another filterset.
      *
      * @param filterset the filterset upon which this filterset will be based.
      */
     protected FilterSet(FilterSet filterset) {
         super();
         this.filters = (Vector) filterset.getFilters().clone();
     }
 
     /**
      * Get the filters in the filter set.
      *
      * @return a Vector of Filter instances.
      */
     protected synchronized Vector getFilters() {
         if (isReference()) {
             return getRef().getFilters();
         }
         dieOnCircularReference();
         //silly hack to avoid stack overflow...
         if (!readingFiles) {
             readingFiles = true;
             final int size = filtersFiles.size();
             for (int i = 0; i < size; i++) {
                 readFiltersFromFile((File) filtersFiles.get(i));
             }
             filtersFiles.clear();
             readingFiles = false;
         }
         return filters;
     }
 
     /**
      * Get the referenced filter set.
      *
      * @return the filterset from the reference.
      */
     protected FilterSet getRef() {
         return (FilterSet) getCheckedRef(FilterSet.class, "filterset");
     }
 
     /**
      * Gets the filter hash of the FilterSet.
      *
      * @return   The hash of the tokens and values for quick lookup.
      */
     public synchronized Hashtable getFilterHash() {
         if (isReference()) {
             return getRef().getFilterHash();
         }
         dieOnCircularReference();
         if (filterHash == null) {
             filterHash = new Hashtable(getFilters().size());
             for (Enumeration e = getFilters().elements(); e.hasMoreElements();) {
                Filter filter = (Filter) e.nextElement();
                filterHash.put(filter.getToken(), filter.getValue());
             }
         }
         return filterHash;
     }
 
     /**
      * Set the file containing the filters for this filterset.
      *
      * @param filtersFile sets the filter file from which to read filters
      *        for this filter set.
      * @throws BuildException if there is an error.
      */
     public void setFiltersfile(File filtersFile) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         filtersFiles.add(filtersFile);
     }
 
     /**
      * Set the string used to id the beginning of a token.
      *
      * @param startOfToken  The new Begintoken value.
      */
     public void setBeginToken(String startOfToken) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         if (startOfToken == null || "".equals(startOfToken)) {
             throw new BuildException("beginToken must not be empty");
         }
         this.startOfToken = startOfToken;
     }
 
     /**
      * Get the begin token for this filterset.
      *
      * @return the filter set's begin token for filtering.
      */
     public String getBeginToken() {
         if (isReference()) {
             return getRef().getBeginToken();
         }
         return startOfToken;
     }
 
     /**
      * Set the string used to id the end of a token.
      *
      * @param endOfToken  The new Endtoken value.
      */
     public void setEndToken(String endOfToken) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         if (endOfToken == null || "".equals(endOfToken)) {
             throw new BuildException("endToken must not be empty");
         }
         this.endOfToken = endOfToken;
     }
 
     /**
      * Get the end token for this filterset.
      *
      * @return the filter set's end token for replacement delimiting.
      */
     public String getEndToken() {
         if (isReference()) {
             return getRef().getEndToken();
         }
         return endOfToken;
     }
 
     /**
      * Set whether recursive token expansion is enabled.
      * @param recurse <code>boolean</code> whether to recurse.
      */
     public void setRecurse(boolean recurse) {
         this.recurse = recurse;
     }
 
     /**
      * Get whether recursive token expansion is enabled.
      * @return <code>boolean</code> whether enabled.
      */
     public boolean isRecurse() {
         return recurse;
     }
 
     /**
      * Read the filters from the given file.
      *
      * @param filtersFile        the file from which filters are read.
      * @exception BuildException when the file cannot be read.
      */
     public synchronized void readFiltersFromFile(File filtersFile) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         if (!filtersFile.exists()) {
            handleMissingFile("Could not read filters from file "
                                      + filtersFile + " as it doesn't exist.");
         }
         if (filtersFile.isFile()) {
            log("Reading filters from " + filtersFile, Project.MSG_VERBOSE);
            FileInputStream in = null;
            try {
               Properties props = new Properties();
               in = new FileInputStream(filtersFile);
               props.load(in);
 
               Enumeration e = props.propertyNames();
               Vector filts = getFilters();
               while (e.hasMoreElements()) {
                  String strPropName = (String) e.nextElement();
                  String strValue = props.getProperty(strPropName);
                  filts.addElement(new Filter(strPropName, strValue));
               }
            } catch (Exception ex) {
               throw new BuildException("Could not read filters from file: "
                   + filtersFile, ex);
            } finally {
               FileUtils.close(in);
            }
         } else {
            handleMissingFile(
                "Must specify a file rather than a directory in "
                + "the filtersfile attribute:" + filtersFile);
         }
         filterHash = null;
     }
 
     /**
      * Does replacement on the given string with token matching.
      * This uses the defined begintoken and endtoken values which default
      * to @ for both.
      * This resets the passedTokens and calls iReplaceTokens to
      * do the actual replacements.
      *
      * @param line  The line in which to process embedded tokens.
      * @return      The input string after token replacement.
      */
     public synchronized String replaceTokens(String line) {
         return iReplaceTokens(line);
     }
 
     /**
      * Add a new filter.
      *
      * @param filter the filter to be added.
      */
     public synchronized void addFilter(Filter filter) {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         filters.addElement(filter);
         filterHash = null;
     }
 
     /**
      * Create a new FiltersFile.
      *
      * @return The filtersfile that was created.
      */
     public FiltersFile createFiltersfile() {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         return new FiltersFile();
     }
 
     /**
      * Add a new filter made from the given token and value.
      *
      * @param token The token for the new filter.
      * @param value The value for the new filter.
      */
     public synchronized void addFilter(String token, String value) {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         addFilter(new Filter(token, value));
     }
 
     /**
      * Add a Filterset to this filter set.
      *
      * @param filterSet the filterset to be added to this filterset
      */
     public synchronized void addConfiguredFilterSet(FilterSet filterSet) {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         for (Enumeration e = filterSet.getFilters().elements(); e.hasMoreElements();) {
             addFilter((Filter) e.nextElement());
         }
     }
 
     /**
     * Test to see if this filter set has filters.
     *
     * @return Return true if there are filters in this set.
     */
     public synchronized boolean hasFilters() {
         return getFilters().size() > 0;
     }
 
     /**
      * Clone the filterset.
      *
      * @return a deep clone of this filterset.
      *
      * @throws BuildException if the clone cannot be performed.
      */
     public synchronized Object clone() throws BuildException {
         if (isReference()) {
             return ((FilterSet) getRef()).clone();
         }
         try {
             FilterSet fs = (FilterSet) super.clone();
             fs.filters = (Vector) getFilters().clone();
             fs.setProject(getProject());
             return fs;
         } catch (CloneNotSupportedException e) {
             throw new BuildException(e);
         }
     }
 
     /**
      * Set the behavior WRT missing filtersfiles.
      * @param onMissingFiltersFile the OnMissing describing the behavior.
      */
     public void setOnMissingFiltersFile(OnMissing onMissingFiltersFile) {
         this.onMissingFiltersFile = onMissingFiltersFile;
     }
 
     /**
      * Get the onMissingFiltersFile setting.
      * @return the OnMissing instance.
      */
     public OnMissing getOnMissingFiltersFile() {
         return onMissingFiltersFile;
     }
 
     /**
      * Does replacement on the given string with token matching.
      * This uses the defined begintoken and endtoken values which default
      * to @ for both.
      *
      * @param line  The line to process the tokens in.
      * @return      The string with the tokens replaced.
      */
     private synchronized String iReplaceTokens(String line) {
         String beginToken = getBeginToken();
         String endToken = getEndToken();
         int index = line.indexOf(beginToken);
 
         if (index > -1) {
             Hashtable tokens = getFilterHash();
             try {
                 StringBuffer b = new StringBuffer();
                 int i = 0;
                 String token = null;
                 String value = null;
 
                 while (index > -1) {
                     //can't have zero-length token
                     int endIndex = line.indexOf(endToken,
                         index + beginToken.length() + 1);
                     if (endIndex == -1) {
                         break;
                     }
                     token
                         = line.substring(index + beginToken.length(), endIndex);
                     b.append(line.substring(i, index));
                     if (tokens.containsKey(token)) {
                         value = (String) tokens.get(token);
                         if (recurse && !value.equals(token)) {
                             // we have another token, let's parse it.
                             value = replaceTokens(value, token);
                         }
                         log("Replacing: " + beginToken + token + endToken
                             + " -> " + value, Project.MSG_VERBOSE);
                         b.append(value);
                         i = index + beginToken.length() + token.length()
                             + endToken.length();
                     } else {
                         // just append first character of beginToken
                         // and search further
                         // we can't skip the complete beginToken since
                         // it may contain the start of another
                         // candidate begin token (Bugzilla 45094)
                         b.append(beginToken.charAt(0));
                         i = index + 1;
                     }
                     index = line.indexOf(beginToken, i);
                 }
 
                 b.append(line.substring(i));
                 return b.toString();
             } catch (StringIndexOutOfBoundsException e) {
                 return line;
             }
         } else {
            return line;
         }
     }
 
     /**
      * This parses tokens which point to tokens.
      * It also maintains a list of currently used tokens, so we cannot
      * get into an infinite loop.
      * @param line the value / token to parse.
      * @param parent the parent token (= the token it was parsed from).
      */
     private synchronized String replaceTokens(String line, String parent)
         throws BuildException {
         String beginToken = getBeginToken();
         String endToken = getEndToken();
         if (recurseDepth == 0) {
             passedTokens = new VectorSet();
         }
         recurseDepth++;
         if (passedTokens.contains(parent) && !duplicateToken) {
             duplicateToken = true;
             System.out.println(
                 "Infinite loop in tokens. Currently known tokens : "
                 + passedTokens.toString() + "\nProblem token : " + beginToken
                 + parent + endToken + " called from " + beginToken
                 + passedTokens.lastElement().toString() + endToken);
             recurseDepth--;
             return parent;
         }
         passedTokens.addElement(parent);
         String value = iReplaceTokens(line);
         if (value.indexOf(beginToken) == -1 && !duplicateToken
                 && recurseDepth == 1) {
             passedTokens = null;
         } else if (duplicateToken) {
             // should always be the case...
             if (passedTokens.size() > 0) {
                 value = (String) passedTokens.remove(passedTokens.size() - 1);
                 if (passedTokens.size() == 0) {
                     value = beginToken + value + endToken;
                     duplicateToken = false;
                 }
             }
         } else if (passedTokens.size() > 0) {
             // remove last seen token when crawling out of recursion 
             passedTokens.remove(passedTokens.size() - 1);
         }
         recurseDepth--;
         return value;
     }
 
     private void handleMissingFile(String message) {
         switch (onMissingFiltersFile.getIndex()) {
         case OnMissing.IGNORE_INDEX:
             return;
         case OnMissing.FAIL_INDEX:
             throw new BuildException(message);
         case OnMissing.WARN_INDEX:
             log(message, Project.MSG_WARN);
             return;
         default:
             throw new BuildException("Invalid value for onMissingFiltersFile");
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/Parameterizable.java b/src/main/org/apache/tools/ant/types/Parameterizable.java
index ed9ce1fab..7945a9a6c 100644
--- a/src/main/org/apache/tools/ant/types/Parameterizable.java
+++ b/src/main/org/apache/tools/ant/types/Parameterizable.java
@@ -1,31 +1,31 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types;
 
 /**
- * Parameterizable objects take genric key value pairs.
+ * Parameterizable objects take generic key value pairs.
  *
  */
 public interface Parameterizable {
     /**
      * Set the parameters
      *
      * @param parameters an array of name/type/value parameters.
      */
     void setParameters(Parameter[] parameters);
 }
diff --git a/src/main/org/apache/tools/ant/types/Path.java b/src/main/org/apache/tools/ant/types/Path.java
index f124ed63b..1e753f809 100644
--- a/src/main/org/apache/tools/ant/types/Path.java
+++ b/src/main/org/apache/tools/ant/types/Path.java
@@ -1,780 +1,780 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types;
 
 import java.io.File;
 import java.lang.reflect.Method;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.Stack;
 import java.util.Vector;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.MagicNames;
 import org.apache.tools.ant.PathTokenizer;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.types.resources.FileResourceIterator;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.JavaEnvUtils;
 
 /**
  * This object represents a path as used by CLASSPATH or PATH
  * environment variable. A path might also be described as a collection
  * of unique filesystem resources.
  * <p>
  * <code>
  * &lt;sometask&gt;<br>
  * &nbsp;&nbsp;&lt;somepath&gt;<br>
  * &nbsp;&nbsp;&nbsp;&nbsp;&lt;pathelement location="/path/to/file.jar" /&gt;<br>
  * &nbsp;&nbsp;&nbsp;&nbsp;&lt;pathelement
  *  path="/path/to/file2.jar:/path/to/class2;/path/to/class3" /&gt;
  * <br>
  * &nbsp;&nbsp;&nbsp;&nbsp;&lt;pathelement location="/path/to/file3.jar" /&gt;<br>
  * &nbsp;&nbsp;&nbsp;&nbsp;&lt;pathelement location="/path/to/file4.jar" /&gt;<br>
  * &nbsp;&nbsp;&lt;/somepath&gt;<br>
  * &lt;/sometask&gt;<br>
  * </code>
  * <p>
- * The object implemention <code>sometask</code> must provide a method called
+ * The object implementation <code>sometask</code> must provide a method called
  * <code>createSomepath</code> which returns an instance of <code>Path</code>.
  * Nested path definitions are handled by the Path object and must be labeled
  * <code>pathelement</code>.<p>
  *
  * The path element takes a parameter <code>path</code> which will be parsed
  * and split into single elements. It will usually be used
  * to define a path from an environment variable.
  */
 
 public class Path extends DataType implements Cloneable, ResourceCollection {
     // CheckStyle:VisibilityModifier OFF - bc
 
     /** The system classpath as a Path object */
     public static final Path systemClasspath =
         new Path(null, System.getProperty("java.class.path"));
 
 
     /**
      * The system bootclasspath as a Path object.
      *
      * @since Ant 1.6.2
      */
     public static final Path systemBootClasspath =
         new Path(null, System.getProperty("sun.boot.class.path"));
 
     private static final Iterator EMPTY_ITERATOR
         = Collections.EMPTY_SET.iterator();
 
     // CheckStyle:VisibilityModifier OFF - bc
 
     /**
      * Helper class, holds the nested <code>&lt;pathelement&gt;</code> values.
      */
     public class PathElement implements ResourceCollection {
         private String[] parts;
 
         /**
          * Set the location.
          *
          * @param loc a <code>File</code> value
          */
         public void setLocation(File loc) {
             parts = new String[] {translateFile(loc.getAbsolutePath())};
         }
 
         /**
          * Set the path.
          *
          * @param path a <code>String</code> value
          */
         public void setPath(String path) {
             parts = Path.translatePath(getProject(), path);
         }
 
         /**
          * Return the converted pathelements.
          *
          * @return a <code>String[]</code> value
          */
         public String[] getParts() {
             return parts;
         }
 
         /**
          * Create an iterator.
          * @return an iterator.
          */
         public Iterator<Resource> iterator() {
             return new FileResourceIterator(getProject(), null, parts);
         }
 
         /**
          * Check if this resource is only for filesystems.
          * @return true.
          */
         public boolean isFilesystemOnly() {
             return true;
         }
 
         /**
          * Get the number of resources.
          * @return the number of parts.
          */
         public int size() {
             return parts == null ? 0 : parts.length;
         }
 
     }
 
     private Boolean preserveBC;
 
     private Union union = null;
     private boolean cache = false;
 
     /**
      * Invoked by IntrospectionHelper for <code>setXXX(Path p)</code>
      * attribute setters.
      * @param p the <code>Project</code> for this path.
      * @param path the <code>String</code> path definition.
      */
     public Path(Project p, String path) {
         this(p);
         createPathElement().setPath(path);
     }
 
     /**
      * Construct an empty <code>Path</code>.
      * @param project the <code>Project</code> for this path.
      */
     public Path(Project project) {
         setProject(project);
     }
 
     /**
      * Adds a element definition to the path.
      * @param location the location of the element to add (must not be
      * <code>null</code> nor empty.
      * @throws BuildException on error
      */
     public void setLocation(File location) throws BuildException {
         checkAttributesAllowed();
         createPathElement().setLocation(location);
     }
 
     /**
      * Parses a path definition and creates single PathElements.
      * @param path the <code>String</code> path definition.
      * @throws BuildException on error
      */
     public void setPath(String path) throws BuildException {
         checkAttributesAllowed();
         createPathElement().setPath(path);
     }
 
     /**
      * Makes this instance in effect a reference to another Path instance.
      *
      * <p>You must not set another attribute or nest elements inside
      * this element if you make it a reference.</p>
      * @param r the reference to another Path
      * @throws BuildException on error
      */
     public void setRefid(Reference r) throws BuildException {
         if (union != null) {
             throw tooManyAttributes();
         }
         super.setRefid(r);
     }
 
     /**
      * Creates the nested <code>&lt;pathelement&gt;</code> element.
      * @return the <code>PathElement</code> to be configured
      * @throws BuildException on error
      */
     public PathElement createPathElement() throws BuildException {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         PathElement pe = new PathElement();
         add(pe);
         return pe;
     }
 
     /**
      * Adds a nested <code>&lt;fileset&gt;</code> element.
      * @param fs a <code>FileSet</code> to be added to the path
      * @throws BuildException on error
      */
     public void addFileset(FileSet fs) throws BuildException {
         if (fs.getProject() == null) {
             fs.setProject(getProject());
         }
         add(fs);
     }
 
     /**
      * Adds a nested <code>&lt;filelist&gt;</code> element.
      * @param fl a <code>FileList</code> to be added to the path
      * @throws BuildException on error
      */
     public void addFilelist(FileList fl) throws BuildException {
         if (fl.getProject() == null) {
             fl.setProject(getProject());
         }
         add(fl);
     }
 
     /**
      * Adds a nested <code>&lt;dirset&gt;</code> element.
      * @param dset a <code>DirSet</code> to be added to the path
      * @throws BuildException on error
      */
     public void addDirset(DirSet dset) throws BuildException {
         if (dset.getProject() == null) {
             dset.setProject(getProject());
         }
         add(dset);
     }
 
     /**
      * Adds a nested path
      * @param path a <code>Path</code> to be added to the path
      * @throws BuildException on error
      * @since Ant 1.6
      */
     public void add(Path path) throws BuildException {
         if (path == this) {
             throw circularReference();
         }
         if (path.getProject() == null) {
             path.setProject(getProject());
         }
         add((ResourceCollection) path);
     }
 
     /**
      * Add a nested <code>ResourceCollection</code>.
      * @param c the ResourceCollection to add.
      * @since Ant 1.7
      */
     public void add(ResourceCollection c) {
         checkChildrenAllowed();
         if (c == null) {
             return;
         }
         if (union == null) {
             union = new Union();
             union.setProject(getProject());
             union.setCache(cache);
         }
         union.add(c);
         setChecked(false);
     }
 
     /**
      * Creates a nested <code>&lt;path&gt;</code> element.
      * @return a <code>Path</code> to be configured
      * @throws BuildException on error
      */
     public Path createPath() throws BuildException {
         Path p = new Path(getProject());
         add(p);
         return p;
     }
 
     /**
      * Append the contents of the other Path instance to this.
      * @param other a <code>Path</code> to be added to the path
      */
     public void append(Path other) {
         if (other == null) {
             return;
         }
         add(other);
     }
 
     /**
      * Adds the components on the given path which exist to this
      * Path. Components that don't exist aren't added.
      *
      * @param source - source path whose components are examined for existence
      */
      public void addExisting(Path source) {
          addExisting(source, false);
      }
 
     /**
      * Same as addExisting, but support classpath behavior if tryUserDir
      * is true. Classpaths are relative to user dir, not the project base.
      * That used to break jspc test
      *
      * @param source the source path
      * @param tryUserDir  if true try the user directory if the file is not present
      */
     public void addExisting(Path source, boolean tryUserDir) {
         String[] list = source.list();
         File userDir = (tryUserDir) ? new File(System.getProperty("user.dir"))
                 : null;
 
         for (int i = 0; i < list.length; i++) {
             File f = resolveFile(getProject(), list[i]);
 
             // probably not the best choice, but it solves the problem of
             // relative paths in CLASSPATH
             if (tryUserDir && !f.exists()) {
                 f = new File(userDir, list[i]);
             }
             if (f.exists()) {
                 setLocation(f);
             } else if (f.getParentFile() != null && f.getParentFile().exists()
                        && containsWildcards(f.getName())) {
                 setLocation(f);
                 log("adding " + f + " which contains wildcards and may not"
                     + " do what you intend it to do depending on your OS or"
                     + " version of Java", Project.MSG_VERBOSE);
             } else {
                 log("dropping " + f + " from path as it doesn't exist",
                     Project.MSG_VERBOSE);
             }
         }
     }
 
     /**
      * Whether to cache the current path.
      * @since Ant 1.8.0
      */
     public void setCache(boolean b) {
         checkAttributesAllowed();
         cache = b;
         if (union != null) {
             union.setCache(b);
         }
     }
 
     /**
      * Returns all path elements defined by this and nested path objects.
      * @return list of path elements.
      */
     public String[] list() {
         if (isReference()) {
             return ((Path) getCheckedRef()).list();
         }
         return assertFilesystemOnly(union) == null
             ? new String[0] : union.list();
     }
 
     /**
      * Returns a textual representation of the path, which can be used as
      * CLASSPATH or PATH environment variable definition.
      * @return a textual representation of the path.
      */
     public String toString() {
         return isReference() ? getCheckedRef().toString()
             : union == null ? "" : union.toString();
     }
 
     /**
      * Splits a PATH (with : or ; as separators) into its parts.
      * @param project the project to use
      * @param source a <code>String</code> value
      * @return an array of strings, one for each path element
      */
     public static String[] translatePath(Project project, String source) {
         final Vector result = new Vector();
         if (source == null) {
             return new String[0];
         }
         PathTokenizer tok = new PathTokenizer(source);
         StringBuffer element = new StringBuffer();
         while (tok.hasMoreTokens()) {
             String pathElement = tok.nextToken();
             try {
                 element.append(resolveFile(project, pathElement).getPath());
             } catch (BuildException e) {
                 project.log("Dropping path element " + pathElement
                     + " as it is not valid relative to the project",
                     Project.MSG_VERBOSE);
             }
             for (int i = 0; i < element.length(); i++) {
                 translateFileSep(element, i);
             }
             result.addElement(element.toString());
             element = new StringBuffer();
         }
         String[] res = new String[result.size()];
         result.copyInto(res);
         return res;
     }
 
     /**
      * Returns its argument with all file separator characters
      * replaced so that they match the local OS conventions.
      * @param source the path to convert
      * @return the converted path
      */
     public static String translateFile(String source) {
         if (source == null) {
           return "";
         }
         final StringBuffer result = new StringBuffer(source);
         for (int i = 0; i < result.length(); i++) {
             translateFileSep(result, i);
         }
         return result.toString();
     }
 
     /**
      * Translates occurrences at a position of / or \ to correct separator of the
      * current platform and returns whether it had to do a
      * replacement.
      * @param buffer a buffer containing a string
      * @param pos the position in the string buffer to convert
      * @return true if the character was a / or \
      */
     protected static boolean translateFileSep(StringBuffer buffer, int pos) {
         if (buffer.charAt(pos) == '/' || buffer.charAt(pos) == '\\') {
             buffer.setCharAt(pos, File.separatorChar);
             return true;
         }
         return false;
     }
 
     /**
      * Fulfill the ResourceCollection contract.
      * @return number of elements as int.
      */
     public synchronized int size() {
         if (isReference()) {
             return ((Path) getCheckedRef()).size();
         }
         dieOnCircularReference();
         return union == null ? 0 : assertFilesystemOnly(union).size();
     }
 
     /**
      * Clone this Path.
      * @return Path with shallowly cloned Resource children.
      */
     public Object clone() {
         try {
             Path result = (Path) super.clone();
             result.union = union == null ? union : (Union) union.clone();
             return result;
         } catch (CloneNotSupportedException e) {
             throw new BuildException(e);
         }
     }
 
     /**
      * Overrides the version of DataType to recurse on all DataType
      * child elements that may have been added.
      * @param stk the stack of data types to use (recursively).
      * @param p   the project to use to dereference the references.
      * @throws BuildException on error.
      */
     protected synchronized void dieOnCircularReference(Stack stk, Project p)
         throws BuildException {
         if (isChecked()) {
             return;
         }
         if (isReference()) {
             super.dieOnCircularReference(stk, p);
         } else {
             if (union != null) {
                 pushAndInvokeCircularReferenceCheck(union, stk, p);
             }
             setChecked(true);
         }
     }
 
     /**
      * Resolve a filename with Project's help - if we know one that is.
      */
     private static File resolveFile(Project project, String relativeName) {
         return FileUtils.getFileUtils().resolveFile(
             (project == null) ? null : project.getBaseDir(), relativeName);
     }
 
     /**
      * Concatenates the system class path in the order specified by
      * the ${build.sysclasspath} property - using &quot;last&quot; as
      * default value.
      * @return the concatenated path
      */
     public Path concatSystemClasspath() {
         return concatSystemClasspath("last");
     }
 
     /**
      * Concatenates the system class path in the order specified by
      * the ${build.sysclasspath} property - using the supplied value
      * if ${build.sysclasspath} has not been set.
      * @param defValue the order ("first", "last", "only")
      * @return the concatenated path
      */
     public Path concatSystemClasspath(String defValue) {
         return concatSpecialPath(defValue, Path.systemClasspath);
     }
 
     /**
      * Concatenates the system boot class path in the order specified
      * by the ${build.sysclasspath} property - using the supplied
      * value if ${build.sysclasspath} has not been set.
      * @param defValue the order ("first", "last", "only")
      * @return the concatenated path
      */
     public Path concatSystemBootClasspath(String defValue) {
         return concatSpecialPath(defValue, Path.systemBootClasspath);
     }
 
     /**
      * Concatenates a class path in the order specified by the
      * ${build.sysclasspath} property - using the supplied value if
      * ${build.sysclasspath} has not been set.
      */
     private Path concatSpecialPath(String defValue, Path p) {
         Path result = new Path(getProject());
 
         String order = defValue;
         String o = getProject() != null 
             ? getProject().getProperty(MagicNames.BUILD_SYSCLASSPATH)
             : System.getProperty(MagicNames.BUILD_SYSCLASSPATH);
         if (o != null) {
             order = o;
         }
         if (order.equals("only")) {
             // only: the developer knows what (s)he is doing
             result.addExisting(p, true);
 
         } else if (order.equals("first")) {
             // first: developer could use a little help
             result.addExisting(p, true);
             result.addExisting(this);
 
         } else if (order.equals("ignore")) {
             // ignore: don't trust anyone
             result.addExisting(this);
 
         } else {
             // last: don't trust the developer
             if (!order.equals("last")) {
                 log("invalid value for " + MagicNames.BUILD_SYSCLASSPATH
                     + ": " + order,
                     Project.MSG_WARN);
             }
             result.addExisting(this);
             result.addExisting(p, true);
         }
         return result;
     }
 
     /**
      * Add the Java Runtime classes to this Path instance.
      */
     public void addJavaRuntime() {
         if (JavaEnvUtils.isKaffe()) {
             // newer versions of Kaffe (1.1.1+) won't have this,
             // but this will be sorted by FileSet anyway.
             File kaffeShare = new File(System.getProperty("java.home")
                                        + File.separator + "share"
                                        + File.separator + "kaffe");
             if (kaffeShare.isDirectory()) {
                 FileSet kaffeJarFiles = new FileSet();
                 kaffeJarFiles.setDir(kaffeShare);
                 kaffeJarFiles.setIncludes("*.jar");
                 addFileset(kaffeJarFiles);
             }
         } else if ("GNU libgcj".equals(System.getProperty("java.vm.name"))) {
             addExisting(systemBootClasspath);
         }
 
         if (System.getProperty("java.vendor").toLowerCase(Locale.ENGLISH).indexOf("microsoft") >= 0) {
             // XXX is this code still necessary? is there any 1.2+ port?
             // Pull in *.zip from packages directory
             FileSet msZipFiles = new FileSet();
             msZipFiles.setDir(new File(System.getProperty("java.home")
                 + File.separator + "Packages"));
             msZipFiles.setIncludes("*.ZIP");
             addFileset(msZipFiles);
         } else {
             // JDK 1.2+ seems to set java.home to the JRE directory.
             addExisting(new Path(null,
                                  System.getProperty("java.home")
                                  + File.separator + "lib"
                                  + File.separator + "rt.jar"));
             // Just keep the old version as well and let addExisting
             // sort it out.
             addExisting(new Path(null,
                                  System.getProperty("java.home")
                                  + File.separator + "jre"
                                  + File.separator + "lib"
                                  + File.separator + "rt.jar"));
 
             // Sun's and Apple's 1.4 have JCE and JSSE in separate jars.
             String[] secJars = {"jce", "jsse"};
             for (int i = 0; i < secJars.length; i++) {
                 addExisting(new Path(null,
                                      System.getProperty("java.home")
                                      + File.separator + "lib"
                                      + File.separator + secJars[i] + ".jar"));
                 addExisting(new Path(null,
                                      System.getProperty("java.home")
                                      + File.separator + ".."
                                      + File.separator + "Classes"
                                      + File.separator + secJars[i] + ".jar"));
             }
 
             // IBM's 1.4 has rt.jar split into 4 smaller jars and a combined
             // JCE/JSSE in security.jar.
             String[] ibmJars
                 = {"core", "graphics", "security", "server", "xml"};
             for (int i = 0; i < ibmJars.length; i++) {
                 addExisting(new Path(null,
                                      System.getProperty("java.home")
                                      + File.separator + "lib"
                                      + File.separator + ibmJars[i] + ".jar"));
             }
 
             // Added for MacOS X
             addExisting(new Path(null,
                                  System.getProperty("java.home")
                                  + File.separator + ".."
                                  + File.separator + "Classes"
                                  + File.separator + "classes.jar"));
             addExisting(new Path(null,
                                  System.getProperty("java.home")
                                  + File.separator + ".."
                                  + File.separator + "Classes"
                                  + File.separator + "ui.jar"));
         }
     }
 
     /**
      * Emulation of extdirs feature in java >= 1.2.
      * This method adds all files in the given
      * directories (but not in sub-directories!) to the classpath,
      * so that you don't have to specify them all one by one.
      * @param extdirs - Path to append files to
      */
     public void addExtdirs(Path extdirs) {
         if (extdirs == null) {
             String extProp = System.getProperty("java.ext.dirs");
             if (extProp != null) {
                 extdirs = new Path(getProject(), extProp);
             } else {
                 return;
             }
         }
 
         String[] dirs = extdirs.list();
         for (int i = 0; i < dirs.length; i++) {
             File dir = resolveFile(getProject(), dirs[i]);
             if (dir.exists() && dir.isDirectory()) {
                 FileSet fs = new FileSet();
                 fs.setDir(dir);
                 fs.setIncludes("*");
                 addFileset(fs);
             }
         }
     }
 
     /**
      * Fulfill the ResourceCollection contract. The Iterator returned
      * will throw ConcurrentModificationExceptions if ResourceCollections
      * are added to this container while the Iterator is in use.
      * @return a "fail-fast" Iterator.
      */
     public final synchronized Iterator<Resource> iterator() {
         if (isReference()) {
             return ((Path) getCheckedRef()).iterator();
         }
         dieOnCircularReference();
         if (getPreserveBC()) {
             return new FileResourceIterator(getProject(), null, list());
         }
         return union == null ? EMPTY_ITERATOR
             : assertFilesystemOnly(union).iterator();
     }
 
     /**
      * Fulfill the ResourceCollection contract.
      * @return whether this is a filesystem-only resource collection.
      */
     public synchronized boolean isFilesystemOnly() {
         if (isReference()) {
             return ((Path) getCheckedRef()).isFilesystemOnly();
         }
         dieOnCircularReference();
         assertFilesystemOnly(union);
         return true;
     }
 
     /**
      * Verify the specified ResourceCollection is filesystem-only.
      * @param rc the ResourceCollection to check.
      * @throws BuildException if <code>rc</code> is not filesystem-only.
      * @return the passed in ResourceCollection.
      */
     protected ResourceCollection assertFilesystemOnly(ResourceCollection rc) {
         if (rc != null && !(rc.isFilesystemOnly())) {
             throw new BuildException(getDataTypeName()
                 + " allows only filesystem resources.");
         }
         return rc;
     }
 
     /**
      * Helps determine whether to preserve BC by calling <code>list()</code> on subclasses.
      * The default behavior of this method is to return <code>true</code> for any subclass
      * that implements <code>list()</code>; this can, of course, be avoided by overriding
      * this method to return <code>false</code>. It is not expected that the result of this
      * method should change over time, thus it is called only once.
      * @return <code>true</code> if <code>iterator()</code> should delegate to <code>list()</code>.
      */
     protected boolean delegateIteratorToList() {
         if (getClass().equals(Path.class)) {
             return false;
         }
         try {
             Method listMethod = getClass().getMethod("list", (Class[]) null);
             return !listMethod.getDeclaringClass().equals(Path.class);
         } catch (Exception e) {
             //shouldn't happen, but
             return false;
         }
     }
 
     private synchronized boolean getPreserveBC() {
         if (preserveBC == null) {
             preserveBC = delegateIteratorToList() ? Boolean.TRUE : Boolean.FALSE;
         }
         return preserveBC.booleanValue();
     }
 
     /**
      * Does the given file name contain wildcards?
      * @since Ant 1.8.2
      */
     private static boolean containsWildcards(String path) {
         return path != null
             && (path.indexOf("*") > -1 || path.indexOf("?") > -1);
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/PropertySet.java b/src/main/org/apache/tools/ant/types/PropertySet.java
index 2267e0d12..bed52a240 100644
--- a/src/main/org/apache/tools/ant/types/PropertySet.java
+++ b/src/main/org/apache/tools/ant/types/PropertySet.java
@@ -1,570 +1,570 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types;
 
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.Stack;
 import java.util.TreeMap;
 import java.util.Hashtable;
 import java.util.Properties;
 import java.util.Vector;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.resources.MappedResource;
 import org.apache.tools.ant.types.resources.PropertyResource;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.regexp.RegexpMatcher;
 import org.apache.tools.ant.util.regexp.RegexpMatcherFactory;
 
 /**
  * A set of properties.
  *
  * @since Ant 1.6
  */
 public class PropertySet extends DataType implements ResourceCollection {
 
     private boolean dynamic = true;
     private boolean negate = false;
     private Set cachedNames;
     private Vector ptyRefs = new Vector();
     private Vector setRefs = new Vector();
     private Mapper mapper;
 
     /**
      * This is a nested class containing a reference to some properties
      * and optionally a source of properties.
      */
     public static class PropertyRef {
 
         private int count;
         private String name;
         private String regex;
         private String prefix;
         private String builtin;
 
         /**
          * Set the name.
          * @param name a <code>String</code> value.
          */
         public void setName(String name) {
             assertValid("name", name);
             this.name = name;
         }
 
         /**
          * Set the regular expression to use to filter the properties.
          * @param regex a regular expression.
          */
         public void setRegex(String regex) {
             assertValid("regex", regex);
             this.regex = regex;
         }
 
         /**
          * Set the prefix to use.
          * @param prefix a <code>String</code> value.
          */
         public void setPrefix(String prefix) {
             assertValid("prefix", prefix);
             this.prefix = prefix;
         }
 
         /**
          * Builtin property names - all, system or commandline.
          * @param b an enumerated <code>BuildinPropertySetName</code> value.
          */
         public void setBuiltin(BuiltinPropertySetName b) {
             String pBuiltIn = b.getValue();
             assertValid("builtin", pBuiltIn);
             this.builtin = pBuiltIn;
         }
 
         private void assertValid(String attr, String value) {
             if (value == null || value.length() < 1) {
                 throw new BuildException("Invalid attribute: " + attr);
             }
 
             if (++count != 1) {
                 throw new BuildException("Attributes name, regex, and "
                     + "prefix are mutually exclusive");
             }
         }
 
         /**
          * A debug toString().
          * @return a string version of this object.
          */
         public String toString() {
             return "name=" + name + ", regex=" + regex + ", prefix=" + prefix
                 + ", builtin=" + builtin;
         }
 
     } //end nested class
 
     /**
      * Allow properties of a particular name in the set.
      * @param name the property name to allow.
      */
     public void appendName(String name) {
         PropertyRef r = new PropertyRef();
         r.setName(name);
         addPropertyref(r);
     }
 
     /**
      * Allow properties whose names match a regex in the set.
      * @param regex the regular expression to use.
      */
     public void appendRegex(String regex) {
         PropertyRef r = new PropertyRef();
         r.setRegex(regex);
         addPropertyref(r);
     }
 
     /**
      * Allow properties whose names start with a prefix in the set.
      * @param prefix the prefix to use.
      */
     public void appendPrefix(String prefix) {
         PropertyRef r = new PropertyRef();
         r.setPrefix(prefix);
         addPropertyref(r);
     }
 
     /**
      * Allow builtin (all, system or commandline) properties in the set.
      * @param b the type of builtin properties.
      */
     public void appendBuiltin(BuiltinPropertySetName b) {
         PropertyRef r = new PropertyRef();
         r.setBuiltin(b);
         addPropertyref(r);
     }
 
     /**
      * Set a mapper to change property names.
      * @param type mapper type.
      * @param from source pattern.
      * @param to output pattern.
      */
     public void setMapper(String type, String from, String to) {
         Mapper m = createMapper();
         Mapper.MapperType mapperType = new Mapper.MapperType();
         mapperType.setValue(type);
         m.setType(mapperType);
         m.setFrom(from);
         m.setTo(to);
     }
 
     /**
      * Add a property reference (nested element) to the references to be used.
      * @param ref a property reference.
      */
     public void addPropertyref(PropertyRef ref) {
         assertNotReference();
         setChecked(false);
         ptyRefs.addElement(ref);
     }
 
     /**
      * Add another property set to this set.
      * @param ref another property set.
      */
     public void addPropertyset(PropertySet ref) {
         assertNotReference();
         setChecked(false);
         setRefs.addElement(ref);
     }
 
     /**
      * Create a mapper to map the property names.
      * @return a mapper to be configured.
      */
     public Mapper createMapper() {
         assertNotReference();
         if (mapper != null) {
             throw new BuildException("Too many <mapper>s!");
         }
         mapper = new Mapper(getProject());
         setChecked(false);
         return mapper;
     }
 
     /**
      * Add a nested FileNameMapper.
      * @param fileNameMapper the mapper to add.
      * @since Ant 1.6.3
      */
     public void add(FileNameMapper fileNameMapper) {
         createMapper().add(fileNameMapper);
     }
 
     /**
      * Set whether to reevaluate the set everytime the set is used.
      * Default is true.
      *
      * @param dynamic if true, reevaluate the property set each time
      *                the set is used. if false cache the property set
      *                the first time and use the cached set on subsequent
      *                occasions.
      */
     public void setDynamic(boolean dynamic) {
         assertNotReference();
         this.dynamic = dynamic;
     }
 
     /**
      * Set whether to negate results.
      * If "true", all properties not selected by nested elements will be returned.
      *  Default is "false".
      * @param negate if true, negate the selection criteria.
      */
     public void setNegate(boolean negate) {
         assertNotReference();
         this.negate = negate;
     }
 
     /**
      * Get the dynamic attribute.
-     * @return true if the property set is to be evalulated each time it is used.
+     * @return true if the property set is to be evaluated each time it is used.
      */
     public boolean getDynamic() {
         if (isReference()) {
             return getRef().dynamic;
         }
         dieOnCircularReference();
         return dynamic;
     }
 
     /**
      * Get the mapper attribute.
      * @return the mapper attribute.
      */
     public Mapper getMapper() {
         if (isReference()) {
             return getRef().mapper;
         }
         dieOnCircularReference();
         return mapper;
     }
 
     /**
      * Convert the system properties to a hashtable.
      * Use propertynames to get the list of properties (including
      * default ones).
      */
     private Hashtable getAllSystemProperties() {
         Hashtable ret = new Hashtable();
         for (Enumeration e = System.getProperties().propertyNames();
              e.hasMoreElements();) {
             String name = (String) e.nextElement();
             ret.put(name, System.getProperties().getProperty(name));
         }
         return ret;
     }
 
     /**
      * This is the operation to get the existing or recalculated properties.
      * @return the properties for this propertyset.
      */
     public Properties getProperties() {
         if (isReference()) {
             return getRef().getProperties();
         }
         dieOnCircularReference();
         Hashtable props = getEffectiveProperties();
         Set names = getPropertyNames(props);
 
         FileNameMapper m = null;
         Mapper myMapper = getMapper();
         if (myMapper != null) {
             m = myMapper.getImplementation();
         }
         Properties properties = new Properties();
         //iterate through the names, get the matching values
         for (Iterator iter = names.iterator(); iter.hasNext();) {
             String name = (String) iter.next();
             String value = (String) props.get(name);
             if (value != null) {
                 // may be null if a system property has been added
                 // after the project instance has been initialized
                 if (m != null) {
                     //map the names
                     String[] newname = m.mapFileName(name);
                     if (newname != null) {
                         name = newname[0];
                     }
                 }
                 properties.setProperty(name, value);
             }
         }
         return properties;
     }
 
     private Hashtable getEffectiveProperties() {
         Project prj = getProject();
         Hashtable result = prj == null ? getAllSystemProperties() : prj.getProperties();
         //quick & dirty, to make nested mapped p-sets work:
         for (Enumeration e = setRefs.elements(); e.hasMoreElements();) {
             PropertySet set = (PropertySet) e.nextElement();
             result.putAll(set.getProperties());
         }
         return result;
     }
 
     private Set getPropertyNames(Hashtable props) {
         Set names;
         if (getDynamic() || cachedNames == null) {
             names = new HashSet();
             addPropertyNames(names, props);
             // Add this PropertySet's nested PropertySets' property names.
             for (Enumeration e = setRefs.elements(); e.hasMoreElements();) {
                 PropertySet set = (PropertySet) e.nextElement();
                 names.addAll(set.getProperties().keySet());
             }
             if (negate) {
                 //make a copy...
                 HashSet complement = new HashSet(props.keySet());
                 complement.removeAll(names);
                 names = complement;
             }
             if (!getDynamic()) {
                 cachedNames = names;
             }
         } else {
             names = cachedNames;
         }
         return names;
     }
 
     /**
      * @param  names the output Set to fill with the property names
      *         matching this PropertySet selection criteria.
      * @param  properties the current Project properties, passed in to
      *         avoid needless duplication of the Hashtable during recursion.
      */
     private void addPropertyNames(Set names, Hashtable properties) {
         if (isReference()) {
             getRef().addPropertyNames(names, properties);
         }
         dieOnCircularReference();
         // Add this PropertySet's property names.
         for (Enumeration e = ptyRefs.elements(); e.hasMoreElements();) {
             PropertyRef r = (PropertyRef) e.nextElement();
             if (r.name != null) {
                 if (properties.get(r.name) != null) {
                     names.add(r.name);
                 }
             } else if (r.prefix != null) {
                 for (Enumeration p = properties.keys(); p.hasMoreElements();) {
                     String name = (String) p.nextElement();
                     if (name.startsWith(r.prefix)) {
                         names.add(name);
                     }
                 }
             } else if (r.regex != null) {
                 RegexpMatcherFactory matchMaker = new RegexpMatcherFactory();
                 RegexpMatcher matcher = matchMaker.newRegexpMatcher();
                 matcher.setPattern(r.regex);
                 for (Enumeration p = properties.keys(); p.hasMoreElements();) {
                     String name = (String) p.nextElement();
                     if (matcher.matches(name)) {
                         names.add(name);
                     }
                 }
             } else if (r.builtin != null) {
 
                 if (r.builtin.equals(BuiltinPropertySetName.ALL)) {
                     names.addAll(properties.keySet());
                 } else if (r.builtin.equals(BuiltinPropertySetName.SYSTEM)) {
                     names.addAll(System.getProperties().keySet());
                 } else if (r.builtin.equals(BuiltinPropertySetName
                                               .COMMANDLINE)) {
                     names.addAll(getProject().getUserProperties().keySet());
                 } else {
                     throw new BuildException("Impossible: Invalid builtin "
                                              + "attribute!");
                 }
             } else {
                 throw new BuildException("Impossible: Invalid PropertyRef!");
             }
         }
     }
 
     /**
      * Performs the check for circular references and returns the
      * referenced PropertySet.
      * @return the referenced PropertySet.
      */
     protected PropertySet getRef() {
         return (PropertySet) getCheckedRef(PropertySet.class, "propertyset");
     }
 
     /**
      * Sets the value of the refid attribute.
      *
      * @param  r the reference this datatype should point to.
      * @throws BuildException if another attribute was set, since
      *         refid and all other attributes are mutually exclusive.
      */
     public final void setRefid(Reference r) {
         if (!noAttributeSet) {
             throw tooManyAttributes();
         }
         super.setRefid(r);
     }
 
     /**
      * Ensures this data type is not a reference.
      *
      * <p>Calling this method as the first line of every bean method of
      * this data type (setXyz, addXyz, createXyz) ensure proper handling
      * of the refid attribute.</p>
      *
      * @throws BuildException if the refid attribute was already set, since
      *         refid and all other attributes are mutually exclusive.
      */
     protected final void assertNotReference() {
         if (isReference()) {
             throw tooManyAttributes();
         }
         noAttributeSet = false;
     }
 
     /**
      * Flag which tracks whether any attribute has been set; used by
      * {@link #assertNotReference()} and {@link #setRefid(Reference)}.
      */
     private boolean noAttributeSet = true;
 
     /**
      * Used for propertyref's builtin attribute.
      */
     public static class BuiltinPropertySetName extends EnumeratedAttribute {
         static final String ALL = "all";
         static final String SYSTEM = "system";
         static final String COMMANDLINE = "commandline";
         /** {@inheritDoc}. */
         public String[] getValues() {
             return new String[] {ALL, SYSTEM, COMMANDLINE};
         }
     }
 
     /**
      * A debug toString.
      * This gets a comma separated list of key=value pairs for
      * the properties in the set.
      * The output order is sorted according to the keys' <i>natural order</i>.
      * @return a string rep of this object.
      */
     public String toString() {
         if (isReference()) {
             return getRef().toString();
         }
         dieOnCircularReference();
         StringBuffer b = new StringBuffer();
         TreeMap sorted = new TreeMap(getProperties());
         for (Iterator i = sorted.entrySet().iterator(); i.hasNext();) {
             Map.Entry e = (Map.Entry) i.next();
             if (b.length() != 0) {
                 b.append(", ");
             }
             b.append(e.getKey().toString());
             b.append("=");
             b.append(e.getValue().toString());
         }
         return b.toString();
     }
 
     /**
      * Fulfill the ResourceCollection interface.
      * @return an Iterator of Resources.
      * @since Ant 1.7
      */
     public Iterator<Resource> iterator() {
         if (isReference()) {
             return getRef().iterator();
         }
         dieOnCircularReference();
         Hashtable props = getEffectiveProperties();
         Set names = getPropertyNames(props);
 
         Mapper myMapper = getMapper();
         final FileNameMapper m = myMapper == null ? null : myMapper.getImplementation();
         final Iterator iter = names.iterator();
 
         return new Iterator<Resource>() {
             public boolean hasNext() {
                 return iter.hasNext();
             }
             public Resource next() {
                 PropertyResource p = new PropertyResource(getProject(), (String) iter.next());
                 return m == null ? (Resource) p : new MappedResource(p, m);
             }
             public void remove() {
                 throw new UnsupportedOperationException();
             }
         };
     }
 
     /**
      * Fulfill the ResourceCollection contract.
      * @return the size of this ResourceCollection.
      */
     public int size() {
         return isReference() ? getRef().size() : getProperties().size();
     }
 
     /**
      * Fulfill the ResourceCollection contract.
      * @return whether this is a filesystem-only resource collection.
      */
     public boolean isFilesystemOnly() {
         if (isReference()) {
             return getRef().isFilesystemOnly();
         }
         dieOnCircularReference();
         return false;
     }
 
     protected synchronized void dieOnCircularReference(Stack stk, Project p)
         throws BuildException {
         if (isChecked()) {
             return;
         }
         if (isReference()) {
             super.dieOnCircularReference(stk, p);
         } else {
             if (mapper != null) {
                 pushAndInvokeCircularReferenceCheck(mapper, stk, p);
             }
             for (Iterator i = setRefs.iterator(); i.hasNext(); ) {
                 pushAndInvokeCircularReferenceCheck((PropertySet) i.next(), stk,
                                                     p);
             }
             setChecked(true);
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/TarFileSet.java b/src/main/org/apache/tools/ant/types/TarFileSet.java
index 7d61ae119..eec1dfa0c 100644
--- a/src/main/org/apache/tools/ant/types/TarFileSet.java
+++ b/src/main/org/apache/tools/ant/types/TarFileSet.java
@@ -1,268 +1,268 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 
 /**
  * A TarFileSet is a FileSet with extra attributes useful in the context of
  * Tar/Jar tasks.
  *
  * A TarFileSet extends FileSets with the ability to extract a subset of the
  * entries of a Tar file for inclusion in another Tar file.  It also includes
  * a prefix attribute which is prepended to each entry in the output Tar file.
  *
  */
 public class TarFileSet extends ArchiveFileSet {
 
     private boolean userNameSet;
     private boolean groupNameSet;
     private boolean userIdSet;
     private boolean groupIdSet;
 
     private String userName = "";
     private String groupName = "";
     private int    uid;
     private int    gid;
 
     /** Constructor for TarFileSet */
     public TarFileSet() {
         super();
     }
 
     /**
-     * Constructor using a fileset arguement.
+     * Constructor using a fileset argument.
      * @param fileset the fileset to use
      */
     protected TarFileSet(FileSet fileset) {
         super(fileset);
     }
 
     /**
-     * Constructor using a tarfileset arguement.
+     * Constructor using a tarfileset argument.
      * @param fileset the tarfileset to use
      */
     protected TarFileSet(TarFileSet fileset) {
         super(fileset);
     }
 
     /**
      * The username for the tar entry
      * This is not the same as the UID.
      * @param userName the user name for the tar entry.
      */
     public void setUserName(String userName) {
         checkTarFileSetAttributesAllowed();
         userNameSet = true;
         this.userName = userName;
     }
 
     /**
      * @return the user name for the tar entry
      */
     public String getUserName() {
         if (isReference()) {
             return ((TarFileSet) getCheckedRef()).getUserName();
         }
         return userName;
     }
 
     /**
      * @return whether the user name has been explicitly set.
      */
     public boolean hasUserNameBeenSet() {
         return userNameSet;
     }
 
     /**
      * The uid for the tar entry
      * This is not the same as the User name.
      * @param uid the id of the user for the tar entry.
      */
     public void setUid(int uid) {
         checkTarFileSetAttributesAllowed();
         userIdSet = true;
         this.uid = uid;
     }
 
     /**
      * @return the uid for the tar entry
      */
     public int getUid() {
         if (isReference()) {
             return ((TarFileSet) getCheckedRef()).getUid();
         }
         return uid;
     }
 
     /**
      * @return whether the user id has been explicitly set.
      */
     public boolean hasUserIdBeenSet() {
         return userIdSet;
     }
 
     /**
      * The groupname for the tar entry; optional, default=""
      * This is not the same as the GID.
      * @param groupName the group name string.
      */
     public void setGroup(String groupName) {
         checkTarFileSetAttributesAllowed();
         groupNameSet = true;
         this.groupName = groupName;
     }
 
     /**
      * @return the group name string.
      */
     public String getGroup() {
         if (isReference()) {
             return ((TarFileSet) getCheckedRef()).getGroup();
         }
         return groupName;
     }
 
     /**
      * @return whether the group name has been explicitly set.
      */
     public boolean hasGroupBeenSet() {
         return groupNameSet;
     }
 
     /**
      * The GID for the tar entry; optional, default="0"
      * This is not the same as the group name.
      * @param gid the group id.
      */
     public void setGid(int gid) {
         checkTarFileSetAttributesAllowed();
         groupIdSet = true;
         this.gid = gid;
     }
 
     /**
      * @return the group identifier.
      */
     public int getGid() {
         if (isReference()) {
             return ((TarFileSet) getCheckedRef()).getGid();
         }
         return gid;
     }
 
     /**
      * @return whether the group id has been explicitly set.
      */
     public boolean hasGroupIdBeenSet() {
         return groupIdSet;
     }
 
     /**
      * Create a new scanner.
      * @return the created scanner.
      */
     protected ArchiveScanner newArchiveScanner() {
         TarScanner zs = new TarScanner();
         return zs;
     }
 
     /**
      * Makes this instance in effect a reference to another instance.
      *
      * <p>You must not set another attribute or nest elements inside
      * this element if you make it a reference.</p>
      * @param r the <code>Reference</code> to use.
      * @throws BuildException on error
      */
     public void setRefid(Reference r) throws BuildException {
         if (userNameSet || userIdSet || groupNameSet || groupIdSet) {
             throw tooManyAttributes();
         }
         super.setRefid(r);
     }
 
     /**
      * A TarFileset accepts another TarFileSet or a FileSet as reference
      * FileSets are often used by the war task for the lib attribute
      * @param p the project to use
      * @return the abstract fileset instance
      */
     protected AbstractFileSet getRef(Project p) {
         dieOnCircularReference(p);
         Object o = getRefid().getReferencedObject(p);
         if (o instanceof TarFileSet) {
             return (AbstractFileSet) o;
         } else if (o instanceof FileSet) {
             TarFileSet zfs = new TarFileSet((FileSet) o);
             configureFileSet(zfs);
             return zfs;
         } else {
             String msg = getRefid().getRefId() + " doesn\'t denote a tarfileset or a fileset";
             throw new BuildException(msg);
         }
     }
 
     /**
      * Configure a fileset based on this fileset.
      * If the fileset is a TarFileSet copy in the tarfileset
      * specific attributes.
      * @param zfs the archive fileset to configure.
      */
     protected void configureFileSet(ArchiveFileSet zfs) {
         super.configureFileSet(zfs);
         if (zfs instanceof TarFileSet) {
             TarFileSet tfs = (TarFileSet) zfs;
             tfs.setUserName(userName);
             tfs.setGroup(groupName);
             tfs.setUid(uid);
             tfs.setGid(gid);
         }
     }
 
     /**
      * Return a TarFileSet that has the same properties
      * as this one.
      * @return the cloned tarFileSet
      */
     public Object clone() {
         if (isReference()) {
             return ((TarFileSet) getRef(getProject())).clone();
         } else {
             return super.clone();
         }
     }
 
     /**
      * A check attributes for TarFileSet.
      * If there is a reference, and
      * it is a TarFileSet, the tar fileset attributes
      * cannot be used.
      */
     private void checkTarFileSetAttributesAllowed() {
         if (getProject() == null
             || (isReference()
                 && (getRefid().getReferencedObject(
                         getProject())
                     instanceof TarFileSet))) {
             checkAttributesAllowed();
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/ZipFileSet.java b/src/main/org/apache/tools/ant/types/ZipFileSet.java
index 6fcc66560..eb6a694dc 100644
--- a/src/main/org/apache/tools/ant/types/ZipFileSet.java
+++ b/src/main/org/apache/tools/ant/types/ZipFileSet.java
@@ -1,147 +1,147 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 
 /**
  * A ZipFileSet is a FileSet with extra attributes useful in the context of
  * Zip/Jar tasks.
  *
  * A ZipFileSet extends FileSets with the ability to extract a subset of the
  * entries of a Zip file for inclusion in another Zip file.  It also includes
  * a prefix attribute which is prepended to each entry in the output Zip file.
  *
  * Since ant 1.6 ZipFileSet can be defined with an id and referenced in packaging tasks
  *
  */
 public class ZipFileSet extends ArchiveFileSet {
 
     private String encoding = null;
 
     /** Constructor for ZipFileSet */
     public ZipFileSet() {
         super();
     }
 
     /**
-     * Constructor using a fileset arguement.
+     * Constructor using a fileset argument.
      * @param fileset the fileset to use
      */
     protected ZipFileSet(FileSet fileset) {
         super(fileset);
     }
 
     /**
-     * Constructor using a zipfileset arguement.
+     * Constructor using a zipfileset argument.
      * @param fileset the zipfileset to use
      */
     protected ZipFileSet(ZipFileSet fileset) {
         super(fileset);
         encoding = fileset.encoding;
     }
 
     /**
      * Set the encoding used for this ZipFileSet.
      * @param enc encoding as String.
      * @since Ant 1.7
      */
     public void setEncoding(String enc) {
         checkZipFileSetAttributesAllowed();
         this.encoding = enc;
     }
 
     /**
      * Get the encoding used for this ZipFileSet.
      * @return String encoding.
      * @since Ant 1.7
      */
     public String getEncoding() {
         if (isReference()) {
             AbstractFileSet ref = getRef(getProject());
             if (ref instanceof ZipFileSet) {
                 return ((ZipFileSet) ref).getEncoding();
             } else {
                 return null;
             }
         }
         return encoding;
     }
 
     /**
      * Return a new archive scanner based on this one.
      * @return a new ZipScanner with the same encoding as this one.
      */
     protected ArchiveScanner newArchiveScanner() {
         ZipScanner zs = new ZipScanner();
         zs.setEncoding(encoding);
         return zs;
     }
 
     /**
      * A ZipFileset accepts another ZipFileSet or a FileSet as reference
      * FileSets are often used by the war task for the lib attribute
      * @param p the project to use
      * @return the abstract fileset instance
      */
     protected AbstractFileSet getRef(Project p) {
         dieOnCircularReference(p);
         Object o = getRefid().getReferencedObject(p);
         if (o instanceof ZipFileSet) {
             return (AbstractFileSet) o;
         } else if (o instanceof FileSet) {
             ZipFileSet zfs = new ZipFileSet((FileSet) o);
             configureFileSet(zfs);
             return zfs;
         } else {
             String msg = getRefid().getRefId() + " doesn\'t denote a zipfileset or a fileset";
             throw new BuildException(msg);
         }
     }
 
     /**
      * Return a ZipFileSet that has the same properties
      * as this one.
      * @return the cloned zipFileSet
      */
     public Object clone() {
         if (isReference()) {
             return ((ZipFileSet) getRef(getProject())).clone();
         } else {
             return super.clone();
         }
     }
 
     /**
      * A check attributes for zipFileSet.
      * If there is a reference, and
      * it is a ZipFileSet, the zip fileset attributes
      * cannot be used.
      */
     private void checkZipFileSetAttributesAllowed() {
         if (getProject() == null
             || (isReference()
                 && (getRefid().getReferencedObject(
                         getProject())
                     instanceof ZipFileSet))) {
             checkAttributesAllowed();
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/optional/ScriptCondition.java b/src/main/org/apache/tools/ant/types/optional/ScriptCondition.java
index a034246f7..fac02bfa4 100644
--- a/src/main/org/apache/tools/ant/types/optional/ScriptCondition.java
+++ b/src/main/org/apache/tools/ant/types/optional/ScriptCondition.java
@@ -1,68 +1,68 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types.optional;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.condition.Condition;
 
 /**
  * A condition that lets you include script.
  * The condition component sets a bean "self", whose attribute "value"
  * must be set to true for the condition to succeed, false to fail.
  * The default is 'false'
  */
 public class ScriptCondition extends AbstractScriptComponent implements Condition {
 
     /**
      * result field
      */
     private boolean value = false;
 
     /**
      * Is this condition true?
      *
      * @return true if the condition is true
      *
      * @throws org.apache.tools.ant.BuildException
      *          if an error occurs
      */
     public boolean eval() throws BuildException {
         initScriptRunner();
         executeScript("ant_condition");
         return getValue();
     }
 
     /**
-     * get the current value of the conditon
+     * get the current value of the condition
      * @return true if the condition
      */
     public boolean getValue() {
         return value;
     }
 
     /**
      * set the value of the condition.
      * This is used by the script to pass the return value.
      * It can be used by an attribute, in which case it sets the default
      * value
      * @param value the value to set the condition to
      */
     public void setValue(boolean value) {
         this.value = value;
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/optional/image/Ellipse.java b/src/main/org/apache/tools/ant/types/optional/image/Ellipse.java
index 9fc5e29f9..23623d0f4 100644
--- a/src/main/org/apache/tools/ant/types/optional/image/Ellipse.java
+++ b/src/main/org/apache/tools/ant/types/optional/image/Ellipse.java
@@ -1,86 +1,86 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types.optional.image;
 
 import javax.media.jai.PlanarImage;
 import java.awt.BasicStroke;
 import java.awt.Graphics2D;
 import java.awt.geom.Ellipse2D;
 import java.awt.image.BufferedImage;
 
 /**
  * Draw an ellipse.
  * @see org.apache.tools.ant.taskdefs.optional.image.Image
  */
 public class Ellipse extends BasicShape implements DrawOperation {
     // CheckStyle:VisibilityModifier OFF - bc
     protected int width = 0;
     protected int height = 0;
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Set the width.
      * @param width the width of the elipse.
      */
     public void setWidth(int width) {
         this.width = width;
     }
 
     /**
      * Set the height.
-     * @param height the height of the elipse.
+     * @param height the height of the ellipse.
      */
     public void setHeight(int height) {
         this.height = height;
     }
 
     /** {@inheritDoc}. */
     public PlanarImage executeDrawOperation() {
         BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR_PRE);
 
         Graphics2D graphics = (Graphics2D) bi.getGraphics();
 
         if (!stroke.equals("transparent")) {
             BasicStroke bStroke = new BasicStroke(stroke_width);
             graphics.setColor(ColorMapper.getColorByName(stroke));
             graphics.setStroke(bStroke);
             graphics.draw(new Ellipse2D.Double(0, 0, width, height));
         }
 
         if (!fill.equals("transparent")) {
             graphics.setColor(ColorMapper.getColorByName(fill));
             graphics.fill(new Ellipse2D.Double(0, 0, width, height));
         }
 
 
         final int size = instructions.size();
         for (int i = 0; i < size; i++) {
             ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
             if (instr instanceof DrawOperation) {
                 PlanarImage img = ((DrawOperation) instr).executeDrawOperation();
                 graphics.drawImage(img.getAsBufferedImage(), null, 0, 0);
             } else if (instr instanceof TransformOperation) {
                 graphics = (Graphics2D) bi.getGraphics();
                 PlanarImage image = ((TransformOperation) instr)
                     .executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
                 bi = image.getAsBufferedImage();
             }
         }
         return PlanarImage.wrapRenderedImage(bi);
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/resources/AbstractClasspathResource.java b/src/main/org/apache/tools/ant/types/resources/AbstractClasspathResource.java
index b70b5a785..336b3d6c8 100644
--- a/src/main/org/apache/tools/ant/types/resources/AbstractClasspathResource.java
+++ b/src/main/org/apache/tools/ant/types/resources/AbstractClasspathResource.java
@@ -1,265 +1,265 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types.resources;
 
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.util.FileUtils;
 
 import java.io.FilterInputStream;
 import java.io.InputStream;
 import java.io.IOException;
 import java.util.Stack;
 
 /**
  *
  * A Resource representation of anything that is accessed via a Java classloader.
  * The core methods to set/resolve the classpath are provided.
  * @since Ant 1.8.0
  *
  */
 
 public abstract class AbstractClasspathResource extends Resource {
     private Path classpath;
     private Reference loader;
     private boolean parentFirst = true;
 
     /**
      * Set the classpath to use when looking up a resource.
      * @param classpath to add to any existing classpath
      */
     public void setClasspath(Path classpath) {
         checkAttributesAllowed();
         if (this.classpath == null) {
             this.classpath = classpath;
         } else {
             this.classpath.append(classpath);
         }
         setChecked(false);
     }
 
     /**
      * Add a classpath to use when looking up a resource.
      * @return The classpath to be configured
      */
     public Path createClasspath() {
         checkChildrenAllowed();
         if (classpath == null) {
             classpath = new Path(getProject());
         }
         setChecked(false);
         return classpath.createPath();
     }
 
     /**
      * Set the classpath to use when looking up a resource,
      * given as reference to a &lt;path&gt; defined elsewhere
      * @param r The reference value
      */
     public void setClasspathRef(Reference r) {
         checkAttributesAllowed();
         createClasspath().setRefid(r);
     }
 
     /**
      * get the classpath used by this <code>LoadProperties</code>.
      * @return The classpath
      */
     public Path getClasspath() {
         if (isReference()) {
             return ((AbstractClasspathResource) getCheckedRef()).getClasspath();
         }
         dieOnCircularReference();
         return classpath;
     }
 
     /**
      * Get the loader.
      * @return the loader.
      */
     public Reference getLoader() {
         if (isReference()) {
             return ((AbstractClasspathResource) getCheckedRef()).getLoader();
         }
         dieOnCircularReference();
         return loader;
     }
 
     /**
      * Use the reference to locate the loader. If the loader is not
      * found, taskdef will use the specified classpath and register it
      * with the specified name.
      *
      * This allow multiple taskdef/typedef to use the same class loader,
      * so they can be used together. It eliminate the need to
      * put them in the CLASSPATH.
      *
      * @param r the reference to locate the loader.
      */
     public void setLoaderRef(Reference r) {
         checkAttributesAllowed();
         loader = r;
     }
 
     /**
      * Whether to consult the parent classloader first.
      *
      * <p>Only relevant if a classpath has been specified.</p>
      *
      * @since Ant 1.8.0
      */
     public void setParentFirst(boolean b) {
         parentFirst = b;
     }
 
     /**
      * Overrides the super version.
      * @param r the Reference to set.
      */
     public void setRefid(Reference r) {
         if (loader != null || classpath != null) {
             throw tooManyAttributes();
         }
         super.setRefid(r);
     }
 
     /**
      * Learn whether this resource exists. This implementation opens the input stream
      * as the test.
      * @return true if this resource exists.
      */
     public boolean isExists() {
         if (isReference()) {
             return  ((Resource) getCheckedRef()).isExists();
         }
         dieOnCircularReference();
         InputStream is = null;
         try {
             is = getInputStream();
             return is != null;
         } catch (IOException ex) {
             return false;
         } finally {
             FileUtils.close(is);
         }
     }
 
     /**
      * Return an InputStream for reading the contents of this Resource.
      * @return an InputStream object.
      * @throws IOException if an error occurs.
      */
     public InputStream getInputStream() throws IOException {
         if (isReference()) {
             return ((Resource) getCheckedRef()).getInputStream();
         }
         dieOnCircularReference();
 
         final ClassLoaderWithFlag classLoader = getClassLoader();
         return !classLoader.needsCleanup()
             ? openInputStream(classLoader.getLoader())
             : new FilterInputStream(openInputStream(classLoader.getLoader())) {
                     public void close() throws IOException {
                         FileUtils.close(in);
                         classLoader.cleanup();
                     }
                     protected void finalize() throws Throwable {
                         try {
                             close();
                         } finally {
                             super.finalize();
                         }
                     }
                 };
     }
 
     /**
      * combines the various ways that could specify a ClassLoader and
      * potentially creates one that needs to be cleaned up when it is
      * no longer needed so that classes can get garbage collected.
      */
     protected ClassLoaderWithFlag getClassLoader() {
         ClassLoader cl = null;
         boolean clNeedsCleanup = false;
         if (loader != null) {
             cl = (ClassLoader) loader.getReferencedObject();
         }
         if (cl == null) {
             if (getClasspath() != null) {
                 Path p = getClasspath().concatSystemClasspath("ignore");
                 if (parentFirst) {
                     cl = getProject().createClassLoader(p);
                 } else {
                     cl = AntClassLoader.newAntClassLoader(getProject()
                                                           .getCoreLoader(),
                                                           getProject(),
                                                           p, false);
                 }
                 clNeedsCleanup = loader == null;
             } else {
                 cl = JavaResource.class.getClassLoader();
             }
             if (loader != null && cl != null) {
                 getProject().addReference(loader.getRefId(), cl);
             }
         }
         return new ClassLoaderWithFlag(cl, clNeedsCleanup);
     }
 
     /**
-     * open the inpout stream from a specific classloader
+     * open the input stream from a specific classloader
      * @param cl the classloader to use. Will be null if the system classloader is used
      * @return an open input stream for the resource
      * @throws IOException if an error occurs.
      */
     protected abstract InputStream openInputStream(ClassLoader cl) throws IOException;
 
     protected synchronized void dieOnCircularReference(Stack stk, Project p) {
         if (isChecked()) {
             return;
         }
         if (isReference()) {
             super.dieOnCircularReference(stk, p);
         } else {
             if (classpath != null) {
                 pushAndInvokeCircularReferenceCheck(classpath, stk, p);
             }
             setChecked(true);
         }
     }
 
     public static class ClassLoaderWithFlag {
         private final ClassLoader loader;
         private final boolean cleanup;
 
         ClassLoaderWithFlag(ClassLoader l, boolean needsCleanup) {
             loader = l;
             cleanup = needsCleanup && l instanceof AntClassLoader;
         }
         public ClassLoader getLoader() { return loader; }
         public boolean needsCleanup() { return cleanup; }
         public void cleanup() {
             if (cleanup) {
                 ((AntClassLoader) loader).cleanup();
             }
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/resources/BZip2Resource.java b/src/main/org/apache/tools/ant/types/resources/BZip2Resource.java
index 2b8cf7c8a..a00d696c3 100644
--- a/src/main/org/apache/tools/ant/types/resources/BZip2Resource.java
+++ b/src/main/org/apache/tools/ant/types/resources/BZip2Resource.java
@@ -1,85 +1,85 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types.resources;
 
 import java.io.InputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 
 import org.apache.tools.bzip2.CBZip2InputStream;
 import org.apache.tools.bzip2.CBZip2OutputStream;
 
 /**
  * A Bzip2 compressed resource.
  *
- * <p>Wraps around another resource, delegates all quries to that
+ * <p>Wraps around another resource, delegates all queries to that
  * other resource but uncompresses/compresses streams on the fly.</p>
  *
  * @since Ant 1.7
  */
 public class BZip2Resource extends CompressedResource {
     private static final char[] MAGIC = new char[] {'B', 'Z'};
 
     /** A no-arg constructor */
     public BZip2Resource() {
     }
 
     /**
      * Constructor with another resource to wrap.
      * @param other the resource to wrap.
      */
     public BZip2Resource(org.apache.tools.ant.types.ResourceCollection other) {
         super(other);
     }
 
     /**
      * Decompress on the fly using {@link CBZip2InputStream}.
      * @param in the stream to wrap.
      * @return the wrapped stream.
      * @throws IOException if there is a problem.
      */
     protected InputStream wrapStream(InputStream in) throws IOException {
         for (int i = 0; i < MAGIC.length; i++) {
             if (in.read() != MAGIC[i]) {
                 throw new IOException("Invalid bz2 stream.");
             }
         }
         return new CBZip2InputStream(in);
     }
 
     /**
      * Compress on the fly using {@link CBZip2OutputStream}.
      * @param out the stream to wrap.
      * @return the wrapped stream.
      * @throws IOException if there is a problem.
      */
     protected OutputStream wrapStream(OutputStream out) throws IOException {
         for (int i = 0; i < MAGIC.length; i++) {
             out.write(MAGIC[i]);
         }
         return new CBZip2OutputStream(out);
     }
 
     /**
      * Get the name of the compression method.
      * @return the string "Bzip2".
      */
     protected String getCompressionName() {
         return "Bzip2";
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/resources/selectors/Name.java b/src/main/org/apache/tools/ant/types/resources/selectors/Name.java
index 590e3ac36..50c242a20 100644
--- a/src/main/org/apache/tools/ant/types/resources/selectors/Name.java
+++ b/src/main/org/apache/tools/ant/types/resources/selectors/Name.java
@@ -1,151 +1,151 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types.resources.selectors;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.RegularExpression;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.selectors.SelectorUtils;
 import org.apache.tools.ant.util.regexp.Regexp;
 import org.apache.tools.ant.util.regexp.RegexpUtil;
 
 /**
  * Name ResourceSelector.
  * @since Ant 1.7
  */
 public class Name implements ResourceSelector {
     private String regex = null;
     private String pattern;
     private boolean cs = true;
     private boolean handleDirSep = false;
 
     // caches for performance reasons
     private RegularExpression reg;
     private Regexp expression;
 
     private Project project;
 
     public void setProject(Project p) {
         project = p;
     }
 
     /**
      * Set the pattern to compare names against.
      * @param n the pattern String to set.
      */
     public void setName(String n) {
         pattern = n;
     }
 
     /**
      * Get the pattern used by this Name ResourceSelector.
      * @return the String selection pattern.
      */
     public String getName() {
         return pattern;
     }
 
     /**
      * Set the regular expression to compare names against.
      * @param r the regex to set.
      * @since Ant 1.8.0
      */
     public void setRegex(String r) {
         regex = r;
         reg = null;
     }
 
     /**
      * Get the regular expression used by this Name ResourceSelector.
      * @return the String selection pattern.
      * @since Ant 1.8.0
      */
     public String getRegex() {
         return regex;
     }
 
     /**
      * Set whether the name comparisons are case-sensitive.
      * @param b boolean case-sensitivity flag.
      */
     public void setCaseSensitive(boolean b) {
         cs = b;
     }
 
     /**
      * Learn whether this Name ResourceSelector is case-sensitive.
      * @return boolean case-sensitivity flag.
      */
     public boolean isCaseSensitive() {
         return cs;
     }
 
     /**
-     * Attribute specifing whether to ignore the difference
+     * Attribute specifying whether to ignore the difference
      * between / and \ (the two common directory characters).
      * @param handleDirSep a boolean, default is false.
      * @since Ant 1.8.0
      */
     public void setHandleDirSep(boolean handleDirSep) {
         this.handleDirSep = handleDirSep;
     }
 
     /**
      * Whether the difference between / and \ (the two common
      * directory characters) is ignored.
      *
      * @since Ant 1.8.0
      */
     public boolean doesHandledirSep() {
         return handleDirSep;
     }
 
     /**
      * Return true if this Resource is selected.
      * @param r the Resource to check.
      * @return whether the Resource was selected.
      */
     public boolean isSelected(Resource r) {
         String n = r.getName();
         if (matches(n)) {
             return true;
         }
         String s = r.toString();
         return s.equals(n) ? false : matches(s);
     }
 
     private boolean matches(String name) {
         if (pattern != null) {
             return SelectorUtils.match(modify(pattern), modify(name), cs);
         } else {
             if (reg == null) {
                 reg = new RegularExpression();
                 reg.setPattern(regex);
                 expression = reg.getRegexp(project);
             }
             return expression.matches(modify(name), RegexpUtil.asOptions(cs));
         }
     }
 
     private String modify(String s) {
         if (s == null || !handleDirSep || s.indexOf("\\") == -1) {
             return s;
         }
         return s.replace('\\', '/');
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/selectors/AbstractSelectorContainer.java b/src/main/org/apache/tools/ant/types/selectors/AbstractSelectorContainer.java
index 481312e86..999adf301 100644
--- a/src/main/org/apache/tools/ant/types/selectors/AbstractSelectorContainer.java
+++ b/src/main/org/apache/tools/ant/types/selectors/AbstractSelectorContainer.java
@@ -1,355 +1,355 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types.selectors;
 
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.Stack;
 import java.util.Vector;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.DataType;
 import org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector;
 
 /**
  * This is the a base class a container of selectors - it does
  * not need do be a selector itself.
  *
  * @since 1.7
  */
 public abstract class AbstractSelectorContainer extends DataType
     implements Cloneable, SelectorContainer {
 
     private Vector selectorsList = new Vector();
 
     /**
      * Indicates whether there are any selectors here.
      * @return true if there are selectors
      */
     public boolean hasSelectors() {
         if (isReference()) {
             return ((AbstractSelectorContainer) getCheckedRef()).hasSelectors();
         }
         dieOnCircularReference();
         return !(selectorsList.isEmpty());
     }
 
     /**
      * Gives the count of the number of selectors in this container
      * @return the number of selectors
      */
     public int selectorCount() {
         if (isReference()) {
             return ((AbstractSelectorContainer) getCheckedRef()).selectorCount();
         }
         dieOnCircularReference();
         return selectorsList.size();
     }
 
     /**
      * Returns the set of selectors as an array.
      * @param p the current project
      * @return an array of selectors
      */
     public FileSelector[] getSelectors(Project p) {
         if (isReference()) {
             return ((AbstractSelectorContainer) getCheckedRef(p))
                 .getSelectors(p);
         }
         dieOnCircularReference(p);
         FileSelector[] result = new FileSelector[selectorsList.size()];
         selectorsList.copyInto(result);
         return result;
     }
 
     /**
      * Returns an enumerator for accessing the set of selectors.
      * @return an enumerator for the selectors
      */
     public Enumeration selectorElements() {
         if (isReference()) {
             return ((AbstractSelectorContainer) getCheckedRef())
                 .selectorElements();
         }
         dieOnCircularReference();
         return selectorsList.elements();
     }
 
     /**
      * Convert the Selectors within this container to a string. This will
      * just be a helper class for the subclasses that put their own name
      * around the contents listed here.
      *
      * @return comma separated list of Selectors contained in this one
      */
     public String toString() {
         StringBuffer buf = new StringBuffer();
         Enumeration e = selectorElements();
         if (e.hasMoreElements()) {
             while (e.hasMoreElements()) {
                 buf.append(e.nextElement().toString());
                 if (e.hasMoreElements()) {
                     buf.append(", ");
                 }
             }
         }
 
         return buf.toString();
     }
 
     /**
      * Add a new selector into this container.
      *
      * @param selector the new selector to add
      */
     public void appendSelector(FileSelector selector) {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         selectorsList.addElement(selector);
         setChecked(false);
     }
 
     /**
      * <p>
      * This validates each contained selector
      * provided that the selector implements the validate interface.
      * </p>
      * <p>Ordinarily, this will validate all the elements of a selector
      * container even if the isSelected() method of some elements is
      * never called. This has two effects:</p>
      * <ul>
      * <li>Validation will often occur twice.
      * <li>Since it is not required that selectors derive from
      * BaseSelector, there could be selectors in the container whose
      * error conditions are not detected if their isSelected() call
      * is never made.
      * </ul>
      */
     public void validate() {
         if (isReference()) {
             ((AbstractSelectorContainer) getCheckedRef()).validate();
         }
         dieOnCircularReference();
         Enumeration e = selectorElements();
         while (e.hasMoreElements()) {
             Object o = e.nextElement();
             if (o instanceof BaseSelector) {
                 ((BaseSelector) o).validate();
             }
         }
     }
 
 
     /* Methods below all add specific selectors */
 
     /**
      * add a "Select" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addSelector(SelectSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add an "And" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addAnd(AndSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add an "Or" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addOr(OrSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a "Not" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addNot(NotSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a "None" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addNone(NoneSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a majority selector entry on the selector list
      * @param selector the selector to add
      */
     public void addMajority(MajoritySelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a selector date entry on the selector list
      * @param selector the selector to add
      */
     public void addDate(DateSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a selector size entry on the selector list
      * @param selector the selector to add
      */
     public void addSize(SizeSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a selector filename entry on the selector list
      * @param selector the selector to add
      */
     public void addFilename(FilenameSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add an extended selector entry on the selector list
      * @param selector the selector to add
      */
     public void addCustom(ExtendSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a contains selector entry on the selector list
      * @param selector the selector to add
      */
     public void addContains(ContainsSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a present selector entry on the selector list
      * @param selector the selector to add
      */
     public void addPresent(PresentSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a depth selector entry on the selector list
      * @param selector the selector to add
      */
     public void addDepth(DepthSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a depends selector entry on the selector list
      * @param selector the selector to add
      */
     public void addDepend(DependSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * adds a different selector to the selector list
      * @param selector the selector to add
      */
     public void addDifferent(DifferentSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * adds a type selector to the selector list
      * @param selector the selector to add
      */
     public void addType(TypeSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a regular expression selector entry on the selector list
      * @param selector the selector to add
      */
     public void addContainsRegexp(ContainsRegexpSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add the modified selector
      * @param selector the selector to add
      * @since ant 1.6
      */
     public void addModified(ModifiedSelector selector) {
         appendSelector(selector);
     }
 
     public void addReadable(ReadableSelector r) {
         appendSelector(r);
     }
 
     public void addWritable(WritableSelector w) {
         appendSelector(w);
     }
 
     /**
-     * add an arbitary selector
+     * add an arbitrary selector
      * @param selector the selector to add
      * @since Ant 1.6
      */
     public void add(FileSelector selector) {
         appendSelector(selector);
     }
 
     protected synchronized void dieOnCircularReference(Stack stk, Project p) {
         if (isChecked()) {
             return;
         }
         if (isReference()) {
             super.dieOnCircularReference(stk, p);
         } else {
             for (Iterator i = selectorsList.iterator(); i.hasNext(); ) {
                 Object o = i.next();
                 if (o instanceof DataType) {
                     pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);
                 }
             }
             setChecked(true);
         }
     }
 
     public synchronized Object clone() {
         if (isReference()) {
             return ((AbstractSelectorContainer) getCheckedRef()).clone();
         }
         try {
             AbstractSelectorContainer sc =
                 (AbstractSelectorContainer) super.clone();
             sc.selectorsList = new Vector(selectorsList);
             return sc;
         } catch (CloneNotSupportedException e) {
             throw new BuildException(e);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/selectors/BaseSelectorContainer.java b/src/main/org/apache/tools/ant/types/selectors/BaseSelectorContainer.java
index a49455256..6d9d2696b 100644
--- a/src/main/org/apache/tools/ant/types/selectors/BaseSelectorContainer.java
+++ b/src/main/org/apache/tools/ant/types/selectors/BaseSelectorContainer.java
@@ -1,348 +1,348 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types.selectors;
 
 import java.io.File;
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.Stack;
 import java.util.Vector;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.DataType;
 import org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector;
 
 /**
  * This is the base class for selectors that can contain other selectors.
  *
  * @since 1.5
  */
 public abstract class BaseSelectorContainer extends BaseSelector
         implements SelectorContainer {
 
     private Vector selectorsList = new Vector();
 
     /**
      * Default constructor.
      */
     public BaseSelectorContainer() {
     }
 
     /**
      * Indicates whether there are any selectors here.
      * @return true if there are selectors
      */
     public boolean hasSelectors() {
         dieOnCircularReference();
         return !(selectorsList.isEmpty());
     }
 
     /**
      * Gives the count of the number of selectors in this container
      * @return the number of selectors
      */
     public int selectorCount() {
         dieOnCircularReference();
         return selectorsList.size();
     }
 
     /**
      * Returns the set of selectors as an array.
      * @param p the current project
      * @return an array of selectors
      */
     public FileSelector[] getSelectors(Project p) {
         dieOnCircularReference();
         FileSelector[] result = new FileSelector[selectorsList.size()];
         selectorsList.copyInto(result);
         return result;
     }
 
     /**
      * Returns an enumerator for accessing the set of selectors.
      * @return an enumerator for the selectors
      */
     public Enumeration selectorElements() {
         dieOnCircularReference();
         return selectorsList.elements();
     }
 
     /**
      * Convert the Selectors within this container to a string. This will
      * just be a helper class for the subclasses that put their own name
      * around the contents listed here.
      *
      * @return comma separated list of Selectors contained in this one
      */
     public String toString() {
         dieOnCircularReference();
         StringBuffer buf = new StringBuffer();
         Enumeration e = selectorElements();
         if (e.hasMoreElements()) {
             while (e.hasMoreElements()) {
                 buf.append(e.nextElement().toString());
                 if (e.hasMoreElements()) {
                     buf.append(", ");
                 }
             }
         }
 
         return buf.toString();
     }
 
     /**
      * Add a new selector into this container.
      *
      * @param selector the new selector to add
      */
     public void appendSelector(FileSelector selector) {
         selectorsList.addElement(selector);
         setChecked(false);
     }
 
     /**
      * <p>This implementation validates the container by calling
      * verifySettings() and then validates each contained selector
      * provided that the selector implements the validate interface.
      * </p>
      * <p>Ordinarily, this will validate all the elements of a selector
      * container even if the isSelected() method of some elements is
      * never called. This has two effects:</p>
      * <ul>
      * <li>Validation will often occur twice.
      * <li>Since it is not required that selectors derive from
      * BaseSelector, there could be selectors in the container whose
      * error conditions are not detected if their isSelected() call
      * is never made.
      * </ul>
      */
     public void validate() {
         verifySettings();
         dieOnCircularReference();
         String errmsg = getError();
         if (errmsg != null) {
             throw new BuildException(errmsg);
         }
         Enumeration e = selectorElements();
         while (e.hasMoreElements()) {
             Object o = e.nextElement();
             if (o instanceof BaseSelector) {
                 ((BaseSelector) o).validate();
             }
         }
     }
 
 
     /**
      * Method that each selector will implement to create their selection
      * behaviour. This is what makes SelectorContainer abstract.
      *
      * @param basedir the base directory the scan is being done from
      * @param filename the name of the file to check
      * @param file a java.io.File object for the filename that the selector
      * can use
      * @return whether the file should be selected or not
      */
     public abstract boolean isSelected(File basedir, String filename,
                                        File file);
 
 
     /* Methods below all add specific selectors */
 
     /**
      * add a "Select" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addSelector(SelectSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add an "And" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addAnd(AndSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add an "Or" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addOr(OrSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a "Not" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addNot(NotSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a "None" selector entry on the selector list
      * @param selector the selector to add
      */
     public void addNone(NoneSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a majority selector entry on the selector list
      * @param selector the selector to add
      */
     public void addMajority(MajoritySelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a selector date entry on the selector list
      * @param selector the selector to add
      */
     public void addDate(DateSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a selector size entry on the selector list
      * @param selector the selector to add
      */
     public void addSize(SizeSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a selector filename entry on the selector list
      * @param selector the selector to add
      */
     public void addFilename(FilenameSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add an extended selector entry on the selector list
      * @param selector the selector to add
      */
     public void addCustom(ExtendSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a contains selector entry on the selector list
      * @param selector the selector to add
      */
     public void addContains(ContainsSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a present selector entry on the selector list
      * @param selector the selector to add
      */
     public void addPresent(PresentSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a depth selector entry on the selector list
      * @param selector the selector to add
      */
     public void addDepth(DepthSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a depends selector entry on the selector list
      * @param selector the selector to add
      */
     public void addDepend(DependSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * adds a different selector to the selector list
      * @param selector the selector to add
      */
     public void addDifferent(DifferentSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * adds a type selector to the selector list
      * @param selector the selector to add
      */
     public void addType(TypeSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add a regular expression selector entry on the selector list
      * @param selector the selector to add
      */
     public void addContainsRegexp(ContainsRegexpSelector selector) {
         appendSelector(selector);
     }
 
     /**
      * add the modified selector
      * @param selector the selector to add
      * @since ant 1.6
      */
     public void addModified(ModifiedSelector selector) {
         appendSelector(selector);
     }
 
     public void addReadable(ReadableSelector r) {
         appendSelector(r);
     }
 
     public void addWritable(WritableSelector w) {
         appendSelector(w);
     }
 
     /**
-     * add an arbitary selector
+     * add an arbitrary selector
      * @param selector the selector to add
      * @since Ant 1.6
      */
     public void add(FileSelector selector) {
         appendSelector(selector);
     }
 
     protected synchronized void dieOnCircularReference(Stack stk, Project p)
         throws BuildException {
         if (isChecked()) {
             return;
         }
         if (isReference()) {
             super.dieOnCircularReference(stk, p);
         } else {
             for (Iterator i = selectorsList.iterator(); i.hasNext();) {
                 Object o = i.next();
                 if (o instanceof DataType) {
                     pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);
                 }
             }
             setChecked(true);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/selectors/ContainsRegexpSelector.java b/src/main/org/apache/tools/ant/types/selectors/ContainsRegexpSelector.java
index 2d84306b6..987fa4d25 100644
--- a/src/main/org/apache/tools/ant/types/selectors/ContainsRegexpSelector.java
+++ b/src/main/org/apache/tools/ant/types/selectors/ContainsRegexpSelector.java
@@ -1,219 +1,219 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types.selectors;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStreamReader;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.Parameter;
 import org.apache.tools.ant.types.RegularExpression;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
 import org.apache.tools.ant.util.regexp.Regexp;
 import org.apache.tools.ant.util.regexp.RegexpUtil;
 
 /**
  * Selector that filters files based on a regular expression.
  *
  * @since Ant 1.6
  */
 public class ContainsRegexpSelector extends BaseExtendSelector
         implements ResourceSelector {
 
     private String userProvidedExpression = null;
     private RegularExpression myRegExp = null;
     private Regexp myExpression = null;
     private boolean caseSensitive = true;
     private boolean multiLine = false;
     private boolean singleLine = false;
     /** Key to used for parameterized custom selector */
     public static final String EXPRESSION_KEY = "expression";
     /** Parameter name for the casesensitive attribute. */
     private static final String CS_KEY = "casesensitive";
     /** Parameter name for the multiline attribute. */
     private static final String ML_KEY = "multiline";
     /** Parameter name for the singleline attribute. */
     private static final String SL_KEY = "singleline";
 
     /**
      * Creates a new <code>ContainsRegexpSelector</code> instance.
      */
     public ContainsRegexpSelector() {
     }
 
     /**
      * @return a string describing this object
      */
     public String toString() {
         StringBuffer buf = new StringBuffer(
                 "{containsregexpselector expression: ");
         buf.append(userProvidedExpression);
         buf.append("}");
         return buf.toString();
     }
 
     /**
      * The regular expression used to search the file.
      *
      * @param theexpression this must match a line in the file to be selected.
      */
     public void setExpression(String theexpression) {
         this.userProvidedExpression = theexpression;
     }
 
     /**
      * Whether to ignore case or not.
      * @param b if false, ignore case.
      * @since Ant 1.8.2
      */
     public void setCaseSensitive(boolean b) {
         caseSensitive = b;
     }
 
     /**
      * Whether to match should be multiline.
      * @param b the value to set.
      * @since Ant 1.8.2
      */
     public void setMultiLine(boolean b) {
         multiLine = b;
     }
 
     /**
      * Whether to treat input as singleline ('.' matches newline).
-     * Corresponsds to java.util.regex.Pattern.DOTALL.
+     * Corresponds to java.util.regex.Pattern.DOTALL.
      * @param b the value to set.
      * @since Ant 1.8.2
      */
     public void setSingleLine(boolean b) {
         singleLine = b;
     }
 
     /**
      * When using this as a custom selector, this method will be called.
      * It translates each parameter into the appropriate setXXX() call.
      *
      * @param parameters the complete set of parameters for this selector
      */
     public void setParameters(Parameter[] parameters) {
         super.setParameters(parameters);
         if (parameters != null) {
             for (int i = 0; i < parameters.length; i++) {
                 String paramname = parameters[i].getName();
                 if (EXPRESSION_KEY.equalsIgnoreCase(paramname)) {
                     setExpression(parameters[i].getValue());
                 } else if (CS_KEY.equalsIgnoreCase(paramname)) {
                     setCaseSensitive(Project
                                      .toBoolean(parameters[i].getValue()));
                 } else if (ML_KEY.equalsIgnoreCase(paramname)) {
                     setMultiLine(Project.toBoolean(parameters[i].getValue()));
                 } else if (SL_KEY.equalsIgnoreCase(paramname)) {
                     setSingleLine(Project.toBoolean(parameters[i].getValue()));
                 } else {
                     setError("Invalid parameter " + paramname);
                 }
             }
         }
     }
 
     /**
      * Checks that an expression was specified.
      *
      */
     public void verifySettings() {
         if (userProvidedExpression == null) {
             setError("The expression attribute is required");
         }
     }
 
     /**
      * Tests a regular expression against each line of text in the file.
      *
      * @param basedir the base directory the scan is being done from
      * @param filename is the name of the file to check
      * @param file is a java.io.File object the selector can use
      * @return whether the file should be selected or not
      */
     public boolean isSelected(File basedir, String filename, File file) {
         return isSelected(new FileResource(file));
     }
 
     /**
      * Tests a regular expression against each line of text in a Resource.
      *
      * @param r the Resource to check.
      * @return whether the Resource is selected or not
      */
     public boolean isSelected(Resource r) {
         String teststr = null;
         BufferedReader in = null;
 
         // throw BuildException on error
 
         validate();
 
         if (r.isDirectory()) {
             return true;
         }
 
         if (myRegExp == null) {
             myRegExp = new RegularExpression();
             myRegExp.setPattern(userProvidedExpression);
             myExpression = myRegExp.getRegexp(getProject());
         }
 
         try {
             in = new BufferedReader(new InputStreamReader(r.getInputStream()));
         } catch (Exception e) {
             throw new BuildException("Could not get InputStream from "
                     + r.toLongString(), e);
         }
         try {
             teststr = in.readLine();
 
             while (teststr != null) {
 
                 if (myExpression.matches(teststr,
                                          RegexpUtil.asOptions(caseSensitive,
                                                               multiLine,
                                                               singleLine))) {
                     return true;
                 }
                 teststr = in.readLine();
             }
 
             return false;
         } catch (IOException ioe) {
             throw new BuildException("Could not read " + r.toLongString());
         } finally {
             try {
                 in.close();
             } catch (Exception e) {
                 throw new BuildException("Could not close "
                                          + r.toLongString());
             }
         }
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/types/selectors/DifferentSelector.java b/src/main/org/apache/tools/ant/types/selectors/DifferentSelector.java
index c11259dc6..9b979e918 100644
--- a/src/main/org/apache/tools/ant/types/selectors/DifferentSelector.java
+++ b/src/main/org/apache/tools/ant/types/selectors/DifferentSelector.java
@@ -1,114 +1,114 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types.selectors;
 
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.BuildException;
 
 import java.io.File;
 import java.io.IOException;
 
 /**
  * This selector selects files against a mapped set of target files, selecting
  * all those files which are different.
  * Files with different lengths are deemed different
  * automatically
  * Files with identical timestamps are viewed as matching by
  * default, unless you specify otherwise.
  * Contents are compared if the lengths are the same
  * and the timestamps are ignored or the same,
  * except if you decide to ignore contents to gain speed.
  * <p>
  * This is a useful selector to work with programs and tasks that don't handle
  * dependency checking properly; Even if a predecessor task always creates its
  * output files, followup tasks can be driven off copies made with a different
  * selector, so their dependencies are driven on the absolute state of the
  * files, not a timestamp.
  * <p>
  * Clearly, however, bulk file comparisons is inefficient; anything that can
  * use timestamps is to be preferred. If this selector must be used, use it
  * over as few files as possible, perhaps following it with an &lt;uptodate;&gt
- * to keep the descendent routines conditional.
+ * to keep the descendant routines conditional.
  *
  */
 public class DifferentSelector extends MappingSelector {
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     private boolean ignoreFileTimes = true;
     private boolean ignoreContents = false;
 
 
     /**
      * This flag tells the selector to ignore file times in the comparison
      * @param ignoreFileTimes if true ignore file times
      */
     public void setIgnoreFileTimes(boolean ignoreFileTimes) {
         this.ignoreFileTimes = ignoreFileTimes;
     }
     /**
      * This flag tells the selector to ignore contents
      * @param ignoreContents if true ignore contents
      * @since ant 1.6.3
      */
     public void setIgnoreContents(boolean ignoreContents) {
         this.ignoreContents = ignoreContents;
     }
     /**
      * this test is our selection test that compared the file with the destfile
      * @param srcfile the source file
      * @param destfile the destination file
      * @return true if the files are different
      */
     protected boolean selectionTest(File srcfile, File destfile) {
 
         //if either of them is missing, they are different
         if (srcfile.exists() != destfile.exists()) {
             return true;
         }
 
         if (srcfile.length() != destfile.length()) {
             // different size =>different files
             return true;
         }
 
         if (!ignoreFileTimes) {
             //same date if dest timestamp is within granularity of the srcfile
             boolean sameDate;
             sameDate = destfile.lastModified() >= srcfile.lastModified() - granularity
                     && destfile.lastModified() <= srcfile.lastModified() + granularity;
 
             // different dates => different files
             if (!sameDate) {
                 return true;
             }
         }
         if (!ignoreContents) {
             //here do a bulk comparison
             try {
                 return !FILE_UTILS.contentEquals(srcfile, destfile);
             } catch (IOException e) {
                 throw new BuildException("while comparing " + srcfile + " and "
                         + destfile, e);
             }
         } else {
             return false;
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/selectors/ReadableSelector.java b/src/main/org/apache/tools/ant/types/selectors/ReadableSelector.java
index 5332b12dc..f4ee5bae0 100644
--- a/src/main/org/apache/tools/ant/types/selectors/ReadableSelector.java
+++ b/src/main/org/apache/tools/ant/types/selectors/ReadableSelector.java
@@ -1,48 +1,48 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types.selectors;
 
 import java.io.File;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
 
 /**
  * A selector that selects readable files.
  *
- * <p>Readable is definied in terms of java.io.File#canRead, this
+ * <p>Readable is defined in terms of java.io.File#canRead, this
  * means the selector will accept any file that exists and is readable
  * by the application.</p>
  *
  * @since Ant 1.8.0
  */
 public class ReadableSelector implements FileSelector, ResourceSelector {
 
     public boolean isSelected(File basedir, String filename, File file) {
         return file != null && file.canRead();
     }
 
     public boolean isSelected(Resource r) {
         FileProvider fp = r.as(FileProvider.class);
         if (fp != null) {
             return isSelected(null, null, fp.getFile());
         }
         return false;
     }
 }
\ No newline at end of file
diff --git a/src/main/org/apache/tools/ant/types/selectors/SelectorContainer.java b/src/main/org/apache/tools/ant/types/selectors/SelectorContainer.java
index 432a36475..1d11cf5bc 100644
--- a/src/main/org/apache/tools/ant/types/selectors/SelectorContainer.java
+++ b/src/main/org/apache/tools/ant/types/selectors/SelectorContainer.java
@@ -1,186 +1,186 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types.selectors;
 
 import java.util.Enumeration;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector;
 
 /**
  * This is the interface for selectors that can contain other selectors.
  *
  * @since 1.5
  */
 public interface SelectorContainer {
 
     /**
      * Indicates whether there are any selectors here.
      *
      * @return whether any selectors are in this container
      */
     boolean hasSelectors();
 
     /**
      * Gives the count of the number of selectors in this container
      *
      * @return the number of selectors in this container
      */
     int selectorCount();
 
     /**
      * Returns the set of selectors as an array.
      * @param p the current project
      * @return an array of selectors in this container
      */
     FileSelector[] getSelectors(Project p);
 
     /**
      * Returns an enumerator for accessing the set of selectors.
      *
      * @return an enumerator that goes through each of the selectors
      */
     Enumeration selectorElements();
 
     /**
      * Add a new selector into this container.
      *
      * @param selector the new selector to add
      */
     void appendSelector(FileSelector selector);
 
     /* Methods below all add specific selectors */
 
     /**
      * add a "Select" selector entry on the selector list
      * @param selector the selector to add
      */
     void addSelector(SelectSelector selector);
 
     /**
      * add an "And" selector entry on the selector list
      * @param selector the selector to add
      */
     void addAnd(AndSelector selector);
 
     /**
      * add an "Or" selector entry on the selector list
      * @param selector the selector to add
      */
     void addOr(OrSelector selector);
 
     /**
      * add a "Not" selector entry on the selector list
      * @param selector the selector to add
      */
     void addNot(NotSelector selector);
 
     /**
      * add a "None" selector entry on the selector list
      * @param selector the selector to add
      */
     void addNone(NoneSelector selector);
 
     /**
      * add a majority selector entry on the selector list
      * @param selector the selector to add
      */
     void addMajority(MajoritySelector selector);
 
     /**
      * add a selector date entry on the selector list
      * @param selector the selector to add
      */
     void addDate(DateSelector selector);
 
     /**
      * add a selector size entry on the selector list
      * @param selector the selector to add
      */
     void addSize(SizeSelector selector);
 
     /**
      * add a selector filename entry on the selector list
      * @param selector the selector to add
      */
     void addFilename(FilenameSelector selector);
 
     /**
      * add an extended selector entry on the selector list
      * @param selector the selector to add
      */
     void addCustom(ExtendSelector selector);
 
     /**
      * add a contains selector entry on the selector list
      * @param selector the selector to add
      */
     void addContains(ContainsSelector selector);
 
     /**
      * add a present selector entry on the selector list
      * @param selector the selector to add
      */
     void addPresent(PresentSelector selector);
 
     /**
      * add a depth selector entry on the selector list
      * @param selector the selector to add
      */
     void addDepth(DepthSelector selector);
 
     /**
      * add a depends selector entry on the selector list
      * @param selector the selector to add
      */
     void addDepend(DependSelector selector);
 
     /**
      * add a regular expression selector entry on the selector list
      * @param selector the selector to add
      */
     void addContainsRegexp(ContainsRegexpSelector selector);
 
     /**
      * add the type selector
      * @param selector the selector to add
      * @since ant 1.6
      */
     void addType(TypeSelector selector);
 
     /**
      * add the different selector
      * @param selector the selector to add
      * @since ant 1.6
      */
     void addDifferent(DifferentSelector selector);
 
     /**
      * add the modified selector
      * @param selector the selector to add
      * @since ant 1.6
      */
     void addModified(ModifiedSelector selector);
 
     /**
-     * add an arbitary selector
+     * add an arbitrary selector
      * @param selector the selector to add
      * @since Ant 1.6
      */
     void add(FileSelector selector);
 }
diff --git a/src/main/org/apache/tools/ant/types/selectors/SelectorScanner.java b/src/main/org/apache/tools/ant/types/selectors/SelectorScanner.java
index 718dbc2d4..df9f8a40d 100644
--- a/src/main/org/apache/tools/ant/types/selectors/SelectorScanner.java
+++ b/src/main/org/apache/tools/ant/types/selectors/SelectorScanner.java
@@ -1,49 +1,49 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types.selectors;
 
 /**
  * An interface used to describe the actions required by any type of
- * directory scanner that supports Selecters.
+ * directory scanner that supports Selectors.
  *
  * @since 1.5
  */
 public interface SelectorScanner {
     /**
      * Sets the selectors the scanner should use.
      *
      * @param selectors the list of selectors
      */
     void setSelectors(FileSelector[] selectors);
 
     /**
      * Directories which were selected out of a scan.
      *
      * @return list of directories not selected
      */
     String[] getDeselectedDirectories();
 
     /**
      * Files which were selected out of a scan.
      *
      * @return list of files not selected
      */
     String[] getDeselectedFiles();
 
 
 }
diff --git a/src/main/org/apache/tools/ant/types/selectors/SelectorUtils.java b/src/main/org/apache/tools/ant/types/selectors/SelectorUtils.java
index 5f2917efe..34e23ed1f 100644
--- a/src/main/org/apache/tools/ant/types/selectors/SelectorUtils.java
+++ b/src/main/org/apache/tools/ant/types/selectors/SelectorUtils.java
@@ -1,695 +1,695 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types.selectors;
 
 import java.io.File;
 import java.util.StringTokenizer;
 import java.util.Vector;
 
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * <p>This is a utility class used by selectors and DirectoryScanner. The
  * functionality more properly belongs just to selectors, but unfortunately
  * DirectoryScanner exposed these as protected methods. Thus we have to
  * support any subclasses of DirectoryScanner that may access these methods.
  * </p>
  * <p>This is a Singleton.</p>
  *
  * @since 1.5
  */
 public final class SelectorUtils {
 
     /**
      * The pattern that matches an arbitrary number of directories.
      * @since Ant 1.8.0
      */
     public static final String DEEP_TREE_MATCH = "**";
 
     private static final SelectorUtils instance = new SelectorUtils();
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Private Constructor
      */
     private SelectorUtils() {
     }
 
     /**
      * Retrieves the instance of the Singleton.
      * @return singleton instance
      */
     public static SelectorUtils getInstance() {
         return instance;
     }
 
     /**
      * Tests whether or not a given path matches the start of a given
      * pattern up to the first "**".
      * <p>
      * This is not a general purpose test and should only be used if you
      * can live with false positives. For example, <code>pattern=**\a</code>
      * and <code>str=b</code> will yield <code>true</code>.
      *
      * @param pattern The pattern to match against. Must not be
      *                <code>null</code>.
      * @param str     The path to match, as a String. Must not be
      *                <code>null</code>.
      *
      * @return whether or not a given path matches the start of a given
      * pattern up to the first "**".
      */
     public static boolean matchPatternStart(String pattern, String str) {
         return matchPatternStart(pattern, str, true);
     }
 
     /**
      * Tests whether or not a given path matches the start of a given
      * pattern up to the first "**".
      * <p>
      * This is not a general purpose test and should only be used if you
      * can live with false positives. For example, <code>pattern=**\a</code>
      * and <code>str=b</code> will yield <code>true</code>.
      *
      * @param pattern The pattern to match against. Must not be
      *                <code>null</code>.
      * @param str     The path to match, as a String. Must not be
      *                <code>null</code>.
      * @param isCaseSensitive Whether or not matching should be performed
      *                        case sensitively.
      *
      * @return whether or not a given path matches the start of a given
      * pattern up to the first "**".
      */
     public static boolean matchPatternStart(String pattern, String str,
                                             boolean isCaseSensitive) {
         // When str starts with a File.separator, pattern has to start with a
         // File.separator.
         // When pattern starts with a File.separator, str has to start with a
         // File.separator.
         if (str.startsWith(File.separator)
                 != pattern.startsWith(File.separator)) {
             return false;
         }
 
         String[] patDirs = tokenizePathAsArray(pattern);
         String[] strDirs = tokenizePathAsArray(str);
         return matchPatternStart(patDirs, strDirs, isCaseSensitive);
     }
 
 
     /**
      * Tests whether or not a given path matches the start of a given
      * pattern up to the first "**".
      * <p>
      * This is not a general purpose test and should only be used if you
      * can live with false positives. For example, <code>pattern=**\a</code>
      * and <code>str=b</code> will yield <code>true</code>.
      *
      * @param patDirs The tokenized pattern to match against. Must not be
      *                <code>null</code>.
      * @param strDirs The tokenized path to match. Must not be
      *                <code>null</code>.
      * @param isCaseSensitive Whether or not matching should be performed
      *                        case sensitively.
      *
      * @return whether or not a given path matches the start of a given
      * pattern up to the first "**".
      */
     static boolean matchPatternStart(String[] patDirs, String[] strDirs,
                                      boolean isCaseSensitive) {
         int patIdxStart = 0;
         int patIdxEnd = patDirs.length - 1;
         int strIdxStart = 0;
         int strIdxEnd = strDirs.length - 1;
 
         // up to first '**'
         while (patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd) {
             String patDir = patDirs[patIdxStart];
             if (patDir.equals(DEEP_TREE_MATCH)) {
                 break;
             }
             if (!match(patDir, strDirs[strIdxStart], isCaseSensitive)) {
                 return false;
             }
             patIdxStart++;
             strIdxStart++;
         }
 
         // CheckStyle:SimplifyBooleanReturnCheck OFF
         // Check turned off as the code needs the comments for the various
         // code paths.
         if (strIdxStart > strIdxEnd) {
             // String is exhausted
             return true;
         } else if (patIdxStart > patIdxEnd) {
             // String not exhausted, but pattern is. Failure.
             return false;
         } else {
             // pattern now holds ** while string is not exhausted
             // this will generate false positives but we can live with that.
             return true;
         }
     }
 
     /**
      * Tests whether or not a given path matches a given pattern.
      *
      * If you need to call this method multiple times with the same 
      * pattern you should rather use TokenizedPath
      *
      * @see TokenizedPath
      * 
      * @param pattern The pattern to match against. Must not be
      *                <code>null</code>.
      * @param str     The path to match, as a String. Must not be
      *                <code>null</code>.
      *
      * @return <code>true</code> if the pattern matches against the string,
      *         or <code>false</code> otherwise.
      */
     public static boolean matchPath(String pattern, String str) {
         String[] patDirs = tokenizePathAsArray(pattern);
         return matchPath(patDirs, tokenizePathAsArray(str), true);
     }
 
     /**
      * Tests whether or not a given path matches a given pattern.
      * 
      * If you need to call this method multiple times with the same 
      * pattern you should rather use TokenizedPattern
      *
      * @see TokenizedPattern
      * 
      * @param pattern The pattern to match against. Must not be
      *                <code>null</code>.
      * @param str     The path to match, as a String. Must not be
      *                <code>null</code>.
      * @param isCaseSensitive Whether or not matching should be performed
      *                        case sensitively.
      *
      * @return <code>true</code> if the pattern matches against the string,
      *         or <code>false</code> otherwise.
      */
     public static boolean matchPath(String pattern, String str,
                                     boolean isCaseSensitive) {
         String[] patDirs = tokenizePathAsArray(pattern);
         return matchPath(patDirs, tokenizePathAsArray(str), isCaseSensitive);
     }
 
     /**
      * Core implementation of matchPath.  It is isolated so that it
      * can be called from TokenizedPattern.
      */
     static boolean matchPath(String[] tokenizedPattern, String[] strDirs,
                              boolean isCaseSensitive) {
         int patIdxStart = 0;
         int patIdxEnd = tokenizedPattern.length - 1;
         int strIdxStart = 0;
         int strIdxEnd = strDirs.length - 1;
 
         // up to first '**'
         while (patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd) {
             String patDir = tokenizedPattern[patIdxStart];
             if (patDir.equals(DEEP_TREE_MATCH)) {
                 break;
             }
             if (!match(patDir, strDirs[strIdxStart], isCaseSensitive)) {
                 return false;
             }
             patIdxStart++;
             strIdxStart++;
         }
         if (strIdxStart > strIdxEnd) {
             // String is exhausted
             for (int i = patIdxStart; i <= patIdxEnd; i++) {
                 if (!tokenizedPattern[i].equals(DEEP_TREE_MATCH)) {
                     return false;
                 }
             }
             return true;
         } else {
             if (patIdxStart > patIdxEnd) {
                 // String not exhausted, but pattern is. Failure.
                 return false;
             }
         }
 
         // up to last '**'
         while (patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd) {
             String patDir = tokenizedPattern[patIdxEnd];
             if (patDir.equals(DEEP_TREE_MATCH)) {
                 break;
             }
             if (!match(patDir, strDirs[strIdxEnd], isCaseSensitive)) {
                 return false;
             }
             patIdxEnd--;
             strIdxEnd--;
         }
         if (strIdxStart > strIdxEnd) {
             // String is exhausted
             for (int i = patIdxStart; i <= patIdxEnd; i++) {
                 if (!tokenizedPattern[i].equals(DEEP_TREE_MATCH)) {
                     return false;
                 }
             }
             return true;
         }
 
         while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {
             int patIdxTmp = -1;
             for (int i = patIdxStart + 1; i <= patIdxEnd; i++) {
                 if (tokenizedPattern[i].equals(DEEP_TREE_MATCH)) {
                     patIdxTmp = i;
                     break;
                 }
             }
             if (patIdxTmp == patIdxStart + 1) {
                 // '**/**' situation, so skip one
                 patIdxStart++;
                 continue;
             }
             // Find the pattern between padIdxStart & padIdxTmp in str between
             // strIdxStart & strIdxEnd
             int patLength = (patIdxTmp - patIdxStart - 1);
             int strLength = (strIdxEnd - strIdxStart + 1);
             int foundIdx = -1;
             strLoop:
                         for (int i = 0; i <= strLength - patLength; i++) {
                             for (int j = 0; j < patLength; j++) {
                                 String subPat = tokenizedPattern[patIdxStart + j + 1];
                                 String subStr = strDirs[strIdxStart + i + j];
                                 if (!match(subPat, subStr, isCaseSensitive)) {
                                     continue strLoop;
                                 }
                             }
 
                             foundIdx = strIdxStart + i;
                             break;
                         }
 
             if (foundIdx == -1) {
                 return false;
             }
 
             patIdxStart = patIdxTmp;
             strIdxStart = foundIdx + patLength;
         }
 
         for (int i = patIdxStart; i <= patIdxEnd; i++) {
             if (!tokenizedPattern[i].equals(DEEP_TREE_MATCH)) {
                 return false;
             }
         }
 
         return true;
     }
 
     /**
      * Tests whether or not a string matches against a pattern.
      * The pattern may contain two special characters:<br>
      * '*' means zero or more characters<br>
      * '?' means one and only one character
      *
      * @param pattern The pattern to match against.
      *                Must not be <code>null</code>.
      * @param str     The string which must be matched against the pattern.
      *                Must not be <code>null</code>.
      *
      * @return <code>true</code> if the string matches against the pattern,
      *         or <code>false</code> otherwise.
      */
     public static boolean match(String pattern, String str) {
         return match(pattern, str, true);
     }
 
     /**
      * Tests whether or not a string matches against a pattern.
      * The pattern may contain two special characters:<br>
      * '*' means zero or more characters<br>
      * '?' means one and only one character
      *
      * @param pattern The pattern to match against.
      *                Must not be <code>null</code>.
      * @param str     The string which must be matched against the pattern.
      *                Must not be <code>null</code>.
      * @param caseSensitive Whether or not matching should be performed
      *                        case sensitively.
      *
      *
      * @return <code>true</code> if the string matches against the pattern,
      *         or <code>false</code> otherwise.
      */
     public static boolean match(String pattern, String str,
                                 boolean caseSensitive) {
         char[] patArr = pattern.toCharArray();
         char[] strArr = str.toCharArray();
         int patIdxStart = 0;
         int patIdxEnd = patArr.length - 1;
         int strIdxStart = 0;
         int strIdxEnd = strArr.length - 1;
         char ch;
 
         boolean containsStar = false;
         for (int i = 0; i < patArr.length; i++) {
             if (patArr[i] == '*') {
                 containsStar = true;
                 break;
             }
         }
 
         if (!containsStar) {
             // No '*'s, so we make a shortcut
             if (patIdxEnd != strIdxEnd) {
                 return false; // Pattern and string do not have the same size
             }
             for (int i = 0; i <= patIdxEnd; i++) {
                 ch = patArr[i];
                 if (ch != '?') {
                     if (different(caseSensitive, ch, strArr[i])) {
                         return false; // Character mismatch
                     }
                 }
             }
             return true; // String matches against pattern
         }
 
         if (patIdxEnd == 0) {
             return true; // Pattern contains only '*', which matches anything
         }
 
         // Process characters before first star
         while (true) {
             ch = patArr[patIdxStart];
             if (ch == '*' || strIdxStart > strIdxEnd) {
                 break;
             }
             if (ch != '?') {
                 if (different(caseSensitive, ch, strArr[strIdxStart])) {
                     return false; // Character mismatch
                 }
             }
             patIdxStart++;
             strIdxStart++;
         }
         if (strIdxStart > strIdxEnd) {
             // All characters in the string are used. Check if only '*'s are
             // left in the pattern. If so, we succeeded. Otherwise failure.
             return allStars(patArr, patIdxStart, patIdxEnd);
         }
 
         // Process characters after last star
         while (true) {
             ch = patArr[patIdxEnd];
             if (ch == '*' || strIdxStart > strIdxEnd) {
                 break;
             }
             if (ch != '?') {
                 if (different(caseSensitive, ch, strArr[strIdxEnd])) {
                     return false; // Character mismatch
                 }
             }
             patIdxEnd--;
             strIdxEnd--;
         }
         if (strIdxStart > strIdxEnd) {
             // All characters in the string are used. Check if only '*'s are
             // left in the pattern. If so, we succeeded. Otherwise failure.
             return allStars(patArr, patIdxStart, patIdxEnd);
         }
 
         // process pattern between stars. padIdxStart and patIdxEnd point
         // always to a '*'.
         while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {
             int patIdxTmp = -1;
             for (int i = patIdxStart + 1; i <= patIdxEnd; i++) {
                 if (patArr[i] == '*') {
                     patIdxTmp = i;
                     break;
                 }
             }
             if (patIdxTmp == patIdxStart + 1) {
                 // Two stars next to each other, skip the first one.
                 patIdxStart++;
                 continue;
             }
             // Find the pattern between padIdxStart & padIdxTmp in str between
             // strIdxStart & strIdxEnd
             int patLength = (patIdxTmp - patIdxStart - 1);
             int strLength = (strIdxEnd - strIdxStart + 1);
             int foundIdx = -1;
             strLoop:
             for (int i = 0; i <= strLength - patLength; i++) {
                 for (int j = 0; j < patLength; j++) {
                     ch = patArr[patIdxStart + j + 1];
                     if (ch != '?') {
                         if (different(caseSensitive, ch,
                                       strArr[strIdxStart + i + j])) {
                             continue strLoop;
                         }
                     }
                 }
 
                 foundIdx = strIdxStart + i;
                 break;
             }
 
             if (foundIdx == -1) {
                 return false;
             }
 
             patIdxStart = patIdxTmp;
             strIdxStart = foundIdx + patLength;
         }
 
         // All characters in the string are used. Check if only '*'s are left
         // in the pattern. If so, we succeeded. Otherwise failure.
         return allStars(patArr, patIdxStart, patIdxEnd);
     }
 
     private static boolean allStars(char[] chars, int start, int end) {
         for (int i = start; i <= end; ++i) {
             if (chars[i] != '*') {
                 return false;
             }
         }
         return true;
     }
 
     private static boolean different(
         boolean caseSensitive, char ch, char other) {
         return caseSensitive
             ? ch != other
             : Character.toUpperCase(ch) != Character.toUpperCase(other);
     }
 
     /**
      * Breaks a path up into a Vector of path elements, tokenizing on
      * <code>File.separator</code>.
      *
      * @param path Path to tokenize. Must not be <code>null</code>.
      *
      * @return a Vector of path elements from the tokenized path
      */
     public static Vector tokenizePath (String path) {
         return tokenizePath(path, File.separator);
     }
 
     /**
      * Breaks a path up into a Vector of path elements, tokenizing on
      *
      * @param path Path to tokenize. Must not be <code>null</code>.
      * @param separator the separator against which to tokenize.
      *
      * @return a Vector of path elements from the tokenized path
      * @since Ant 1.6
      */
     public static Vector tokenizePath (String path, String separator) {
         Vector ret = new Vector();
         if (FileUtils.isAbsolutePath(path)) {
             String[] s = FILE_UTILS.dissect(path);
             ret.add(s[0]);
             path = s[1];
         }
         StringTokenizer st = new StringTokenizer(path, separator);
         while (st.hasMoreTokens()) {
             ret.addElement(st.nextToken());
         }
         return ret;
     }
 
     /**
      * Same as {@link #tokenizePath tokenizePath} but hopefully faster.
      */
     /*package*/ static String[] tokenizePathAsArray(String path) {
         String root = null;
         if (FileUtils.isAbsolutePath(path)) {
             String[] s = FILE_UTILS.dissect(path);
             root = s[0];
             path = s[1];
         }
         char sep = File.separatorChar;
         int start = 0;
         int len = path.length();
         int count = 0;
         for (int pos = 0; pos < len; pos++) {
             if (path.charAt(pos) == sep) {
                 if (pos != start) {
                     count++;
                 }
                 start = pos + 1;
             }
         }
         if (len != start) {
             count++;
         }
         String[] l = new String[count + ((root == null) ? 0 : 1)];
 
         if (root != null) {
             l[0] = root;
             count = 1;
         } else {
             count = 0;
         }
         start = 0;
         for (int pos = 0; pos < len; pos++) {
             if (path.charAt(pos) == sep) {
                 if (pos != start) {
                     String tok = path.substring(start, pos);
                     l[count++] = tok;
                 }
                 start = pos + 1;
             }
         }
         if (len != start) {
             String tok = path.substring(start);
             l[count/*++*/] = tok;
         }
         return l;
     }
 
     /**
      * Returns dependency information on these two files. If src has been
      * modified later than target, it returns true. If target doesn't exist,
      * it likewise returns true. Otherwise, target is newer than src and
      * is not out of date, thus the method returns false. It also returns
      * false if the src file doesn't even exist, since how could the
      * target then be out of date.
      *
      * @param src the original file
      * @param target the file being compared against
      * @param granularity the amount in seconds of slack we will give in
      *        determining out of dateness
      * @return whether the target is out of date
      */
     public static boolean isOutOfDate(File src, File target, int granularity) {
         if (!src.exists()) {
             return false;
         }
         if (!target.exists()) {
             return true;
         }
         if ((src.lastModified() - granularity) > target.lastModified()) {
             return true;
         }
         return false;
     }
 
     /**
      * Returns dependency information on these two resources. If src has been
      * modified later than target, it returns true. If target doesn't exist,
      * it likewise returns true. Otherwise, target is newer than src and
      * is not out of date, thus the method returns false. It also returns
      * false if the src file doesn't even exist, since how could the
      * target then be out of date.
      *
      * @param src the original resource
      * @param target the resource being compared against
      * @param granularity the int amount in seconds of slack we will give in
      *        determining out of dateness
      * @return whether the target is out of date
      */
     public static boolean isOutOfDate(Resource src, Resource target,
                                       int granularity) {
         return isOutOfDate(src, target, (long) granularity);
     }
 
     /**
      * Returns dependency information on these two resources. If src has been
      * modified later than target, it returns true. If target doesn't exist,
      * it likewise returns true. Otherwise, target is newer than src and
      * is not out of date, thus the method returns false. It also returns
      * false if the src file doesn't even exist, since how could the
      * target then be out of date.
      *
      * @param src the original resource
      * @param target the resource being compared against
      * @param granularity the long amount in seconds of slack we will give in
      *        determining out of dateness
      * @return whether the target is out of date
      */
     public static boolean isOutOfDate(Resource src, Resource target, long granularity) {
         long sourceLastModified = src.getLastModified();
         long targetLastModified = target.getLastModified();
         return src.isExists()
                 && (sourceLastModified == Resource.UNKNOWN_DATETIME
                         || targetLastModified == Resource.UNKNOWN_DATETIME
                                 || (sourceLastModified - granularity) > targetLastModified);
     }
 
     /**
      * "Flattens" a string by removing all whitespace (space, tab, linefeed,
      * carriage return, and formfeed). This uses StringTokenizer and the
-     * default set of tokens as documented in the single arguement constructor.
+     * default set of tokens as documented in the single argument constructor.
      *
      * @param input a String to remove all whitespace.
      * @return a String that has had all whitespace removed.
      */
     public static String removeWhitespace(String input) {
         StringBuffer result = new StringBuffer();
         if (input != null) {
             StringTokenizer st = new StringTokenizer(input);
             while (st.hasMoreTokens()) {
                 result.append(st.nextToken());
             }
         }
         return result.toString();
     }
 
     /**
      * Tests if a string contains stars or question marks
      * @param input a String which one wants to test for containing wildcard
      * @return true if the string contains at least a star or a question mark
      */
     public static boolean hasWildcards(String input) {
         return (input.indexOf('*') != -1 || input.indexOf('?') != -1);
     }
 
     /**
      * removes from a pattern all tokens to the right containing wildcards
      * @param input the input string
      * @return the leftmost part of the pattern without wildcards
      */
     public static String rtrimWildcardTokens(String input) {
         return new TokenizedPattern(input).rtrimWildcardTokens().toString();
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/types/selectors/modifiedselector/ModifiedSelector.java b/src/main/org/apache/tools/ant/types/selectors/modifiedselector/ModifiedSelector.java
index c4d230760..0002786a3 100644
--- a/src/main/org/apache/tools/ant/types/selectors/modifiedselector/ModifiedSelector.java
+++ b/src/main/org/apache/tools/ant/types/selectors/modifiedselector/ModifiedSelector.java
@@ -1,973 +1,973 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types.selectors.modifiedselector;
 
 
 // Java
 import java.io.File;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.Vector;
 
 // Ant
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.IntrospectionHelper;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.BuildListener;
 import org.apache.tools.ant.BuildEvent;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.Parameter;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
 import org.apache.tools.ant.types.selectors.BaseExtendSelector;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.ResourceUtils;
 
 
 /**
  * <p>Selector class that uses <i>Algorithm</i>, <i>Cache</i> and <i>Comparator</i>
  * for its work.
  * The <i>Algorithm</i> is used for computing a hashvalue for a file.
  * The <i>Comparator</i> decides whether to select or not.
  * The <i>Cache</i> stores the other value for comparison by the <i>Comparator</i>
  * in a persistent manner.</p>
  *
  * <p>The ModifiedSelector is implemented as a <b>CoreSelector</b> and uses default
- * values for all its attributes therefore the simpliest example is <pre>
+ * values for all its attributes therefore the simplest example is <pre>
  *   &lt;copy todir="dest"&gt;
  *       &lt;filelist dir="src"&gt;
  *           &lt;modified/&gt;
  *       &lt;/filelist&gt;
  *   &lt;/copy&gt;
  * </pre></p>
  *
  * <p>The same example rewritten as CoreSelector with setting the all values
  * (same as defaults are) would be <pre>
  *   &lt;copy todir="dest"&gt;
  *       &lt;filelist dir="src"&gt;
  *           &lt;modified update="true"
  *                     cache="propertyfile"
  *                     algorithm="digest"
  *                     comparator="equal"&gt;
  *               &lt;param name="cache.cachefile"     value="cache.properties"/&gt;
  *               &lt;param name="algorithm.algorithm" value="MD5"/&gt;
  *           &lt;/modified&gt;
  *       &lt;/filelist&gt;
  *   &lt;/copy&gt;
  * </pre></p>
  *
  * <p>And the same rewritten as CustomSelector would be<pre>
  *   &lt;copy todir="dest"&gt;
  *       &lt;filelist dir="src"&gt;
  *           &lt;custom class="org.apache.tools.ant.type.selectors.ModifiedSelector"&gt;
  *               &lt;param name="update"     value="true"/&gt;
  *               &lt;param name="cache"      value="propertyfile"/&gt;
  *               &lt;param name="algorithm"  value="digest"/&gt;
  *               &lt;param name="comparator" value="equal"/&gt;
  *               &lt;param name="cache.cachefile"     value="cache.properties"/&gt;
  *               &lt;param name="algorithm.algorithm" value="MD5"/&gt;
  *           &lt;/custom&gt;
  *       &lt;/filelist&gt;
  *   &lt;/copy&gt;
  * </pre></p>
  *
  * <p>If you want to provide your own interface implementation you can do
  * that via the *classname attributes. If the classes are not on Ant's core
  * classpath, you will have to provide the path via nested &lt;classpath&gt;
  * element, so that the selector can find the classes. <pre>
  *   &lt;modified cacheclassname="com.mycompany.MyCache"&gt;
  *       &lt;classpath&gt;
- *           &lt;pathelement location="lib/mycompony-antutil.jar"/&gt;
+ *           &lt;pathelement location="lib/mycompany-antutil.jar"/&gt;
  *       &lt;/classpath&gt;
  *   &lt;/modified&gt;
  * </pre></p>
  *
  * <p>All these three examples copy the files from <i>src</i> to <i>dest</i>
  * using the ModifiedSelector. The ModifiedSelector uses the <i>PropertyfileCache
  * </i>, the <i>DigestAlgorithm</i> and the <i>EqualComparator</i> for its
  * work. The PropertyfileCache stores key-value-pairs in a simple java
  * properties file. The filename is <i>cache.properties</i>. The <i>update</i>
  * flag lets the selector update the values in the cache (and on first call
  * creates the cache). The <i>DigestAlgorithm</i> computes a hashvalue using the
  * java.security.MessageDigest class with its MD5-Algorithm and its standard
  * provider. The new computed hashvalue and the stored one are compared by
  * the <i>EqualComparator</i> which returns 'true' (more correct a value not
  * equals zero (1)) if the values are not the same using simple String
  * comparison.</p>
  *
  * <p>A useful scenario for this selector is inside a build environment
  * for homepage generation (e.g. with <a href="http://forrest.apache.org/">
  * Apache Forrest</a>). <pre>
  * &lt;target name="generate-and-upload-site"&gt;
  *     &lt;echo&gt; generate the site using forrest &lt;/echo&gt;
  *     &lt;antcall target="site"/&gt;
  *
  *     &lt;echo&gt; upload the changed files &lt;/echo&gt;
  *     &lt;ftp server="${ftp.server}" userid="${ftp.user}" password="${ftp.pwd}"&gt;
  *         &lt;fileset dir="htdocs/manual"&gt;
  *             &lt;modified/&gt;
  *         &lt;/fileset&gt;
  *     &lt;/ftp&gt;
  * &lt;/target&gt;
  * </pre> Here all <b>changed</b> files are uploaded to the server. The
  * ModifiedSelector saves therefore much upload time.</p>
  *
  *
  * <p>This selector uses reflection for setting the values of its three interfaces
  * (using org.apache.tools.ant.IntrospectionHelper) therefore no special
  * 'configuration interfaces' has to be implemented by new caches, algorithms or
  * comparators. All present <i>set</i>XX methods can be used. E.g. the DigestAlgorithm
  * can use a specified provider for computing its value. For selecting this
  * there is a <i>setProvider(String providername)</i> method. So you can use
  * a nested <i>&lt;param name="algorithm.provider" value="MyProvider"/&gt;</i>.
  *
  *
  * @since  Ant 1.6
  */
 public class ModifiedSelector extends BaseExtendSelector
                               implements BuildListener, ResourceSelector {
 
     private static final String CACHE_PREFIX = "cache.";
     private static final String ALGORITHM_PREFIX = "algorithm.";
     private static final String COMPARATOR_PREFIX = "comparator.";
 
 
     // -----  attributes  -----
 
 
     /** Cache name for later instantiation. */
     private CacheName cacheName = null;
 
     /** User specified classname for Cache. */
     private String cacheClass;
 
     /** Algorithm name for later instantiation. */
     private AlgorithmName algoName = null;
 
     /** User specified classname for Algorithm. */
     private String algorithmClass;
 
     /** Comparator name for later instantiation. */
     private ComparatorName compName = null;
 
     /** User specified classname for Comparator. */
     private String comparatorClass;
 
     /** Should the cache be updated? */
     private boolean update = true;
 
     /** Are directories selected? */
     private boolean selectDirectories = true;
 
     /**
      * Should Resources whithout an InputStream, and
      * therefore without checking, be selected?
      */
     private boolean selectResourcesWithoutInputStream = true;
 
     /** Delay the writing of the cache file */
     private boolean delayUpdate = true;
 
 
     // ----- internal member variables -----
 
 
     /** How should the cached value and the new one compared? */
     private Comparator comparator = null;
 
     /** Algorithm for computing new values and updating the cache. */
     private Algorithm algorithm = null;
 
     /** The Cache containing the old values. */
     private Cache cache = null;
 
     /** Count of modified properties */
     private int modified = 0;
 
     /** Flag whether this object is configured. Configuration is only done once. */
     private boolean isConfigured = false;
 
     /**
      * Parameter vector with parameters for later initialization.
      * @see #configure
      */
     private Vector configParameter = new Vector();
 
     /**
      * Parameter vector with special parameters for later initialization.
      * The names have the pattern '*.*', e.g. 'cache.cachefile'.
      * These parameters are used <b>after</b> the parameters with the pattern '*'.
      * @see #configure
      */
     private Vector specialParameter = new Vector();
 
     /** The classloader of this class. */
     private ClassLoader myClassLoader = null;
 
     /** provided classpath for the classloader */
     private Path classpath = null;
 
 
     // -----  constructors  -----
 
 
     /** Bean-Constructor. */
     public ModifiedSelector() {
     }
 
 
     // ----- configuration  -----
 
 
     /** Overrides BaseSelector.verifySettings(). */
     public void verifySettings() {
         configure();
         if (cache == null) {
             setError("Cache must be set.");
         } else if (algorithm == null) {
             setError("Algorithm must be set.");
         } else if (!cache.isValid()) {
             setError("Cache must be proper configured.");
         } else if (!algorithm.isValid()) {
             setError("Algorithm must be proper configured.");
         }
     }
 
 
     /**
      * Configures this Selector.
      * Does this work only once per Selector object.
      * <p>Because some problems while configuring from <custom>Selector
      * the configuration is done in the following order:<ol>
      * <li> collect the configuration data </li>
      * <li> wait for the first isSelected() call </li>
      * <li> set the default values </li>
      * <li> set values for name pattern '*': update, cache, algorithm, comparator </li>
      * <li> set values for name pattern '*.*: cache.cachefile, ... </li>
      * </ol></p>
      * <p>This configuration algorithm is needed because you don't know
      * the order of arriving config-data. E.g. if you first set the
      * <i>cache.cachefilename</i> and after that the <i>cache</i> itself,
      * the default value for cachefilename is used, because setting the
      * cache implies creating a new Cache instance - with its defaults.</p>
      */
     public void configure() {
         //
         // -----  The "Singleton"  -----
         //
         if (isConfigured) {
             return;
         }
         isConfigured = true;
 
         //
         // -----  Set default values  -----
         //
         Project p = getProject();
         String filename = "cache.properties";
         File cachefile = null;
         if (p != null) {
             // normal use inside Ant
             cachefile = new File(p.getBaseDir(), filename);
 
             // set self as a BuildListener to delay cachefile saves
             getProject().addBuildListener(this);
         } else {
             // no reference to project - e.g. during normal JUnit tests
             cachefile = new File(filename);
             setDelayUpdate(false);
         }
         Cache      defaultCache      = new PropertiesfileCache(cachefile);
         Algorithm  defaultAlgorithm  = new DigestAlgorithm();
         Comparator defaultComparator = new EqualComparator();
 
         //
         // -----  Set the main attributes, pattern '*'  -----
         //
         for (Iterator itConfig = configParameter.iterator(); itConfig.hasNext();) {
             Parameter par = (Parameter) itConfig.next();
             if (par.getName().indexOf(".") > 0) {
                 // this is a *.* parameter for later use
                 specialParameter.add(par);
             } else {
                 useParameter(par);
             }
         }
         configParameter = new Vector();
 
         // specify the algorithm classname
         if (algoName != null) {
             // use Algorithm defined via name
             if ("hashvalue".equals(algoName.getValue())) {
                 algorithm = new HashvalueAlgorithm();
             } else if ("digest".equals(algoName.getValue())) {
                 algorithm = new DigestAlgorithm();
             } else if ("checksum".equals(algoName.getValue())) {
                 algorithm = new ChecksumAlgorithm();
             }
         } else {
             if (algorithmClass != null) {
                 // use Algorithm specified by classname
                 algorithm = (Algorithm) loadClass(
                     algorithmClass,
                     "is not an Algorithm.",
                     Algorithm.class);
             } else {
                 // nothing specified - use default
                 algorithm = defaultAlgorithm;
             }
         }
 
         // specify the cache classname
         if (cacheName != null) {
             // use Cache defined via name
             if ("propertyfile".equals(cacheName.getValue())) {
                 cache = new PropertiesfileCache();
             }
         } else {
             if (cacheClass != null) {
                 // use Cache specified by classname
                 cache = (Cache) loadClass(cacheClass, "is not a Cache.", Cache.class);
             } else {
                 // nothing specified - use default
                 cache = defaultCache;
             }
         }
 
         // specify the comparator classname
         if (compName != null) {
             // use Algorithm defined via name
             if ("equal".equals(compName.getValue())) {
                 comparator = new EqualComparator();
              } else if ("rule".equals(compName.getValue())) {
                 // TODO there is a problem with the constructor for the RBC.
                 // you have to provide the rules in the constructors - no setters
                 // available.
                 throw new BuildException("RuleBasedCollator not yet supported.");
                 // Have to think about lazy initialization here...  JHM
                 // comparator = new java.text.RuleBasedCollator();
             }
         } else {
             if (comparatorClass != null) {
                 // use Algorithm specified by classname
                 comparator = (Comparator) loadClass(
                     comparatorClass,
                     "is not a Comparator.",
                     Comparator.class);
             } else {
                 // nothing specified - use default
                 comparator = defaultComparator;
             }
         }
 
         //
         // -----  Set the special attributes, pattern '*.*'  -----
         //
         for (Iterator itSpecial = specialParameter.iterator(); itSpecial.hasNext();) {
             Parameter par = (Parameter) itSpecial.next();
             useParameter(par);
         }
         specialParameter = new Vector();
     }
 
 
     /**
      * Loads the specified class and initializes an object of that class.
      * Throws a BuildException using the given message if an error occurs during
      * loading/instantiation or if the object is not from the given type.
      * @param classname the classname
      * @param msg the message-part for the BuildException
      * @param type the type to check against
      * @return a castable object
      */
     protected Object loadClass(String classname, String msg, Class type) {
         try {
             // load the specified class
             ClassLoader cl = getClassLoader();
             Class clazz = null;
             if (cl != null) {
                 clazz = cl.loadClass(classname);
             } else {
                 clazz = Class.forName(classname);
             }
 
             Object rv = clazz.newInstance();
 
             if (!type.isInstance(rv)) {
                 throw new BuildException("Specified class (" + classname + ") " + msg);
             }
             return rv;
         } catch (ClassNotFoundException e) {
             throw new BuildException("Specified class (" + classname + ") not found.");
         } catch (Exception e) {
             throw new BuildException(e);
         }
     }
 
 
     // -----  the selection work  -----
 
 
     /**
      * Implementation of ResourceSelector.isSelected().
      *
      * @param resource The resource to check
      * @return whether the resource is selected
      * @see ResourceSelector#isSelected(Resource)
      */
     public boolean isSelected(Resource resource) {
         if (resource.isFilesystemOnly()) {
             // We have a 'resourced' file, so reconvert it and use
             // the 'old' implementation.
             FileResource fileResource = (FileResource) resource;
             File file = fileResource.getFile();
             String filename = fileResource.getName();
             File basedir = fileResource.getBaseDir();
             return isSelected(basedir, filename, file);
         } else {
             try {
                 // How to handle non-file-Resources? I copy temporarily the
                 // resource to a file and use the file-implementation.
                 FileUtils fu = FileUtils.getFileUtils();
                 File tmpFile = fu.createTempFile("modified-", ".tmp", null, true, false);
                 Resource tmpResource = new FileResource(tmpFile);
                 ResourceUtils.copyResource(resource, tmpResource);
                 boolean isSelected = isSelected(tmpFile.getParentFile(),
                                                 tmpFile.getName(),
                                                 resource.toLongString());
                 tmpFile.delete();
                 return isSelected;
             } catch (UnsupportedOperationException uoe) {
                 log("The resource '"
                   + resource.getName()
                   + "' does not provide an InputStream, so it is not checked. "
                   + "Akkording to 'selres' attribute value it is "
                   + ((selectResourcesWithoutInputStream) ? "" : " not")
                   + "selected.", Project.MSG_INFO);
                 return selectResourcesWithoutInputStream;
             } catch (Exception e) {
                 throw new BuildException(e);
             }
         }
     }
 
 
     /**
      * Implementation of BaseExtendSelector.isSelected().
      *
      * @param basedir as described in BaseExtendSelector
      * @param filename as described in BaseExtendSelector
      * @param file as described in BaseExtendSelector
      * @return as described in BaseExtendSelector
      */
     public boolean isSelected(File basedir, String filename, File file) {
         return isSelected(basedir, filename, file.getAbsolutePath());
     }
 
 
     /**
      * The business logic of this selector for use as ResourceSelector of
      * FileSelector.
      *
      * @param basedir as described in BaseExtendSelector
      * @param filename as described in BaseExtendSelector
      * @param cacheKey the name for the key for storing the hashvalue
      * @return
      */
     private boolean isSelected(File basedir, String filename, String cacheKey) {
         validate();
         File f = new File(basedir, filename);
 
         // You can not compute a value for a directory
         if (f.isDirectory()) {
             return selectDirectories;
         }
 
         // Get the values and do the comparison
         String cachedValue = String.valueOf(cache.get(f.getAbsolutePath()));
         String newValue = algorithm.getValue(f);
 
         boolean rv = (comparator.compare(cachedValue, newValue) != 0);
 
         // Maybe update the cache
         if (update && rv) {
             cache.put(f.getAbsolutePath(), newValue);
             setModified(getModified() + 1);
             if (!getDelayUpdate()) {
                 saveCache();
             }
         }
 
         return rv;
     }
 
 
    /**
     * save the cache file
     */
     protected void saveCache() {
         if (getModified() > 0) {
             cache.save();
             setModified(0);
         }
     }
 
 
     // -----  attribute and nested element support  -----
 
 
     /**
      * Setter for algorithmClass.
      * @param classname  new value
      */
     public void setAlgorithmClass(String classname) {
         algorithmClass = classname;
     }
 
 
     /**
      * Setter for comparatorClass.
      * @param classname  new value
      */
     public void setComparatorClass(String classname) {
         comparatorClass = classname;
     }
 
 
     /**
      * Setter for cacheClass.
      * @param classname  new value
      */
     public void setCacheClass(String classname) {
         cacheClass = classname;
     }
 
 
     /**
      * Support for <i>update</i> attribute.
      * @param update new value
      */
     public void setUpdate(boolean update) {
         this.update = update;
     }
 
 
     /**
      * Support for <i>seldirs</i> attribute.
      * @param seldirs new value
      */
     public void setSeldirs(boolean seldirs) {
         selectDirectories = seldirs;
     }
 
 
     /**
      * Support for <i>selres</i> attribute.
      * @param newValue the new value
      */
     public void setSelres(boolean newValue) {
         this.selectResourcesWithoutInputStream = newValue;
     }
 
 
     /**
      * Getter for the modified count
      * @return modified count
      */
     public int getModified() {
         return modified;
     }
 
 
     /**
      * Setter for the modified count
      * @param modified count
      */
     public void setModified(int modified) {
         this.modified = modified;
     }
 
 
     /**
      * Getter for the delay update
      * @return true if we should delay for performance
      */
     public boolean getDelayUpdate() {
         return delayUpdate;
     }
 
 
     /**
      * Setter for the delay update
      * @param delayUpdate true if we should delay for performance
      */
     public void setDelayUpdate(boolean delayUpdate) {
         this.delayUpdate = delayUpdate;
     }
 
 
     /**
      * Add the classpath.
      * @param path the classpath
      */
     public void addClasspath(Path path) {
         if (classpath != null) {
             throw new BuildException("<classpath> can be set only once.");
         }
         classpath = path;
     }
 
 
     /**
      * Returns and initializes the classloader for this class.
      * @return the classloader
      */
     public ClassLoader getClassLoader() {
         if (myClassLoader == null) {
             myClassLoader = (classpath == null)
                 // the usual classloader
                 ? getClass().getClassLoader()
                 // additional use the provided classpath
                 // Memory leak in line below
                 : getProject().createClassLoader(classpath);
         }
         return myClassLoader;
     }
 
 
     /**
      * Set the used ClassLoader.
      * If you invoke this selector by API (e.g. inside some testcases) the selector
      * will use a different classloader for loading the interface implementations than
      * the caller. Therefore you will get a ClassCastException if you get the
      * implementations from the selector and cast them.
      * @param loader the ClassLoader to use
      */
     public void setClassLoader(ClassLoader loader) {
         myClassLoader = loader;
     }
 
 
     /**
      * Support for nested &lt;param&gt; tags.
      * @param key the key of the parameter
      * @param value the value of the parameter
      */
     public void addParam(String key, Object value) {
         Parameter par = new Parameter();
         par.setName(key);
         par.setValue(String.valueOf(value));
         configParameter.add(par);
     }
 
 
     /**
      * Support for nested &lt;param&gt; tags.
      * @param parameter the parameter object
      */
     public void addParam(Parameter parameter) {
         configParameter.add(parameter);
     }
 
 
     /**
      * Defined in org.apache.tools.ant.types.Parameterizable.
      * Overwrite implementation in superclass because only special
      * parameters are valid.
      * @see #addParam(String,Object).
      * @param parameters the parameters to set.
      */
     public void setParameters(Parameter[] parameters) {
         if (parameters != null) {
             for (int i = 0; i < parameters.length; i++) {
                 configParameter.add(parameters[i]);
             }
         }
     }
 
 
     /**
      * Support for nested <param name="" value=""/> tags.
      * Parameter named <i>cache</i>, <i>algorithm</i>,
      * <i>comparator</i> or <i>update</i> are mapped to
      * the respective set-Method.
      * Parameter which names starts with <i>cache.</i> or
      * <i>algorithm.</i> or <i>comparator.</i> are tried
      * to set on the appropriate object via its set-methods.
      * Other parameters are invalid and an BuildException will
      * be thrown.
      *
      * @param parameter  Key and value as parameter object
      */
     public void useParameter(Parameter parameter) {
         String key = parameter.getName();
         String value = parameter.getValue();
         if ("cache".equals(key)) {
             CacheName cn = new CacheName();
             cn.setValue(value);
             setCache(cn);
         } else if ("algorithm".equals(key)) {
             AlgorithmName an = new AlgorithmName();
             an.setValue(value);
             setAlgorithm(an);
         } else if ("comparator".equals(key)) {
             ComparatorName cn = new ComparatorName();
             cn.setValue(value);
             setComparator(cn);
         } else if ("update".equals(key)) {
             boolean updateValue =
                 ("true".equalsIgnoreCase(value))
                 ? true
                 : false;
             setUpdate(updateValue);
         } else if ("delayupdate".equals(key)) {
             boolean updateValue =
                 ("true".equalsIgnoreCase(value))
                 ? true
                 : false;
             setDelayUpdate(updateValue);
         } else if ("seldirs".equals(key)) {
             boolean sdValue =
                 ("true".equalsIgnoreCase(value))
                 ? true
                 : false;
             setSeldirs(sdValue);
         } else if (key.startsWith(CACHE_PREFIX)) {
             String name = key.substring(CACHE_PREFIX.length());
             tryToSetAParameter(cache, name, value);
         } else if (key.startsWith(ALGORITHM_PREFIX)) {
             String name = key.substring(ALGORITHM_PREFIX.length());
             tryToSetAParameter(algorithm, name, value);
         } else if (key.startsWith(COMPARATOR_PREFIX)) {
             String name = key.substring(COMPARATOR_PREFIX.length());
             tryToSetAParameter(comparator, name, value);
         } else {
             setError("Invalid parameter " + key);
         }
     }
 
 
     /**
      * Try to set a value on an object using reflection.
      * Helper method for easier access to IntrospectionHelper.setAttribute().
      * @param obj the object on which the attribute should be set
      * @param name the attributename
      * @param value the new value
      */
     protected void tryToSetAParameter(Object obj, String name, String value) {
         Project prj = (getProject() != null) ? getProject() : new Project();
         IntrospectionHelper iHelper
             = IntrospectionHelper.getHelper(prj, obj.getClass());
         try {
             iHelper.setAttribute(prj, obj, name, value);
         } catch (org.apache.tools.ant.BuildException e) {
             // no-op
         }
     }
 
 
     // ----- 'beautiful' output -----
 
 
     /**
      * Override Object.toString().
      * @return information about this selector
      */
     public String toString() {
         StringBuffer buf = new StringBuffer("{modifiedselector");
         buf.append(" update=").append(update);
         buf.append(" seldirs=").append(selectDirectories);
         buf.append(" cache=").append(cache);
         buf.append(" algorithm=").append(algorithm);
         buf.append(" comparator=").append(comparator);
         buf.append("}");
         return buf.toString();
     }
 
 
     // ----- BuildListener interface methods -----
 
 
     /**
      * Signals that the last target has finished.
-     * @param event recieved BuildEvent
+     * @param event received BuildEvent
     */
     public void buildFinished(BuildEvent event) {
         if (getDelayUpdate()) {
             saveCache();
         }
     }
 
 
     /**
      * Signals that a target has finished.
      * @param event recieved BuildEvent
     */
     public void targetFinished(BuildEvent event) {
         if (getDelayUpdate()) {
             saveCache();
         }
     }
 
 
     /**
      * Signals that a task has finished.
      * @param event recieved BuildEvent
     */
     public void taskFinished(BuildEvent event) {
         if (getDelayUpdate()) {
             saveCache();
         }
     }
 
 
     /**
      * Signals that a build has started.
      * @param event recieved BuildEvent
     */
     public void buildStarted(BuildEvent event) {
         // no-op
     }
 
 
     /**
      * Signals that a target is starting.
      * @param event received BuildEvent
     */
     public void targetStarted(BuildEvent event) {
         // no-op
     }
 
 
 
     /**
      * Signals that a task is starting.
      * @param event recieved BuildEvent
     */
     public void taskStarted(BuildEvent event) {
         // no-op
     }
 
 
     /**
      * Signals a message logging event.
      * @param event recieved BuildEvent
     */
     public void messageLogged(BuildEvent event) {
         // no-op
     }
 
 
     // The EnumeratedAttributes for the three interface implementations.
     // Name-Classname mapping is done in the configure() method.
 
 
     /**
      * Get the cache type to use.
      * @return the enumerated cache type
      */
     public Cache getCache() {
         return cache;
     }
 
     /**
      * Set the cache type to use.
      * @param name an enumerated cache type.
      */
     public void setCache(CacheName name) {
         cacheName = name;
     }
 
     /**
      * The enumerated type for cache.
      * The values are "propertyfile".
      */
     public static class CacheName extends EnumeratedAttribute {
         /**
          * {@inheritDoc}
          * @see EnumeratedAttribute#getValues()
          */
         public String[] getValues() {
             return new String[] {"propertyfile" };
         }
     }
 
     /**
      * Get the algorithm type to use.
      * @return the enumerated algorithm type
      */
     public Algorithm getAlgorithm() {
         return algorithm;
     }
 
     /**
      * Set the algorithm type to use.
      * @param name an enumerated algorithm type.
      */
     public void setAlgorithm(AlgorithmName name) {
         algoName = name;
     }
 
     /**
      * The enumerated type for algorithm.
      * The values are "hashValue", "digest" and "checksum".
      */
     public static class AlgorithmName extends EnumeratedAttribute {
         /**
          * {@inheritDoc}
          * @see EnumeratedAttribute#getValues()
          */
         public String[] getValues() {
             return new String[] {"hashvalue", "digest", "checksum" };
         }
     }
 
     /**
      * Get the comparator type to use.
      * @return the enumerated comparator type
      */
     public Comparator getComparator() {
         return comparator;
     }
 
     /**
      * Set the comparator type to use.
      * @param name an enumerated comparator type.
      */
     public void setComparator(ComparatorName name) {
         compName = name;
     }
 
     /**
      * The enumerated type for algorithm.
      * The values are "equal" and "rule".
      */
     public static class ComparatorName extends EnumeratedAttribute {
         /**
          * {@inheritDoc}
          * @see EnumeratedAttribute#getValues()
          */
         public String[] getValues() {
             return new String[] {"equal", "rule" };
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/util/ContainerMapper.java b/src/main/org/apache/tools/ant/util/ContainerMapper.java
index f47f42783..c3bf08c89 100644
--- a/src/main/org/apache/tools/ant/util/ContainerMapper.java
+++ b/src/main/org/apache/tools/ant/util/ContainerMapper.java
@@ -1,118 +1,118 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.util;
 
 import java.util.List;
 import java.util.Iterator;
 import java.util.ArrayList;
 import java.util.Collections;
 import org.apache.tools.ant.types.Mapper;
 
 /**
  * A <code>FileNameMapper</code> that contains
  * other <code>FileNameMapper</code>s.
  * @see FileNameMapper
  */
 public abstract class ContainerMapper implements FileNameMapper {
 
     private List mappers = new ArrayList();
 
     /**
      * Add a <code>Mapper</code>.
      * @param mapper the <code>Mapper</code> to add.
      */
     public void addConfiguredMapper(Mapper mapper) {
         add(mapper.getImplementation());
     }
 
     /**
      * An add configured version of the add method.
      * This class used to contain an add method and an
      * addConfiguredMapper method. Dur to ordering,
      * the add method was always called first. This
-     * addConfigued method has been added to allow
+     * addConfigured method has been added to allow
      * chaining to work correctly.
      * @param fileNameMapper a <code>FileNameMapper</code>.
      */
     public void addConfigured(FileNameMapper fileNameMapper) {
         add(fileNameMapper);
     }
 
     /**
      * Add a <code>FileNameMapper</code>.
      * @param fileNameMapper a <code>FileNameMapper</code>.
      * @throws IllegalArgumentException if attempting to add this
      *         <code>ContainerMapper</code> to itself, or if the specified
      *         <code>FileNameMapper</code> is itself a <code>ContainerMapper</code>
      *         that contains this <code>ContainerMapper</code>.
      */
     public synchronized void add(FileNameMapper fileNameMapper) {
         if (this == fileNameMapper
             || (fileNameMapper instanceof ContainerMapper
             && ((ContainerMapper) fileNameMapper).contains(this))) {
             throw new IllegalArgumentException(
                 "Circular mapper containment condition detected");
         } else {
             mappers.add(fileNameMapper);
         }
     }
 
     /**
      * Return <code>true</code> if this <code>ContainerMapper</code> or any of
      * its sub-elements contains the specified <code>FileNameMapper</code>.
      * @param fileNameMapper   the <code>FileNameMapper</code> to search for.
      * @return <code>boolean</code>.
      */
     protected synchronized boolean contains(FileNameMapper fileNameMapper) {
         boolean foundit = false;
         for (Iterator iter = mappers.iterator(); iter.hasNext() && !foundit;) {
             FileNameMapper next = (FileNameMapper) (iter.next());
             foundit = (next == fileNameMapper
                 || (next instanceof ContainerMapper
                 && ((ContainerMapper) next).contains(fileNameMapper)));
         }
         return foundit;
     }
 
     /**
      * Get the <code>List</code> of <code>FileNameMapper</code>s.
      * @return <code>List</code>.
      */
     public synchronized List getMappers() {
         return Collections.unmodifiableList(mappers);
     }
 
     /**
      * Empty implementation.
      * @param ignore ignored.
      */
     public void setFrom(String ignore) {
         //Empty
     }
 
     /**
      * Empty implementation.
      * @param ignore ignored.
      */
     public void setTo(String ignore) {
         //Empty
     }
 
 }
 
diff --git a/src/main/org/apache/tools/ant/util/JavaEnvUtils.java b/src/main/org/apache/tools/ant/util/JavaEnvUtils.java
index 3f3b7d2ac..08cc22cc4 100644
--- a/src/main/org/apache/tools/ant/util/JavaEnvUtils.java
+++ b/src/main/org/apache/tools/ant/util/JavaEnvUtils.java
@@ -1,521 +1,521 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.FileWriter;
 import java.io.BufferedWriter;
 import java.util.Vector;
 import org.apache.tools.ant.taskdefs.condition.Os;
 
 /**
  * A set of helper methods related to locating executables or checking
- * conditons of a given Java installation.
+ * conditions of a given Java installation.
  *
  * @since Ant 1.5
  */
 public final class JavaEnvUtils {
 
     private JavaEnvUtils() {
     }
 
     /** Are we on a DOS-based system */
     private static final boolean IS_DOS = Os.isFamily("dos");
     /** Are we on Novell NetWare */
     private static final boolean IS_NETWARE = Os.isName("netware");
     /** Are we on AIX */
     private static final boolean IS_AIX = Os.isName("aix");
 
     /** shortcut for System.getProperty("java.home") */
     private static final String JAVA_HOME = System.getProperty("java.home");
 
     /** FileUtils instance for path normalization */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /** Version of currently running VM. */
     private static String javaVersion;
 
     /** floating version of the JVM */
     private static int javaVersionNumber;
 
     /** Version constant for Java 1.0 */
     public static final String JAVA_1_0 = "1.0";
     /** Number Version constant for Java 1.0 */
     public static final int VERSION_1_0 = 10;
 
     /** Version constant for Java 1.1 */
     public static final String JAVA_1_1 = "1.1";
     /** Number Version constant for Java 1.1 */
     public static final int VERSION_1_1 = 11;
 
     /** Version constant for Java 1.2 */
     public static final String JAVA_1_2 = "1.2";
     /** Number Version constant for Java 1.2 */
     public static final int VERSION_1_2 = 12;
 
     /** Version constant for Java 1.3 */
     public static final String JAVA_1_3 = "1.3";
     /** Number Version constant for Java 1.3 */
     public static final int VERSION_1_3 = 13;
 
     /** Version constant for Java 1.4 */
     public static final String JAVA_1_4 = "1.4";
     /** Number Version constant for Java 1.4 */
     public static final int VERSION_1_4 = 14;
 
     /** Version constant for Java 1.5 */
     public static final String JAVA_1_5 = "1.5";
     /** Number Version constant for Java 1.5 */
     public static final int VERSION_1_5 = 15;
 
     /** Version constant for Java 1.6 */
     public static final String JAVA_1_6 = "1.6";
     /** Number Version constant for Java 1.6 */
     public static final int VERSION_1_6 = 16;
 
     /** Version constant for Java 1.7 */
     public static final String JAVA_1_7 = "1.7";
     /** Number Version constant for Java 1.7 */
     public static final int VERSION_1_7 = 17;
 
     /** Version constant for Java 1.8 */
     public static final String JAVA_1_8 = "1.8";
     /** Number Version constant for Java 1.8 */
     public static final int VERSION_1_8 = 18;
 
     /** Whether this is the Kaffe VM */
     private static boolean kaffeDetected;
     /** Whether this is the GNU VM (gcj/gij) */
     private static boolean gijDetected;
 
     /** Whether this is Apache Harmony */
     private static boolean harmonyDetected;
 
     /** array of packages in the runtime */
     private static Vector jrePackages;
 
 
     static {
 
         // Determine the Java version by looking at available classes
         // java.net.Proxy was introduced in JDK 1.5
         // java.lang.CharSequence was introduced in JDK 1.4
         // java.lang.StrictMath was introduced in JDK 1.3
         // java.lang.ThreadLocal was introduced in JDK 1.2
         // java.lang.Void was introduced in JDK 1.1
         // Count up version until a NoClassDefFoundError ends the try
 
         try {
             javaVersion = JAVA_1_0;
             javaVersionNumber = VERSION_1_0;
             Class.forName("java.lang.Void");
             javaVersion = JAVA_1_1;
             javaVersionNumber++;
             Class.forName("java.lang.ThreadLocal");
             javaVersion = JAVA_1_2;
             javaVersionNumber++;
             Class.forName("java.lang.StrictMath");
             javaVersion = JAVA_1_3;
             javaVersionNumber++;
             Class.forName("java.lang.CharSequence");
             javaVersion = JAVA_1_4;
             javaVersionNumber++;
             Class.forName("java.net.Proxy");
             javaVersion = JAVA_1_5;
             javaVersionNumber++;
             Class.forName("java.net.CookieStore");
             javaVersion = JAVA_1_6;
             javaVersionNumber++;
             Class.forName("java.nio.file.FileSystem");
             javaVersion = JAVA_1_7;
             javaVersionNumber++;
             Class.forName("java.lang.reflect.Executable");
             javaVersion = JAVA_1_8;
             javaVersionNumber++;
         } catch (Throwable t) {
             // swallow as we've hit the max class version that
             // we have
         }
         kaffeDetected = false;
         try {
             Class.forName("kaffe.util.NotImplemented");
             kaffeDetected = true;
         } catch (Throwable t) {
             // swallow as this simply doesn't seem to be Kaffe
         }
         gijDetected = false;
         try {
             Class.forName("gnu.gcj.Core");
             gijDetected = true;
         } catch (Throwable t) {
             // swallow as this simply doesn't seem to be gcj/gij
         }
         harmonyDetected = false;
         try {
             Class.forName("org.apache.harmony.luni.util.Base64");
             harmonyDetected = true;
         } catch (Throwable t) {
             // swallow as this simply doesn't seem to be Apache Harmony
         }
     }
 
     /**
      * Returns the version of Java this class is running under.
      * @return the version of Java as a String, e.g. "1.6"
      */
     public static String getJavaVersion() {
         return javaVersion;
     }
 
 
     /**
      * Returns the version of Java this class is running under.
-     * This number can be used for comparisions; it will always be
+     * This number can be used for comparisons; it will always be
      * @return the version of Java as a number 10x the major/minor,
      * e.g Java1.5 has a value of 15
      */
     public static int getJavaVersionNumber() {
         return javaVersionNumber;
     }
 
     /**
      * Compares the current Java version to the passed in String -
      * assumes the argument is one of the constants defined in this
      * class.
      * Note that Ant now requires JDK 1.4+ so {@link #JAVA_1_0} through
      * {@link #JAVA_1_3} need no longer be tested for.
      * @param version the version to check against the current version.
      * @return true if the version of Java is the same as the given version.
      * @since Ant 1.5
      */
     public static boolean isJavaVersion(String version) {
         return javaVersion.equals(version);
     }
 
     /**
      * Compares the current Java version to the passed in String -
      * assumes the argument is one of the constants defined in this
      * class.
      * Note that Ant now requires JDK 1.4+ so {@link #JAVA_1_0} through
      * {@link #JAVA_1_3} need no longer be tested for.
      * @param version the version to check against the current version.
      * @return true if the version of Java is the same or higher than the
      * given version.
      * @since Ant 1.7
      */
     public static boolean isAtLeastJavaVersion(String version) {
         return javaVersion.compareTo(version) >= 0;
     }
 
     /**
      * Checks whether the current Java VM is Kaffe.
      * @return true if the current Java VM is Kaffe.
      * @since Ant 1.6.3
      * @see <a href="http://www.kaffe.org/">http://www.kaffe.org/</a>
      */
     public static boolean isKaffe() {
         return kaffeDetected;
     }
 
     /**
      * Checks whether the current Java VM is the GNU interpreter gij
      * or we are running in a gcj precompiled binary.
      * @since Ant 1.8.2
      * @return true if the current Java VM is gcj/gij.
      */
     public static boolean isGij() {
         return gijDetected;
     }
 
     /**
      * Checks whether the current VM is Apache Harmony.
      * @since Ant 1.8.2
      * @return true if the current VM is Apache Harmony.
      */
     public static boolean isApacheHarmony() {
         return harmonyDetected;
     }
 
     /**
      * Finds an executable that is part of a JRE installation based on
      * the java.home system property.
      *
      * <p><code>java</code>, <code>keytool</code>,
      * <code>policytool</code>, <code>orbd</code>, <code>rmid</code>,
      * <code>rmiregistry</code>, <code>servertool</code> and
      * <code>tnameserv</code> are JRE executables on Sun based
      * JRE's.</p>
      *
      * <p>You typically find them in <code>JAVA_HOME/jre/bin</code> if
      * <code>JAVA_HOME</code> points to your JDK installation.  JDK
      * &lt; 1.2 has them in the same directory as the JDK
      * executables.</p>
      * @param command the java executable to find.
      * @return the path to the command.
      * @since Ant 1.5
      */
     public static String getJreExecutable(String command) {
         if (IS_NETWARE) {
             // Extrapolating from:
             // "NetWare may have a "java" in that directory, but 99% of
             // the time, you don't want to execute it" -- Jeff Tulley
             // <JTULLEY@novell.com>
             return command;
         }
 
         File jExecutable = null;
 
         if (IS_AIX) {
             // On IBM's JDK 1.2 the directory layout is different, 1.3 follows
             // Sun's layout.
             jExecutable = findInDir(JAVA_HOME + "/sh", command);
         }
 
         if (jExecutable == null) {
             jExecutable = findInDir(JAVA_HOME + "/bin", command);
         }
 
         if (jExecutable != null) {
             return jExecutable.getAbsolutePath();
         } else {
             // Unfortunately on Windows java.home doesn't always refer
             // to the correct location, so we need to fall back to
             // assuming java is somewhere on the PATH.
             return addExtension(command);
         }
     }
 
     /**
      * Finds an executable that is part of a JDK installation based on
      * the java.home system property.
      *
      * <p>You typically find them in <code>JAVA_HOME/bin</code> if
      * <code>JAVA_HOME</code> points to your JDK installation.</p>
      * @param command the java executable to find.
      * @return the path to the command.
      * @since Ant 1.5
      */
     public static String getJdkExecutable(String command) {
         if (IS_NETWARE) {
             // Extrapolating from:
             // "NetWare may have a "java" in that directory, but 99% of
             // the time, you don't want to execute it" -- Jeff Tulley
             // <JTULLEY@novell.com>
             return command;
         }
 
         File jExecutable = null;
 
         if (IS_AIX) {
             // On IBM's JDK 1.2 the directory layout is different, 1.3 follows
             // Sun's layout.
             jExecutable = findInDir(JAVA_HOME + "/../sh", command);
         }
 
         if (jExecutable == null) {
             jExecutable = findInDir(JAVA_HOME + "/../bin", command);
         }
 
         if (jExecutable != null) {
             return jExecutable.getAbsolutePath();
         } else {
             // fall back to JRE bin directory, also catches JDK 1.0 and 1.1
             // where java.home points to the root of the JDK and Mac OS X where
             // the whole directory layout is different from Sun's
             return getJreExecutable(command);
         }
     }
 
     /**
      * Adds a system specific extension to the name of an executable.
      *
      * @since Ant 1.5
      */
     private static String addExtension(String command) {
         // This is the most common extension case - exe for windows and OS/2,
         // nothing for *nix.
         return command + (IS_DOS ? ".exe" : "");
     }
 
     /**
      * Look for an executable in a given directory.
      *
      * @return null if the executable cannot be found.
      */
     private static File findInDir(String dirName, String commandName) {
         File dir = FILE_UTILS.normalize(dirName);
         File executable = null;
         if (dir.exists()) {
             executable = new File(dir, addExtension(commandName));
             if (!executable.exists()) {
                 executable = null;
             }
         }
         return executable;
     }
 
     /**
      * demand creation of the package list.
      * When you add a new package, add a new test below.
      */
 
     private static void buildJrePackages() {
         jrePackages = new Vector();
         switch(javaVersionNumber) {
             case VERSION_1_8:
             case VERSION_1_7:
             case VERSION_1_6:
             case VERSION_1_5:
                 //In Java1.5, the apache stuff moved.
                 jrePackages.addElement("com.sun.org.apache");
                 //fall through.
             case VERSION_1_4:
                 if (javaVersionNumber == VERSION_1_4) {
                     jrePackages.addElement("org.apache.crimson");
                     jrePackages.addElement("org.apache.xalan");
                     jrePackages.addElement("org.apache.xml");
                     jrePackages.addElement("org.apache.xpath");
                 }
                 jrePackages.addElement("org.ietf.jgss");
                 jrePackages.addElement("org.w3c.dom");
                 jrePackages.addElement("org.xml.sax");
                 // fall through
             case VERSION_1_3:
                 jrePackages.addElement("org.omg");
                 jrePackages.addElement("com.sun.corba");
                 jrePackages.addElement("com.sun.jndi");
                 jrePackages.addElement("com.sun.media");
                 jrePackages.addElement("com.sun.naming");
                 jrePackages.addElement("com.sun.org.omg");
                 jrePackages.addElement("com.sun.rmi");
                 jrePackages.addElement("sunw.io");
                 jrePackages.addElement("sunw.util");
                 // fall through
             case VERSION_1_2:
                 jrePackages.addElement("com.sun.java");
                 jrePackages.addElement("com.sun.image");
                 // are there any here that we forgot?
                 // fall through
             case VERSION_1_1:
             default:
                 //things like sun.reflection, sun.misc, sun.net
                 jrePackages.addElement("sun");
                 jrePackages.addElement("java");
                 jrePackages.addElement("javax");
                 break;
         }
     }
 
     /**
      * Testing helper method; kept here for unification of changes.
      * @return a list of test classes depending on the java version.
      */
     public static Vector getJrePackageTestCases() {
         Vector tests = new Vector();
         tests.addElement("java.lang.Object");
         switch(javaVersionNumber) {
             case VERSION_1_8:
             case VERSION_1_7:
             case VERSION_1_6:
             case VERSION_1_5:
                 tests.addElement(
                     "com.sun.org.apache.xerces.internal.jaxp.datatype.DatatypeFactoryImpl ");
                 // Fall tru
             case VERSION_1_4:
                 tests.addElement("sun.audio.AudioPlayer");
                 if (javaVersionNumber == VERSION_1_4) {
                     tests.addElement("org.apache.crimson.parser.ContentModel");
                     tests.addElement("org.apache.xalan.processor.ProcessorImport");
                     tests.addElement("org.apache.xml.utils.URI");
                     tests.addElement("org.apache.xpath.XPathFactory");
                 }
                 tests.addElement("org.ietf.jgss.Oid");
                 tests.addElement("org.w3c.dom.Attr");
                 tests.addElement("org.xml.sax.XMLReader");
                 // fall through
             case VERSION_1_3:
                 tests.addElement("org.omg.CORBA.Any");
                 tests.addElement("com.sun.corba.se.internal.corba.AnyImpl");
                 tests.addElement("com.sun.jndi.ldap.LdapURL");
                 tests.addElement("com.sun.media.sound.Printer");
                 tests.addElement("com.sun.naming.internal.VersionHelper");
                 tests.addElement("com.sun.org.omg.CORBA.Initializer");
                 tests.addElement("sunw.io.Serializable");
                 tests.addElement("sunw.util.EventListener");
                 // fall through
             case VERSION_1_2:
                 tests.addElement("javax.accessibility.Accessible");
                 tests.addElement("sun.misc.BASE64Encoder");
                 tests.addElement("com.sun.image.codec.jpeg.JPEGCodec");
                 // fall through
             case VERSION_1_1:
             default:
                 //things like sun.reflection, sun.misc, sun.net
                 tests.addElement("sun.reflect.SerializationConstructorAccessorImpl");
                 tests.addElement("sun.net.www.http.HttpClient");
                 tests.addElement("sun.audio.AudioPlayer");
                 break;
         }
         return tests;
     }
     /**
      * get a vector of strings of packages built into
      * that platforms runtime jar(s)
      * @return list of packages.
      */
     public static Vector getJrePackages() {
         if (jrePackages == null) {
             buildJrePackages();
         }
         return jrePackages;
     }
 
     /**
      *
      * Writes the command into a temporary DCL script and returns the
      * corresponding File object.
      * It is the job of the caller to delete the file on exit.
      * @param cmd the command.
      * @return the file containing the command.
      * @throws IOException if there is an error writing to the file.
      */
     public static File createVmsJavaOptionFile(String[] cmd)
             throws IOException {
         File script = FILE_UTILS.createTempFile("ANT", ".JAVA_OPTS", null, false, true);
         BufferedWriter out = null;
         try {
             out = new BufferedWriter(new FileWriter(script));
             for (int i = 0; i < cmd.length; i++) {
                 out.write(cmd[i]);
                 out.newLine();
             }
         } finally {
             FileUtils.close(out);
         }
         return script;
     }
 
     /**
      * Return the value of ${java.home}
      * @return the java home value.
      */
     public static String getJavaHome() {
         return JAVA_HOME;
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/KeepAliveInputStream.java b/src/main/org/apache/tools/ant/util/KeepAliveInputStream.java
index ac5919710..fe5e32fd7 100644
--- a/src/main/org/apache/tools/ant/util/KeepAliveInputStream.java
+++ b/src/main/org/apache/tools/ant/util/KeepAliveInputStream.java
@@ -1,67 +1,67 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
 /**
  * Class that can be used to wrap <tt>System.in</tt>
  * without getting anxious about any client closing the stream.
  *
  * <p>
  * In code-language it means that it is not necessary to do:
  * <pre>
  * if (out != System.in) {
  *   in.close();
  * }
  * </pre>
  * </p>
  *
  * @since Ant 1.6
  */
 public class KeepAliveInputStream extends FilterInputStream {
 
     /**
      * Constructor of KeepAliveInputStream.
      *
      * @param in an InputStream value, it should be standard input.
      */
     public KeepAliveInputStream(InputStream in) {
         super(in);
     }
 
     /**
      * This method does nothing.
-     * @throws IOException as we are overridding FilterInputStream.
+     * @throws IOException as we are overriding FilterInputStream.
      */
     public void close() throws IOException {
         // do not close the stream
     }
 
     /**
      * Convenience factory method that returns a non-closing
      * InputStream around System.in.
      *
      * @since Ant 1.8.0
      */
     public static InputStream wrapSystemIn() {
         return new KeepAliveInputStream(System.in);
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/KeepAliveOutputStream.java b/src/main/org/apache/tools/ant/util/KeepAliveOutputStream.java
index 4e437e906..9f5c06b96 100644
--- a/src/main/org/apache/tools/ant/util/KeepAliveOutputStream.java
+++ b/src/main/org/apache/tools/ant/util/KeepAliveOutputStream.java
@@ -1,84 +1,84 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.io.FilterOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.PrintStream;
 
 /**
  * Class that can be used to wrap <tt>System.out</tt> and <tt>System.err</tt>
  * without getting anxious about any client closing the stream.
  *
  * <p>
  * In code-language it means that it is not necessary to do:
  * <pre>
  * if (out != System.out && out!= System.err) {
  *   out.close();
  * }
  * </pre>
  * </p>
  *
  */
 public class KeepAliveOutputStream extends FilterOutputStream {
 
     /**
      * Constructor of KeepAliveOutputStream.
      *
-     * @param out an OutputStream value, it shoudl be standard output.
+     * @param out an OutputStream value, it should be standard output.
      */
     public KeepAliveOutputStream(OutputStream out) {
         super(out);
     }
 
     /**
      * This method does nothing.
-     * @throws IOException as we are overridding FilterOutputStream.
+     * @throws IOException as we are overriding FilterOutputStream.
      */
     public void close() throws IOException {
         // do not close the stream
     }
 
     /**
      * Convenience factory method that returns a non-closing
      * PrintStream around System.out.
      *
      * @since Ant 1.8.0
      */
     public static PrintStream wrapSystemOut() {
         return wrap(System.out);
     }
 
     /**
      * Convenience factory method that returns a non-closing
      * PrintStream around System.err.
      *
      * @since Ant 1.8.0
      */
     public static PrintStream wrapSystemErr() {
         return wrap(System.err);
     }
 
     /**
      * @since Ant 1.8.0
      */
     private static PrintStream wrap(PrintStream ps) {
         return new PrintStream(new KeepAliveOutputStream(ps));
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/LazyFileOutputStream.java b/src/main/org/apache/tools/ant/util/LazyFileOutputStream.java
index 7d289b9c1..7e5bf7863 100644
--- a/src/main/org/apache/tools/ant/util/LazyFileOutputStream.java
+++ b/src/main/org/apache/tools/ant/util/LazyFileOutputStream.java
@@ -1,162 +1,162 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 
 /**
  * Class that delays opening the output file until the first bytes
  * shall be written or the method {@link #open open} has been invoked
  * explicitly.
  *
  * @since Ant 1.6
  */
 public class LazyFileOutputStream extends OutputStream {
 
     private FileOutputStream fos;
     private File file;
     private boolean append;
     private boolean alwaysCreate;
     private boolean opened = false;
     private boolean closed = false;
 
     /**
      * Creates a stream that will eventually write to the file with
      * the given name and replace it.
      * @param name the filename.
      */
     public LazyFileOutputStream(String name) {
         this(name, false);
     }
 
     /**
      * Creates a stream that will eventually write to the file with
      * the given name and optionally append to instead of replacing
      * it.
      * @param name the filename.
      * @param append if true append rather than replace.
      */
     public LazyFileOutputStream(String name, boolean append) {
         this(new File(name), append);
     }
 
     /**
      * Creates a stream that will eventually write to the file with
      * the given name and replace it.
      * @param f the file to create.
      */
     public LazyFileOutputStream(File f) {
         this(f, false);
     }
 
     /**
      * Creates a stream that will eventually write to the file with
      * the given name and optionally append to instead of replacing
      * it.
      * @param file the file to create.
      * @param append if true append rather than replace.
      */
     public LazyFileOutputStream(File file, boolean append) {
         this(file, append, false);
     }
 
     /**
      * Creates a stream that will eventually write to the file with
      * the given name, optionally append to instead of replacing
      * it, and optionally always create a file (even if zero length).
      * @param file the file to create.
      * @param append if true append rather than replace.
      * @param alwaysCreate if true create the file even if nothing to write.
      */
     public LazyFileOutputStream(File file, boolean append,
                                 boolean alwaysCreate) {
         this.file = file;
         this.append = append;
         this.alwaysCreate = alwaysCreate;
     }
 
     /**
      * Explicitly open the file for writing.
      *
      * <p>Returns silently if the file has already been opened.</p>
      * @throws IOException if there is an error.
      */
     public void open() throws IOException {
         ensureOpened();
     }
 
     /**
      * Close the file.
      * @throws IOException if there is an error.
      */
     public synchronized void close() throws IOException {
         if (alwaysCreate && !closed) {
             ensureOpened();
         }
         if (opened) {
             fos.close();
         }
         closed = true;
     }
 
     /**
      * Delegates to the three-arg version.
      * @param b the bytearray to write.
      * @throws IOException if there is a problem.
      */
     public void write(byte[] b) throws IOException {
         write(b, 0, b.length);
     }
 
     /**
      * Write part of a byte array.
      * @param b the byte array.
      * @param offset write from this index.
      * @param len    the number of bytes to write.
-     * @throws IOException if there is a probem.
+     * @throws IOException if there is a problem.
      */
     public synchronized void write(byte[] b, int offset, int len)
         throws IOException {
         ensureOpened();
         fos.write(b, offset, len);
     }
 
     /**
      * Write a byte.
      * @param b the byte to write.
      * @throws IOException if there is a problem.
      */
     public synchronized void write(int b) throws IOException {
         ensureOpened();
         fos.write(b);
     }
 
     private synchronized void ensureOpened() throws IOException {
         if (closed) {
             throw new IOException(file + " has already been closed.");
         }
 
         if (!opened) {
             fos = new FileOutputStream(file.getAbsolutePath(), append);
             opened = true;
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/LineTokenizer.java b/src/main/org/apache/tools/ant/util/LineTokenizer.java
index 21bfb021a..11e7ebce4 100644
--- a/src/main/org/apache/tools/ant/util/LineTokenizer.java
+++ b/src/main/org/apache/tools/ant/util/LineTokenizer.java
@@ -1,115 +1,115 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.io.Reader;
 import java.io.IOException;
 
 import org.apache.tools.ant.ProjectComponent;
 
 /**
- * class to tokenize the input as lines seperated
+ * class to tokenize the input as lines separated
  * by \r (mac style), \r\n (dos/windows style) or \n (unix style)
  * @since Ant 1.6
  */
 public class LineTokenizer extends ProjectComponent
     implements Tokenizer {
     private static final int NOT_A_CHAR = -2;
     private String  lineEnd = "";
     private int     pushed = NOT_A_CHAR;
     private boolean includeDelims = false;
 
     /**
      * attribute includedelims - whether to include
      * the line ending with the line, or to return
      * it in the posttoken
      * default false
      * @param includeDelims if true include /r and /n in the line
      */
 
     public void setIncludeDelims(boolean includeDelims) {
         this.includeDelims = includeDelims;
     }
 
     /**
      * get the next line from the input
      *
      * @param in the input reader
      * @return the line excluding /r or /n, unless includedelims is set
      * @exception IOException if an error occurs reading
      */
     public String getToken(Reader in) throws IOException {
         int ch = -1;
         if (pushed != NOT_A_CHAR) {
             ch = pushed;
             pushed = NOT_A_CHAR;
         } else {
             ch = in.read();
         }
         if (ch == -1) {
             return null;
         }
 
         lineEnd = "";
         StringBuffer line = new StringBuffer();
 
         int state = 0;
         while (ch != -1) {
             if (state == 0) {
                 if (ch == '\r') {
                     state = 1;
                 } else if (ch == '\n') {
                     lineEnd = "\n";
                     break;
                 } else {
                     line.append((char) ch);
                 }
             } else {
                 state = 0;
                 if (ch == '\n') {
                     lineEnd = "\r\n";
                 } else {
                     pushed = ch;
                     lineEnd = "\r";
                 }
                 break;
             }
             ch = in.read();
         }
         if (ch == -1 && state == 1) {
             lineEnd = "\r";
         }
 
         if (includeDelims) {
             line.append(lineEnd);
         }
         return line.toString();
     }
 
     /**
      * @return the line ending character(s) for the current line
      */
     public String getPostToken() {
         if (includeDelims) {
             return "";
         }
         return lineEnd;
     }
 
 }
 
diff --git a/src/main/org/apache/tools/ant/util/PackageNameMapper.java b/src/main/org/apache/tools/ant/util/PackageNameMapper.java
index 2ccde5d14..87477c3d9 100644
--- a/src/main/org/apache/tools/ant/util/PackageNameMapper.java
+++ b/src/main/org/apache/tools/ant/util/PackageNameMapper.java
@@ -1,49 +1,49 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.io.File;
 
 /**
  * Maps directory name matches into a dotted package name. This is
- * useful for matching JUnit test cases againt their XML formatter
+ * useful for matching JUnit test cases against their XML formatter
  * results.
  * <pre>
  * &lt;mapper classname="org.apache.tools.ant.util.PackageNameMapper"
  *         from="*Test.java" to="${test.data.dir}/TEST-*Test.xml"/&gt;
  * </pre>
  *
  */
 public class PackageNameMapper extends GlobPatternMapper {
     /**
      *  Returns the part of the given string that matches the * in the
      *  &quot;from&quot; pattern replacing file separators with dots
      *
      *@param  name  Source filename
      *@return       Replaced variable part
      */
     protected String extractVariablePart(String name) {
         String var = name.substring(prefixLength,
                 name.length() - postfixLength);
         if (getHandleDirSep()) {
             var = name.replace('/', '.').replace('\\', '.');
         }
         return var.replace(File.separatorChar, '.');
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/util/RegexpPatternMapper.java b/src/main/org/apache/tools/ant/util/RegexpPatternMapper.java
index 5d8d0f5e5..9265207d6 100644
--- a/src/main/org/apache/tools/ant/util/RegexpPatternMapper.java
+++ b/src/main/org/apache/tools/ant/util/RegexpPatternMapper.java
@@ -1,158 +1,158 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.util;
 
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.util.regexp.RegexpMatcher;
 import org.apache.tools.ant.util.regexp.RegexpMatcherFactory;
 import org.apache.tools.ant.util.regexp.RegexpUtil;
 
 /**
  * Implementation of FileNameMapper that does regular expression
  * replacements.
  *
  */
 public class RegexpPatternMapper implements FileNameMapper {
 
     private static final int DECIMAL = 10;
 
     // CheckStyle:VisibilityModifier OFF - bc
     protected RegexpMatcher reg = null;
     protected char[] to = null;
     protected StringBuffer result = new StringBuffer();
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Constructor for RegexpPatternMapper.
      * @throws BuildException on error.
      */
     public RegexpPatternMapper() throws BuildException {
         reg = (new RegexpMatcherFactory()).newRegexpMatcher();
     }
 
     private boolean handleDirSep = false;
     private int     regexpOptions = 0;
 
     /**
-     * Attribute specifing whether to ignore the difference
+     * Attribute specifying whether to ignore the difference
      * between / and \ (the two common directory characters).
      * @param handleDirSep a boolean, default is false.
      * @since Ant 1.6.3
      */
     public void setHandleDirSep(boolean handleDirSep) {
         this.handleDirSep = handleDirSep;
     }
 
     /**
-     * Attribute specifing whether to ignore the case difference
+     * Attribute specifying whether to ignore the case difference
      * in the names.
      *
      * @param caseSensitive a boolean, default is false.
      * @since Ant 1.6.3
      */
     public void setCaseSensitive(boolean caseSensitive) {
         regexpOptions = RegexpUtil.asOptions(caseSensitive);
     }
 
     /**
      * Sets the &quot;from&quot; pattern. Required.
      * @param from the from pattern.
      * @throws BuildException on error.
      */
     public void setFrom(String from) throws BuildException {
         if (from != null) {
             try {
                 reg.setPattern(from);
             } catch (NoClassDefFoundError e) {
                 // depending on the implementation the actual RE won't
                 // get instantiated in the constructor.
                 throw new BuildException("Cannot load regular expression matcher",
                                          e);
             }
         } else {
             throw new BuildException("this mapper requires a 'from' attribute");
         }
     }
 
     /**
      * Sets the &quot;to&quot; pattern. Required.
      * @param to the to pattern.
      * @throws BuildException on error.
      */
     public void setTo(String to) {
         if (to != null) {
             this.to = to.toCharArray();
         } else {
             throw new BuildException("this mapper requires a 'to' attribute");
         }
     }
 
     /**
      * Returns null if the source file name doesn't match the
      * &quot;from&quot; pattern, an one-element array containing the
      * translated file otherwise.
      * @param sourceFileName the source file name
      * @return a one-element array containing the translated file or
      *         null if the to pattern did not match
      */
     public String[] mapFileName(String sourceFileName) {
         if (handleDirSep) {
             if (sourceFileName.indexOf("\\") != -1) {
                 sourceFileName = sourceFileName.replace('\\', '/');
             }
         }
         if (reg == null  || to == null
             || !reg.matches(sourceFileName, regexpOptions)) {
             return null;
         }
         return new String[] {replaceReferences(sourceFileName)};
     }
 
     /**
      * Replace all backreferences in the to pattern with the matched
      * groups of the source.
      * @param source the source file name.
      * @return the translated file name.
      */
     protected String replaceReferences(String source) {
         Vector v = reg.getGroups(source, regexpOptions);
 
         result.setLength(0);
         for (int i = 0; i < to.length; i++) {
             if (to[i] == '\\') {
                 if (++i < to.length) {
                     int value = Character.digit(to[i], DECIMAL);
                     if (value > -1) {
                         result.append((String) v.elementAt(value));
                     } else {
                         result.append(to[i]);
                     }
                 } else {
                     // XXX - should throw an exception instead?
                     result.append('\\');
                 }
             } else {
                 result.append(to[i]);
             }
         }
         return result.substring(0);
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/util/ResourceUtils.java b/src/main/org/apache/tools/ant/util/ResourceUtils.java
index d1f4876a2..e572a553c 100644
--- a/src/main/org/apache/tools/ant/util/ResourceUtils.java
+++ b/src/main/org/apache/tools/ant/util/ResourceUtils.java
@@ -1,782 +1,782 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Reader;
 import java.nio.channels.FileChannel;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.Vector;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectComponent;
 import org.apache.tools.ant.filters.util.ChainReaderHelper;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.TimeComparison;
 import org.apache.tools.ant.types.ResourceFactory;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.FilterSetCollection;
 import org.apache.tools.ant.types.resources.Appendable;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.types.resources.Restrict;
 import org.apache.tools.ant.types.resources.Resources;
 import org.apache.tools.ant.types.resources.Touchable;
 import org.apache.tools.ant.types.resources.selectors.Date;
 import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
 import org.apache.tools.ant.types.selectors.SelectorUtils;
 
 // CheckStyle:HideUtilityClassConstructorCheck OFF - bc
 
 /**
  * This class provides utility methods to process Resources.
  *
  * @since Ant 1.5.2
  */
 public class ResourceUtils {
 
     /** Utilities used for file operations */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Name of charset "ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1".
      *
      * @since Ant 1.8.1
      */
     public static final String ISO_8859_1 = "ISO-8859-1";
 
     private static final long MAX_IO_CHUNK_SIZE = 16*1024*1024; // 16 MB
 
     /**
      * Tells which source files should be reprocessed based on the
      * last modification date of target files.
      * @param logTo where to send (more or less) interesting output.
      * @param source array of resources bearing relative path and last
      * modification date.
      * @param mapper filename mapper indicating how to find the target
      * files.
      * @param targets object able to map as a resource a relative path
      * at <b>destination</b>.
      * @return array containing the source files which need to be
      * copied or processed, because the targets are out of date or do
      * not exist.
      */
     public static Resource[] selectOutOfDateSources(ProjectComponent logTo,
                                                     Resource[] source,
                                                     FileNameMapper mapper,
                                                     ResourceFactory targets) {
         return selectOutOfDateSources(logTo, source, mapper, targets,
                                       FILE_UTILS.getFileTimestampGranularity());
     }
 
     /**
      * Tells which source files should be reprocessed based on the
      * last modification date of target files.
      * @param logTo where to send (more or less) interesting output.
      * @param source array of resources bearing relative path and last
      * modification date.
      * @param mapper filename mapper indicating how to find the target
      * files.
      * @param targets object able to map as a resource a relative path
      * at <b>destination</b>.
      * @param granularity The number of milliseconds leeway to give
      * before deciding a target is out of date.
      * @return array containing the source files which need to be
      * copied or processed, because the targets are out of date or do
      * not exist.
      * @since Ant 1.6.2
      */
     public static Resource[] selectOutOfDateSources(ProjectComponent logTo,
                                                     Resource[] source,
                                                     FileNameMapper mapper,
                                                     ResourceFactory targets,
                                                     long granularity) {
         Union u = new Union();
         u.addAll(Arrays.asList(source));
         ResourceCollection rc
             = selectOutOfDateSources(logTo, u, mapper, targets, granularity);
         return rc.size() == 0 ? new Resource[0] : ((Union) rc).listResources();
     }
 
     /**
      * Tells which sources should be reprocessed based on the
      * last modification date of targets.
      * @param logTo where to send (more or less) interesting output.
      * @param source ResourceCollection.
      * @param mapper filename mapper indicating how to find the target Resources.
      * @param targets object able to map a relative path as a Resource.
      * @param granularity The number of milliseconds leeway to give
      * before deciding a target is out of date.
      * @return ResourceCollection.
      * @since Ant 1.7
      */
     public static ResourceCollection selectOutOfDateSources(ProjectComponent logTo,
                                                             ResourceCollection source,
                                                             FileNameMapper mapper,
                                                             ResourceFactory targets,
                                                             final long granularity) {
         logFuture(logTo, source, granularity);
         ResourceSelectorProvider p = 
             new ResourceSelectorProvider() {
                 public ResourceSelector
                     getTargetSelectorForSource(final Resource sr) {
                     return new ResourceSelector() {
                         public boolean isSelected(Resource target) {
                             /* Extra I/O, probably wasted:
                                if (target.isDirectory()) {
                                return false;
                                }
                             */
                             return SelectorUtils.isOutOfDate(sr, target,
                                                              granularity);
                         }
                     };
                 }
             };
         return selectSources(logTo, source, mapper, targets, p);
     }
 
     /**
      * Tells which sources should be reprocessed because the given
      * selector selects at least one target.
      * 
      * @param logTo where to send (more or less) interesting output.
      * @param source ResourceCollection.
      * @param mapper filename mapper indicating how to find the target Resources.
      * @param targets object able to map a relative path as a Resource.
      * @param selector returns a selector that is applied to target
      * files.  If it selects at least one target the source will be
      * added to the returned collection.
      * @return ResourceCollection.
      * @since Ant 1.8.0
      */
     public static ResourceCollection selectSources(ProjectComponent logTo,
                                                    ResourceCollection source,
                                                    FileNameMapper mapper,
                                                    ResourceFactory targets,
                                                    ResourceSelectorProvider selector) {
         if (source.size() == 0) {
             logTo.log("No sources found.", Project.MSG_VERBOSE);
             return Resources.NONE;
         }
         source = Union.getInstance(source);
 
         Union result = new Union();
         for (Resource sr : source) {
             String srName = sr.getName();
             srName = srName == null
                 ? srName : srName.replace('/', File.separatorChar);
 
             String[] targetnames = null;
             try {
                 targetnames = mapper.mapFileName(srName);
             } catch (Exception e) {
                 logTo.log("Caught " + e + " mapping resource " + sr,
                     Project.MSG_VERBOSE);
             }
             if (targetnames == null || targetnames.length == 0) {
                 logTo.log(sr + " skipped - don\'t know how to handle it",
                       Project.MSG_VERBOSE);
                 continue;
             }
             for (int i = 0; i < targetnames.length; i++) {
                 if (targetnames[i] == null) {
                     targetnames[i] = "(no name)";
                 }
             }
             Union targetColl = new Union();
             for (int i = 0; i < targetnames.length; i++) {
                 targetColl.add(targets.getResource(
                     targetnames[i].replace(File.separatorChar, '/')));
             }
             //find the out-of-date targets:
             Restrict r = new Restrict();
             r.add(selector.getTargetSelectorForSource(sr));
             r.add(targetColl);
             if (r.size() > 0) {
                 result.add(sr);
                 Resource t = r.iterator().next();
                 logTo.log(sr.getName() + " added as " + t.getName()
                     + (t.isExists() ? " is outdated." : " doesn\'t exist."),
                     Project.MSG_VERBOSE);
                 continue;
             }
             //log uptodateness of all targets:
             logTo.log(sr.getName()
                   + " omitted as " + targetColl.toString()
                   + (targetColl.size() == 1 ? " is" : " are ")
                   + " up to date.", Project.MSG_VERBOSE);
         }
         return result;
     }
 
     /**
      * Convenience method to copy content from one Resource to another.
      * No filtering is performed.
      *
      * @param source the Resource to copy from.
      *                   Must not be <code>null</code>.
      * @param dest   the Resource to copy to.
      *                 Must not be <code>null</code>.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.7
      */
     public static void copyResource(Resource source, Resource dest) throws IOException {
         copyResource(source, dest, null);
     }
 
     /**
      * Convenience method to copy content from one Resource to another.
      * No filtering is performed.
      *
      * @param source the Resource to copy from.
      *                   Must not be <code>null</code>.
      * @param dest   the Resource to copy to.
      *                 Must not be <code>null</code>.
      * @param project the project instance.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.7
      */
     public static void copyResource(Resource source, Resource dest, Project project)
         throws IOException {
         copyResource(source, dest, null, null, false,
                      false, null, null, project);
     }
 
     // CheckStyle:ParameterNumberCheck OFF - bc
     /**
      * Convenience method to copy content from one Resource to another
      * specifying whether token filtering must be used, whether filter chains
      * must be used, whether newer destination files may be overwritten and
      * whether the last modified time of <code>dest</code> file should be made
      * equal to the last modified time of <code>source</code>.
      *
      * @param source the Resource to copy from.
      *                   Must not be <code>null</code>.
      * @param dest   the Resource to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination Resource should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the destination Resource should be set to that
      *                             of the source.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.7
      */
     public static void copyResource(Resource source, Resource dest,
                              FilterSetCollection filters, Vector filterChains,
                              boolean overwrite, boolean preserveLastModified,
                              String inputEncoding, String outputEncoding,
                              Project project)
         throws IOException {
         copyResource(source, dest, filters, filterChains, overwrite, preserveLastModified, false, inputEncoding, outputEncoding, project);
     }
 
     // CheckStyle:ParameterNumberCheck OFF - bc
     /**
      * Convenience method to copy content from one Resource to another
      * specifying whether token filtering must be used, whether filter chains
      * must be used, whether newer destination files may be overwritten and
      * whether the last modified time of <code>dest</code> file should be made
      * equal to the last modified time of <code>source</code>.
      *
      * @param source the Resource to copy from.
      *                   Must not be <code>null</code>.
      * @param dest   the Resource to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination Resource should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the destination Resource should be set to that
      *                             of the source.
      * @param append Whether to append to an Appendable Resource.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.8
      */
     public static void copyResource(Resource source, Resource dest,
                             FilterSetCollection filters, Vector filterChains,
                             boolean overwrite, boolean preserveLastModified,
                                     boolean append,
                             String inputEncoding, String outputEncoding,
                             Project project)
         throws IOException {
         copyResource(source, dest, filters, filterChains, overwrite,
                      preserveLastModified, append, inputEncoding,
                      outputEncoding, project, /* force: */ false);
     }
 
     /**
      * Convenience method to copy content from one Resource to another
      * specifying whether token filtering must be used, whether filter chains
      * must be used, whether newer destination files may be overwritten and
      * whether the last modified time of <code>dest</code> file should be made
      * equal to the last modified time of <code>source</code>.
      *
      * @param source the Resource to copy from.
      *                   Must not be <code>null</code>.
      * @param dest   the Resource to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination Resource should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the destination Resource should be set to that
      *                             of the source.
      * @param append Whether to append to an Appendable Resource.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
-     * @param force whether read-only taret files will be overwritten
+     * @param force whether read-only target files will be overwritten
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.8.2
      */
     public static void copyResource(Resource source, Resource dest,
                             FilterSetCollection filters, Vector filterChains,
                             boolean overwrite, boolean preserveLastModified,
                                     boolean append,
                                     String inputEncoding, String outputEncoding,
                                     Project project, boolean force)
         throws IOException {
         if (!(overwrite || SelectorUtils.isOutOfDate(source, dest, FileUtils.getFileUtils()
                 .getFileTimestampGranularity()))) {
             return;
         }
         final boolean filterSetsAvailable = (filters != null
                                              && filters.hasFilters());
         final boolean filterChainsAvailable = (filterChains != null
                                                && filterChains.size() > 0);
 
         File destFile = null;
         if (dest.as(FileProvider.class) != null) {
             destFile = dest.as(FileProvider.class).getFile();
         }
         if (destFile != null && destFile.isFile() && !destFile.canWrite()) {
             if (!force) {
                 throw new IOException("can't write to read-only destination "
                                       + "file " + destFile);
             } else if (!FILE_UTILS.tryHardToDelete(destFile)) {
                 throw new IOException("failed to delete read-only "
                                       + "destination file " + destFile);
             }
         }
 
         if (filterSetsAvailable) {
             BufferedReader in = null;
             BufferedWriter out = null;
             try {
                 InputStreamReader isr = null;
                 if (inputEncoding == null) {
                     isr = new InputStreamReader(source.getInputStream());
                 } else {
                     isr = new InputStreamReader(source.getInputStream(),
                                                 inputEncoding);
                 }
                 in = new BufferedReader(isr);
                 OutputStream os = getOutputStream(dest, append, project);
                 OutputStreamWriter osw;
                 if (outputEncoding == null) {
                     osw = new OutputStreamWriter(os);
                 } else {
                     osw = new OutputStreamWriter(os, outputEncoding);
                 }
                 out = new BufferedWriter(osw);
                 if (filterChainsAvailable) {
                     ChainReaderHelper crh = new ChainReaderHelper();
                     crh.setBufferSize(FileUtils.BUF_SIZE);
                     crh.setPrimaryReader(in);
                     crh.setFilterChains(filterChains);
                     crh.setProject(project);
                     Reader rdr = crh.getAssembledReader();
                     in = new BufferedReader(rdr);
                 }
                 LineTokenizer lineTokenizer = new LineTokenizer();
                 lineTokenizer.setIncludeDelims(true);
                 String newline = null;
                 String line = lineTokenizer.getToken(in);
                 while (line != null) {
                     if (line.length() == 0) {
                         // this should not happen, because the lines are
                         // returned with the end of line delimiter
                         out.newLine();
                     } else {
                         newline = filters.replaceTokens(line);
                         out.write(newline);
                     }
                     line = lineTokenizer.getToken(in);
                 }
             } finally {
                 FileUtils.close(out);
                 FileUtils.close(in);
             }
         } else if (filterChainsAvailable
                    || (inputEncoding != null
                        && !inputEncoding.equals(outputEncoding))
                    || (inputEncoding == null && outputEncoding != null)) {
             BufferedReader in = null;
             BufferedWriter out = null;
             try {
                 InputStreamReader isr = null;
                 if (inputEncoding == null) {
                     isr = new InputStreamReader(source.getInputStream());
                 } else {
                     isr = new InputStreamReader(source.getInputStream(),
                                                 inputEncoding);
                 }
                 in = new BufferedReader(isr);
                 OutputStream os = getOutputStream(dest, append, project);
                 OutputStreamWriter osw;
                 if (outputEncoding == null) {
                     osw = new OutputStreamWriter(os);
                 } else {
                     osw = new OutputStreamWriter(os, outputEncoding);
                 }
                 out = new BufferedWriter(osw);
                 if (filterChainsAvailable) {
                     ChainReaderHelper crh = new ChainReaderHelper();
                     crh.setBufferSize(FileUtils.BUF_SIZE);
                     crh.setPrimaryReader(in);
                     crh.setFilterChains(filterChains);
                     crh.setProject(project);
                     Reader rdr = crh.getAssembledReader();
                     in = new BufferedReader(rdr);
                 }
                 char[] buffer = new char[FileUtils.BUF_SIZE];
                 while (true) {
                     int nRead = in.read(buffer, 0, buffer.length);
                     if (nRead == -1) {
                         break;
                     }
                     out.write(buffer, 0, nRead);
                 }
             } finally {
                 FileUtils.close(out);
                 FileUtils.close(in);
             }
         } else if (source.as(FileProvider.class) != null
                    && destFile != null) {
             File sourceFile =
                 source.as(FileProvider.class).getFile();
 
             File parent = destFile.getParentFile();
             if (parent != null && !parent.isDirectory()
                 && !destFile.getParentFile().mkdirs()) {
                 throw new IOException("failed to create the parent directory"
                                       + " for " + destFile);
             }
 
             FileInputStream in = null;
             FileOutputStream out = null;
             FileChannel srcChannel = null;
             FileChannel destChannel = null;
 
             try {
                 in = new FileInputStream(sourceFile);
                 out = new FileOutputStream(destFile);
                     
                 srcChannel = in.getChannel();
                 destChannel = out.getChannel();
                 
                 long position = 0;
                 long count = srcChannel.size();
                 while (position < count) {
                     long chunk = Math.min(MAX_IO_CHUNK_SIZE, count - position);
                     position +=
                         destChannel.transferFrom(srcChannel, position, chunk);
                 }
             } finally {
                 FileUtils.close(srcChannel);
                 FileUtils.close(destChannel);
                 FileUtils.close(out);
                 FileUtils.close(in);
             }
         } else {
             InputStream in = null;
             OutputStream out = null;
             try {
                 in = source.getInputStream();
                 out = getOutputStream(dest, append, project);
 
                 byte[] buffer = new byte[FileUtils.BUF_SIZE];
                 int count = 0;
                 do {
                     out.write(buffer, 0, count);
                     count = in.read(buffer, 0, buffer.length);
                 } while (count != -1);
             } finally {
                 FileUtils.close(out);
                 FileUtils.close(in);
             }
         }
         if (preserveLastModified) {
             Touchable t = dest.as(Touchable.class);
             if (t != null) {
                 setLastModified(t, source.getLastModified());
             }
         }
     }
     // CheckStyle:ParameterNumberCheck ON
 
     /**
      * Set the last modified time of an object implementing
      * org.apache.tools.ant.types.resources.Touchable .
      *
      * @param t the Touchable whose modified time is to be set.
      * @param time the time to which the last modified time is to be set.
      *             if this is -1, the current time is used.
      * @since Ant 1.7
      */
     public static void setLastModified(Touchable t, long time) {
         t.touch((time < 0) ? System.currentTimeMillis() : time);
     }
 
     /**
      * Compares the contents of two Resources.
      *
      * @param r1 the Resource whose content is to be compared.
      * @param r2 the other Resource whose content is to be compared.
      * @param text true if the content is to be treated as text and
      *        differences in kind of line break are to be ignored.
      *
      * @return true if the content of the Resources is the same.
      *
      * @throws IOException if the Resources cannot be read.
      * @since Ant 1.7
      */
     public static boolean contentEquals(Resource r1, Resource r2, boolean text) throws IOException {
         if (r1.isExists() != r2.isExists()) {
             return false;
         }
         if (!r1.isExists()) {
             // two not existing files are equal
             return true;
         }
         // should the following two be switched?  If r1 and r2 refer to the same file,
         // isn't their content equal regardless of whether that file is a directory?
         if (r1.isDirectory() || r2.isDirectory()) {
             // don't want to compare directory contents for now
             return false;
         }
         if (r1.equals(r2)) {
             return true;
         }
         if (!text) {
             long s1 = r1.getSize();
             long s2 = r2.getSize();
             if (s1 != Resource.UNKNOWN_SIZE && s2 != Resource.UNKNOWN_SIZE
                     && s1 != s2) {
                 return false;
             }
         }
         return compareContent(r1, r2, text) == 0;
     }
 
     /**
      * Compare the content of two Resources. A nonexistent Resource's
      * content is "less than" that of an existing Resource; a directory-type
      * Resource's content is "less than" that of a file-type Resource.
      * @param r1 the Resource whose content is to be compared.
      * @param r2 the other Resource whose content is to be compared.
      * @param text true if the content is to be treated as text and
      *        differences in kind of line break are to be ignored.
      * @return a negative integer, zero, or a positive integer as the first
      *         argument is less than, equal to, or greater than the second.
      * @throws IOException if the Resources cannot be read.
      * @since Ant 1.7
      */
     public static int compareContent(Resource r1, Resource r2, boolean text) throws IOException {
         if (r1.equals(r2)) {
             return 0;
         }
         boolean e1 = r1.isExists();
         boolean e2 = r2.isExists();
         if (!(e1 || e2)) {
             return 0;
         }
         if (e1 != e2) {
             return e1 ? 1 : -1;
         }
         boolean d1 = r1.isDirectory();
         boolean d2 = r2.isDirectory();
         if (d1 && d2) {
             return 0;
         }
         if (d1 || d2) {
             return d1 ? -1 : 1;
         }
         return text ? textCompare(r1, r2) : binaryCompare(r1, r2);
     }
 
     /**
      * Convenience method to turn any fileProvider into a basic
      * FileResource with the file's immediate parent as the basedir,
      * for tasks that need one.
      * @param fileProvider input
      * @return fileProvider if it is a FileResource instance, or a new
      * FileResource with fileProvider's file.
      * @since Ant 1.8
      */
     public static FileResource asFileResource(FileProvider fileProvider) {
         if (fileProvider instanceof FileResource || fileProvider == null) {
             return (FileResource) fileProvider;
         }
         FileResource result = new FileResource(fileProvider.getFile());
         result.setProject(Project.getProject(fileProvider));
         return result;
     }
 
     /**
      * Binary compares the contents of two Resources.
      * <p>
      * simple but sub-optimal comparision algorithm. written for working
      * rather than fast. Better would be a block read into buffers followed
      * by long comparisions apart from the final 1-7 bytes.
      * </p>
      *
      * @param r1 the Resource whose content is to be compared.
      * @param r2 the other Resource whose content is to be compared.
      * @return a negative integer, zero, or a positive integer as the first
      *         argument is less than, equal to, or greater than the second.
      * @throws IOException if the Resources cannot be read.
      * @since Ant 1.7
      */
     private static int binaryCompare(Resource r1, Resource r2) throws IOException {
         InputStream in1 = null;
         InputStream in2 = null;
         try {
             in1 = new BufferedInputStream(r1.getInputStream());
             in2 = new BufferedInputStream(r2.getInputStream());
 
             for (int b1 = in1.read(); b1 != -1; b1 = in1.read()) {
                 int b2 = in2.read();
                 if (b1 != b2) {
                     return b1 > b2 ? 1 : -1;
                 }
             }
             return in2.read() == -1 ? 0 : -1;
         } finally {
             FileUtils.close(in1);
             FileUtils.close(in2);
         }
     }
 
     /**
      * Text compares the contents of two Resources.
      * Ignores different kinds of line endings.
      * @param r1 the Resource whose content is to be compared.
      * @param r2 the other Resource whose content is to be compared.
      * @return a negative integer, zero, or a positive integer as the first
      *         argument is less than, equal to, or greater than the second.
      * @throws IOException if the Resources cannot be read.
      * @since Ant 1.7
      */
     private static int textCompare(Resource r1, Resource r2) throws IOException {
         BufferedReader in1 = null;
         BufferedReader in2 = null;
         try {
             in1 = new BufferedReader(new InputStreamReader(r1.getInputStream()));
             in2 = new BufferedReader(new InputStreamReader(r2.getInputStream()));
 
             String expected = in1.readLine();
             while (expected != null) {
                 String actual = in2.readLine();
                 if (!expected.equals(actual)) {
                     if (actual == null) {
                         return 1;
                     }
                     return expected.compareTo(actual);
                 }
                 expected = in1.readLine();
             }
             return in2.readLine() == null ? 0 : -1;
         } finally {
             FileUtils.close(in1);
             FileUtils.close(in2);
         }
     }
 
     /**
      * Log which Resources (if any) have been modified in the future.
      * @param logTo the ProjectComponent to do the logging.
      * @param rc the collection of Resources to check.
      * @param granularity the timestamp granularity to use.
      * @since Ant 1.7
      */
     private static void logFuture(ProjectComponent logTo,
                                   ResourceCollection rc, long granularity) {
         long now = System.currentTimeMillis() + granularity;
         Date sel = new Date();
         sel.setMillis(now);
         sel.setWhen(TimeComparison.AFTER);
         Restrict future = new Restrict();
         future.add(sel);
         future.add(rc);
         for (Resource r : future) {
             logTo.log("Warning: " + r.getName() + " modified in the future.", Project.MSG_WARN);
         }
     }
 
     private static OutputStream getOutputStream(Resource resource, boolean append, Project project)
             throws IOException {
         if (append) {
             Appendable a = resource.as(Appendable.class);
             if (a != null) {
                 return a.getAppendOutputStream();
             }
             project.log("Appendable OutputStream not available for non-appendable resource "
                     + resource + "; using plain OutputStream", Project.MSG_VERBOSE);
         }
         return resource.getOutputStream();
     }
 
     public static interface ResourceSelectorProvider {
         ResourceSelector getTargetSelectorForSource(Resource source);
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/ScriptRunner.java b/src/main/org/apache/tools/ant/util/ScriptRunner.java
index 1bc2adc2b..735e55557 100644
--- a/src/main/org/apache/tools/ant/util/ScriptRunner.java
+++ b/src/main/org/apache/tools/ant/util/ScriptRunner.java
@@ -1,27 +1,27 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 /**
- * This class is here for backwards compatiblity.
+ * This class is here for backwards compatibility.
  * @deprecated Implementation moved to another location. Use
  *             that org.apache.tools.ant.types.optional.ScriptRunner instead.
  */
 public class ScriptRunner
     extends org.apache.tools.ant.util.optional.ScriptRunner {
 }
diff --git a/src/main/org/apache/tools/ant/util/SymbolicLinkUtils.java b/src/main/org/apache/tools/ant/util/SymbolicLinkUtils.java
index bac58c46a..f52ea0d03 100644
--- a/src/main/org/apache/tools/ant/util/SymbolicLinkUtils.java
+++ b/src/main/org/apache/tools/ant/util/SymbolicLinkUtils.java
@@ -1,294 +1,294 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FilenameFilter;
 import java.io.IOException;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.Execute;
 
 /**
  * Contains methods related to symbolic links - or what Ant thinks is
  * a symbolic link based on the absent support for them in Java.
  *
  * @since Ant 1.8.0
  */
 public class SymbolicLinkUtils {
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Shared instance.
      */
     private static final SymbolicLinkUtils PRIMARY_INSTANCE =
         new SymbolicLinkUtils();
 
     /**
      * Method to retrieve The SymbolicLinkUtils, which is shared by
      * all users of this method.
      * @return an instance of SymbolicLinkUtils.
      */
     public static SymbolicLinkUtils getSymbolicLinkUtils() {
         // keep the door open for Java X.Y specific subclass if symbolic
         // links ever become supported in the classlib
         return PRIMARY_INSTANCE;
     }
 
     /**
      * Empty constructor.
      */
     protected SymbolicLinkUtils() {
     }
 
     /**
      * Checks whether a given file is a symbolic link.
      *
      * <p>It doesn't really test for symbolic links but whether the
      * canonical and absolute paths of the file are identical--this
      * may lead to false positives on some platforms.</p>
      *
      * @param file the file to test.  Must not be null.
      *
      * @return true if the file is a symbolic link.
      * @throws IOException on error.
      */
     public boolean isSymbolicLink(File file) throws IOException {
         return isSymbolicLink(file.getParentFile(), file.getName());
     }
 
     /**
      * Checks whether a given file is a symbolic link.
      *
      * <p>It doesn't really test for symbolic links but whether the
      * canonical and absolute paths of the file are identical--this
      * may lead to false positives on some platforms.</p>
      *
      * @param name the name of the file to test.
      *
      * @return true if the file is a symbolic link.
      * @throws IOException on error.
      */
     public boolean isSymbolicLink(String name) throws IOException {
         return isSymbolicLink(new File(name));
     }
 
     /**
      * Checks whether a given file is a symbolic link.
      *
      * <p>It doesn't really test for symbolic links but whether the
      * canonical and absolute paths of the file are identical--this
      * may lead to false positives on some platforms.</p>
      *
      * @param parent the parent directory of the file to test
      * @param name the name of the file to test.
      *
      * @return true if the file is a symbolic link.
      * @throws IOException on error.
      */
     public boolean isSymbolicLink(File parent, String name)
         throws IOException {
         File toTest = parent != null
             ? new File(parent.getCanonicalPath(), name)
             : new File(name);
         return !toTest.getAbsolutePath().equals(toTest.getCanonicalPath());
     }
 
     /**
      * Checks whether a given file is a broken symbolic link.
      *
      * <p>It doesn't really test for symbolic links but whether Java
      * reports that the File doesn't exist but its parent's child list
      * contains it--this may lead to false positives on some
      * platforms.</p>
      *
      * <p>Note that #isSymbolicLink returns false if this method
      * returns true since Java won't produce a canonical name
      * different from the abolute one if the link is broken.</p>
      *
      * @param name the name of the file to test.
      *
      * @return true if the file is a broken symbolic link.
      * @throws IOException on error.
      */
     public boolean isDanglingSymbolicLink(String name) throws IOException {
         return isDanglingSymbolicLink(new File(name));
     }
 
     /**
      * Checks whether a given file is a broken symbolic link.
      *
      * <p>It doesn't really test for symbolic links but whether Java
      * reports that the File doesn't exist but its parent's child list
      * contains it--this may lead to false positives on some
      * platforms.</p>
      *
      * <p>Note that #isSymbolicLink returns false if this method
      * returns true since Java won't produce a canonical name
      * different from the abolute one if the link is broken.</p>
      *
      * @param file the file to test.
      *
      * @return true if the file is a broken symbolic link.
      * @throws IOException on error.
      */
     public boolean isDanglingSymbolicLink(File file) throws IOException {
         return isDanglingSymbolicLink(file.getParentFile(), file.getName());
     }
 
     /**
      * Checks whether a given file is a broken symbolic link.
      *
      * <p>It doesn't really test for symbolic links but whether Java
      * reports that the File doesn't exist but its parent's child list
      * contains it--this may lead to false positives on some
      * platforms.</p>
      *
      * <p>Note that #isSymbolicLink returns false if this method
      * returns true since Java won't produce a canonical name
      * different from the abolute one if the link is broken.</p>
      *
      * @param parent the parent directory of the file to test
      * @param name the name of the file to test.
      *
      * @return true if the file is a broken symbolic link.
      * @throws IOException on error.
      */
     public boolean isDanglingSymbolicLink(File parent, String name) 
         throws IOException {
         File f = new File(parent, name);
         if (!f.exists()) {
             final String localName = f.getName();
             String[] c = parent.list(new FilenameFilter() {
                     public boolean accept(File d, String n) {
                         return localName.equals(n);
                     }
                 });
             return c != null && c.length > 0;
         }
         return false;
     }
 
     /**
      * Delete a symlink (without deleting the associated resource).
      *
      * <p>This is a utility method that removes a unix symlink without
      * removing the resource that the symlink points to. If it is
      * accidentally invoked on a real file, the real file will not be
      * harmed, but silently ignored.</p>
      *
-     * <p>Normaly this method works by
+     * <p>Normally this method works by
      * getting the canonical path of the link, using the canonical path to
      * rename the resource (breaking the link) and then deleting the link.
      * The resource is then returned to its original name inside a finally
      * block to ensure that the resource is unharmed even in the event of
      * an exception.</p>
      *
      * <p>There may be cases where the algorithm described above doesn't work,
      * in that case the method tries to use the native "rm" command on
      * the symlink instead.</p>
      *
      * @param link A <code>File</code> object of the symlink to delete.
      * @param task An Ant Task required if "rm" needs to be invoked.
      *
      * @throws IOException If calls to <code>File.rename</code>,
      * <code>File.delete</code> or <code>File.getCanonicalPath</code>
      * fail.
      * @throws BuildException if the execution of "rm" failed.
      */
     public void deleteSymbolicLink(File link, Task task)
         throws IOException {
         if (isDanglingSymbolicLink(link)) {
             if (!link.delete()) {
                 throw new IOException("failed to remove dangling symbolic link "
                                       + link);
             }
             return;
         }
 
         if (!isSymbolicLink(link)) {
             // plain file, not a link
             return;
         }
 
         if (!link.exists()) {
             throw new FileNotFoundException("No such symbolic link: " + link);
         }
 
         // find the resource of the existing link:
         File target = link.getCanonicalFile();
 
         // no reason to try the renaming algorithm if we aren't allowed to
         // write to the target's parent directory.  Let's hope that
         // File.canWrite works on all platforms.
 
         if (task == null || target.getParentFile().canWrite()) {
 
             // rename the resource, thus breaking the link:
             File temp = FILE_UTILS.createTempFile("symlink", ".tmp",
                                                   target.getParentFile(), false,
                                                   false);
 
             if (FILE_UTILS.isLeadingPath(target, link)) {
                 // link points to a parent directory, renaming the parent
                 // will rename the file
                 link = new File(temp,
                                 FILE_UTILS.removeLeadingPath(target, link));
             }
 
             boolean renamedTarget = false;
             try {
                 try {
                     FILE_UTILS.rename(target, temp);
                     renamedTarget = true;
                 } catch (IOException e) {
                     throw new IOException("Couldn't rename resource when "
                                           + "attempting to delete '" + link
                                           + "'.  Reason: " + e.getMessage());
                 }
                 // delete the (now) broken link:
                 if (!link.delete()) {
                     throw new IOException("Couldn't delete symlink: "
                                           + link
                                           + " (was it a real file? is this "
                                           + "not a UNIX system?)");
                 }
             } finally {
                 if (renamedTarget) {
                     // return the resource to its original name:
                     try {
                         FILE_UTILS.rename(temp, target);
                     } catch (IOException e) {
                         throw new IOException("Couldn't return resource "
                                               + temp
                                               + " to its original name: "
                                               + target.getAbsolutePath()
                                               + ". Reason: " + e.getMessage()
                                               + "\n THE RESOURCE'S NAME ON DISK"
                                               + " HAS BEEN CHANGED BY THIS"
                                               + " ERROR!\n");
                     }
                 }
             }
         } else {
             Execute.runCommand(task,
                                new String[] {"rm", link.getAbsolutePath()});
         }
     }
 
 }
\ No newline at end of file
diff --git a/src/main/org/apache/tools/ant/util/UUEncoder.java b/src/main/org/apache/tools/ant/util/UUEncoder.java
index 666b42220..1c17c6270 100644
--- a/src/main/org/apache/tools/ant/util/UUEncoder.java
+++ b/src/main/org/apache/tools/ant/util/UUEncoder.java
@@ -1,148 +1,148 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.io.InputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.PrintStream;
 
 /**
  * UUEncoding of an input stream placed into an outputstream.
  * This class is meant to be a drop in replacement for
  * sun.misc.UUEncoder, which was previously used by Ant.
  * The uuencode algorithm code has been copied from the
  * geronimo project.
  **/
 
 public class UUEncoder {
     protected static final int DEFAULT_MODE = 644;
     private static final int MAX_CHARS_PER_LINE = 45;
     private static final int INPUT_BUFFER_SIZE = MAX_CHARS_PER_LINE * 100;
     private OutputStream out;
     private String name;
 
     /**
-     * Constructor specifing a name for the encoded buffer, begin
+     * Constructor specifying a name for the encoded buffer, begin
      * line will be:
      * <pre>
      *   begin 644 [NAME]
      * </pre>
      * @param name the name of the encoded buffer.
      */
     public UUEncoder(String name) {
         this.name = name;
     }
 
     /**
      * UUEncode bytes from the input stream, and write them as text characters
      * to the output stream. This method will run until it exhausts the
      * input stream.
      * @param is the input stream.
      * @param out the output stream.
      * @throws IOException if there is an error.
      */
     public void encode(InputStream is, OutputStream out)
         throws IOException {
         this.out = out;
         encodeBegin();
         byte[] buffer = new byte[INPUT_BUFFER_SIZE];
         int count;
         while ((count = is.read(buffer, 0, buffer.length)) != -1) {
             int pos = 0;
             while (count > 0) {
                 int num = count > MAX_CHARS_PER_LINE
                     ? MAX_CHARS_PER_LINE
                     : count;
                 encodeLine(buffer, pos, num, out);
                 pos += num;
                 count -= num;
             }
         }
         out.flush();
         encodeEnd();
     }
 
     /**
      * Encode a string to the output.
      */
     private void encodeString(String n) throws IOException {
         PrintStream writer = new PrintStream(out);
         writer.print(n);
         writer.flush();
     }
 
     private void encodeBegin() throws IOException {
         encodeString("begin " + DEFAULT_MODE + " " + name + "\n");
     }
 
     private void encodeEnd() throws IOException {
         encodeString(" \nend\n");
     }
 
     /**
      * Encode a single line of data (less than or equal to 45 characters).
      *
      * @param data   The array of byte data.
      * @param off    The starting offset within the data.
      * @param length Length of the data to encode.
      * @param out    The output stream the encoded data is written to.
      *
      * @exception IOException
      */
     private void encodeLine(
         byte[] data, int offset, int length, OutputStream out)
         throws IOException {
         // write out the number of characters encoded in this line.
         // CheckStyle:MagicNumber OFF
         out.write((byte) ((length & 0x3F) + ' '));
         // CheckStyle:MagicNumber ON
         byte a;
         byte b;
         byte c;
 
         for (int i = 0; i < length;) {
             // set the padding defaults
             b = 1;
             c = 1;
             // get the next 3 bytes (if we have them)
             a = data[offset + i++];
             if (i < length) {
                 b = data[offset + i++];
                 if (i < length) {
                     c = data[offset + i++];
                 }
             }
 
             // CheckStyle:MagicNumber OFF
             byte d1 = (byte) (((a >>> 2) & 0x3F) + ' ');
             byte d2 = (byte) ((((a << 4) & 0x30) | ((b >>> 4) & 0x0F)) + ' ');
             byte d3 = (byte) ((((b << 2) & 0x3C) | ((c >>> 6) & 0x3)) + ' ');
             byte d4 = (byte) ((c & 0x3F) + ' ');
             // CheckStyle:MagicNumber ON
 
             out.write(d1);
             out.write(d2);
             out.write(d3);
             out.write(d4);
         }
 
         // terminate with a linefeed alone
         out.write('\n');
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/XmlConstants.java b/src/main/org/apache/tools/ant/util/XmlConstants.java
index fdf0343cf..3fae4d3c2 100644
--- a/src/main/org/apache/tools/ant/util/XmlConstants.java
+++ b/src/main/org/apache/tools/ant/util/XmlConstants.java
@@ -1,61 +1,61 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 /**
  * XML Parser constants, all kept in one place for ease of reuse
  * @see <a href="http://xml.apache.org/xerces-j/features.html">Xerces features</a>
  * @see <a href="http://xml.apache.org/xerces-j/properties.html">Xerces properties</a>
  * @see <a href=
  * "http://www.saxproject.org/apidoc/org/xml/sax/package-summary.html#package_description"
  * >SAX.</a>
  */
 
 public class XmlConstants {
     /** property for location of xml schema */
     public static final String PROPERTY_SCHEMA_LOCATION =
             "http://apache.org/xml/properties/schema/external-schemaLocation";
     /** property for location of no-name schema */
     public static final String PROPERTY_NO_NAMESPACE_SCHEMA_LOCATION =
             "http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation";
     /** property for full validation */
     public static final String FEATURE_XSD_FULL_VALIDATION =
             "http://apache.org/xml/features/validation/schema-full-checking";
     /** property for xsd */
     public static final String FEATURE_XSD = "http://apache.org/xml/features/validation/schema";
 
     /** property for validation */
     public static final String FEATURE_VALIDATION = "http://xml.org/sax/features/validation";
     /** property for namespace support */
     public static final String FEATURE_NAMESPACES = "http://xml.org/sax/features/namespaces";
     /** property for schema language */
     public static final String FEATURE_JAXP12_SCHEMA_LANGUAGE =
             "http://java.sun.com/xml/jaxp/properties/schemaLanguage";
     /** property for schema source */
     public static final String FEATURE_JAXP12_SCHEMA_SOURCE =
             "http://java.sun.com/xml/jaxp/properties/schemaSource";
     /** the namespace for XML schema */
     public static final String URI_XSD =
             "http://www.w3.org/2001/XMLSchema";
     /** the sax external entities feature */
     public static final String FEATURE_EXTERNAL_ENTITIES =
             "http://xml.org/sax/features/external-general-entities";
-    /** the apache.org/xml disalllow doctype decl feature */
+    /** the apache.org/xml disallow doctype decl feature */
     public static final String FEATURE_DISALLOW_DTD =
             "http://apache.org/xml/features/disallow-doctype-decl";
 }
diff --git a/src/main/org/apache/tools/ant/util/depend/bcel/AncestorAnalyzer.java b/src/main/org/apache/tools/ant/util/depend/bcel/AncestorAnalyzer.java
index a1724f55f..664f3b0b7 100644
--- a/src/main/org/apache/tools/ant/util/depend/bcel/AncestorAnalyzer.java
+++ b/src/main/org/apache/tools/ant/util/depend/bcel/AncestorAnalyzer.java
@@ -1,144 +1,144 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util.depend.bcel;
 import java.io.File;
 import java.io.IOException;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Vector;
 import org.apache.bcel.classfile.ClassParser;
 import org.apache.bcel.classfile.JavaClass;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.util.depend.AbstractAnalyzer;
 
 /**
  * A dependency analyzer which returns superclass and superinterface
  * dependencies.
  *
  */
 public class AncestorAnalyzer extends AbstractAnalyzer {
 
     /**
      * Default constructor
      *
      * Causes the BCEL classes to load to ensure BCEL dependencies can
      * be satisfied
      */
     public AncestorAnalyzer() {
         // force BCEL classes to load now
         try {
             new ClassParser("force");
         } catch (Exception e) {
             // all released versions of BCEL may throw an IOException
             // here, but BCEL's trunk does no longer declare to do so
             if (!(e instanceof IOException)) {
                 throw new BuildException(e);
             }
             // ignore IOException like we've always done
         }
     }
 
     /**
      * Determine the dependencies of the configured root classes.
      *
      * @param files a vector to be populated with the files which contain
      *      the dependency classes
      * @param classes a vector to be populated with the names of the
-     *      depencency classes.
+     *      dependency classes.
      */
     protected void determineDependencies(Vector files, Vector classes) {
         // we get the root classes and build up a set of
         // classes upon which they depend
         Hashtable dependencies = new Hashtable();
         Hashtable containers = new Hashtable();
         Hashtable toAnalyze = new Hashtable();
         Hashtable nextAnalyze = new Hashtable();
         for (Enumeration e = getRootClasses(); e.hasMoreElements();) {
             String classname = (String) e.nextElement();
             toAnalyze.put(classname, classname);
         }
 
         int count = 0;
         int maxCount = isClosureRequired() ? MAX_LOOPS : 2;
         while (toAnalyze.size() != 0 && count++ < maxCount) {
             nextAnalyze.clear();
             for (Enumeration e = toAnalyze.keys(); e.hasMoreElements();) {
                 String classname = (String) e.nextElement();
                 dependencies.put(classname, classname);
                 try {
                     File container = getClassContainer(classname);
                     if (container == null) {
                         continue;
                     }
                     containers.put(container, container);
 
                     ClassParser parser = null;
                     if (container.getName().endsWith(".class")) {
                         parser = new ClassParser(container.getPath());
                     } else {
                         parser = new ClassParser(container.getPath(),
                             classname.replace('.', '/') + ".class");
                     }
 
                     JavaClass javaClass = parser.parse();
                     String[] interfaces = javaClass.getInterfaceNames();
                     for (int i = 0; i < interfaces.length; ++i) {
                         String interfaceName = interfaces[i];
                         if (!dependencies.containsKey(interfaceName)) {
                             nextAnalyze.put(interfaceName, interfaceName);
                         }
                     }
 
                     if (javaClass.isClass()) {
                         String superClass = javaClass.getSuperclassName();
                         if (!dependencies.containsKey(superClass)) {
                             nextAnalyze.put(superClass, superClass);
                         }
                     }
                 } catch (IOException ioe) {
                     // ignore
                 }
             }
 
             Hashtable temp = toAnalyze;
             toAnalyze = nextAnalyze;
             nextAnalyze = temp;
         }
 
         files.removeAllElements();
         for (Enumeration e = containers.keys(); e.hasMoreElements();) {
             files.addElement((File) e.nextElement());
         }
 
         classes.removeAllElements();
         for (Enumeration e = dependencies.keys(); e.hasMoreElements();) {
             classes.addElement((String) e.nextElement());
         }
     }
 
     /**
      * Indicate if this analyzer can determine dependent files.
      *
      * @return true if the analyzer provides dependency file information.
      */
     protected boolean supportsFileDependencies() {
         return true;
     }
 
 }
 
diff --git a/src/main/org/apache/tools/ant/util/depend/bcel/DependencyVisitor.java b/src/main/org/apache/tools/ant/util/depend/bcel/DependencyVisitor.java
index 07bd388d4..5fd59a6ab 100644
--- a/src/main/org/apache/tools/ant/util/depend/bcel/DependencyVisitor.java
+++ b/src/main/org/apache/tools/ant/util/depend/bcel/DependencyVisitor.java
@@ -1,191 +1,191 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util.depend.bcel;
 
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.StringTokenizer;
 import org.apache.bcel.classfile.ConstantClass;
 import org.apache.bcel.classfile.ConstantPool;
 import org.apache.bcel.classfile.EmptyVisitor;
 import org.apache.bcel.classfile.Field;
 import org.apache.bcel.classfile.JavaClass;
 import org.apache.bcel.classfile.Method;
 import org.apache.bcel.classfile.ConstantNameAndType;
 
 /**
  * A BCEL visitor implementation to collect class dependency information
  *
  */
 public class DependencyVisitor extends EmptyVisitor {
     /** The collectd dependencies */
     private Hashtable dependencies = new Hashtable();
     /**
      * The current class's constant pool - used to determine class names
      * from class references.
      */
     private ConstantPool constantPool;
 
     /**
      * Get the dependencies collected by this visitor
      *
      * @return a Enumeration of classnames, being the classes upon which the
      *      visited classes depend.
      */
     public Enumeration getDependencies() {
         return dependencies.keys();
     }
 
-    /** Clear the curretn set of collected dependencies. */
+    /** Clear the current set of collected dependencies. */
     public void clearDependencies() {
         dependencies.clear();
     }
 
     /**
      * Visit the constant pool of a class
      *
      * @param constantPool the constant pool of the class being visited.
      */
     public void visitConstantPool(ConstantPool constantPool) {
         this.constantPool = constantPool;
     }
 
     /**
      * Visit a class reference
      *
      * @param constantClass the constantClass entry for the class reference
      */
     public void visitConstantClass(ConstantClass constantClass) {
         String classname
              = constantClass.getConstantValue(constantPool).toString();
         addSlashClass(classname);
     }
 
     /**
      * Visit a name and type ref
      *
      * Look for class references in this
      *
      * @param obj the name and type reference being visited.
      */
     public void visitConstantNameAndType(ConstantNameAndType obj) {
         String name = obj.getName(constantPool);
         if (obj.getSignature(constantPool).equals("Ljava/lang/Class;")
                 && name.startsWith("class$")) {
             String classname
                 = name.substring("class$".length()).replace('$', '.');
             // does the class have a package structure
             int index = classname.lastIndexOf(".");
             if (index > 0) {
                 char start;
                 // check if the package structure is more than 1 level deep
                 int index2 = classname.lastIndexOf(".", index - 1);
                 if (index2 != -1) {
                     // class name has more than 1 package level 'com.company.Class'
                     start = classname.charAt(index2 + 1);
                 } else {
                     // class name has only 1 package level 'package.Class'
                     start = classname.charAt(0);
                 }
                 // Check to see if it's an inner class 'com.company.Class$Inner'
                 // CheckStyle:MagicNumber OFF
                 if ((start > 0x40) && (start < 0x5B)) {
                     // first letter of the previous segment of the class name 'Class'
                     // is upper case ascii. so according to the spec it's an inner class
                     classname = classname.substring(0, index) + "$"
                         + classname.substring(index + 1);
                     addClass(classname);
                 } else {
                     // Add the class in dotted notation 'com.company.Class'
                     addClass(classname);
                 }
                 // CheckStyle:MagicNumber ON
             } else {
                 // Add a class with no package 'Class'
                 addClass(classname);
             }
         }
     }
 
     /**
      * Visit a field of the class.
      *
      * @param field the field being visited
      */
     public void visitField(Field field) {
         addClasses(field.getSignature());
     }
 
     /**
      * Visit a Java class
      *
      * @param javaClass the class being visited.
      */
     public void visitJavaClass(JavaClass javaClass) {
         addClass(javaClass.getClassName());
     }
 
     /**
      * Visit a method of the current class
      *
      * @param method the method being visited.
      */
     public void visitMethod(Method method) {
         String signature = method.getSignature();
         int pos = signature.indexOf(")");
         addClasses(signature.substring(1, pos));
         addClasses(signature.substring(pos + 1));
     }
 
     /**
      * Add a classname to the list of dependency classes
      *
      * @param classname the class to be added to the list of dependencies.
      */
     void addClass(String classname) {
         dependencies.put(classname, classname);
     }
 
     /**
      * Add all the classes from a descriptor string.
      *
      * @param string the descriptor string, being descriptors separated by
      *      ';' characters.
      */
     private void addClasses(String string) {
         StringTokenizer tokens = new StringTokenizer(string, ";");
         while (tokens.hasMoreTokens()) {
             String descriptor = tokens.nextToken();
             int pos = descriptor.indexOf('L');
             if (pos != -1) {
                 addSlashClass(descriptor.substring(pos + 1));
             }
         }
     }
 
     /**
      * Adds a class name in slash format
      * (for example org/apache/tools/ant/Main).
      *
      * @param classname the class name in slash format
      */
     private void addSlashClass(String classname) {
         addClass(classname.replace('/', '.'));
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/util/depend/bcel/FullAnalyzer.java b/src/main/org/apache/tools/ant/util/depend/bcel/FullAnalyzer.java
index 865ca4426..5e964c842 100644
--- a/src/main/org/apache/tools/ant/util/depend/bcel/FullAnalyzer.java
+++ b/src/main/org/apache/tools/ant/util/depend/bcel/FullAnalyzer.java
@@ -1,137 +1,137 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util.depend.bcel;
 import java.io.File;
 import java.io.IOException;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Vector;
 import org.apache.bcel.classfile.ClassParser;
 import org.apache.bcel.classfile.DescendingVisitor;
 import org.apache.bcel.classfile.JavaClass;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.util.depend.AbstractAnalyzer;
 
 /**
  * An analyzer capable fo traversing all class - class relationships.
  *
  */
 public class FullAnalyzer extends AbstractAnalyzer {
     /**
      * Default constructor
      *
      * Causes the BCEL classes to load to ensure BCEL dependencies can
      * be satisfied
      */
     public FullAnalyzer() {
         // force BCEL classes to load now
         try {
             new ClassParser("force");
         } catch (Exception e) {
             // all released versions of BCEL may throw an IOException
             // here, but BCEL's trunk does no longer declare to do so
             if (!(e instanceof IOException)) {
                 throw new BuildException(e);
             }
             // ignore IOException like we've always done
         }
     }
 
     /**
      * Determine the dependencies of the configured root classes.
      *
      * @param files a vector to be populated with the files which contain
      *      the dependency classes
      * @param classes a vector to be populated with the names of the
-     *      depencency classes.
+     *      dependency classes.
      */
     protected void determineDependencies(Vector files, Vector classes) {
         // we get the root classes and build up a set of
         // classes upon which they depend
         Hashtable dependencies = new Hashtable();
         Hashtable containers = new Hashtable();
         Hashtable toAnalyze = new Hashtable();
         for (Enumeration e = getRootClasses(); e.hasMoreElements();) {
             String classname = (String) e.nextElement();
             toAnalyze.put(classname, classname);
         }
 
         int count = 0;
         int maxCount = isClosureRequired() ? MAX_LOOPS : 2;
         while (toAnalyze.size() != 0 && count++ < maxCount) {
             DependencyVisitor dependencyVisitor = new DependencyVisitor();
             for (Enumeration e = toAnalyze.keys(); e.hasMoreElements();) {
                 String classname = (String) e.nextElement();
                 dependencies.put(classname, classname);
                 try {
                     File container = getClassContainer(classname);
                     if (container == null) {
                         continue;
                     }
                     containers.put(container, container);
 
                     ClassParser parser = null;
                     if (container.getName().endsWith(".class")) {
                         parser = new ClassParser(container.getPath());
                     } else {
                         parser = new ClassParser(container.getPath(),
                             classname.replace('.', '/') + ".class");
                     }
 
                     JavaClass javaClass = parser.parse();
                     DescendingVisitor traverser
                          = new DescendingVisitor(javaClass, dependencyVisitor);
                     traverser.visit();
                 } catch (IOException ioe) {
                     // ignore
                 }
             }
 
             toAnalyze.clear();
 
             // now recover all the dependencies collected and add to the list.
             Enumeration depsEnum = dependencyVisitor.getDependencies();
             while (depsEnum.hasMoreElements()) {
                 String className = (String) depsEnum.nextElement();
                 if (!dependencies.containsKey(className)) {
                     toAnalyze.put(className, className);
                 }
             }
         }
 
         files.removeAllElements();
         for (Enumeration e = containers.keys(); e.hasMoreElements();) {
             files.addElement((File) e.nextElement());
         }
 
         classes.removeAllElements();
         for (Enumeration e = dependencies.keys(); e.hasMoreElements();) {
             classes.addElement((String) e.nextElement());
         }
     }
 
     /**
      * Indicate if this analyzer can determine dependent files.
      *
      * @return true if the analyzer provides dependency file information.
      */
     protected boolean supportsFileDependencies() {
         return true;
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/util/facade/FacadeTaskHelper.java b/src/main/org/apache/tools/ant/util/facade/FacadeTaskHelper.java
index 55a3f18a3..ba77de2c1 100644
--- a/src/main/org/apache/tools/ant/util/facade/FacadeTaskHelper.java
+++ b/src/main/org/apache/tools/ant/util/facade/FacadeTaskHelper.java
@@ -1,165 +1,165 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.util.facade;
 
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.Path;
 
 /**
  * Helper class for facade implementations - encapsulates treatment of
  * explicit implementation choices, magic properties and
  * implementation specific command line arguments.
  *
  *
  * @since Ant 1.5
  */
 public class FacadeTaskHelper {
 
     /**
      * Command line arguments.
      */
     private List args = new ArrayList();
 
     /**
      * The explicitly chosen implementation.
      */
     private String userChoice;
 
     /**
      * The magic property to consult.
      */
     private String magicValue;
 
     /**
      * The default value.
      */
     private String defaultValue;
 
     /**
      * User specified path used as classpath when loading the implementation.
      */
     private Path implementationClasspath;
 
     /**
      * @param defaultValue The default value for the implementation.
      * Must not be null.
      */
     public FacadeTaskHelper(String defaultValue) {
         this(defaultValue, null);
     }
 
     /**
      * @param defaultValue The default value for the implementation.
      * Must not be null.
      * @param magicValue the value of a magic property that may hold a user.
      * choice.  May be null.
      */
     public FacadeTaskHelper(String defaultValue, String magicValue) {
         this.defaultValue = defaultValue;
         this.magicValue = magicValue;
     }
 
     /**
      * Used to set the value of the magic property.
      * @param magicValue the value of a magic property that may hold a user.
      */
     public void setMagicValue(String magicValue) {
         this.magicValue = magicValue;
     }
 
     /**
      * Used for explicit user choices.
      * @param userChoice the explicitly chosen implementation.
      */
     public void setImplementation(String userChoice) {
         this.userChoice = userChoice;
     }
 
     /**
      * Retrieves the implementation.
      * @return the implementation.
      */
     public String getImplementation() {
         return userChoice != null ? userChoice
                                   : (magicValue != null ? magicValue
                                                         : defaultValue);
     }
 
     /**
      * Retrieves the explicit user choice.
      * @return the explicit user choice.
      */
     public String getExplicitChoice() {
         return userChoice;
     }
 
     /**
      * Command line argument.
      * @param arg an argument to add.
      */
     public void addImplementationArgument(ImplementationSpecificArgument arg) {
         args.add(arg);
     }
 
     /**
      * Retrieves the command line arguments enabled for the current
      * facade implementation.
-     * @return an array of command line arguements.
+     * @return an array of command line arguments.
      */
     public String[] getArgs() {
         List tmp = new ArrayList(args.size());
         for (Iterator e = args.iterator(); e.hasNext();) {
             ImplementationSpecificArgument arg =
                 ((ImplementationSpecificArgument) e.next());
             String[] curr = arg.getParts(getImplementation());
             for (int i = 0; i < curr.length; i++) {
                 tmp.add(curr[i]);
             }
         }
         String[] res = new String[tmp.size()];
         return (String[]) tmp.toArray(res);
     }
 
     /**
      * Tests whether the implementation has been chosen by the user
      * (either via a magic property or explicitly.
      * @return true if magic or user choice has be set.
      * @since Ant 1.5.2
      */
     public boolean hasBeenSet() {
         return userChoice != null || magicValue != null;
     }
 
     /**
      * The classpath to use when loading the implementation.
      *
      * @param project the current project
      * @return a Path instance that may be appended to
      * @since Ant 1.8.0
      */
     public Path getImplementationClasspath(Project project) {
         if (implementationClasspath == null) {
             implementationClasspath = new Path(project);
         }
         return implementationClasspath;
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/facade/ImplementationSpecificArgument.java b/src/main/org/apache/tools/ant/util/facade/ImplementationSpecificArgument.java
index 2b2b838ca..ba7f14a01 100644
--- a/src/main/org/apache/tools/ant/util/facade/ImplementationSpecificArgument.java
+++ b/src/main/org/apache/tools/ant/util/facade/ImplementationSpecificArgument.java
@@ -1,61 +1,61 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.util.facade;
 
 import org.apache.tools.ant.types.Commandline;
 
 /**
- * Extension of Commandline.Argument with a new attribute that choses
+ * Extension of Commandline.Argument with a new attribute that chooses
  * a specific implementation of the facade.
  *
  *
  * @since Ant 1.5
  */
 public class ImplementationSpecificArgument extends Commandline.Argument {
     private String impl;
 
     /** Constructor for ImplementationSpecificArgument. */
     public ImplementationSpecificArgument() {
         super();
     }
 
     /**
      * Set the implementation this argument is for.
      * @param impl the implementation this command line argument is for.
      */
     public void setImplementation(String impl) {
         this.impl = impl;
     }
 
     /**
      * Return the parts this Argument consists of, if the
      * implementation matches the chosen implementation.
      * @see org.apache.tools.ant.types.Commandline.Argument#getParts()
      * @param chosenImpl the implementation to check against.
-     * @return the parts if the implemention matches or an zero length
+     * @return the parts if the implementation matches or an zero length
      *         array if not.
      */
     public final String[] getParts(String chosenImpl) {
         if (impl == null || impl.equals(chosenImpl)) {
             return super.getParts();
         } else {
             return new String[0];
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/optional/JavaxScriptRunner.java b/src/main/org/apache/tools/ant/util/optional/JavaxScriptRunner.java
index 82377ccf4..e5ba85995 100644
--- a/src/main/org/apache/tools/ant/util/optional/JavaxScriptRunner.java
+++ b/src/main/org/apache/tools/ant/util/optional/JavaxScriptRunner.java
@@ -1,163 +1,163 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.util.optional;
 
 import org.apache.tools.ant.BuildException;
 
 import java.util.Iterator;
 import org.apache.tools.ant.util.ScriptRunnerBase;
 import org.apache.tools.ant.util.ReflectWrapper;
 
 /**
  * This class is used to run scripts using JSR 223.
  * @since Ant 1.7.0
  */
 public class JavaxScriptRunner extends ScriptRunnerBase {
     private ReflectWrapper engine;
 
     /**
      * Get the name of the manager prefix.
      * @return "javax"
      */
     public String getManagerName() {
         return "javax";
     }
 
     /** {@inheritDoc}. */
     public boolean supportsLanguage() {
         if (engine != null) {
             return true;
         }
         checkLanguage();
         ClassLoader origLoader = replaceContextLoader();
         try {
             return createEngine() != null;
         } catch (Exception ex) {
             return false;
         } finally {
             restoreContextLoader(origLoader);
         }
     }
 
     /**
      * Do the work to run the script.
      *
      * @param execName the name that will be passed to the
      *                 scripting engine for this script execution.
      *
-     * @exception BuildException if someting goes wrong exectuing the script.
+     * @exception BuildException if something goes wrong executing the script.
      */
     public void executeScript(String execName) throws BuildException {
         evaluateScript(execName);
     }
 
     /**
      * Do the work to eval the script.
      *
      * @param execName the name that will be passed to the
      *                 scripting engine for this script execution.
      * @return the result of the evaluation
      * @exception BuildException if something goes wrong executing the script.
      */
     public Object evaluateScript(String execName) throws BuildException {
         checkLanguage();
         ClassLoader origLoader = replaceContextLoader();
         try {
             ReflectWrapper engine = createEngine();
             if (engine == null) {
                 throw new BuildException(
                     "Unable to create javax script engine for "
                     + getLanguage());
             }
             for (Iterator i = getBeans().keySet().iterator(); i.hasNext();) {
                 String key = (String) i.next();
                 Object value = getBeans().get(key);
                 if ("FX".equalsIgnoreCase(getLanguage())) {
                     engine.invoke(
                         "put", String.class, key
                         + ":" + value.getClass().getName(),
                         Object.class, value);
                 } else {
                     engine.invoke(
                         "put", String.class, key,
                         Object.class, value);
                 }
             }
             // execute the script
             return engine.invoke("eval", String.class, getScript());
         } catch (BuildException be) {
             //catch and rethrow build exceptions
 
             // this may be a BuildException wrapping a ScriptException
             // deeply wrapping yet another BuildException - for
             // example because of self.fail() - see
             // https://issues.apache.org/bugzilla/show_bug.cgi?id=47509
             throw unwrap(be);
         } catch (Exception be) {
             //any other exception? Get its cause
             Throwable t = be;
             Throwable te = be.getCause();
             if (te != null) {
                 if  (te instanceof BuildException) {
                     throw (BuildException) te;
                 } else {
                     t = te;
                 }
             }
             throw new BuildException(t);
         } finally {
             restoreContextLoader(origLoader);
         }
     }
 
     private ReflectWrapper createEngine() throws Exception {
         if (engine != null) {
             return engine;
         }
         ReflectWrapper manager = new ReflectWrapper(
             getClass().getClassLoader(), "javax.script.ScriptEngineManager");
         Object e = manager.invoke(
             "getEngineByName", String.class, getLanguage());
         if (e == null) {
             return null;
         }
         ReflectWrapper ret = new ReflectWrapper(e);
         if (getKeepEngine()) {
             this.engine = ret;
         }
         return ret;
     }
 
     /**
      * Traverse a Throwable's cause(s) and return the BuildException
      * most deeply nested into it - if any.
      */
     private static BuildException unwrap(Throwable t) {
         BuildException deepest =
             t instanceof BuildException ? (BuildException) t : null;
         Throwable current = t;
         while (current.getCause() != null) {
             current = current.getCause();
             if (current instanceof BuildException) {
                 deepest = (BuildException) current;
             }
         }
         return deepest;
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/regexp/RegexpMatcher.java b/src/main/org/apache/tools/ant/util/regexp/RegexpMatcher.java
index 5c36d9b74..edd1cfe83 100644
--- a/src/main/org/apache/tools/ant/util/regexp/RegexpMatcher.java
+++ b/src/main/org/apache/tools/ant/util/regexp/RegexpMatcher.java
@@ -1,109 +1,109 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.util.regexp;
 
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 
 /**
  * Interface describing a regular expression matcher.
  *
  */
 public interface RegexpMatcher {
 
     /***
      * Default Mask (case insensitive, neither multiline nor
      * singleline specified).
      */
     int MATCH_DEFAULT          = 0x00000000;
 
     /***
-     * Perform a case insenstive match
+     * Perform a case insensitive match
      */
     int MATCH_CASE_INSENSITIVE = 0x00000100;
 
     /***
      * Treat the input as a multiline input
      */
     int MATCH_MULTILINE        = 0x00001000;
 
     /***
      * Treat the input as singleline input ('.' matches newline)
      */
     int MATCH_SINGLELINE       = 0x00010000;
 
 
     /**
      * Set the regexp pattern from the String description.
      * @param pattern the pattern to match
      * @throws BuildException on error
      */
     void setPattern(String pattern) throws BuildException;
 
     /**
      * Get a String representation of the regexp pattern
      * @return the pattern
      * @throws BuildException on error
      */
     String getPattern() throws BuildException;
 
     /**
      * Does the given argument match the pattern?
      * @param argument the string to match against
      * @return true if the pattern matches
      * @throws BuildException on error
      */
     boolean matches(String argument) throws BuildException;
 
     /**
      * Returns a Vector of matched groups found in the argument
      * using default options.
      *
      * <p>Group 0 will be the full match, the rest are the
      * parenthesized subexpressions</p>.
      *
      * @param argument the string to match against
      * @return the vector of groups
      * @throws BuildException on error
      */
     Vector getGroups(String argument) throws BuildException;
 
     /***
      * Does this regular expression match the input, given
      * certain options
      * @param input The string to check for a match
      * @param options The list of options for the match. See the
      *                MATCH_ constants above.
      * @return true if the pattern matches
      * @throws BuildException on error
      */
     boolean matches(String input, int options) throws BuildException;
 
     /***
      * Get the match groups from this regular expression.  The return
      * type of the elements is always String.
      * @param input The string to check for a match
      * @param options The list of options for the match. See the
      *                MATCH_ constants above.
      * @return the vector of groups
      * @throws BuildException on error
      */
     Vector getGroups(String input, int options) throws BuildException;
 
 }
diff --git a/src/main/org/apache/tools/bzip2/CBZip2OutputStream.java b/src/main/org/apache/tools/bzip2/CBZip2OutputStream.java
index cfee7fcfd..965b7a2a6 100644
--- a/src/main/org/apache/tools/bzip2/CBZip2OutputStream.java
+++ b/src/main/org/apache/tools/bzip2/CBZip2OutputStream.java
@@ -1,1580 +1,1580 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 /*
  * This package is based on the work done by Keiron Liddle, Aftex Software
  * <keiron@aftexsw.com> to whom the Ant project is very grateful for his
  * great code.
  */
 
 package org.apache.tools.bzip2;
 
 import java.io.IOException;
 import java.io.OutputStream;
 
 /**
  * An output stream that compresses into the BZip2 format (without the file
  * header chars) into another stream.
  *
  * <p>
  * The compression requires large amounts of memory. Thus you should call the
  * {@link #close() close()} method as soon as possible, to force
  * <tt>CBZip2OutputStream</tt> to release the allocated memory.
  * </p>
  *
  * <p> You can shrink the amount of allocated memory and maybe raise
  * the compression speed by choosing a lower blocksize, which in turn
  * may cause a lower compression ratio. You can avoid unnecessary
  * memory allocation by avoiding using a blocksize which is bigger
  * than the size of the input.  </p>
  *
  * <p> You can compute the memory usage for compressing by the
  * following formula: </p>
  *
  * <pre>
  * &lt;code&gt;400k + (9 * blocksize)&lt;/code&gt;.
  * </pre>
  *
  * <p> To get the memory required for decompression by {@link
  * CBZip2InputStream CBZip2InputStream} use </p>
  *
  * <pre>
  * &lt;code&gt;65k + (5 * blocksize)&lt;/code&gt;.
  * </pre>
  *
  * <table width="100%" border="1">
  * <colgroup> <col width="33%" /> <col width="33%" /> <col width="33%" />
  * </colgroup>
  * <tr>
  * <th colspan="3">Memory usage by blocksize</th>
  * </tr>
  * <tr>
  * <th align="right">Blocksize</th> <th align="right">Compression<br>
  * memory usage</th> <th align="right">Decompression<br>
  * memory usage</th>
  * </tr>
  * <tr>
  * <td align="right">100k</td>
  * <td align="right">1300k</td>
  * <td align="right">565k</td>
  * </tr>
  * <tr>
  * <td align="right">200k</td>
  * <td align="right">2200k</td>
  * <td align="right">1065k</td>
  * </tr>
  * <tr>
  * <td align="right">300k</td>
  * <td align="right">3100k</td>
  * <td align="right">1565k</td>
  * </tr>
  * <tr>
  * <td align="right">400k</td>
  * <td align="right">4000k</td>
  * <td align="right">2065k</td>
  * </tr>
  * <tr>
  * <td align="right">500k</td>
  * <td align="right">4900k</td>
  * <td align="right">2565k</td>
  * </tr>
  * <tr>
  * <td align="right">600k</td>
  * <td align="right">5800k</td>
  * <td align="right">3065k</td>
  * </tr>
  * <tr>
  * <td align="right">700k</td>
  * <td align="right">6700k</td>
  * <td align="right">3565k</td>
  * </tr>
  * <tr>
  * <td align="right">800k</td>
  * <td align="right">7600k</td>
  * <td align="right">4065k</td>
  * </tr>
  * <tr>
  * <td align="right">900k</td>
  * <td align="right">8500k</td>
  * <td align="right">4565k</td>
  * </tr>
  * </table>
  *
  * <p>
  * For decompression <tt>CBZip2InputStream</tt> allocates less memory if the
  * bzipped input is smaller than one block.
  * </p>
  *
  * <p>
  * Instances of this class are not threadsafe.
  * </p>
  *
  * <p>
  * TODO: Update to BZip2 1.0.1
  * </p>
  *
  */
 public class CBZip2OutputStream extends OutputStream
     implements BZip2Constants {
 
     /**
      * The minimum supported blocksize <tt> == 1</tt>.
      */
     public static final int MIN_BLOCKSIZE = 1;
 
     /**
      * The maximum supported blocksize <tt> == 9</tt>.
      */
     public static final int MAX_BLOCKSIZE = 9;
 
     /**
      * This constant is accessible by subclasses for historical
      * purposes. If you don't know what it means then you don't need
      * it.
      */
     protected static final int SETMASK = (1 << 21);
 
     /**
      * This constant is accessible by subclasses for historical
      * purposes. If you don't know what it means then you don't need
      * it.
      */
     protected static final int CLEARMASK = (~SETMASK);
 
     /**
      * This constant is accessible by subclasses for historical
      * purposes. If you don't know what it means then you don't need
      * it.
      */
     protected static final int GREATER_ICOST = 15;
 
     /**
      * This constant is accessible by subclasses for historical
      * purposes. If you don't know what it means then you don't need
      * it.
      */
     protected static final int LESSER_ICOST = 0;
 
     /**
      * This constant is accessible by subclasses for historical
      * purposes. If you don't know what it means then you don't need
      * it.
      */
     protected static final int SMALL_THRESH = 20;
 
     /**
      * This constant is accessible by subclasses for historical
      * purposes. If you don't know what it means then you don't need
      * it.
      */
     protected static final int DEPTH_THRESH = 10;
 
     /**
      * This constant is accessible by subclasses for historical
      * purposes. If you don't know what it means then you don't need
      * it.
      */
     protected static final int WORK_FACTOR = 30;
 
     /**
      * This constant is accessible by subclasses for historical
      * purposes. If you don't know what it means then you don't need
      * it.
      * <p> If you are ever unlucky/improbable enough to get a stack
      * overflow whilst sorting, increase the following constant and
      * try again. In practice I have never seen the stack go above 27
      * elems, so the following limit seems very generous.  </p>
      */
     protected static final int QSORT_STACK_SIZE = 1000;
 
     /**
      * Knuth's increments seem to work better than Incerpi-Sedgewick here.
      * Possibly because the number of elems to sort is usually small, typically
      * &lt;= 20.
      */
     private static final int[] INCS = { 1, 4, 13, 40, 121, 364, 1093, 3280,
                                         9841, 29524, 88573, 265720, 797161,
                                         2391484 };
 
     /**
      * This method is accessible by subclasses for historical
      * purposes. If you don't know what it does then you don't need
      * it.
      */
     protected static void hbMakeCodeLengths(char[] len, int[] freq,
                                             int alphaSize, int maxLen) {
         /*
          * Nodes and heap entries run from 1. Entry 0 for both the heap and
          * nodes is a sentinel.
          */
         final int[] heap = new int[MAX_ALPHA_SIZE * 2];
         final int[] weight = new int[MAX_ALPHA_SIZE * 2];
         final int[] parent = new int[MAX_ALPHA_SIZE * 2];
 
         for (int i = alphaSize; --i >= 0;) {
             weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
         }
 
         for (boolean tooLong = true; tooLong;) {
             tooLong = false;
 
             int nNodes = alphaSize;
             int nHeap = 0;
             heap[0] = 0;
             weight[0] = 0;
             parent[0] = -2;
 
             for (int i = 1; i <= alphaSize; i++) {
                 parent[i] = -1;
                 nHeap++;
                 heap[nHeap] = i;
 
                 int zz = nHeap;
                 int tmp = heap[zz];
                 while (weight[tmp] < weight[heap[zz >> 1]]) {
                     heap[zz] = heap[zz >> 1];
                     zz >>= 1;
                 }
                 heap[zz] = tmp;
             }
 
             // assert (nHeap < (MAX_ALPHA_SIZE + 2)) : nHeap;
 
             while (nHeap > 1) {
                 int n1 = heap[1];
                 heap[1] = heap[nHeap];
                 nHeap--;
 
                 int yy = 0;
                 int zz = 1;
                 int tmp = heap[1];
 
                 while (true) {
                     yy = zz << 1;
 
                     if (yy > nHeap) {
                         break;
                     }
 
                     if ((yy < nHeap)
                         && (weight[heap[yy + 1]] < weight[heap[yy]])) {
                         yy++;
                     }
 
                     if (weight[tmp] < weight[heap[yy]]) {
                         break;
                     }
 
                     heap[zz] = heap[yy];
                     zz = yy;
                 }
 
                 heap[zz] = tmp;
 
                 int n2 = heap[1];
                 heap[1] = heap[nHeap];
                 nHeap--;
 
                 yy = 0;
                 zz = 1;
                 tmp = heap[1];
 
                 while (true) {
                     yy = zz << 1;
 
                     if (yy > nHeap) {
                         break;
                     }
 
                     if ((yy < nHeap)
                         && (weight[heap[yy + 1]] < weight[heap[yy]])) {
                         yy++;
                     }
 
                     if (weight[tmp] < weight[heap[yy]]) {
                         break;
                     }
 
                     heap[zz] = heap[yy];
                     zz = yy;
                 }
 
                 heap[zz] = tmp;
                 nNodes++;
                 parent[n1] = parent[n2] = nNodes;
 
                 final int weight_n1 = weight[n1];
                 final int weight_n2 = weight[n2];
                 weight[nNodes] = (((weight_n1 & 0xffffff00)
                                    + (weight_n2 & 0xffffff00))
                                   |
                                   (1 + (((weight_n1 & 0x000000ff)
                                          > (weight_n2 & 0x000000ff))
                                         ? (weight_n1 & 0x000000ff)
                                         : (weight_n2 & 0x000000ff))
                                    ));
 
                 parent[nNodes] = -1;
                 nHeap++;
                 heap[nHeap] = nNodes;
 
                 tmp = 0;
                 zz = nHeap;
                 tmp = heap[zz];
                 final int weight_tmp = weight[tmp];
                 while (weight_tmp < weight[heap[zz >> 1]]) {
                     heap[zz] = heap[zz >> 1];
                     zz >>= 1;
                 }
                 heap[zz] = tmp;
 
             }
 
             // assert (nNodes < (MAX_ALPHA_SIZE * 2)) : nNodes;
 
             for (int i = 1; i <= alphaSize; i++) {
                 int j = 0;
                 int k = i;
 
                 for (int parent_k; (parent_k = parent[k]) >= 0;) {
                     k = parent_k;
                     j++;
                 }
 
                 len[i - 1] = (char) j;
                 if (j > maxLen) {
                     tooLong = true;
                 }
             }
 
             if (tooLong) {
                 for (int i = 1; i < alphaSize; i++) {
                     int j = weight[i] >> 8;
                     j = 1 + (j >> 1);
                     weight[i] = j << 8;
                 }
             }
         }
     }
 
     private static void hbMakeCodeLengths(final byte[] len, final int[] freq,
                                           final Data dat, final int alphaSize,
                                           final int maxLen) {
         /*
          * Nodes and heap entries run from 1. Entry 0 for both the heap and
          * nodes is a sentinel.
          */
         final int[] heap = dat.heap;
         final int[] weight = dat.weight;
         final int[] parent = dat.parent;
 
         for (int i = alphaSize; --i >= 0;) {
             weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
         }
 
         for (boolean tooLong = true; tooLong;) {
             tooLong = false;
 
             int nNodes = alphaSize;
             int nHeap = 0;
             heap[0] = 0;
             weight[0] = 0;
             parent[0] = -2;
 
             for (int i = 1; i <= alphaSize; i++) {
                 parent[i] = -1;
                 nHeap++;
                 heap[nHeap] = i;
 
                 int zz = nHeap;
                 int tmp = heap[zz];
                 while (weight[tmp] < weight[heap[zz >> 1]]) {
                     heap[zz] = heap[zz >> 1];
                     zz >>= 1;
                 }
                 heap[zz] = tmp;
             }
 
             while (nHeap > 1) {
                 int n1 = heap[1];
                 heap[1] = heap[nHeap];
                 nHeap--;
 
                 int yy = 0;
                 int zz = 1;
                 int tmp = heap[1];
 
                 while (true) {
                     yy = zz << 1;
 
                     if (yy > nHeap) {
                         break;
                     }
 
                     if ((yy < nHeap)
                         && (weight[heap[yy + 1]] < weight[heap[yy]])) {
                         yy++;
                     }
 
                     if (weight[tmp] < weight[heap[yy]]) {
                         break;
                     }
 
                     heap[zz] = heap[yy];
                     zz = yy;
                 }
 
                 heap[zz] = tmp;
 
                 int n2 = heap[1];
                 heap[1] = heap[nHeap];
                 nHeap--;
 
                 yy = 0;
                 zz = 1;
                 tmp = heap[1];
 
                 while (true) {
                     yy = zz << 1;
 
                     if (yy > nHeap) {
                         break;
                     }
 
                     if ((yy < nHeap)
                         && (weight[heap[yy + 1]] < weight[heap[yy]])) {
                         yy++;
                     }
 
                     if (weight[tmp] < weight[heap[yy]]) {
                         break;
                     }
 
                     heap[zz] = heap[yy];
                     zz = yy;
                 }
 
                 heap[zz] = tmp;
                 nNodes++;
                 parent[n1] = parent[n2] = nNodes;
 
                 final int weight_n1 = weight[n1];
                 final int weight_n2 = weight[n2];
                 weight[nNodes] = ((weight_n1 & 0xffffff00)
                                   + (weight_n2 & 0xffffff00))
                     | (1 + (((weight_n1 & 0x000000ff)
                              > (weight_n2 & 0x000000ff))
                             ? (weight_n1 & 0x000000ff)
                             : (weight_n2 & 0x000000ff)));
 
                 parent[nNodes] = -1;
                 nHeap++;
                 heap[nHeap] = nNodes;
 
                 tmp = 0;
                 zz = nHeap;
                 tmp = heap[zz];
                 final int weight_tmp = weight[tmp];
                 while (weight_tmp < weight[heap[zz >> 1]]) {
                     heap[zz] = heap[zz >> 1];
                     zz >>= 1;
                 }
                 heap[zz] = tmp;
 
             }
 
             for (int i = 1; i <= alphaSize; i++) {
                 int j = 0;
                 int k = i;
 
                 for (int parent_k; (parent_k = parent[k]) >= 0;) {
                     k = parent_k;
                     j++;
                 }
 
                 len[i - 1] = (byte) j;
                 if (j > maxLen) {
                     tooLong = true;
                 }
             }
 
             if (tooLong) {
                 for (int i = 1; i < alphaSize; i++) {
                     int j = weight[i] >> 8;
                     j = 1 + (j >> 1);
                     weight[i] = j << 8;
                 }
             }
         }
     }
 
     /**
      * Index of the last char in the block, so the block size == last + 1.
      */
     private int last;
 
     /**
      * Always: in the range 0 .. 9. The current block size is 100000 * this
      * number.
      */
     private final int blockSize100k;
 
     private int bsBuff;
     private int bsLive;
     private final CRC crc = new CRC();
 
     private int nInUse;
 
     private int nMTF;
 
     private int currentChar = -1;
     private int runLength = 0;
 
     private int blockCRC;
     private int combinedCRC;
     private final int allowableBlockSize;
 
     /**
      * All memory intensive stuff.
      */
     private Data data;
     private BlockSort blockSorter;
 
     private OutputStream out;
 
     /**
      * Chooses a blocksize based on the given length of the data to compress.
      *
      * @return The blocksize, between {@link #MIN_BLOCKSIZE} and
      *         {@link #MAX_BLOCKSIZE} both inclusive. For a negative
      *         <tt>inputLength</tt> this method returns <tt>MAX_BLOCKSIZE</tt>
      *         always.
      *
      * @param inputLength
      *            The length of the data which will be compressed by
      *            <tt>CBZip2OutputStream</tt>.
      */
     public static int chooseBlockSize(long inputLength) {
         return (inputLength > 0) ? (int) Math
             .min((inputLength / 132000) + 1, 9) : MAX_BLOCKSIZE;
     }
 
     /**
      * Constructs a new <tt>CBZip2OutputStream</tt> with a blocksize of 900k.
      *
      * <p>
      * <b>Attention: </b>The caller is responsible to write the two BZip2 magic
      * bytes <tt>"BZ"</tt> to the specified stream prior to calling this
      * constructor.
      * </p>
      *
      * @param out *
      *            the destination stream.
      *
      * @throws IOException
      *             if an I/O error occurs in the specified stream.
      * @throws NullPointerException
      *             if <code>out == null</code>.
      */
     public CBZip2OutputStream(final OutputStream out) throws IOException {
         this(out, MAX_BLOCKSIZE);
     }
 
     /**
      * Constructs a new <tt>CBZip2OutputStream</tt> with specified blocksize.
      *
      * <p>
      * <b>Attention: </b>The caller is responsible to write the two BZip2 magic
      * bytes <tt>"BZ"</tt> to the specified stream prior to calling this
      * constructor.
      * </p>
      *
      *
      * @param out
      *            the destination stream.
      * @param blockSize
      *            the blockSize as 100k units.
      *
      * @throws IOException
      *             if an I/O error occurs in the specified stream.
      * @throws IllegalArgumentException
      *             if <code>(blockSize < 1) || (blockSize > 9)</code>.
      * @throws NullPointerException
      *             if <code>out == null</code>.
      *
      * @see #MIN_BLOCKSIZE
      * @see #MAX_BLOCKSIZE
      */
     public CBZip2OutputStream(final OutputStream out, final int blockSize)
         throws IOException {
         super();
 
         if (blockSize < 1) {
             throw new IllegalArgumentException("blockSize(" + blockSize
                                                + ") < 1");
         }
         if (blockSize > 9) {
             throw new IllegalArgumentException("blockSize(" + blockSize
                                                + ") > 9");
         }
 
         this.blockSize100k = blockSize;
         this.out = out;
 
         /* 20 is just a paranoia constant */
         this.allowableBlockSize = (this.blockSize100k * BZip2Constants.baseBlockSize) - 20;
         init();
     }
 
     /** {@inheritDoc} */
     @Override
     public void write(final int b) throws IOException {
         if (this.out != null) {
             write0(b);
         } else {
             throw new IOException("closed");
         }
     }
 
     /**
      * Writes the current byte to the buffer, run-length encoding it
      * if it has been repeated at least four times (the first step
      * RLEs sequences of four identical bytes).
      *
      * <p>Flushes the current block before writing data if it is
      * full.</p>
      *
      * <p>"write to the buffer" means adding to data.buffer starting
      * two steps "after" this.last - initially starting at index 1
      * (not 0) - and updating this.last to point to the last index
      * written minus 1.</p>
      */
     private void writeRun() throws IOException {
         final int lastShadow = this.last;
 
         if (lastShadow < this.allowableBlockSize) {
             final int currentCharShadow = this.currentChar;
             final Data dataShadow = this.data;
             dataShadow.inUse[currentCharShadow] = true;
             final byte ch = (byte) currentCharShadow;
 
             int runLengthShadow = this.runLength;
             this.crc.updateCRC(currentCharShadow, runLengthShadow);
 
             switch (runLengthShadow) {
             case 1:
                 dataShadow.block[lastShadow + 2] = ch;
                 this.last = lastShadow + 1;
                 break;
 
             case 2:
                 dataShadow.block[lastShadow + 2] = ch;
                 dataShadow.block[lastShadow + 3] = ch;
                 this.last = lastShadow + 2;
                 break;
 
             case 3: {
                 final byte[] block = dataShadow.block;
                 block[lastShadow + 2] = ch;
                 block[lastShadow + 3] = ch;
                 block[lastShadow + 4] = ch;
                 this.last = lastShadow + 3;
             }
                 break;
 
             default: {
                 runLengthShadow -= 4;
                 dataShadow.inUse[runLengthShadow] = true;
                 final byte[] block = dataShadow.block;
                 block[lastShadow + 2] = ch;
                 block[lastShadow + 3] = ch;
                 block[lastShadow + 4] = ch;
                 block[lastShadow + 5] = ch;
                 block[lastShadow + 6] = (byte) runLengthShadow;
                 this.last = lastShadow + 5;
             }
                 break;
 
             }
         } else {
             endBlock();
             initBlock();
             writeRun();
         }
     }
 
     /**
-     * Overriden to close the stream.
+     * Overridden to close the stream.
      */
     @Override
     protected void finalize() throws Throwable {
         finish();
         super.finalize();
     }
 
 
     public void finish() throws IOException {
         if (out != null) {
             try {
                 if (this.runLength > 0) {
                     writeRun();
                 }
                 this.currentChar = -1;
                 endBlock();
                 endCompression();
             } finally {
                 this.out = null;
                 this.data = null;
                 this.blockSorter = null;
             }
         }
     }
 
     @Override
     public void close() throws IOException {
         if (out != null) {
             OutputStream outShadow = this.out;
             finish();
             outShadow.close();
         }
     }
 
     @Override
     public void flush() throws IOException {
         OutputStream outShadow = this.out;
         if (outShadow != null) {
             outShadow.flush();
         }
     }
 
     private void init() throws IOException {
         // write magic: done by caller who created this stream
         // this.out.write('B');
         // this.out.write('Z');
 
         this.data = new Data(this.blockSize100k);
         this.blockSorter = new BlockSort(this.data);
 
         /*
          * Write `magic' bytes h indicating file-format == huffmanised, followed
          * by a digit indicating blockSize100k.
          */
         bsPutUByte('h');
         bsPutUByte('0' + this.blockSize100k);
 
         this.combinedCRC = 0;
         initBlock();
     }
 
     private void initBlock() {
         // blockNo++;
         this.crc.initialiseCRC();
         this.last = -1;
         // ch = 0;
 
         boolean[] inUse = this.data.inUse;
         for (int i = 256; --i >= 0;) {
             inUse[i] = false;
         }
     }
 
     private void endBlock() throws IOException {
         this.blockCRC = this.crc.getFinalCRC();
         this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >>> 31);
         this.combinedCRC ^= this.blockCRC;
 
         // empty block at end of file
         if (this.last == -1) {
             return;
         }
 
         /* sort the block and establish posn of original string */
         blockSort();
 
         /*
          * A 6-byte block header, the value chosen arbitrarily as 0x314159265359
          * :-). A 32 bit value does not really give a strong enough guarantee
          * that the value will not appear by chance in the compressed
          * datastream. Worst-case probability of this event, for a 900k block,
          * is about 2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48
          * bits. For a compressed file of size 100Gb -- about 100000 blocks --
          * only a 48-bit marker will do. NB: normal compression/ decompression
          * donot rely on these statistical properties. They are only important
          * when trying to recover blocks from damaged files.
          */
         bsPutUByte(0x31);
         bsPutUByte(0x41);
         bsPutUByte(0x59);
         bsPutUByte(0x26);
         bsPutUByte(0x53);
         bsPutUByte(0x59);
 
         /* Now the block's CRC, so it is in a known place. */
         bsPutInt(this.blockCRC);
 
         /* Now a single bit indicating no randomisation. */
         bsW(1, 0);
 
         /* Finally, block's contents proper. */
         moveToFrontCodeAndSend();
     }
 
     private void endCompression() throws IOException {
         /*
          * Now another magic 48-bit number, 0x177245385090, to indicate the end
          * of the last block. (sqrt(pi), if you want to know. I did want to use
          * e, but it contains too much repetition -- 27 18 28 18 28 46 -- for me
          * to feel statistically comfortable. Call me paranoid.)
          */
         bsPutUByte(0x17);
         bsPutUByte(0x72);
         bsPutUByte(0x45);
         bsPutUByte(0x38);
         bsPutUByte(0x50);
         bsPutUByte(0x90);
 
         bsPutInt(this.combinedCRC);
         bsFinishedWithStream();
     }
 
     /**
      * Returns the blocksize parameter specified at construction time.
      */
     public final int getBlockSize() {
         return this.blockSize100k;
     }
 
     @Override
     public void write(final byte[] buf, int offs, final int len)
         throws IOException {
         if (offs < 0) {
             throw new IndexOutOfBoundsException("offs(" + offs + ") < 0.");
         }
         if (len < 0) {
             throw new IndexOutOfBoundsException("len(" + len + ") < 0.");
         }
         if (offs + len > buf.length) {
             throw new IndexOutOfBoundsException("offs(" + offs + ") + len("
                                                 + len + ") > buf.length("
                                                 + buf.length + ").");
         }
         if (this.out == null) {
             throw new IOException("stream closed");
         }
 
         for (int hi = offs + len; offs < hi;) {
             write0(buf[offs++]);
         }
     }
 
     /**
      * Keeps track of the last bytes written and implicitly performs
      * run-length encoding as the first step of the bzip2 algorithm.
      */
     private void write0(int b) throws IOException {
         if (this.currentChar != -1) {
             b &= 0xff;
             if (this.currentChar == b) {
                 if (++this.runLength > 254) {
                     writeRun();
                     this.currentChar = -1;
                     this.runLength = 0;
                 }
                 // else nothing to do
             } else {
                 writeRun();
                 this.runLength = 1;
                 this.currentChar = b;
             }
         } else {
             this.currentChar = b & 0xff;
             this.runLength++;
         }
     }
 
     private static void hbAssignCodes(final int[] code, final byte[] length,
                                       final int minLen, final int maxLen,
                                       final int alphaSize) {
         int vec = 0;
         for (int n = minLen; n <= maxLen; n++) {
             for (int i = 0; i < alphaSize; i++) {
                 if ((length[i] & 0xff) == n) {
                     code[i] = vec;
                     vec++;
                 }
             }
             vec <<= 1;
         }
     }
 
     private void bsFinishedWithStream() throws IOException {
         while (this.bsLive > 0) {
             int ch = this.bsBuff >> 24;
             this.out.write(ch); // write 8-bit
             this.bsBuff <<= 8;
             this.bsLive -= 8;
         }
     }
 
     private void bsW(final int n, final int v) throws IOException {
         final OutputStream outShadow = this.out;
         int bsLiveShadow = this.bsLive;
         int bsBuffShadow = this.bsBuff;
 
         while (bsLiveShadow >= 8) {
             outShadow.write(bsBuffShadow >> 24); // write 8-bit
             bsBuffShadow <<= 8;
             bsLiveShadow -= 8;
         }
 
         this.bsBuff = bsBuffShadow | (v << (32 - bsLiveShadow - n));
         this.bsLive = bsLiveShadow + n;
     }
 
     private void bsPutUByte(final int c) throws IOException {
         bsW(8, c);
     }
 
     private void bsPutInt(final int u) throws IOException {
         bsW(8, (u >> 24) & 0xff);
         bsW(8, (u >> 16) & 0xff);
         bsW(8, (u >> 8) & 0xff);
         bsW(8, u & 0xff);
     }
 
     private void sendMTFValues() throws IOException {
         final byte[][] len = this.data.sendMTFValues_len;
         final int alphaSize = this.nInUse + 2;
 
         for (int t = N_GROUPS; --t >= 0;) {
             byte[] len_t = len[t];
             for (int v = alphaSize; --v >= 0;) {
                 len_t[v] = GREATER_ICOST;
             }
         }
 
         /* Decide how many coding tables to use */
         // assert (this.nMTF > 0) : this.nMTF;
         final int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3
             : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
 
         /* Generate an initial set of coding tables */
         sendMTFValues0(nGroups, alphaSize);
 
         /*
          * Iterate up to N_ITERS times to improve the tables.
          */
         final int nSelectors = sendMTFValues1(nGroups, alphaSize);
 
         /* Compute MTF values for the selectors. */
         sendMTFValues2(nGroups, nSelectors);
 
         /* Assign actual codes for the tables. */
         sendMTFValues3(nGroups, alphaSize);
 
         /* Transmit the mapping table. */
         sendMTFValues4();
 
         /* Now the selectors. */
         sendMTFValues5(nGroups, nSelectors);
 
         /* Now the coding tables. */
         sendMTFValues6(nGroups, alphaSize);
 
         /* And finally, the block data proper */
         sendMTFValues7();
     }
 
     private void sendMTFValues0(final int nGroups, final int alphaSize) {
         final byte[][] len = this.data.sendMTFValues_len;
         final int[] mtfFreq = this.data.mtfFreq;
 
         int remF = this.nMTF;
         int gs = 0;
 
         for (int nPart = nGroups; nPart > 0; nPart--) {
             final int tFreq = remF / nPart;
             int ge = gs - 1;
             int aFreq = 0;
 
             for (final int a = alphaSize - 1; (aFreq < tFreq) && (ge < a);) {
                 aFreq += mtfFreq[++ge];
             }
 
             if ((ge > gs) && (nPart != nGroups) && (nPart != 1)
                 && (((nGroups - nPart) & 1) != 0)) {
                 aFreq -= mtfFreq[ge--];
             }
 
             final byte[] len_np = len[nPart - 1];
             for (int v = alphaSize; --v >= 0;) {
                 if ((v >= gs) && (v <= ge)) {
                     len_np[v] = LESSER_ICOST;
                 } else {
                     len_np[v] = GREATER_ICOST;
                 }
             }
 
             gs = ge + 1;
             remF -= aFreq;
         }
     }
 
     private int sendMTFValues1(final int nGroups, final int alphaSize) {
         final Data dataShadow = this.data;
         final int[][] rfreq = dataShadow.sendMTFValues_rfreq;
         final int[] fave = dataShadow.sendMTFValues_fave;
         final short[] cost = dataShadow.sendMTFValues_cost;
         final char[] sfmap = dataShadow.sfmap;
         final byte[] selector = dataShadow.selector;
         final byte[][] len = dataShadow.sendMTFValues_len;
         final byte[] len_0 = len[0];
         final byte[] len_1 = len[1];
         final byte[] len_2 = len[2];
         final byte[] len_3 = len[3];
         final byte[] len_4 = len[4];
         final byte[] len_5 = len[5];
         final int nMTFShadow = this.nMTF;
 
         int nSelectors = 0;
 
         for (int iter = 0; iter < N_ITERS; iter++) {
             for (int t = nGroups; --t >= 0;) {
                 fave[t] = 0;
                 int[] rfreqt = rfreq[t];
                 for (int i = alphaSize; --i >= 0;) {
                     rfreqt[i] = 0;
                 }
             }
 
             nSelectors = 0;
 
             for (int gs = 0; gs < this.nMTF;) {
                 /* Set group start & end marks. */
 
                 /*
                  * Calculate the cost of this group as coded by each of the
                  * coding tables.
                  */
 
                 final int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);
 
                 if (nGroups == N_GROUPS) {
                     // unrolled version of the else-block
 
                     short cost0 = 0;
                     short cost1 = 0;
                     short cost2 = 0;
                     short cost3 = 0;
                     short cost4 = 0;
                     short cost5 = 0;
 
                     for (int i = gs; i <= ge; i++) {
                         final int icv = sfmap[i];
                         cost0 += len_0[icv] & 0xff;
                         cost1 += len_1[icv] & 0xff;
                         cost2 += len_2[icv] & 0xff;
                         cost3 += len_3[icv] & 0xff;
                         cost4 += len_4[icv] & 0xff;
                         cost5 += len_5[icv] & 0xff;
                     }
 
                     cost[0] = cost0;
                     cost[1] = cost1;
                     cost[2] = cost2;
                     cost[3] = cost3;
                     cost[4] = cost4;
                     cost[5] = cost5;
 
                 } else {
                     for (int t = nGroups; --t >= 0;) {
                         cost[t] = 0;
                     }
 
                     for (int i = gs; i <= ge; i++) {
                         final int icv = sfmap[i];
                         for (int t = nGroups; --t >= 0;) {
                             cost[t] += len[t][icv] & 0xff;
                         }
                     }
                 }
 
                 /*
                  * Find the coding table which is best for this group, and
                  * record its identity in the selector table.
                  */
                 int bt = -1;
                 for (int t = nGroups, bc = 999999999; --t >= 0;) {
                     final int cost_t = cost[t];
                     if (cost_t < bc) {
                         bc = cost_t;
                         bt = t;
                     }
                 }
 
                 fave[bt]++;
                 selector[nSelectors] = (byte) bt;
                 nSelectors++;
 
                 /*
                  * Increment the symbol frequencies for the selected table.
                  */
                 final int[] rfreq_bt = rfreq[bt];
                 for (int i = gs; i <= ge; i++) {
                     rfreq_bt[sfmap[i]]++;
                 }
 
                 gs = ge + 1;
             }
 
             /*
              * Recompute the tables based on the accumulated frequencies.
              */
             for (int t = 0; t < nGroups; t++) {
                 hbMakeCodeLengths(len[t], rfreq[t], this.data, alphaSize, 20);
             }
         }
 
         return nSelectors;
     }
 
     private void sendMTFValues2(final int nGroups, final int nSelectors) {
         // assert (nGroups < 8) : nGroups;
 
         final Data dataShadow = this.data;
         byte[] pos = dataShadow.sendMTFValues2_pos;
 
         for (int i = nGroups; --i >= 0;) {
             pos[i] = (byte) i;
         }
 
         for (int i = 0; i < nSelectors; i++) {
             final byte ll_i = dataShadow.selector[i];
             byte tmp = pos[0];
             int j = 0;
 
             while (ll_i != tmp) {
                 j++;
                 byte tmp2 = tmp;
                 tmp = pos[j];
                 pos[j] = tmp2;
             }
 
             pos[0] = tmp;
             dataShadow.selectorMtf[i] = (byte) j;
         }
     }
 
     private void sendMTFValues3(final int nGroups, final int alphaSize) {
         int[][] code = this.data.sendMTFValues_code;
         byte[][] len = this.data.sendMTFValues_len;
 
         for (int t = 0; t < nGroups; t++) {
             int minLen = 32;
             int maxLen = 0;
             final byte[] len_t = len[t];
             for (int i = alphaSize; --i >= 0;) {
                 final int l = len_t[i] & 0xff;
                 if (l > maxLen) {
                     maxLen = l;
                 }
                 if (l < minLen) {
                     minLen = l;
                 }
             }
 
             // assert (maxLen <= 20) : maxLen;
             // assert (minLen >= 1) : minLen;
 
             hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);
         }
     }
 
     private void sendMTFValues4() throws IOException {
         final boolean[] inUse = this.data.inUse;
         final boolean[] inUse16 = this.data.sentMTFValues4_inUse16;
 
         for (int i = 16; --i >= 0;) {
             inUse16[i] = false;
             final int i16 = i * 16;
             for (int j = 16; --j >= 0;) {
                 if (inUse[i16 + j]) {
                     inUse16[i] = true;
                 }
             }
         }
 
         for (int i = 0; i < 16; i++) {
             bsW(1, inUse16[i] ? 1 : 0);
         }
 
         final OutputStream outShadow = this.out;
         int bsLiveShadow = this.bsLive;
         int bsBuffShadow = this.bsBuff;
 
         for (int i = 0; i < 16; i++) {
             if (inUse16[i]) {
                 final int i16 = i * 16;
                 for (int j = 0; j < 16; j++) {
                     // inlined: bsW(1, inUse[i16 + j] ? 1 : 0);
                     while (bsLiveShadow >= 8) {
                         outShadow.write(bsBuffShadow >> 24); // write 8-bit
                         bsBuffShadow <<= 8;
                         bsLiveShadow -= 8;
                     }
                     if (inUse[i16 + j]) {
                         bsBuffShadow |= 1 << (32 - bsLiveShadow - 1);
                     }
                     bsLiveShadow++;
                 }
             }
         }
 
         this.bsBuff = bsBuffShadow;
         this.bsLive = bsLiveShadow;
     }
 
     private void sendMTFValues5(final int nGroups, final int nSelectors)
         throws IOException {
         bsW(3, nGroups);
         bsW(15, nSelectors);
 
         final OutputStream outShadow = this.out;
         final byte[] selectorMtf = this.data.selectorMtf;
 
         int bsLiveShadow = this.bsLive;
         int bsBuffShadow = this.bsBuff;
 
         for (int i = 0; i < nSelectors; i++) {
             for (int j = 0, hj = selectorMtf[i] & 0xff; j < hj; j++) {
                 // inlined: bsW(1, 1);
                 while (bsLiveShadow >= 8) {
                     outShadow.write(bsBuffShadow >> 24);
                     bsBuffShadow <<= 8;
                     bsLiveShadow -= 8;
                 }
                 bsBuffShadow |= 1 << (32 - bsLiveShadow - 1);
                 bsLiveShadow++;
             }
 
             // inlined: bsW(1, 0);
             while (bsLiveShadow >= 8) {
                 outShadow.write(bsBuffShadow >> 24);
                 bsBuffShadow <<= 8;
                 bsLiveShadow -= 8;
             }
             // bsBuffShadow |= 0 << (32 - bsLiveShadow - 1);
             bsLiveShadow++;
         }
 
         this.bsBuff = bsBuffShadow;
         this.bsLive = bsLiveShadow;
     }
 
     private void sendMTFValues6(final int nGroups, final int alphaSize)
         throws IOException {
         final byte[][] len = this.data.sendMTFValues_len;
         final OutputStream outShadow = this.out;
 
         int bsLiveShadow = this.bsLive;
         int bsBuffShadow = this.bsBuff;
 
         for (int t = 0; t < nGroups; t++) {
             byte[] len_t = len[t];
             int curr = len_t[0] & 0xff;
 
             // inlined: bsW(5, curr);
             while (bsLiveShadow >= 8) {
                 outShadow.write(bsBuffShadow >> 24); // write 8-bit
                 bsBuffShadow <<= 8;
                 bsLiveShadow -= 8;
             }
             bsBuffShadow |= curr << (32 - bsLiveShadow - 5);
             bsLiveShadow += 5;
 
             for (int i = 0; i < alphaSize; i++) {
                 int lti = len_t[i] & 0xff;
                 while (curr < lti) {
                     // inlined: bsW(2, 2);
                     while (bsLiveShadow >= 8) {
                         outShadow.write(bsBuffShadow >> 24); // write 8-bit
                         bsBuffShadow <<= 8;
                         bsLiveShadow -= 8;
                     }
                     bsBuffShadow |= 2 << (32 - bsLiveShadow - 2);
                     bsLiveShadow += 2;
 
                     curr++; /* 10 */
                 }
 
                 while (curr > lti) {
                     // inlined: bsW(2, 3);
                     while (bsLiveShadow >= 8) {
                         outShadow.write(bsBuffShadow >> 24); // write 8-bit
                         bsBuffShadow <<= 8;
                         bsLiveShadow -= 8;
                     }
                     bsBuffShadow |= 3 << (32 - bsLiveShadow - 2);
                     bsLiveShadow += 2;
 
                     curr--; /* 11 */
                 }
 
                 // inlined: bsW(1, 0);
                 while (bsLiveShadow >= 8) {
                     outShadow.write(bsBuffShadow >> 24); // write 8-bit
                     bsBuffShadow <<= 8;
                     bsLiveShadow -= 8;
                 }
                 // bsBuffShadow |= 0 << (32 - bsLiveShadow - 1);
                 bsLiveShadow++;
             }
         }
 
         this.bsBuff = bsBuffShadow;
         this.bsLive = bsLiveShadow;
     }
 
     private void sendMTFValues7() throws IOException {
         final Data dataShadow = this.data;
         final byte[][] len = dataShadow.sendMTFValues_len;
         final int[][] code = dataShadow.sendMTFValues_code;
         final OutputStream outShadow = this.out;
         final byte[] selector = dataShadow.selector;
         final char[] sfmap = dataShadow.sfmap;
         final int nMTFShadow = this.nMTF;
 
         int selCtr = 0;
 
         int bsLiveShadow = this.bsLive;
         int bsBuffShadow = this.bsBuff;
 
         for (int gs = 0; gs < nMTFShadow;) {
             final int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);
             final int selector_selCtr = selector[selCtr] & 0xff;
             final int[] code_selCtr = code[selector_selCtr];
             final byte[] len_selCtr = len[selector_selCtr];
 
             while (gs <= ge) {
                 final int sfmap_i = sfmap[gs];
 
                 //
                 // inlined: bsW(len_selCtr[sfmap_i] & 0xff,
                 // code_selCtr[sfmap_i]);
                 //
                 while (bsLiveShadow >= 8) {
                     outShadow.write(bsBuffShadow >> 24);
                     bsBuffShadow <<= 8;
                     bsLiveShadow -= 8;
                 }
                 final int n = len_selCtr[sfmap_i] & 0xFF;
                 bsBuffShadow |= code_selCtr[sfmap_i] << (32 - bsLiveShadow - n);
                 bsLiveShadow += n;
 
                 gs++;
             }
 
             gs = ge + 1;
             selCtr++;
         }
 
         this.bsBuff = bsBuffShadow;
         this.bsLive = bsLiveShadow;
     }
 
     private void moveToFrontCodeAndSend() throws IOException {
         bsW(24, this.data.origPtr);
         generateMTFValues();
         sendMTFValues();
     }
 
     private void blockSort() {
         blockSorter.blockSort(data, last);
     }
 
     /*
      * Performs Move-To-Front on the Burrows-Wheeler transformed
      * buffer, storing the MTFed data in data.sfmap in RUNA/RUNB
      * run-length-encoded form.
      *
      * <p>Keeps track of byte frequencies in data.mtfFreq at the same time.</p>
      */
     private void generateMTFValues() {
         final int lastShadow = this.last;
         final Data dataShadow = this.data;
         final boolean[] inUse = dataShadow.inUse;
         final byte[] block = dataShadow.block;
         final int[] fmap = dataShadow.fmap;
         final char[] sfmap = dataShadow.sfmap;
         final int[] mtfFreq = dataShadow.mtfFreq;
         final byte[] unseqToSeq = dataShadow.unseqToSeq;
         final byte[] yy = dataShadow.generateMTFValues_yy;
 
         // make maps
         int nInUseShadow = 0;
         for (int i = 0; i < 256; i++) {
             if (inUse[i]) {
                 unseqToSeq[i] = (byte) nInUseShadow;
                 nInUseShadow++;
             }
         }
         this.nInUse = nInUseShadow;
 
         final int eob = nInUseShadow + 1;
 
         for (int i = eob; i >= 0; i--) {
             mtfFreq[i] = 0;
         }
 
         for (int i = nInUseShadow; --i >= 0;) {
             yy[i] = (byte) i;
         }
 
         int wr = 0;
         int zPend = 0;
 
         for (int i = 0; i <= lastShadow; i++) {
             final byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];
             byte tmp = yy[0];
             int j = 0;
 
             while (ll_i != tmp) {
                 j++;
                 byte tmp2 = tmp;
                 tmp = yy[j];
                 yy[j] = tmp2;
             }
             yy[0] = tmp;
 
             if (j == 0) {
                 zPend++;
             } else {
                 if (zPend > 0) {
                     zPend--;
                     while (true) {
                         if ((zPend & 1) == 0) {
                             sfmap[wr] = RUNA;
                             wr++;
                             mtfFreq[RUNA]++;
                         } else {
                             sfmap[wr] = RUNB;
                             wr++;
                             mtfFreq[RUNB]++;
                         }
 
                         if (zPend >= 2) {
                             zPend = (zPend - 2) >> 1;
                         } else {
                             break;
                         }
                     }
                     zPend = 0;
                 }
                 sfmap[wr] = (char) (j + 1);
                 wr++;
                 mtfFreq[j + 1]++;
             }
         }
 
         if (zPend > 0) {
             zPend--;
             while (true) {
                 if ((zPend & 1) == 0) {
                     sfmap[wr] = RUNA;
                     wr++;
                     mtfFreq[RUNA]++;
                 } else {
                     sfmap[wr] = RUNB;
                     wr++;
                     mtfFreq[RUNB]++;
                 }
 
                 if (zPend >= 2) {
                     zPend = (zPend - 2) >> 1;
                 } else {
                     break;
                 }
             }
         }
 
         sfmap[wr] = (char) eob;
         mtfFreq[eob]++;
         this.nMTF = wr + 1;
     }
 
     static final class Data extends Object {
 
         // with blockSize 900k
         /* maps unsigned byte => "does it occur in block" */
         final boolean[] inUse = new boolean[256]; // 256 byte
         final byte[] unseqToSeq = new byte[256]; // 256 byte
         final int[] mtfFreq = new int[MAX_ALPHA_SIZE]; // 1032 byte
         final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte
         final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte
 
         final byte[] generateMTFValues_yy = new byte[256]; // 256 byte
         final byte[][] sendMTFValues_len = new byte[N_GROUPS][MAX_ALPHA_SIZE]; // 1548
         // byte
         final int[][] sendMTFValues_rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192
         // byte
         final int[] sendMTFValues_fave = new int[N_GROUPS]; // 24 byte
         final short[] sendMTFValues_cost = new short[N_GROUPS]; // 12 byte
         final int[][] sendMTFValues_code = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192
         // byte
         final byte[] sendMTFValues2_pos = new byte[N_GROUPS]; // 6 byte
         final boolean[] sentMTFValues4_inUse16 = new boolean[16]; // 16 byte
 
         final int[] heap = new int[MAX_ALPHA_SIZE + 2]; // 1040 byte
         final int[] weight = new int[MAX_ALPHA_SIZE * 2]; // 2064 byte
         final int[] parent = new int[MAX_ALPHA_SIZE * 2]; // 2064 byte
 
         // ------------
         // 333408 byte
 
         /* holds the RLEd block of original data starting at index 1.
          * After sorting the last byte added to the buffer is at index
          * 0. */
         final byte[] block; // 900021 byte
         /* maps index in Burrows-Wheeler transformed block => index of
          * byte in original block */
         final int[] fmap; // 3600000 byte
         final char[] sfmap; // 3600000 byte
         // ------------
         // 8433529 byte
         // ============
 
         /**
          * Index of original line in Burrows-Wheeler table.
          *
          * <p>This is the index in fmap that points to the last byte
          * of the original data.</p>
          */
         int origPtr;
 
         Data(int blockSize100k) {
             super();
 
             final int n = blockSize100k * BZip2Constants.baseBlockSize;
             this.block = new byte[(n + 1 + NUM_OVERSHOOT_BYTES)];
             this.fmap = new int[n];
             this.sfmap = new char[2 * n];
         }
 
     }
 
 }
diff --git a/src/main/org/apache/tools/mail/ErrorInQuitException.java b/src/main/org/apache/tools/mail/ErrorInQuitException.java
index 2c9b85f3f..6f78a1428 100644
--- a/src/main/org/apache/tools/mail/ErrorInQuitException.java
+++ b/src/main/org/apache/tools/mail/ErrorInQuitException.java
@@ -1,43 +1,43 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.mail;
 
 import java.io.IOException;
 
 /**
- * Specialized IOException that get thrown if SMPT's QUIT command fails.
+ * Specialized IOException that get thrown if SMTP's QUIT command fails.
  *
  * <p>This seems to happen with some version of MS Exchange that
  * doesn't respond with a 221 code immediately.  See <a
  * href="http://nagoya.apache.org/bugzilla/show_bug.cgi?id=5273">Bug
  * report 5273</a>.</p>
  *
  */
 public class ErrorInQuitException extends IOException {
 
     /**
      * Initialise from an IOException
      *
      * @param e the IO Exception.
      */
     public ErrorInQuitException(IOException e) {
         super(e.getMessage());
     }
 
 }
diff --git a/src/main/org/apache/tools/mail/MailMessage.java b/src/main/org/apache/tools/mail/MailMessage.java
index 882ca4779..a4c8bfef7 100644
--- a/src/main/org/apache/tools/mail/MailMessage.java
+++ b/src/main/org/apache/tools/mail/MailMessage.java
@@ -1,526 +1,526 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 /*
  * The original version of this class was donated by Jason Hunter,
  * who wrote the class as part of the com.oreilly.servlet
  * package for his book "Java Servlet Programming" (O'Reilly).
  * See http://www.servlets.com.
  *
  */
 
 package org.apache.tools.mail;
 
 import java.io.IOException;
 import java.io.PrintStream;
 import java.io.BufferedOutputStream;
 import java.io.OutputStream;
 import java.net.Socket;
 import java.net.InetAddress;
 import java.util.Vector;
 import java.util.Enumeration;
 
 /**
  * A class to help send SMTP email.
  * This class is an improvement on the sun.net.smtp.SmtpClient class
  * found in the JDK.  This version has extra functionality, and can be used
  * with JVMs that did not extend from the JDK.  It's not as robust as
  * the JavaMail Standard Extension classes, but it's easier to use and
  * easier to install, and has an Open Source license.
  * <p>
  * It can be used like this:
  * <blockquote><pre>
  * String mailhost = "localhost";  // or another mail host
  * String from = "Mail Message Servlet &lt;MailMessage@server.com&gt;";
  * String to = "to@you.com";
  * String cc1 = "cc1@you.com";
  * String cc2 = "cc2@you.com";
  * String bcc = "bcc@you.com";
  * &nbsp;
  * MailMessage msg = new MailMessage(mailhost);
  * msg.setPort(25);
  * msg.from(from);
  * msg.to(to);
  * msg.cc(cc1);
  * msg.cc(cc2);
  * msg.bcc(bcc);
  * msg.setSubject("Test subject");
  * PrintStream out = msg.getPrintStream();
  * &nbsp;
  * Enumeration enum = req.getParameterNames();
  * while (enum.hasMoreElements()) {
  *   String name = (String)enum.nextElement();
  *   String value = req.getParameter(name);
  *   out.println(name + " = " + value);
  * }
  * &nbsp;
  * msg.sendAndClose();
  * </pre></blockquote>
  * <p>
- * Be sure to set the from address, then set the recepient
+ * Be sure to set the from address, then set the recipient
  * addresses, then set the subject and other headers, then get the
  * PrintStream, then write the message, and finally send and close.
  * The class does minimal error checking internally; it counts on the mail
  * host to complain if there's any malformatted input or out of order
  * execution.
  * <p>
  * An attachment mechanism based on RFC 1521 could be implemented on top of
  * this class.  In the meanwhile, JavaMail is the best solution for sending
  * email with attachments.
  * <p>
  * Still to do:
  * <ul>
  * <li>Figure out how to close the connection in case of error
  * </ul>
  *
  * @version 1.1, 2000/03/19, added angle brackets to address, helps some servers
  * version 1.0, 1999/12/29
  */
 public class MailMessage {
 
     /** default mailhost */
     public static final String DEFAULT_HOST = "localhost";
 
     /** default port for SMTP: 25 */
     public static final int DEFAULT_PORT = 25;
 
     /** host name for the mail server */
     private String host;
 
     /** host port for the mail server */
     private int port = DEFAULT_PORT;
 
     /** sender email address */
     private String from;
 
     /** list of email addresses to reply to */
     private Vector replyto;
 
     /** list of email addresses to send to */
     private Vector to;
 
     /** list of email addresses to cc to */
     private Vector cc;
 
     /** headers to send in the mail */
     private Vector headersKeys;
     private Vector headersValues;
 
     private MailPrintStream out;
 
     private SmtpResponseReader in;
 
     private Socket socket;
     private static final int OK_READY = 220;
     private static final int OK_HELO = 250;
     private static final int OK_FROM = 250;
     private static final int OK_RCPT_1 = 250;
     private static final int OK_RCPT_2 = 251;
     private static final int OK_DATA = 354;
     private static final int OK_DOT = 250;
     private static final int OK_QUIT = 221;
 
   /**
    * Constructs a new MailMessage to send an email.
    * Use localhost as the mail server with port 25.
    *
    * @exception IOException if there's any problem contacting the mail server
    */
   public MailMessage() throws IOException {
     this(DEFAULT_HOST, DEFAULT_PORT);
   }
 
   /**
    * Constructs a new MailMessage to send an email.
    * Use the given host as the mail server with port 25.
    *
    * @param host the mail server to use
    * @exception IOException if there's any problem contacting the mail server
    */
   public MailMessage(String host) throws IOException {
     this(host, DEFAULT_PORT);
   }
 
   /**
    * Constructs a new MailMessage to send an email.
    * Use the given host and port as the mail server.
    *
    * @param host the mail server to use
    * @param port the port to connect to
    * @exception IOException if there's any problem contacting the mail server
    */
   public MailMessage(String host, int port) throws IOException {
     this.port = port;
     this.host = host;
     replyto = new Vector();
     to = new Vector();
     cc = new Vector();
     headersKeys = new Vector();
     headersValues = new Vector();
     connect();
     sendHelo();
   }
 
     /**
      * Set the port to connect to the SMTP host.
      * @param port the port to use for connection.
      * @see #DEFAULT_PORT
      */
     public void setPort(int port) {
         this.port = port;
     }
 
     /**
      * Sets the from address.  Also sets the "From" header.  This method should
      * be called only once.
      * @param from the from address
      * @exception IOException if there's any problem reported by the mail server
      */
     public void from(String from) throws IOException {
         sendFrom(from);
         this.from = from;
     }
 
     /**
      * Sets the replyto address
      * This method may be
      * called multiple times.
      * @param rto the replyto address
      *
      */
     public void replyto(String rto) {
       this.replyto.addElement(rto);
     }
 
   /**
    * Sets the to address.  Also sets the "To" header.  This method may be
    * called multiple times.
    *
    * @param to the to address
    * @exception IOException if there's any problem reported by the mail server
    */
   public void to(String to) throws IOException {
     sendRcpt(to);
     this.to.addElement(to);
   }
 
   /**
    * Sets the cc address.  Also sets the "Cc" header.  This method may be
    * called multiple times.
    *
    * @param cc the cc address
    * @exception IOException if there's any problem reported by the mail server
    */
   public void cc(String cc) throws IOException {
     sendRcpt(cc);
     this.cc.addElement(cc);
   }
 
   /**
    * Sets the bcc address.  Does NOT set any header since it's a *blind* copy.
    * This method may be called multiple times.
    *
    * @param bcc the bcc address
    * @exception IOException if there's any problem reported by the mail server
    */
   public void bcc(String bcc) throws IOException {
     sendRcpt(bcc);
     // No need to keep track of Bcc'd addresses
   }
 
   /**
    * Sets the subject of the mail message.  Actually sets the "Subject"
    * header.
    * @param subj the subject of the mail message
    */
   public void setSubject(String subj) {
     setHeader("Subject", subj);
   }
 
   /**
    * Sets the named header to the given value.  RFC 822 provides the rules for
    * what text may constitute a header name and value.
    * @param name name of the header
    * @param value contents of the header
    */
   public void setHeader(String name, String value) {
     // Blindly trust the user doesn't set any invalid headers
     headersKeys.add(name);
     headersValues.add(value);
   }
 
   /**
    * Returns a PrintStream that can be used to write the body of the message.
    * A stream is used since email bodies are byte-oriented.  A writer can
    * be wrapped on top if necessary for internationalization.
    * This is actually done in Message.java
    *
    * @return a printstream containing the data and the headers of the email
    * @exception IOException if there's any problem reported by the mail server
    * @see org.apache.tools.ant.taskdefs.email.Message
    */
   public PrintStream getPrintStream() throws IOException {
     setFromHeader();
     setReplyToHeader();
     setToHeader();
     setCcHeader();
     setHeader("X-Mailer", "org.apache.tools.mail.MailMessage (ant.apache.org)");
     sendData();
     flushHeaders();
     return out;
   }
 
 
   // RFC 822 s4.1: "From:" header must be sent
   // We rely on error checking by the MTA
   void setFromHeader() {
     setHeader("From", from);
   }
 
   // RFC 822 s4.1: "Reply-To:" header is optional
   void setReplyToHeader() {
     if (!replyto.isEmpty()) {
       setHeader("Reply-To", vectorToList(replyto));
     }
   }
 
   void setToHeader() {
     if (!to.isEmpty()) {
       setHeader("To", vectorToList(to));
     }
   }
 
   void setCcHeader() {
     if (!cc.isEmpty()) {
       setHeader("Cc", vectorToList(cc));
     }
   }
 
   String vectorToList(Vector v) {
     StringBuffer buf = new StringBuffer();
     Enumeration e = v.elements();
     while (e.hasMoreElements()) {
       buf.append(e.nextElement());
       if (e.hasMoreElements()) {
         buf.append(", ");
       }
     }
     return buf.toString();
   }
 
   void flushHeaders() throws IOException {
     // RFC 822 s4.1:
     //   "Header fields are NOT required to occur in any particular order,
     //    except that the message body MUST occur AFTER the headers"
     // (the same section specifies a reccommended order, which we ignore)
    final int size = headersKeys.size();
    for (int i = 0; i < size; i++) {
       String name = (String) headersKeys.elementAt(i);
       String value = (String) headersValues.elementAt(i);
       out.println(name + ": " + value);
     }
     out.println();
     out.flush();
   }
 
   /**
    * Sends the message and closes the connection to the server.
    * The MailMessage object cannot be reused.
    *
    * @exception IOException if there's any problem reported by the mail server
    */
   public void sendAndClose() throws IOException {
       try {
           sendDot();
           sendQuit();
       } finally {
           disconnect();
       }
   }
 
   // Make a limited attempt to extract a sanitized email address
   // Prefer text in <brackets>, ignore anything in (parentheses)
   static String sanitizeAddress(String s) {
     int paramDepth = 0;
     int start = 0;
     int end = 0;
     int len = s.length();
 
     for (int i = 0; i < len; i++) {
       char c = s.charAt(i);
       if (c == '(') {
         paramDepth++;
         if (start == 0) {
           end = i;  // support "address (name)"
         }
       } else if (c == ')') {
         paramDepth--;
         if (end == 0) {
           start = i + 1;  // support "(name) address"
         }
       } else if (paramDepth == 0 && c == '<') {
         start = i + 1;
       } else if (paramDepth == 0 && c == '>') {
         end = i;
       }
     }
 
     if (end == 0) {
       end = len;
     }
 
     return s.substring(start, end);
   }
 
   // * * * * * Raw protocol methods below here * * * * *
 
   void connect() throws IOException {
     socket = new Socket(host, port);
     out = new MailPrintStream(
           new BufferedOutputStream(
           socket.getOutputStream()));
     in = new SmtpResponseReader(socket.getInputStream());
     getReady();
   }
 
   void getReady() throws IOException {
     String response = in.getResponse();
     int[] ok = {OK_READY};
     if (!isResponseOK(response, ok)) {
       throw new IOException(
         "Didn't get introduction from server: " + response);
     }
   }
   void sendHelo() throws IOException {
     String local = InetAddress.getLocalHost().getHostName();
     int[] ok = {OK_HELO};
     send("HELO " + local, ok);
   }
   void sendFrom(String from) throws IOException {
     int[] ok = {OK_FROM};
     send("MAIL FROM: " + "<" + sanitizeAddress(from) + ">", ok);
   }
   void sendRcpt(String rcpt) throws IOException {
     int[] ok = {OK_RCPT_1, OK_RCPT_2};
     send("RCPT TO: " + "<" + sanitizeAddress(rcpt) + ">", ok);
   }
 
   void sendData() throws IOException {
     int[] ok = {OK_DATA};
     send("DATA", ok);
   }
 
   void sendDot() throws IOException {
     int[] ok = {OK_DOT};
     send("\r\n.", ok);  // make sure dot is on new line
   }
 
     void sendQuit() throws IOException {
         int[] ok = {OK_QUIT};
         try {
             send("QUIT", ok);
         } catch (IOException e) {
             throw new ErrorInQuitException(e);
         }
     }
 
     void send(String msg, int[] ok) throws IOException {
         out.rawPrint(msg + "\r\n");  // raw supports <CRLF>.<CRLF>
         String response = in.getResponse();
         if (!isResponseOK(response, ok)) {
             throw new IOException("Unexpected reply to command: "
                                   + msg + ": " + response);
         }
     }
 
   boolean isResponseOK(String response, int[] ok) {
     // Check that the response is one of the valid codes
     for (int i = 0; i < ok.length; i++) {
       if (response.startsWith("" + ok[i])) {
         return true;
       }
     }
     return false;
   }
 
     void disconnect() throws IOException {
         if (out != null) {
             out.close();
         }
         if (in != null) {
             try {
                 in.close();
             } catch (IOException e) {
                 // ignore
             }
         }
         if (socket != null) {
             try {
                 socket.close();
             } catch (IOException e) {
                 // ignore
             }
         }
     }
 }
 
 /**
  * This PrintStream subclass makes sure that <CRLF>. becomes <CRLF>..
  *  per RFC 821.  It also ensures that new lines are always \r\n.
 */
 class MailPrintStream extends PrintStream {
 
   private int lastChar;
 
   public MailPrintStream(OutputStream out) {
     super(out, true);  // deprecated, but email is byte-oriented
   }
 
   // Mac does \n\r, but that's tough to distinguish from Windows \r\n\r\n.
   // Don't tackle that problem right now.
   public void write(int b) {
     if (b == '\n' && lastChar != '\r') {
       rawWrite('\r');  // ensure always \r\n
       rawWrite(b);
     } else if (b == '.' && lastChar == '\n') {
       rawWrite('.');  // add extra dot
       rawWrite(b);
     } else {
       rawWrite(b);
     }
     lastChar = b;
   }
 
   public void write(byte[] buf, int off, int len) {
     for (int i = 0; i < len; i++) {
       write(buf[off + i]);
     }
   }
 
   void rawWrite(int b) {
     super.write(b);
   }
 
   void rawPrint(String s) {
     int len = s.length();
     for (int i = 0; i < len; i++) {
       rawWrite(s.charAt(i));
     }
   }
 }
 
diff --git a/src/main/org/apache/tools/tar/TarEntry.java b/src/main/org/apache/tools/tar/TarEntry.java
index 726957221..bca54861d 100644
--- a/src/main/org/apache/tools/tar/TarEntry.java
+++ b/src/main/org/apache/tools/tar/TarEntry.java
@@ -1,664 +1,664 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 /*
  * This package is based on the work done by Timothy Gerard Endres
  * (time@ice.com) to whom the Ant project is very grateful for his great code.
  */
 
 package org.apache.tools.tar;
 
 import java.io.File;
 import java.util.Date;
 import java.util.Locale;
 
 /**
  * This class represents an entry in a Tar archive. It consists
  * of the entry's header, as well as the entry's File. Entries
  * can be instantiated in one of three ways, depending on how
  * they are to be used.
  * <p>
  * TarEntries that are created from the header bytes read from
  * an archive are instantiated with the TarEntry( byte[] )
  * constructor. These entries will be used when extracting from
  * or listing the contents of an archive. These entries have their
  * header filled in using the header bytes. They also set the File
  * to null, since they reference an archive entry not a file.
  * <p>
  * TarEntries that are created from Files that are to be written
  * into an archive are instantiated with the TarEntry( File )
  * constructor. These entries have their header filled in using
  * the File's information. They also keep a reference to the File
  * for convenience when writing entries.
  * <p>
  * Finally, TarEntries can be constructed from nothing but a name.
  * This allows the programmer to construct the entry by hand, for
  * instance when only an InputStream is available for writing to
  * the archive, and the header information is constructed from
  * other information. In this case the header fields are set to
  * defaults and the File is set to null.
  *
  * <p>
  * The C structure for a Tar Entry's header is:
  * <pre>
  * struct header {
  * char name[NAMSIZ];
  * char mode[8];
  * char uid[8];
  * char gid[8];
  * char size[12];
  * char mtime[12];
  * char chksum[8];
  * char linkflag;
  * char linkname[NAMSIZ];
  * char magic[8];
  * char uname[TUNMLEN];
  * char gname[TGNMLEN];
  * char devmajor[8];
  * char devminor[8];
  * } header;
  * </pre>
  *
  */
 
 public class TarEntry implements TarConstants {
     /** The entry's name. */
     private StringBuffer name;
 
     /** The entry's permission mode. */
     private int mode;
 
     /** The entry's user id. */
     private int userId;
 
     /** The entry's group id. */
     private int groupId;
 
     /** The entry's size. */
     private long size;
 
     /** The entry's modification time. */
     private long modTime;
 
     /** The entry's link flag. */
     private byte linkFlag;
 
     /** The entry's link name. */
     private StringBuffer linkName;
 
     /** The entry's magic tag. */
     private StringBuffer magic;
 
     /** The entry's user name. */
     private StringBuffer userName;
 
     /** The entry's group name. */
     private StringBuffer groupName;
 
     /** The entry's major device number. */
     private int devMajor;
 
     /** The entry's minor device number. */
     private int devMinor;
 
     /** The entry's file reference */
     private File file;
 
     /** Maximum length of a user's name in the tar file */
     public static final int MAX_NAMELEN = 31;
 
     /** Default permissions bits for directories */
     public static final int DEFAULT_DIR_MODE = 040755;
 
     /** Default permissions bits for files */
     public static final int DEFAULT_FILE_MODE = 0100644;
 
     /** Convert millis to seconds */
     public static final int MILLIS_PER_SECOND = 1000;
 
     /**
      * Construct an empty entry and prepares the header values.
      */
     private TarEntry () {
         this.magic = new StringBuffer(TMAGIC);
         this.name = new StringBuffer();
         this.linkName = new StringBuffer();
 
         String user = System.getProperty("user.name", "");
 
         if (user.length() > MAX_NAMELEN) {
             user = user.substring(0, MAX_NAMELEN);
         }
 
         this.userId = 0;
         this.groupId = 0;
         this.userName = new StringBuffer(user);
         this.groupName = new StringBuffer("");
         this.file = null;
     }
 
     /**
      * Construct an entry with only a name. This allows the programmer
      * to construct the entry's header "by hand". File is set to null.
      *
      * @param name the entry name
      */
     public TarEntry(String name) {
         this(name, false);
     }
 
     /**
      * Construct an entry with only a name. This allows the programmer
      * to construct the entry's header "by hand". File is set to null.
      *
      * @param name the entry name
      * @param preserveLeadingSlashes whether to allow leading slashes
      * in the name.
      */
     public TarEntry(String name, boolean preserveLeadingSlashes) {
         this();
 
         name = normalizeFileName(name, preserveLeadingSlashes);
         boolean isDir = name.endsWith("/");
 
         this.devMajor = 0;
         this.devMinor = 0;
         this.name = new StringBuffer(name);
         this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;
         this.linkFlag = isDir ? LF_DIR : LF_NORMAL;
         this.userId = 0;
         this.groupId = 0;
         this.size = 0;
         this.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;
         this.linkName = new StringBuffer("");
         this.userName = new StringBuffer("");
         this.groupName = new StringBuffer("");
         this.devMajor = 0;
         this.devMinor = 0;
 
     }
 
     /**
      * Construct an entry with a name and a link flag.
      *
      * @param name the entry name
      * @param linkFlag the entry link flag.
      */
     public TarEntry(String name, byte linkFlag) {
         this(name);
         this.linkFlag = linkFlag;
         if (linkFlag == LF_GNUTYPE_LONGNAME) {
             magic = new StringBuffer(GNU_TMAGIC);
         }
     }
 
     /**
      * Construct an entry for a file. File is set to file, and the
      * header is constructed from information from the file.
      *
      * @param file The file that the entry represents.
      */
     public TarEntry(File file) {
         this();
 
         this.file = file;
 
         String fileName = normalizeFileName(file.getPath(), false);
         this.linkName = new StringBuffer("");
         this.name = new StringBuffer(fileName);
 
         if (file.isDirectory()) {
             this.mode = DEFAULT_DIR_MODE;
             this.linkFlag = LF_DIR;
 
             int nameLength = name.length();
             if (nameLength == 0 || name.charAt(nameLength - 1) != '/') {
                 this.name.append("/");
             }
             this.size = 0;
         } else {
             this.mode = DEFAULT_FILE_MODE;
             this.linkFlag = LF_NORMAL;
             this.size = file.length();
         }
 
         this.modTime = file.lastModified() / MILLIS_PER_SECOND;
         this.devMajor = 0;
         this.devMinor = 0;
     }
 
     /**
      * Construct an entry from an archive's header bytes. File is set
      * to null.
      *
      * @param headerBuf The header bytes from a tar archive entry.
      */
     public TarEntry(byte[] headerBuf) {
         this();
         parseTarHeader(headerBuf);
     }
 
     /**
      * Determine if the two entries are equal. Equality is determined
      * by the header names being equal.
      *
      * @param it Entry to be checked for equality.
      * @return True if the entries are equal.
      */
     public boolean equals(TarEntry it) {
         return getName().equals(it.getName());
     }
 
     /**
      * Determine if the two entries are equal. Equality is determined
      * by the header names being equal.
      *
      * @param it Entry to be checked for equality.
      * @return True if the entries are equal.
      */
     public boolean equals(Object it) {
         if (it == null || getClass() != it.getClass()) {
             return false;
         }
         return equals((TarEntry) it);
     }
 
     /**
      * Hashcodes are based on entry names.
      *
      * @return the entry hashcode
      */
     public int hashCode() {
         return getName().hashCode();
     }
 
     /**
      * Determine if the given entry is a descendant of this entry.
      * Descendancy is determined by the name of the descendant
      * starting with this entry's name.
      *
-     * @param desc Entry to be checked as a descendent of this.
+     * @param desc Entry to be checked as a descendant of this.
      * @return True if entry is a descendant of this.
      */
     public boolean isDescendent(TarEntry desc) {
         return desc.getName().startsWith(getName());
     }
 
     /**
      * Get this entry's name.
      *
      * @return This entry's name.
      */
     public String getName() {
         return name.toString();
     }
 
     /**
      * Set this entry's name.
      *
      * @param name This entry's new name.
      */
     public void setName(String name) {
         this.name = new StringBuffer(normalizeFileName(name, false));
     }
 
     /**
      * Set the mode for this entry
      *
      * @param mode the mode for this entry
      */
     public void setMode(int mode) {
         this.mode = mode;
     }
 
     /**
      * Get this entry's link name.
      *
      * @return This entry's link name.
      */
     public String getLinkName() {
         return linkName.toString();
     }
 
     /**
      * Get this entry's user id.
      *
      * @return This entry's user id.
      */
     public int getUserId() {
         return userId;
     }
 
     /**
      * Set this entry's user id.
      *
      * @param userId This entry's new user id.
      */
     public void setUserId(int userId) {
         this.userId = userId;
     }
 
     /**
      * Get this entry's group id.
      *
      * @return This entry's group id.
      */
     public int getGroupId() {
         return groupId;
     }
 
     /**
      * Set this entry's group id.
      *
      * @param groupId This entry's new group id.
      */
     public void setGroupId(int groupId) {
         this.groupId = groupId;
     }
 
     /**
      * Get this entry's user name.
      *
      * @return This entry's user name.
      */
     public String getUserName() {
         return userName.toString();
     }
 
     /**
      * Set this entry's user name.
      *
      * @param userName This entry's new user name.
      */
     public void setUserName(String userName) {
         this.userName = new StringBuffer(userName);
     }
 
     /**
      * Get this entry's group name.
      *
      * @return This entry's group name.
      */
     public String getGroupName() {
         return groupName.toString();
     }
 
     /**
      * Set this entry's group name.
      *
      * @param groupName This entry's new group name.
      */
     public void setGroupName(String groupName) {
         this.groupName = new StringBuffer(groupName);
     }
 
     /**
      * Convenience method to set this entry's group and user ids.
      *
      * @param userId This entry's new user id.
      * @param groupId This entry's new group id.
      */
     public void setIds(int userId, int groupId) {
         setUserId(userId);
         setGroupId(groupId);
     }
 
     /**
      * Convenience method to set this entry's group and user names.
      *
      * @param userName This entry's new user name.
      * @param groupName This entry's new group name.
      */
     public void setNames(String userName, String groupName) {
         setUserName(userName);
         setGroupName(groupName);
     }
 
     /**
      * Set this entry's modification time. The parameter passed
      * to this method is in "Java time".
      *
      * @param time This entry's new modification time.
      */
     public void setModTime(long time) {
         modTime = time / MILLIS_PER_SECOND;
     }
 
     /**
      * Set this entry's modification time.
      *
      * @param time This entry's new modification time.
      */
     public void setModTime(Date time) {
         modTime = time.getTime() / MILLIS_PER_SECOND;
     }
 
     /**
      * Set this entry's modification time.
      *
      * @return time This entry's new modification time.
      */
     public Date getModTime() {
         return new Date(modTime * MILLIS_PER_SECOND);
     }
 
     /**
      * Get this entry's file.
      *
      * @return This entry's file.
      */
     public File getFile() {
         return file;
     }
 
     /**
      * Get this entry's mode.
      *
      * @return This entry's mode.
      */
     public int getMode() {
         return mode;
     }
 
     /**
      * Get this entry's file size.
      *
      * @return This entry's file size.
      */
     public long getSize() {
         return size;
     }
 
     /**
      * Set this entry's file size.
      *
      * @param size This entry's new file size.
      */
     public void setSize(long size) {
         this.size = size;
     }
 
 
     /**
      * Indicate if this entry is a GNU long name block
      *
      * @return true if this is a long name extension provided by GNU tar
      */
     public boolean isGNULongNameEntry() {
         return linkFlag == LF_GNUTYPE_LONGNAME
                            && name.toString().equals(GNU_LONGLINK);
     }
 
     /**
      * Return whether or not this entry represents a directory.
      *
      * @return True if this entry is a directory.
      */
     public boolean isDirectory() {
         if (file != null) {
             return file.isDirectory();
         }
 
         if (linkFlag == LF_DIR) {
             return true;
         }
 
         if (getName().endsWith("/")) {
             return true;
         }
 
         return false;
     }
 
     /**
      * If this entry represents a file, and the file is a directory, return
      * an array of TarEntries for this entry's children.
      *
      * @return An array of TarEntry's for this entry's children.
      */
     public TarEntry[] getDirectoryEntries() {
         if (file == null || !file.isDirectory()) {
             return new TarEntry[0];
         }
 
         String[]   list = file.list();
         TarEntry[] result = new TarEntry[list.length];
 
         for (int i = 0; i < list.length; ++i) {
             result[i] = new TarEntry(new File(file, list[i]));
         }
 
         return result;
     }
 
     /**
      * Write an entry's header information to a header buffer.
      *
      * @param outbuf The tar entry header buffer to fill in.
      */
     public void writeEntryHeader(byte[] outbuf) {
         int offset = 0;
 
         offset = TarUtils.getNameBytes(name, outbuf, offset, NAMELEN);
         offset = TarUtils.getOctalBytes(mode, outbuf, offset, MODELEN);
         offset = TarUtils.getOctalBytes(userId, outbuf, offset, UIDLEN);
         offset = TarUtils.getOctalBytes(groupId, outbuf, offset, GIDLEN);
         offset = TarUtils.getLongOctalBytes(size, outbuf, offset, SIZELEN);
         offset = TarUtils.getLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);
 
         int csOffset = offset;
 
         for (int c = 0; c < CHKSUMLEN; ++c) {
             outbuf[offset++] = (byte) ' ';
         }
 
         outbuf[offset++] = linkFlag;
         offset = TarUtils.getNameBytes(linkName, outbuf, offset, NAMELEN);
         offset = TarUtils.getNameBytes(magic, outbuf, offset, MAGICLEN);
         offset = TarUtils.getNameBytes(userName, outbuf, offset, UNAMELEN);
         offset = TarUtils.getNameBytes(groupName, outbuf, offset, GNAMELEN);
         offset = TarUtils.getOctalBytes(devMajor, outbuf, offset, DEVLEN);
         offset = TarUtils.getOctalBytes(devMinor, outbuf, offset, DEVLEN);
 
         while (offset < outbuf.length) {
             outbuf[offset++] = 0;
         }
 
         long chk = TarUtils.computeCheckSum(outbuf);
 
         TarUtils.getCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);
     }
 
     /**
      * Parse an entry's header information from a header buffer.
      *
      * @param header The tar entry header buffer to get information from.
      */
     public void parseTarHeader(byte[] header) {
         int offset = 0;
 
         name = TarUtils.parseName(header, offset, NAMELEN);
         offset += NAMELEN;
         mode = (int) TarUtils.parseOctal(header, offset, MODELEN);
         offset += MODELEN;
         userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);
         offset += UIDLEN;
         groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);
         offset += GIDLEN;
         size = TarUtils.parseOctal(header, offset, SIZELEN);
         offset += SIZELEN;
         modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);
         offset += MODTIMELEN;
         offset += CHKSUMLEN;
         linkFlag = header[offset++];
         linkName = TarUtils.parseName(header, offset, NAMELEN);
         offset += NAMELEN;
         magic = TarUtils.parseName(header, offset, MAGICLEN);
         offset += MAGICLEN;
         userName = TarUtils.parseName(header, offset, UNAMELEN);
         offset += UNAMELEN;
         groupName = TarUtils.parseName(header, offset, GNAMELEN);
         offset += GNAMELEN;
         devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);
         offset += DEVLEN;
         devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);
     }
 
     /**
      * Strips Windows' drive letter as well as any leading slashes,
      * turns path separators into forward slahes.
      */
     private static String normalizeFileName(String fileName,
                                             boolean preserveLeadingSlashes) {
         String osname = System.getProperty("os.name").toLowerCase(Locale.ENGLISH);
 
         if (osname != null) {
 
             // Strip off drive letters!
             // REVIEW Would a better check be "(File.separator == '\')"?
 
             if (osname.startsWith("windows")) {
                 if (fileName.length() > 2) {
                     char ch1 = fileName.charAt(0);
                     char ch2 = fileName.charAt(1);
 
                     if (ch2 == ':'
                         && ((ch1 >= 'a' && ch1 <= 'z')
                             || (ch1 >= 'A' && ch1 <= 'Z'))) {
                         fileName = fileName.substring(2);
                     }
                 }
             } else if (osname.indexOf("netware") > -1) {
                 int colon = fileName.indexOf(':');
                 if (colon != -1) {
                     fileName = fileName.substring(colon + 1);
                 }
             }
         }
 
         fileName = fileName.replace(File.separatorChar, '/');
 
         // No absolute pathnames
         // Windows (and Posix?) paths can start with "\\NetworkDrive\",
         // so we loop on starting /'s.
         while (!preserveLeadingSlashes && fileName.startsWith("/")) {
             fileName = fileName.substring(1);
         }
         return fileName;
     }
 }
diff --git a/src/main/org/apache/tools/tar/TarInputStream.java b/src/main/org/apache/tools/tar/TarInputStream.java
index f6c126ce4..00f96746b 100644
--- a/src/main/org/apache/tools/tar/TarInputStream.java
+++ b/src/main/org/apache/tools/tar/TarInputStream.java
@@ -1,402 +1,402 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 /*
  * This package is based on the work done by Timothy Gerard Endres
  * (time@ice.com) to whom the Ant project is very grateful for his great code.
  */
 
 package org.apache.tools.tar;
 
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
 /**
  * The TarInputStream reads a UNIX tar archive as an InputStream.
  * methods are provided to position at each successive entry in
  * the archive, and the read each entry as a normal input stream
  * using read().
  *
  */
 public class TarInputStream extends FilterInputStream {
     private static final int SMALL_BUFFER_SIZE = 256;
     private static final int BUFFER_SIZE = 8 * 1024;
     private static final int LARGE_BUFFER_SIZE = 32 * 1024;
     private static final int BYTE_MASK = 0xFF;
 
     // CheckStyle:VisibilityModifier OFF - bc
     protected boolean debug;
     protected boolean hasHitEOF;
     protected long entrySize;
     protected long entryOffset;
     protected byte[] readBuf;
     protected TarBuffer buffer;
     protected TarEntry currEntry;
 
     /**
      * This contents of this array is not used at all in this class,
      * it is only here to avoid repreated object creation during calls
      * to the no-arg read method.
      */
     protected byte[] oneBuf;
 
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Constructor for TarInputStream.
      * @param is the input stream to use
      */
     public TarInputStream(InputStream is) {
         this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
     }
 
     /**
      * Constructor for TarInputStream.
      * @param is the input stream to use
      * @param blockSize the block size to use
      */
     public TarInputStream(InputStream is, int blockSize) {
         this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);
     }
 
     /**
      * Constructor for TarInputStream.
      * @param is the input stream to use
      * @param blockSize the block size to use
      * @param recordSize the record size to use
      */
     public TarInputStream(InputStream is, int blockSize, int recordSize) {
         super(is);
 
         this.buffer = new TarBuffer(is, blockSize, recordSize);
         this.readBuf = null;
         this.oneBuf = new byte[1];
         this.debug = false;
         this.hasHitEOF = false;
     }
 
     /**
      * Sets the debugging flag.
      *
      * @param debug True to turn on debugging.
      */
     public void setDebug(boolean debug) {
         this.debug = debug;
         buffer.setDebug(debug);
     }
 
     /**
      * Closes this stream. Calls the TarBuffer's close() method.
      * @throws IOException on error
      */
     public void close() throws IOException {
         buffer.close();
     }
 
     /**
      * Get the record size being used by this stream's TarBuffer.
      *
      * @return The TarBuffer record size.
      */
     public int getRecordSize() {
         return buffer.getRecordSize();
     }
 
     /**
      * Get the available data that can be read from the current
      * entry in the archive. This does not indicate how much data
      * is left in the entire archive, only in the current entry.
      * This value is determined from the entry's size header field
      * and the amount of data already read from the current entry.
-     * Integer.MAX_VALUE is returen in case more than Integer.MAX_VALUE
+     * Integer.MAX_VALUE is returned in case more than Integer.MAX_VALUE
      * bytes are left in the current entry in the archive.
      *
      * @return The number of available bytes for the current entry.
      * @throws IOException for signature
      */
     public int available() throws IOException {
         if (entrySize - entryOffset > Integer.MAX_VALUE) {
             return Integer.MAX_VALUE;
         }
         return (int) (entrySize - entryOffset);
     }
 
     /**
      * Skip bytes in the input buffer. This skips bytes in the
      * current entry's data, not the entire archive, and will
      * stop at the end of the current entry's data if the number
      * to skip extends beyond that point.
      *
      * @param numToSkip The number of bytes to skip.
      * @return the number actually skipped
      * @throws IOException on error
      */
     public long skip(long numToSkip) throws IOException {
         // REVIEW
         // This is horribly inefficient, but it ensures that we
         // properly skip over bytes via the TarBuffer...
         //
         byte[] skipBuf = new byte[BUFFER_SIZE];
         long skip = numToSkip;
         while (skip > 0) {
             int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);
             int numRead = read(skipBuf, 0, realSkip);
             if (numRead == -1) {
                 break;
             }
             skip -= numRead;
         }
         return (numToSkip - skip);
     }
 
     /**
      * Since we do not support marking just yet, we return false.
      *
      * @return False.
      */
     public boolean markSupported() {
         return false;
     }
 
     /**
      * Since we do not support marking just yet, we do nothing.
      *
      * @param markLimit The limit to mark.
      */
     public void mark(int markLimit) {
     }
 
     /**
      * Since we do not support marking just yet, we do nothing.
      */
     public void reset() {
     }
 
     /**
      * Get the next entry in this tar archive. This will skip
      * over any remaining data in the current entry, if there
      * is one, and place the input stream at the header of the
      * next entry, and read the header and instantiate a new
      * TarEntry from the header bytes and return that entry.
      * If there are no more entries in the archive, null will
      * be returned to indicate that the end of the archive has
      * been reached.
      *
      * @return The next TarEntry in the archive, or null.
      * @throws IOException on error
      */
     public TarEntry getNextEntry() throws IOException {
         if (hasHitEOF) {
             return null;
         }
 
         if (currEntry != null) {
             long numToSkip = entrySize - entryOffset;
 
             if (debug) {
                 System.err.println("TarInputStream: SKIP currENTRY '"
                         + currEntry.getName() + "' SZ "
                         + entrySize + " OFF "
                         + entryOffset + "  skipping "
                         + numToSkip + " bytes");
             }
 
             while (numToSkip > 0) {
                 long skipped = skip(numToSkip);
                 if (skipped <= 0) {
                     throw new RuntimeException("failed to skip current tar"
                                                + " entry");
                 }
                 numToSkip -= skipped;
             }
 
             readBuf = null;
         }
 
         byte[] headerBuf = buffer.readRecord();
 
         if (headerBuf == null) {
             if (debug) {
                 System.err.println("READ NULL RECORD");
             }
             hasHitEOF = true;
         } else if (buffer.isEOFRecord(headerBuf)) {
             if (debug) {
                 System.err.println("READ EOF RECORD");
             }
             hasHitEOF = true;
         }
 
         if (hasHitEOF) {
             currEntry = null;
         } else {
             currEntry = new TarEntry(headerBuf);
 
             if (debug) {
                 System.err.println("TarInputStream: SET CURRENTRY '"
                         + currEntry.getName()
                         + "' size = "
                         + currEntry.getSize());
             }
 
             entryOffset = 0;
 
             entrySize = currEntry.getSize();
         }
 
         if (currEntry != null && currEntry.isGNULongNameEntry()) {
             // read in the name
             StringBuffer longName = new StringBuffer();
             byte[] buf = new byte[SMALL_BUFFER_SIZE];
             int length = 0;
             while ((length = read(buf)) >= 0) {
                 longName.append(new String(buf, 0, length));
             }
             getNextEntry();
             if (currEntry == null) {
                 // Bugzilla: 40334
                 // Malformed tar file - long entry name not followed by entry
                 return null;
             }
             // remove trailing null terminator
             if (longName.length() > 0
                 && longName.charAt(longName.length() - 1) == 0) {
                 longName.deleteCharAt(longName.length() - 1);
             }
             currEntry.setName(longName.toString());
         }
 
         return currEntry;
     }
 
     /**
      * Reads a byte from the current tar archive entry.
      *
      * This method simply calls read( byte[], int, int ).
      *
      * @return The byte read, or -1 at EOF.
      * @throws IOException on error
      */
     public int read() throws IOException {
         int num = read(oneBuf, 0, 1);
         return num == -1 ? -1 : ((int) oneBuf[0]) & BYTE_MASK;
     }
 
     /**
      * Reads bytes from the current tar archive entry.
      *
      * This method is aware of the boundaries of the current
      * entry in the archive and will deal with them as if they
      * were this stream's start and EOF.
      *
      * @param buf The buffer into which to place bytes read.
      * @param offset The offset at which to place bytes read.
      * @param numToRead The number of bytes to read.
      * @return The number of bytes read, or -1 at EOF.
      * @throws IOException on error
      */
     public int read(byte[] buf, int offset, int numToRead) throws IOException {
         int totalRead = 0;
 
         if (entryOffset >= entrySize) {
             return -1;
         }
 
         if ((numToRead + entryOffset) > entrySize) {
             numToRead = (int) (entrySize - entryOffset);
         }
 
         if (readBuf != null) {
             int sz = (numToRead > readBuf.length) ? readBuf.length
                     : numToRead;
 
             System.arraycopy(readBuf, 0, buf, offset, sz);
 
             if (sz >= readBuf.length) {
                 readBuf = null;
             } else {
                 int newLen = readBuf.length - sz;
                 byte[] newBuf = new byte[newLen];
 
                 System.arraycopy(readBuf, sz, newBuf, 0, newLen);
 
                 readBuf = newBuf;
             }
 
             totalRead += sz;
             numToRead -= sz;
             offset += sz;
         }
 
         while (numToRead > 0) {
             byte[] rec = buffer.readRecord();
 
             if (rec == null) {
                 // Unexpected EOF!
                 throw new IOException("unexpected EOF with " + numToRead
                         + " bytes unread");
             }
 
             int sz = numToRead;
             int recLen = rec.length;
 
             if (recLen > sz) {
                 System.arraycopy(rec, 0, buf, offset, sz);
 
                 readBuf = new byte[recLen - sz];
 
                 System.arraycopy(rec, sz, readBuf, 0, recLen - sz);
             } else {
                 sz = recLen;
 
                 System.arraycopy(rec, 0, buf, offset, recLen);
             }
 
             totalRead += sz;
             numToRead -= sz;
             offset += sz;
         }
 
         entryOffset += totalRead;
 
         return totalRead;
     }
 
     /**
      * Copies the contents of the current tar archive entry directly into
      * an output stream.
      *
      * @param out The OutputStream into which to write the entry's data.
      * @throws IOException on error
      */
     public void copyEntryContents(OutputStream out) throws IOException {
         byte[] buf = new byte[LARGE_BUFFER_SIZE];
 
         while (true) {
             int numRead = read(buf, 0, buf.length);
 
             if (numRead == -1) {
                 break;
             }
 
             out.write(buf, 0, numRead);
         }
     }
 }
diff --git a/src/main/org/apache/tools/zip/AbstractUnicodeExtraField.java b/src/main/org/apache/tools/zip/AbstractUnicodeExtraField.java
index 3ba2e0ea5..02e6e1e70 100644
--- a/src/main/org/apache/tools/zip/AbstractUnicodeExtraField.java
+++ b/src/main/org/apache/tools/zip/AbstractUnicodeExtraField.java
@@ -1,162 +1,162 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.zip;
 
 import java.io.UnsupportedEncodingException;
 import java.util.zip.CRC32;
 import java.util.zip.ZipException;
 
 /**
  * A common base class for Unicode extra information extra fields.
  */
 public abstract class AbstractUnicodeExtraField implements ZipExtraField {
     private long nameCRC32;
     private byte[] unicodeName;
     private byte[] data;
 
     protected AbstractUnicodeExtraField() {
     }
 
     /**
      * Assemble as unicode extension from the name/comment and
-     * encoding of the orginal zip entry.
+     * encoding of the original zip entry.
      * 
      * @param text The file name or comment.
      * @param bytes The encoded of the filename or comment in the zip
      * file.
      * @param off The offset of the encoded filename or comment in
      * <code>bytes</code>.
      * @param len The length of the encoded filename or commentin
      * <code>bytes</code>.
      */
     protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,
                                         int len) {
         CRC32 crc32 = new CRC32();
         crc32.update(bytes, off, len);
         nameCRC32 = crc32.getValue();
 
         try {
             unicodeName = text.getBytes("UTF-8");
         } catch (UnsupportedEncodingException e) {
             throw new RuntimeException("FATAL: UTF-8 encoding not supported.",
                                        e);
         }
     }
 
     /**
      * Assemble as unicode extension from the name/comment and
-     * encoding of the orginal zip entry.
+     * encoding of the original zip entry.
      * 
      * @param text The file name or comment.
      * @param bytes The encoded of the filename or comment in the zip
      * file.
      */
     protected AbstractUnicodeExtraField(String text, byte[] bytes) {
 
         this(text, bytes, 0, bytes.length);
     }
 
     private void assembleData() {
         if (unicodeName == null) {
             return;
         }
 
         data = new byte[5 + unicodeName.length];
         // version 1
         data[0] = 0x01;
         System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);
         System.arraycopy(unicodeName, 0, data, 5, unicodeName.length);
     }
 
     /**
      * @return The CRC32 checksum of the filename or comment as
      *         encoded in the central directory of the zip file.
      */
     public long getNameCRC32() {
         return nameCRC32;
     }
 
     /**
      * @param nameCRC32 The CRC32 checksum of the filename as encoded
      *         in the central directory of the zip file to set.
      */
     public void setNameCRC32(long nameCRC32) {
         this.nameCRC32 = nameCRC32;
         data = null;
     }
 
     /**
      * @return The utf-8 encoded name.
      */
     public byte[] getUnicodeName() {
         return unicodeName;
     }
 
     /**
      * @param unicodeName The utf-8 encoded name to set.
      */
     public void setUnicodeName(byte[] unicodeName) {
         this.unicodeName = unicodeName;
         data = null;
     }
 
     public byte[] getCentralDirectoryData() {
         if (data == null) {
             this.assembleData();
         }
         return data;
     }
 
     public ZipShort getCentralDirectoryLength() {
         if (data == null) {
             assembleData();
         }
         return new ZipShort(data.length);
     }
 
     public byte[] getLocalFileDataData() {
         return getCentralDirectoryData();
     }
 
     public ZipShort getLocalFileDataLength() {
         return getCentralDirectoryLength();
     }
 
     public void parseFromLocalFileData(byte[] buffer, int offset, int length)
         throws ZipException {
 
         if (length < 5) {
             throw new ZipException("UniCode path extra data must have at least"
                                    + " 5 bytes.");
         }
 
         int version = buffer[offset];
 
         if (version != 0x01) {
             throw new ZipException("Unsupported version [" + version
                                    + "] for UniCode path extra data.");
         }
 
         nameCRC32 = ZipLong.getValue(buffer, offset + 1);
         unicodeName = new byte[length - 5];
         System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5);
         data = null;
     }
 
 }
diff --git a/src/main/org/apache/tools/zip/ExtraFieldUtils.java b/src/main/org/apache/tools/zip/ExtraFieldUtils.java
index 7f6460ebb..ffa03b6c0 100644
--- a/src/main/org/apache/tools/zip/ExtraFieldUtils.java
+++ b/src/main/org/apache/tools/zip/ExtraFieldUtils.java
@@ -1,313 +1,313 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.zip;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.zip.ZipException;
 
 /**
  * ZipExtraField related methods
  *
  */
 // CheckStyle:HideUtilityClassConstructorCheck OFF (bc)
 public class ExtraFieldUtils {
 
     private static final int WORD = 4;
 
     /**
      * Static registry of known extra fields.
      *
      * @since 1.1
      */
     private static final Map implementations;
 
     static {
         implementations = new HashMap();
         register(AsiExtraField.class);
         register(JarMarker.class);
         register(UnicodePathExtraField.class);
         register(UnicodeCommentExtraField.class);
     }
 
     /**
      * Register a ZipExtraField implementation.
      *
      * <p>The given class must have a no-arg constructor and implement
      * the {@link ZipExtraField ZipExtraField interface}.</p>
      * @param c the class to register
      *
      * @since 1.1
      */
     public static void register(Class c) {
         try {
             ZipExtraField ze = (ZipExtraField) c.newInstance();
             implementations.put(ze.getHeaderId(), c);
         } catch (ClassCastException cc) {
             throw new RuntimeException(c + " doesn\'t implement ZipExtraField");
         } catch (InstantiationException ie) {
             throw new RuntimeException(c + " is not a concrete class");
         } catch (IllegalAccessException ie) {
             throw new RuntimeException(c + "\'s no-arg constructor is not public");
         }
     }
 
     /**
-     * Create an instance of the approriate ExtraField, falls back to
+     * Create an instance of the appropriate ExtraField, falls back to
      * {@link UnrecognizedExtraField UnrecognizedExtraField}.
      * @param headerId the header identifier
-     * @return an instance of the appropiate ExtraField
+     * @return an instance of the appropriate ExtraField
      * @exception InstantiationException if unable to instantiate the class
-     * @exception IllegalAccessException if not allowed to instatiate the class
+     * @exception IllegalAccessException if not allowed to instantiate the class
      * @since 1.1
      */
     public static ZipExtraField createExtraField(ZipShort headerId)
         throws InstantiationException, IllegalAccessException {
         Class c = (Class) implementations.get(headerId);
         if (c != null) {
             return (ZipExtraField) c.newInstance();
         }
         UnrecognizedExtraField u = new UnrecognizedExtraField();
         u.setHeaderId(headerId);
         return u;
     }
 
     /**
      * Split the array into ExtraFields and populate them with the
      * given data as local file data, throwing an exception if the
      * data cannot be parsed.
      * @param data an array of bytes as it appears in local file data
      * @return an array of ExtraFields
      * @throws ZipException on error
      */
     public static ZipExtraField[] parse(byte[] data) throws ZipException {
         return parse(data, true, UnparseableExtraField.THROW);
     }
 
     /**
      * Split the array into ExtraFields and populate them with the
      * given data, throwing an exception if the data cannot be parsed.
      * @param data an array of bytes
      * @param local whether data originates from the local file data
      * or the central directory
      * @return an array of ExtraFields
      * @since 1.1
      * @throws ZipException on error
      */
     public static ZipExtraField[] parse(byte[] data, boolean local)
         throws ZipException {
         return parse(data, local, UnparseableExtraField.THROW);
     }
 
     /**
      * Split the array into ExtraFields and populate them with the
      * given data.
      * @param data an array of bytes
      * @param local whether data originates from the local file data
      * or the central directory
      * @param onUnparseableData what to do if the extra field data
      * cannot be parsed.
      * @return an array of ExtraFields
      * @throws ZipException on error
      * @since Ant 1.8.1
      */
     public static ZipExtraField[] parse(byte[] data, boolean local,
                                         UnparseableExtraField onUnparseableData)
         throws ZipException {
         List v = new ArrayList();
         int start = 0;
         LOOP:
         while (start <= data.length - WORD) {
             ZipShort headerId = new ZipShort(data, start);
             int length = (new ZipShort(data, start + 2)).getValue();
             if (start + WORD + length > data.length) {
                 switch(onUnparseableData.getKey()) {
                 case UnparseableExtraField.THROW_KEY:
                     throw new ZipException("bad extra field starting at "
                                            + start + ".  Block length of "
                                            + length + " bytes exceeds remaining"
                                            + " data of "
                                            + (data.length - start - WORD)
                                            + " bytes.");
                 case UnparseableExtraField.READ_KEY:
                     UnparseableExtraFieldData field =
                         new UnparseableExtraFieldData();
                     if (local) {
                         field.parseFromLocalFileData(data, start,
                                                      data.length - start);
                     } else {
                         field.parseFromCentralDirectoryData(data, start,
                                                             data.length - start);
                     }
                     v.add(field);
                     /*FALLTHROUGH*/
                 case UnparseableExtraField.SKIP_KEY:
                     // since we cannot parse the data we must assume
                     // the extra field consumes the whole rest of the
                     // available data
                     break LOOP;
                 default:
                     throw new ZipException("unknown UnparseableExtraField key: "
                                            + onUnparseableData.getKey());
                 }
             }
             try {
                 ZipExtraField ze = createExtraField(headerId);
                 if (local
                     || !(ze instanceof CentralDirectoryParsingZipExtraField)) {
                     ze.parseFromLocalFileData(data, start + WORD, length);
                 } else {
                     ((CentralDirectoryParsingZipExtraField) ze)
                         .parseFromCentralDirectoryData(data, start + WORD,
                                                        length);
                 }
                 v.add(ze);
             } catch (InstantiationException ie) {
                 throw new ZipException(ie.getMessage());
             } catch (IllegalAccessException iae) {
                 throw new ZipException(iae.getMessage());
             }
             start += (length + WORD);
         }
 
         ZipExtraField[] result = new ZipExtraField[v.size()];
         return (ZipExtraField[]) v.toArray(result);
     }
 
     /**
      * Merges the local file data fields of the given ZipExtraFields.
      * @param data an array of ExtraFiles
      * @return an array of bytes
      * @since 1.1
      */
     public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {
         final boolean lastIsUnparseableHolder = data.length > 0
             && data[data.length - 1] instanceof UnparseableExtraFieldData;
         int regularExtraFieldCount =
             lastIsUnparseableHolder ? data.length - 1 : data.length;
 
         int sum = WORD * regularExtraFieldCount;
         for (int i = 0; i < data.length; i++) {
             sum += data[i].getLocalFileDataLength().getValue();
         }
 
         byte[] result = new byte[sum];
         int start = 0;
         for (int i = 0; i < regularExtraFieldCount; i++) {
             System.arraycopy(data[i].getHeaderId().getBytes(),
                              0, result, start, 2);
             System.arraycopy(data[i].getLocalFileDataLength().getBytes(),
                              0, result, start + 2, 2);
             byte[] local = data[i].getLocalFileDataData();
             System.arraycopy(local, 0, result, start + WORD, local.length);
             start += (local.length + WORD);
         }
         if (lastIsUnparseableHolder) {
             byte[] local = data[data.length - 1].getLocalFileDataData();
             System.arraycopy(local, 0, result, start, local.length);
         }
         return result;
     }
 
     /**
      * Merges the central directory fields of the given ZipExtraFields.
      * @param data an array of ExtraFields
      * @return an array of bytes
      * @since 1.1
      */
     public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {
         final boolean lastIsUnparseableHolder = data.length > 0
             && data[data.length - 1] instanceof UnparseableExtraFieldData;
         int regularExtraFieldCount =
             lastIsUnparseableHolder ? data.length - 1 : data.length;
 
         int sum = WORD * regularExtraFieldCount;
         for (int i = 0; i < data.length; i++) {
             sum += data[i].getCentralDirectoryLength().getValue();
         }
         byte[] result = new byte[sum];
         int start = 0;
         for (int i = 0; i < regularExtraFieldCount; i++) {
             System.arraycopy(data[i].getHeaderId().getBytes(),
                              0, result, start, 2);
             System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),
                              0, result, start + 2, 2);
             byte[] local = data[i].getCentralDirectoryData();
             System.arraycopy(local, 0, result, start + WORD, local.length);
             start += (local.length + WORD);
         }
         if (lastIsUnparseableHolder) {
             byte[] local = data[data.length - 1].getCentralDirectoryData();
             System.arraycopy(local, 0, result, start, local.length);
         }
         return result;
     }
 
     /**
      * "enum" for the possible actions to take if the extra field
      * cannot be parsed.
      */
     public static final class UnparseableExtraField {
         /**
          * Key for "throw an exception" action.
          */
         public static final int THROW_KEY = 0;
         /**
          * Key for "skip" action.
          */
         public static final int SKIP_KEY = 1;
         /**
          * Key for "read" action.
          */
         public static final int READ_KEY = 2;
 
         /**
          * Throw an exception if field cannot be parsed.
          */
         public static final UnparseableExtraField THROW
             = new UnparseableExtraField(THROW_KEY);
 
         /**
          * Skip the extra field entirely and don't make its data
          * available - effectively removing the extra field data.
          */
         public static final UnparseableExtraField SKIP
             = new UnparseableExtraField(SKIP_KEY);
 
         /**
          * Read the extra field data into an instance of {@link
          * UnparseableExtraFieldData UnparseableExtraFieldData}.
          */
         public static final UnparseableExtraField READ
             = new UnparseableExtraField(READ_KEY);
 
         private final int key;
 
         private UnparseableExtraField(int k) {
             key = k;
         }
 
         /**
          * Key of the action to take.
          */
         public int getKey() { return key; }
     }
 }
diff --git a/src/main/org/apache/tools/zip/ZipEntry.java b/src/main/org/apache/tools/zip/ZipEntry.java
index a14abccfb..834ba8ba9 100644
--- a/src/main/org/apache/tools/zip/ZipEntry.java
+++ b/src/main/org/apache/tools/zip/ZipEntry.java
@@ -1,517 +1,517 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.zip;
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.zip.ZipException;
 
 /**
  * Extension that adds better handling of extra fields and provides
  * access to the internal and external file attributes.
  *
  * <p>The extra data is expected to follow the recommendation of
  * the .ZIP File Format Specification created by PKWARE Inc. :</p>
  * <ul>
  *   <li>the extra byte array consists of a sequence of extra fields</li>
  *   <li>each extra fields starts by a two byte header id followed by
  *   a two byte sequence holding the length of the remainder of
  *   data.</li>
  * </ul>
  *
  * <p>Any extra data that cannot be parsed by the rules above will be
  * consumed as "unparseable" extra data and treated differently by the
  * methods of this class.  Versions prior to Apache Commons Compress
  * 1.1 would have thrown an exception if any attempt was made to read
  * or write extra data not conforming to the recommendation.</p>
  * @see <a href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">
  * .ZIP File Format Specification</a> 
  *
  */
 public class ZipEntry extends java.util.zip.ZipEntry implements Cloneable {
 
     public static final int PLATFORM_UNIX = 3;
     public static final int PLATFORM_FAT  = 0;
     private static final int SHORT_MASK = 0xFFFF;
     private static final int SHORT_SHIFT = 16;
 
     private int internalAttributes = 0;
     private int platform = PLATFORM_FAT;
     private long externalAttributes = 0;
     private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;
     private UnparseableExtraFieldData unparseableExtra = null;
     private String name = null;
 
     /**
      * Creates a new zip entry with the specified name.
      * @param name the name of the entry
      * @since 1.1
      */
     public ZipEntry(String name) {
         super(name);
     }
 
     /**
      * Creates a new zip entry with fields taken from the specified zip entry.
      * @param entry the entry to get fields from
      * @since 1.1
      * @throws ZipException on error
      */
     public ZipEntry(java.util.zip.ZipEntry entry) throws ZipException {
         super(entry);
         byte[] extra = entry.getExtra();
         if (extra != null) {
             setExtraFields(ExtraFieldUtils.parse(extra, true,
                                                  ExtraFieldUtils
                                                  .UnparseableExtraField.READ));
         } else {
             // initializes extra data to an empty byte array
             setExtra();
         }
     }
 
     /**
      * Creates a new zip entry with fields taken from the specified zip entry.
      * @param entry the entry to get fields from
      * @throws ZipException on error
      * @since 1.1
      */
     public ZipEntry(ZipEntry entry) throws ZipException {
         this((java.util.zip.ZipEntry) entry);
         setInternalAttributes(entry.getInternalAttributes());
         setExternalAttributes(entry.getExternalAttributes());
         setExtraFields(entry.getExtraFields(true));
     }
 
     /**
      * @since 1.9
      */
     protected ZipEntry() {
         super("");
     }
 
     /**
      * Overwrite clone.
      * @return a cloned copy of this ZipEntry
      * @since 1.1
      */
     public Object clone() {
         ZipEntry e = (ZipEntry) super.clone();
 
         e.setInternalAttributes(getInternalAttributes());
         e.setExternalAttributes(getExternalAttributes());
         e.setExtraFields(getExtraFields(true));
         return e;
     }
 
     /**
      * Retrieves the internal file attributes.
      *
      * @return the internal file attributes
      * @since 1.1
      */
     public int getInternalAttributes() {
         return internalAttributes;
     }
 
     /**
      * Sets the internal file attributes.
      * @param value an <code>int</code> value
      * @since 1.1
      */
     public void setInternalAttributes(int value) {
         internalAttributes = value;
     }
 
     /**
      * Retrieves the external file attributes.
      * @return the external file attributes
      * @since 1.1
      */
     public long getExternalAttributes() {
         return externalAttributes;
     }
 
     /**
      * Sets the external file attributes.
      * @param value an <code>long</code> value
      * @since 1.1
      */
     public void setExternalAttributes(long value) {
         externalAttributes = value;
     }
 
     /**
      * Sets Unix permissions in a way that is understood by Info-Zip's
      * unzip command.
      * @param mode an <code>int</code> value
      * @since Ant 1.5.2
      */
     public void setUnixMode(int mode) {
         // CheckStyle:MagicNumberCheck OFF - no point
         setExternalAttributes((mode << SHORT_SHIFT)
                               // MS-DOS read-only attribute
                               | ((mode & 0200) == 0 ? 1 : 0)
                               // MS-DOS directory flag
                               | (isDirectory() ? 0x10 : 0));
         // CheckStyle:MagicNumberCheck ON
         platform = PLATFORM_UNIX;
     }
 
     /**
      * Unix permission.
      * @return the unix permissions
      * @since Ant 1.6
      */
     public int getUnixMode() {
         return platform != PLATFORM_UNIX ? 0 :
             (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);
     }
 
     /**
      * Platform specification to put into the &quot;version made
      * by&quot; part of the central file header.
      *
      * @return PLATFORM_FAT unless {@link #setUnixMode setUnixMode}
-     * has been called, in which case PLATORM_UNIX will be returned.
+     * has been called, in which case PLATFORM_UNIX will be returned.
      *
      * @since Ant 1.5.2
      */
     public int getPlatform() {
         return platform;
     }
 
     /**
      * Set the platform (UNIX or FAT).
      * @param platform an <code>int</code> value - 0 is FAT, 3 is UNIX
      * @since 1.9
      */
     protected void setPlatform(int platform) {
         this.platform = platform;
     }
 
     /**
      * Replaces all currently attached extra fields with the new array.
      * @param fields an array of extra fields
      * @since 1.1
      */
     public void setExtraFields(ZipExtraField[] fields) {
         extraFields = new LinkedHashMap();
         for (int i = 0; i < fields.length; i++) {
             if (fields[i] instanceof UnparseableExtraFieldData) {
                 unparseableExtra = (UnparseableExtraFieldData) fields[i];
             } else {
                 extraFields.put(fields[i].getHeaderId(), fields[i]);
             }
         }
         setExtra();
     }
 
     /**
      * Retrieves all extra fields that have been parsed successfully.
      * @return an array of the extra fields
      */
     public ZipExtraField[] getExtraFields() {
         return getExtraFields(false);
     }
 
     /**
      * Retrieves extra fields.
      * @param includeUnparseable whether to also return unparseable
      * extra fields as {@link UnparseableExtraFieldData} if such data
      * exists.
      * @return an array of the extra fields
      * @since 1.1
      */
     public ZipExtraField[] getExtraFields(boolean includeUnparseable) {
         if (extraFields == null) {
             return !includeUnparseable || unparseableExtra == null
                 ? new ZipExtraField[0]
                 : new ZipExtraField[] { unparseableExtra };
         }
         List result = new ArrayList(extraFields.values());
         if (includeUnparseable && unparseableExtra != null) {
             result.add(unparseableExtra);
         }
         return (ZipExtraField[]) result.toArray(new ZipExtraField[0]);
     }
 
     /**
      * Adds an extra field - replacing an already present extra field
      * of the same type.
      *
      * <p>If no extra field of the same type exists, the field will be
      * added as last field.</p>
      * @param ze an extra field
      * @since 1.1
      */
     public void addExtraField(ZipExtraField ze) {
         if (ze instanceof UnparseableExtraFieldData) {
             unparseableExtra = (UnparseableExtraFieldData) ze;
         } else {
             if (extraFields == null) {
                 extraFields = new LinkedHashMap();
             }
             extraFields.put(ze.getHeaderId(), ze);
         }
         setExtra();
     }
 
     /**
      * Adds an extra field - replacing an already present extra field
      * of the same type.
      *
      * <p>The new extra field will be the first one.</p>
      * @param ze an extra field
      * @since 1.1
      */
     public void addAsFirstExtraField(ZipExtraField ze) {
         if (ze instanceof UnparseableExtraFieldData) {
             unparseableExtra = (UnparseableExtraFieldData) ze;
         } else {
             LinkedHashMap copy = extraFields;
             extraFields = new LinkedHashMap();
             extraFields.put(ze.getHeaderId(), ze);
             if (copy != null) {
                 copy.remove(ze.getHeaderId());
                 extraFields.putAll(copy);
             }
         }
         setExtra();
     }
 
     /**
      * Remove an extra field.
      * @param type the type of extra field to remove
      * @since 1.1
      */
     public void removeExtraField(ZipShort type) {
         if (extraFields == null) {
             throw new java.util.NoSuchElementException();
         }
         if (extraFields.remove(type) == null) {
             throw new java.util.NoSuchElementException();
         }
         setExtra();
     }
 
     /**
      * Removes unparseable extra field data.
      */
     public void removeUnparseableExtraFieldData() {
         if (unparseableExtra == null) {
             throw new java.util.NoSuchElementException();
         }
         unparseableExtra = null;
         setExtra();
     }
 
     /**
      * Looks up an extra field by its header id.
      *
      * @return null if no such field exists.
      */
     public ZipExtraField getExtraField(ZipShort type) {
         if (extraFields != null) {
             return (ZipExtraField) extraFields.get(type);
         }
         return null;
     }
 
     /**
      * Looks up extra field data that couldn't be parsed correctly.
      *
      * @return null if no such field exists.
      */
     public UnparseableExtraFieldData getUnparseableExtraFieldData() {
         return unparseableExtra;
     }
 
     /**
      * Parses the given bytes as extra field data and consumes any
      * unparseable data as an {@link UnparseableExtraFieldData}
      * instance.
      * @param extra an array of bytes to be parsed into extra fields
      * @throws RuntimeException if the bytes cannot be parsed
      * @since 1.1
      * @throws RuntimeException on error
      */
     public void setExtra(byte[] extra) throws RuntimeException {
         try {
             ZipExtraField[] local =
                 ExtraFieldUtils.parse(extra, true,
                                       ExtraFieldUtils.UnparseableExtraField.READ);
             mergeExtraFields(local, true);
         } catch (Exception e) {
             // actually this is not be possible as of Ant 1.8.1
             throw new RuntimeException("Error parsing extra fields for entry: "
                                        + getName() + " - " + e.getMessage(), e);
         }
     }
 
     /**
      * Unfortunately {@link java.util.zip.ZipOutputStream
      * java.util.zip.ZipOutputStream} seems to access the extra data
      * directly, so overriding getExtra doesn't help - we need to
      * modify super's data directly.
      *
      * @since 1.1
      */
     protected void setExtra() {
         super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));
     }
 
     /**
      * Sets the central directory part of extra fields.
      */
     public void setCentralDirectoryExtra(byte[] b) {
         try {
             ZipExtraField[] central =
                 ExtraFieldUtils.parse(b, false,
                                       ExtraFieldUtils.UnparseableExtraField.READ);
             mergeExtraFields(central, false);
         } catch (Exception e) {
             throw new RuntimeException(e.getMessage(), e);
         }
     }
 
     /**
      * Retrieves the extra data for the local file data.
      * @return the extra data for local file
      * @since 1.1
      */
     public byte[] getLocalFileDataExtra() {
         byte[] extra = getExtra();
         return extra != null ? extra : new byte[0];
     }
 
     /**
      * Retrieves the extra data for the central directory.
      * @return the central directory extra data
      * @since 1.1
      */
     public byte[] getCentralDirectoryExtra() {
         return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields(true));
     }
 
     /**
      * Make this class work in JDK 1.1 like a 1.2 class.
      *
      * <p>This either stores the size for later usage or invokes
      * setCompressedSize via reflection.</p>
      * @param size the size to use
      * @deprecated since 1.7.
      *             Use setCompressedSize directly.
      * @since 1.2
      */
     public void setComprSize(long size) {
         setCompressedSize(size);
     }
 
     /**
      * Get the name of the entry.
      * @return the entry name
      * @since 1.9
      */
     public String getName() {
         return name == null ? super.getName() : name;
     }
 
     /**
      * Is this entry a directory?
      * @return true if the entry is a directory
      * @since 1.10
      */
     public boolean isDirectory() {
         return getName().endsWith("/");
     }
 
     /**
      * Set the name of the entry.
      * @param name the name to use
      */
     protected void setName(String name) {
         this.name = name;
     }
 
     /**
      * Get the hashCode of the entry.
      * This uses the name as the hashcode.
      * @return a hashcode.
      * @since Ant 1.7
      */
     public int hashCode() {
         // this method has severe consequences on performance. We cannot rely
         // on the super.hashCode() method since super.getName() always return
         // the empty string in the current implemention (there's no setter)
         // so it is basically draining the performance of a hashmap lookup
         return getName().hashCode();
     }
 
     /**
      * The equality method. In this case, the implementation returns 'this == o'
      * which is basically the equals method of the Object class.
      * @param o the object to compare to
      * @return true if this object is the same as <code>o</code>
      * @since Ant 1.7
      */
     public boolean equals(Object o) {
         return (this == o);
     }
 
     /**
      * If there are no extra fields, use the given fields as new extra
      * data - otherwise merge the fields assuming the existing fields
      * and the new fields stem from different locations inside the
      * archive.
      * @param f the extra fields to merge
      * @param local whether the new fields originate from local data
      */
     private void mergeExtraFields(ZipExtraField[] f, boolean local)
         throws ZipException {
         if (extraFields == null) {
             setExtraFields(f);
         } else {
             for (int i = 0; i < f.length; i++) {
                 ZipExtraField existing;
                 if (f[i] instanceof UnparseableExtraFieldData) {
                     existing = unparseableExtra;
                 } else {
                     existing = getExtraField(f[i].getHeaderId());
                 }
                 if (existing == null) {
                     addExtraField(f[i]);
                 } else {
                     if (local
                         || !(existing
                              instanceof CentralDirectoryParsingZipExtraField)) {
                         byte[] b = f[i].getLocalFileDataData();
                         existing.parseFromLocalFileData(b, 0, b.length);
                     } else {
                         byte[] b = f[i].getCentralDirectoryData();
                         ((CentralDirectoryParsingZipExtraField) existing)
                             .parseFromCentralDirectoryData(b, 0, b.length);
                     }
                 }
             }
             setExtra();
         }
     }
 }
diff --git a/src/main/org/apache/tools/zip/ZipFile.java b/src/main/org/apache/tools/zip/ZipFile.java
index 6614fe4c9..2336916fc 100644
--- a/src/main/org/apache/tools/zip/ZipFile.java
+++ b/src/main/org/apache/tools/zip/ZipFile.java
@@ -1,749 +1,749 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.zip;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.RandomAccessFile;
 import java.util.Calendar;
 import java.util.Collections;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.zip.CRC32;
 import java.util.zip.Inflater;
 import java.util.zip.InflaterInputStream;
 import java.util.zip.ZipException;
 
 /**
  * Replacement for <code>java.util.ZipFile</code>.
  *
  * <p>This class adds support for file name encodings other than UTF-8
  * (which is required to work on ZIP files created by native zip tools
  * and is able to skip a preamble like the one found in self
  * extracting archives.  Furthermore it returns instances of
  * <code>org.apache.tools.zip.ZipEntry</code> instead of
  * <code>java.util.zip.ZipEntry</code>.</p>
  *
  * <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would
  * have to reimplement all methods anyway.  Like
  * <code>java.util.ZipFile</code>, it uses RandomAccessFile under the
  * covers and supports compressed and uncompressed entries.</p>
  *
  * <p>The method signatures mimic the ones of
  * <code>java.util.zip.ZipFile</code>, with a couple of exceptions:
  *
  * <ul>
  *   <li>There is no getName method.</li>
  *   <li>entries has been renamed to getEntries.</li>
  *   <li>getEntries and getEntry return
  *   <code>org.apache.tools.zip.ZipEntry</code> instances.</li>
  *   <li>close is allowed to throw IOException.</li>
  * </ul>
  *
  */
 public class ZipFile {
     private static final int HASH_SIZE = 509;
     private static final int SHORT     =   2;
     private static final int WORD      =   4;
     private static final int NIBLET_MASK = 0x0f;
     private static final int BYTE_SHIFT = 8;
     private static final int POS_0 = 0;
     private static final int POS_1 = 1;
     private static final int POS_2 = 2;
     private static final int POS_3 = 3;
 
     /**
      * Maps ZipEntrys to Longs, recording the offsets of the local
      * file headers.
      */
     private final Map entries = new HashMap(HASH_SIZE);
 
     /**
      * Maps String to ZipEntrys, name -> actual entry.
      */
     private final Map nameMap = new HashMap(HASH_SIZE);
 
     private static final class OffsetEntry {
         private long headerOffset = -1;
         private long dataOffset = -1;
     }
 
     /**
      * The encoding to use for filenames and the file comment.
      *
      * <p>For a list of possible values see <a
      * href="http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.
      * Defaults to the platform's default character encoding.</p>
      */
     private String encoding = null;
 
     /**
      * The zip encoding to use for filenames and the file comment.
      */
     private final ZipEncoding zipEncoding;
 
     /**
      * The actual data source.
      */
     private RandomAccessFile archive;
 
     /**
      * Whether to look for and use Unicode extra fields.
      */
     private final boolean useUnicodeExtraFields;
 
     /**
      * Opens the given file for reading, assuming the platform's
      * native encoding for file names.
      *
      * @param f the archive.
      *
      * @throws IOException if an error occurs while reading the file.
      */
     public ZipFile(File f) throws IOException {
         this(f, null);
     }
 
     /**
      * Opens the given file for reading, assuming the platform's
      * native encoding for file names.
      *
      * @param name name of the archive.
      *
      * @throws IOException if an error occurs while reading the file.
      */
     public ZipFile(String name) throws IOException {
         this(new File(name), null);
     }
 
     /**
      * Opens the given file for reading, assuming the specified
      * encoding for file names, scanning unicode extra fields.
      *
      * @param name name of the archive.
      * @param encoding the encoding to use for file names
      *
      * @throws IOException if an error occurs while reading the file.
      */
     public ZipFile(String name, String encoding) throws IOException {
         this(new File(name), encoding, true);
     }
 
     /**
      * Opens the given file for reading, assuming the specified
      * encoding for file names and scanning for unicode extra fields.
      *
      * @param f the archive.
      * @param encoding the encoding to use for file names, use null
      * for the platform's default encoding
      *
      * @throws IOException if an error occurs while reading the file.
      */
     public ZipFile(File f, String encoding) throws IOException {
         this(f, encoding, true);
     }
 
     /**
      * Opens the given file for reading, assuming the specified
      * encoding for file names.
      *
      * @param f the archive.
      * @param encoding the encoding to use for file names, use null
      * for the platform's default encoding
      * @param useUnicodeExtraFields whether to use InfoZIP Unicode
      * Extra Fields (if present) to set the file names.
      *
      * @throws IOException if an error occurs while reading the file.
      */
     public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)
         throws IOException {
         this.encoding = encoding;
         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
         this.useUnicodeExtraFields = useUnicodeExtraFields;
         archive = new RandomAccessFile(f, "r");
         boolean success = false;
         try {
             Map entriesWithoutUTF8Flag = populateFromCentralDirectory();
             resolveLocalFileHeaderData(entriesWithoutUTF8Flag);
             success = true;
         } finally {
             if (!success) {
                 try {
                     archive.close();
                 } catch (IOException e2) {
                     // swallow, throw the original exception instead
                 }
             }
         }
     }
 
     /**
      * The encoding to use for filenames and the file comment.
      *
      * @return null if using the platform's default character encoding.
      */
     public String getEncoding() {
         return encoding;
     }
 
     /**
      * Closes the archive.
      * @throws IOException if an error occurs closing the archive.
      */
     public void close() throws IOException {
         archive.close();
     }
 
     /**
      * close a zipfile quietly; throw no io fault, do nothing
      * on a null parameter
      * @param zipfile file to close, can be null
      */
     public static void closeQuietly(ZipFile zipfile) {
         if (zipfile != null) {
             try {
                 zipfile.close();
             } catch (IOException e) {
                 //ignore
             }
         }
     }
 
     /**
      * Returns all entries.
      * @return all entries as {@link ZipEntry} instances
      */
     public Enumeration getEntries() {
         return Collections.enumeration(entries.keySet());
     }
 
     /**
      * Returns a named entry - or <code>null</code> if no entry by
      * that name exists.
      * @param name name of the entry.
      * @return the ZipEntry corresponding to the given name - or
      * <code>null</code> if not present.
      */
     public ZipEntry getEntry(String name) {
         return (ZipEntry) nameMap.get(name);
     }
 
     /**
      * Returns an InputStream for reading the contents of the given entry.
      * @param ze the entry to get the stream for.
      * @return a stream to read the entry from.
-     * @throws IOException if unable to create an input stream from the zipenty
+     * @throws IOException if unable to create an input stream from the zipentry
      * @throws ZipException if the zipentry has an unsupported
      * compression method
      */
     public InputStream getInputStream(ZipEntry ze)
         throws IOException, ZipException {
         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze);
         if (offsetEntry == null) {
             return null;
         }
         long start = offsetEntry.dataOffset;
         BoundedInputStream bis =
             new BoundedInputStream(start, ze.getCompressedSize());
         switch (ze.getMethod()) {
             case ZipEntry.STORED:
                 return bis;
             case ZipEntry.DEFLATED:
                 bis.addDummy();
                 final Inflater inflater = new Inflater(true);
                 return new InflaterInputStream(bis, inflater) {
                     public void close() throws IOException {
                         super.close();
                         inflater.end();
                     }
                 };
             default:
                 throw new ZipException("Found unsupported compression method "
                                        + ze.getMethod());
         }
     }
 
     private static final int CFH_LEN =
         /* version made by                 */ SHORT
         /* version needed to extract       */ + SHORT
         /* general purpose bit flag        */ + SHORT
         /* compression method              */ + SHORT
         /* last mod file time              */ + SHORT
         /* last mod file date              */ + SHORT
         /* crc-32                          */ + WORD
         /* compressed size                 */ + WORD
         /* uncompressed size               */ + WORD
         /* filename length                 */ + SHORT
         /* extra field length              */ + SHORT
         /* file comment length             */ + SHORT
         /* disk number start               */ + SHORT
         /* internal file attributes        */ + SHORT
         /* external file attributes        */ + WORD
         /* relative offset of local header */ + WORD;
 
     /**
      * Reads the central directory of the given archive and populates
      * the internal tables with ZipEntry instances.
      *
      * <p>The ZipEntrys will know all data that can be obtained from
      * the central directory alone, but not the data that requires the
      * local file header or additional data to be read.</p>
      *
      * @return a Map&lt;ZipEntry, NameAndComment>&gt; of
      * zipentries that didn't have the language encoding flag set when
      * read.
      */
     private Map populateFromCentralDirectory()
         throws IOException {
         HashMap noUTF8Flag = new HashMap();
 
         positionAtCentralDirectory();
 
         byte[] cfh = new byte[CFH_LEN];
 
         byte[] signatureBytes = new byte[WORD];
         archive.readFully(signatureBytes);
         long sig = ZipLong.getValue(signatureBytes);
         final long cfhSig = ZipLong.getValue(ZipOutputStream.CFH_SIG);
         if (sig != cfhSig && startsWithLocalFileHeader()) {
             throw new IOException("central directory is empty, can't expand"
                                   + " corrupt archive.");
         }
         while (sig == cfhSig) {
             archive.readFully(cfh);
             int off = 0;
             ZipEntry ze = new ZipEntry();
 
             int versionMadeBy = ZipShort.getValue(cfh, off);
             off += SHORT;
             ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);
 
             off += SHORT; // skip version info
 
             final int generalPurposeFlag = ZipShort.getValue(cfh, off);
             final boolean hasUTF8Flag = 
                 (generalPurposeFlag & ZipOutputStream.UFT8_NAMES_FLAG) != 0;
             final ZipEncoding entryEncoding =
                 hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
 
             off += SHORT;
 
             ze.setMethod(ZipShort.getValue(cfh, off));
             off += SHORT;
 
             // FIXME this is actually not very cpu cycles friendly as we are converting from
             // dos to java while the underlying Sun implementation will convert
             // from java to dos time for internal storage...
             long time = dosToJavaTime(ZipLong.getValue(cfh, off));
             ze.setTime(time);
             off += WORD;
 
             ze.setCrc(ZipLong.getValue(cfh, off));
             off += WORD;
 
             ze.setCompressedSize(ZipLong.getValue(cfh, off));
             off += WORD;
 
             ze.setSize(ZipLong.getValue(cfh, off));
             off += WORD;
 
             int fileNameLen = ZipShort.getValue(cfh, off);
             off += SHORT;
 
             int extraLen = ZipShort.getValue(cfh, off);
             off += SHORT;
 
             int commentLen = ZipShort.getValue(cfh, off);
             off += SHORT;
 
             off += SHORT; // disk number
 
             ze.setInternalAttributes(ZipShort.getValue(cfh, off));
             off += SHORT;
 
             ze.setExternalAttributes(ZipLong.getValue(cfh, off));
             off += WORD;
 
             byte[] fileName = new byte[fileNameLen];
             archive.readFully(fileName);
             ze.setName(entryEncoding.decode(fileName));
 
             // LFH offset,
             OffsetEntry offset = new OffsetEntry();
             offset.headerOffset = ZipLong.getValue(cfh, off);
             // data offset will be filled later
             entries.put(ze, offset);
 
             nameMap.put(ze.getName(), ze);
 
             byte[] cdExtraData = new byte[extraLen];
             archive.readFully(cdExtraData);
             ze.setCentralDirectoryExtra(cdExtraData);
 
             byte[] comment = new byte[commentLen];
             archive.readFully(comment);
             ze.setComment(entryEncoding.decode(comment));
 
             archive.readFully(signatureBytes);
             sig = ZipLong.getValue(signatureBytes);
 
             if (!hasUTF8Flag && useUnicodeExtraFields) {
                 noUTF8Flag.put(ze, new NameAndComment(fileName, comment));
             }
         }
         return noUTF8Flag;
     }
 
     private static final int MIN_EOCD_SIZE =
         /* end of central dir signature    */ WORD
         /* number of this disk             */ + SHORT
         /* number of the disk with the     */
         /* start of the central directory  */ + SHORT
         /* total number of entries in      */
         /* the central dir on this disk    */ + SHORT
         /* total number of entries in      */
         /* the central dir                 */ + SHORT
         /* size of the central directory   */ + WORD
         /* offset of start of central      */
         /* directory with respect to       */
         /* the starting disk number        */ + WORD
         /* zipfile comment length          */ + SHORT;
 
     private static final int MAX_EOCD_SIZE = MIN_EOCD_SIZE
         /* maximum length of zipfile comment */ + 0xFFFF;
 
     private static final int CFD_LOCATOR_OFFSET =
         /* end of central dir signature    */ WORD
         /* number of this disk             */ + SHORT
         /* number of the disk with the     */
         /* start of the central directory  */ + SHORT
         /* total number of entries in      */
         /* the central dir on this disk    */ + SHORT
         /* total number of entries in      */
         /* the central dir                 */ + SHORT
         /* size of the central directory   */ + WORD;
 
     /**
      * Searches for the &quot;End of central dir record&quot;, parses
      * it and positions the stream at the first central directory
      * record.
      */
     private void positionAtCentralDirectory()
         throws IOException {
         boolean found = false;
         long off = archive.length() - MIN_EOCD_SIZE;
         final long stopSearching =
             Math.max(0L, archive.length() - MAX_EOCD_SIZE);
         if (off >= 0) {
             final byte[] sig = ZipOutputStream.EOCD_SIG;
             for (; off >= stopSearching; off--) {
                 archive.seek(off);
                 int curr = archive.read();
                 if (curr == -1) {
                     break;
                 }
                 if (curr == sig[POS_0]) {
                     curr = archive.read();
                     if (curr == sig[POS_1]) {
                         curr = archive.read();
                         if (curr == sig[POS_2]) {
                             curr = archive.read();
                             if (curr == sig[POS_3]) {
                                 found = true;
                                 break;
                             }
                         }
                     }
                 }
             }
         }
         if (!found) {
             throw new ZipException("archive is not a ZIP archive");
         }
         archive.seek(off + CFD_LOCATOR_OFFSET);
         byte[] cfdOffset = new byte[WORD];
         archive.readFully(cfdOffset);
         archive.seek(ZipLong.getValue(cfdOffset));
     }
 
     /**
      * Number of bytes in local file header up to the &quot;length of
      * filename&quot; entry.
      */
     private static final long LFH_OFFSET_FOR_FILENAME_LENGTH =
         /* local file header signature     */ WORD
         /* version needed to extract       */ + SHORT
         /* general purpose bit flag        */ + SHORT
         /* compression method              */ + SHORT
         /* last mod file time              */ + SHORT
         /* last mod file date              */ + SHORT
         /* crc-32                          */ + WORD
         /* compressed size                 */ + WORD
         /* uncompressed size               */ + WORD;
 
     /**
      * Walks through all recorded entries and adds the data available
      * from the local file header.
      *
      * <p>Also records the offsets for the data to read from the
      * entries.</p>
      */
     private void resolveLocalFileHeaderData(Map entriesWithoutUTF8Flag)
         throws IOException {
         Enumeration e = Collections.enumeration(new HashSet(entries.keySet()));
         while (e.hasMoreElements()) {
             ZipEntry ze = (ZipEntry) e.nextElement();
             OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze);
             long offset = offsetEntry.headerOffset;
             archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);
             byte[] b = new byte[SHORT];
             archive.readFully(b);
             int fileNameLen = ZipShort.getValue(b);
             archive.readFully(b);
             int extraFieldLen = ZipShort.getValue(b);
             int lenToSkip = fileNameLen;
             while (lenToSkip > 0) {
                 int skipped = archive.skipBytes(lenToSkip);
                 if (skipped <= 0) {
                     throw new RuntimeException("failed to skip file name in"
                                                + " local file header");
                 }
                 lenToSkip -= skipped;
             }            
             byte[] localExtraData = new byte[extraFieldLen];
             archive.readFully(localExtraData);
             ze.setExtra(localExtraData);
             /*dataOffsets.put(ze,
                             new Long(offset + LFH_OFFSET_FOR_FILENAME_LENGTH
                                      + SHORT + SHORT + fileNameLen + extraFieldLen));
             */
             offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH
                 + SHORT + SHORT + fileNameLen + extraFieldLen;
 
             if (entriesWithoutUTF8Flag.containsKey(ze)) {
                 // changing the name of a ZipEntry is going to change
                 // the hashcode
                 // - see https://issues.apache.org/jira/browse/COMPRESS-164
                 entries.remove(ze);
                 setNameAndCommentFromExtraFields(ze,
                                                  (NameAndComment)
                                                  entriesWithoutUTF8Flag.get(ze));
                 entries.put(ze, offsetEntry);
             }
         }
     }
 
     /**
      * Convert a DOS date/time field to a Date object.
      *
      * @param zipDosTime contains the stored DOS time.
      * @return a Date instance corresponding to the given time.
      */
     protected static Date fromDosTime(ZipLong zipDosTime) {
         long dosTime = zipDosTime.getValue();
         return new Date(dosToJavaTime(dosTime));
     }
 
     /*
      * Converts DOS time to Java time (number of milliseconds since epoch).
      */
     private static long dosToJavaTime(long dosTime) {
         Calendar cal = Calendar.getInstance();
         // CheckStyle:MagicNumberCheck OFF - no point
         cal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);
         cal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);
         cal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);
         cal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);
         cal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);
         cal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);
         // CheckStyle:MagicNumberCheck ON
         return cal.getTime().getTime();
     }
 
 
     /**
      * Retrieve a String from the given bytes using the encoding set
      * for this ZipFile.
      *
      * @param bytes the byte array to transform
      * @return String obtained by using the given encoding
      * @throws ZipException if the encoding cannot be recognized.
      */
     protected String getString(byte[] bytes) throws ZipException {
         try {
             return ZipEncodingHelper.getZipEncoding(encoding).decode(bytes);
         } catch (IOException ex) {
             throw new ZipException("Failed to decode name: " + ex.getMessage());
         }
     }
 
     /**
      * Checks whether the archive starts with a LFH.  If it doesn't,
      * it may be an empty archive.
      */
     private boolean startsWithLocalFileHeader() throws IOException {
         archive.seek(0);
         final byte[] start = new byte[WORD];
         archive.readFully(start);
         for (int i = 0; i < start.length; i++) {
             if (start[i] != ZipOutputStream.LFH_SIG[i]) {
                 return false;
             }
         }
         return true;
     }
 
     /**
      * If the entry has Unicode*ExtraFields and the CRCs of the
      * names/comments match those of the extra fields, transfer the
      * known Unicode values from the extra field.
      */
     private void setNameAndCommentFromExtraFields(ZipEntry ze,
                                                   NameAndComment nc) {
         UnicodePathExtraField name = (UnicodePathExtraField)
             ze.getExtraField(UnicodePathExtraField.UPATH_ID);
         String originalName = ze.getName();
         String newName = getUnicodeStringIfOriginalMatches(name, nc.name);
         if (newName != null && !originalName.equals(newName)) {
             ze.setName(newName);
             nameMap.remove(originalName);
             nameMap.put(newName, ze);
         }
 
         if (nc.comment != null && nc.comment.length > 0) {
             UnicodeCommentExtraField cmt = (UnicodeCommentExtraField)
                 ze.getExtraField(UnicodeCommentExtraField.UCOM_ID);
             String newComment =
                 getUnicodeStringIfOriginalMatches(cmt, nc.comment);
             if (newComment != null) {
                 ze.setComment(newComment);
             }
         }
     }
 
     /**
      * If the stored CRC matches the one of the given name, return the
      * Unicode name of the given field.
      *
      * <p>If the field is null or the CRCs don't match, return null
      * instead.</p>
      */
     private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,
                                                      byte[] orig) {
         if (f != null) {
             CRC32 crc32 = new CRC32();
             crc32.update(orig);
             long origCRC32 = crc32.getValue();
 
             if (origCRC32 == f.getNameCRC32()) {
                 try {
                     return ZipEncodingHelper
                         .UTF8_ZIP_ENCODING.decode(f.getUnicodeName());
                 } catch (IOException ex) {
                     // UTF-8 unsupported?  should be impossible the
                     // Unicode*ExtraField must contain some bad bytes
 
                     // TODO log this anywhere?
                     return null;
                 }
             }
         }
         return null;
     }
 
     /**
      * InputStream that delegates requests to the underlying
      * RandomAccessFile, making sure that only bytes from a certain
      * range can be read.
      */
     private class BoundedInputStream extends InputStream {
         private long remaining;
         private long loc;
         private boolean addDummyByte = false;
 
         BoundedInputStream(long start, long remaining) {
             this.remaining = remaining;
             loc = start;
         }
 
         public int read() throws IOException {
             if (remaining-- <= 0) {
                 if (addDummyByte) {
                     addDummyByte = false;
                     return 0;
                 }
                 return -1;
             }
             synchronized (archive) {
                 archive.seek(loc++);
                 return archive.read();
             }
         }
 
         public int read(byte[] b, int off, int len) throws IOException {
             if (remaining <= 0) {
                 if (addDummyByte) {
                     addDummyByte = false;
                     b[off] = 0;
                     return 1;
                 }
                 return -1;
             }
 
             if (len <= 0) {
                 return 0;
             }
 
             if (len > remaining) {
                 len = (int) remaining;
             }
             int ret = -1;
             synchronized (archive) {
                 archive.seek(loc);
                 ret = archive.read(b, off, len);
             }
             if (ret > 0) {
                 loc += ret;
                 remaining -= ret;
             }
             return ret;
         }
 
         /**
          * Inflater needs an extra dummy byte for nowrap - see
          * Inflater's javadocs.
          */
         void addDummy() {
             addDummyByte = true;
         }
     }
 
     private static final class NameAndComment {
         private final byte[] name;
         private final byte[] comment;
         private NameAndComment(byte[] name, byte[] comment) {
             this.name = name;
             this.comment = comment;
         }
     }
 }
